{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/traefik-1-6-get-our-latest-tetedemoine-1859164bf521/","result":{"data":{"ghostPost":{"childHtmlRehype":{"html":"<figure class=\"kg-card kg-image-card kg-card-hascaption fluid-image\" style=\"flex: 2.05863539445629 1 0\"><img src=\"https://miro.medium.com/max/3862/1*FA-ZxO_2HjFO9sJpBE1SEw.png\" alt=\"1*FA-ZxO_2HjFO9sJpBE1SEw\" maxWidth=\"1931\"><figcaption><a href=\"https://en.wikipedia.org/wiki/T%C3%AAte_de_Moine\" class=\"bf cn hz ia ib ic\" target=\"_blank\" rel=\"noopener\" style=\"box-sizing: inherit; color: inherit; text-decoration: none; -webkit-tap-highlight-color: transparent; background-repeat: repeat-x; background-image: url(&#x22;data:image/svg+xml;utf8,<svg preserveAspectRatio=\\&#x22;none\\&#x22; viewBox=\\&#x22;0 0 1 1\\&#x22; xmlns=\\&#x22;http://www.w3.org/2000/svg\\&#x22;><line x1=\\&#x22;0\\&#x22; y1=\\&#x22;0\\&#x22; x2=\\&#x22;1\\&#x22; y2=\\&#x22;1\\&#x22; stroke=\\&#x22;rgba(0, 0, 0, 0.84)\\&#x22; /></svg>&#x22;); background-size: 1px 1px; background-position: 0px calc(1em + 1px);\">Monk‚Äôs head</a></figcaption></figure><p>After 3 months of development, we are thrilled to announce the fresh new release of Traefik: <em><em>1.6</em></em>, codename ‚Äú<em><em>tetedemoine‚Äù</em></em>.</p><p>We merged 168 pull requests from more than 43 contributors! A huge thanks goes out to each of you who helped on this new version üòò.</p><p>The full changelog can be found <a href=\"https://github.com/containous/traefik/releases/tag/v1.6.0\" rel=\"noopener\">here</a> but here are some new features we want to highlight:</p><h2 id=\"let-s-encrypt-wildcard-certificates\">Let‚Äôs Encrypt Wildcard Certificates</h2><figure class=\"kg-card kg-image-card fluid-image\" style=\"flex: 2.051282051282051 1 0\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-60.png\" alt=\"image-60\" maxWidth=\"400\"></figure><p>This was a long-awaited feature; we are proud to announce that we officially support Let‚Äôs Encrypt wildcard certificates generation, thanks to <a href=\"https://github.com/nmengin\" rel=\"noopener\">Nicolas Mengin</a> (and thanks to <a href=\"https://github.com/xenolf\" rel=\"noopener\">xenolf</a> to the initial ACMEv2 support in <a href=\"https://github.com/xenolf/lego\" rel=\"noopener\">lego</a>). This greatly simplifies certificate management as it avoids generating multiple sub-domains certificates. Now, it‚Äôs possible to generate root domain certificates, which will work for every sub-domain.</p><p>Note: ACME wildcard certificates can only be generated thanks to a <code>DNS-01</code> challenge:</p><pre><code class=\"language-toml\">[acme]\n# ...\n[[acme.domains]]\n  main = \"*.local1.com\"\n  sans = [\"local1.com\"]\n[[acme.domains]]\n  main = \"*.local2.com\"\n# ...</code></pre><p>No more <a href=\"https://letsencrypt.org/docs/rate-limits/\" rel=\"noopener\">Let‚Äôs Encrypt rate limits</a> :)</p><h2 id=\"open-tracing-zipkin-support\">Open Tracing &#x26; Zipkin support</h2><figure class=\"kg-card kg-image-card fluid-image\" style=\"flex: 1.3651877133105803 1 0\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-61.png\" alt=\"image-61\" maxWidth=\"400\"></figure><p>In microservice architectures, being able to reconstruct the elaborate journeys that transactions take as they propagate across a distributed system has become a minimum requirement for effective monitoring.</p><blockquote><em><em>OpenTracing allows developers of application code, OSS packages, and OSS services to instrument their own code without binding to any particular tracing vendor.</em></em></blockquote><p>We received a wonderful gift from <a href=\"https://github.com/tcolgate\" rel=\"noopener\">Tristan Colgate-McFarlane</a> (with the help of <a href=\"https://github.com/containous/traefik/pull/2587\" rel=\"noopener\">Micha√´l Matur</a>) who implemented Open Tracing support, right into Traefik. Have a look at the <a href=\"https://docs.traefik.io/v1.6/configuration/tracing/\" rel=\"noopener\">documentation</a> to get more details.</p><h2 id=\"new-web-ui\">New Web UI</h2><p><a href=\"https://github.com/jkuri\" rel=\"noopener\">Jan Kuri</a> &#x26; <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a> revamped our web UI, and we love how shiny it is. Amazing job!</p><figure class=\"kg-card kg-image-card fluid-image\" style=\"flex: 1.4436248682824024 1 0\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-62.png\" alt=\"image-62\" maxWidth=\"2740\"></figure><figure class=\"kg-card kg-image-card fluid-image\" style=\"flex: 1.434279705573081 1 0\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-63.png\" alt=\"image-63\" maxWidth=\"2728\"></figure><h2 id=\"tls-certificates-in-kubernetes-secrets\">TLS Certificates in Kubernetes Secrets</h2><figure class=\"kg-card kg-image-card fluid-image\" style=\"flex: 1 1 0\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-64.png\" alt=\"image-64\" maxWidth=\"200\"></figure><p>Another awaited feature, <a href=\"https://github.com/gopenguin\" rel=\"noopener\">gopenguin</a> added Kubernetes Secrets support for fetching TLS certificates. This enables Traefik to read the Kubernetes secret defined in an ingress resource <a href=\"https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress\" rel=\"noopener\">via the </a><code><a href=\"https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress\" rel=\"noopener\">tls</a></code><a href=\"https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress\" rel=\"noopener\"> property</a>:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: traefik-ui.minikube\n    http:\n      paths:\n      - backend:\n          serviceName: traefik-web-ui\n          servicePort: 80\n  tls:\n   - secretName: traefik-ui-tls-cert</code></pre><h2 id=\"access-logs-filtering\">Access Logs Filtering</h2><figure class=\"kg-card kg-image-card fluid-image\" style=\"flex: 2.051282051282051 1 0\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-65.png\" alt=\"image-65\" maxWidth=\"400\"></figure><p>With the <a href=\"https://en.wikipedia.org/wiki/General_Data_Protection_Regulation\" rel=\"noopener\">GDPR</a> becoming real in EU, logging and storage of (potentially) personally identifiable information now need to be reduced in many organizations.</p><p>After a <a href=\"https://github.com/containous/traefik/issues/2875\" rel=\"noopener\">public proposal</a>, <a href=\"https://github.com/containous/traefik/pull/2587\" rel=\"noopener\">Micha√´l Matur</a> implemented a way to filter the content of access logs based on simple rules. Your can now <code>keep</code>, <code>drop</code>or <code>redact</code>fields and headers from your access logs. Take a look at <a href=\"https://docs.traefik.io/v1.6/configuration/logs/#access-logs\" rel=\"noopener\">our documentation</a> to get a deeper insight.</p><h2 id=\"labels-homogenization\">Labels Homogenization</h2><p>Probably one of the biggest refactoring of all time on Traefik, <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a> changed the way we manage labels internally, in order to homogenize labels on all providers. We now support all labels on all providers, no more specific code on this part üéâ</p><p>This will make it a lot easier to maintain, and we will be able to ship new features faster on all providers.</p><hr><p>But that‚Äôs not all, check the whole <a href=\"https://github.com/containous/traefik/releases/tag/v1.6.0\" rel=\"noopener\">changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we also have been working on background refactoring tasks that will help us improving Traefik in future releases.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on Github or get the official Docker image!</p><pre><code class=\"language-shell\">docker pull traefik:v1.6.0 (or 1.6.0, v1.6, 1.6, tetedemoine)\ndocker pull traefik:v1.6.0-alpine (or 1.6.0-alpine, v1.6-alpine, 1.6-alpine, tetedemoine-alpine)</code></pre><p>The <em><em>versioned</em></em> documentation can be found on <a href=\"https://docs.traefik.io/\" rel=\"noopener\">https://docs.traefik.io</a>.</p><hr><p><strong><strong>We are hiring developers and evangelists, try to solve our puzzle:containo.us/#jobs !</strong></strong></p><p>Traefik is still growing fast, we almost passed <strong><strong>15k stars</strong></strong> on Github and <strong><strong>90M downloads</strong></strong>!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Twitter</a> or on the <a href=\"https://community.containo.us\">Community Forum</a>!</p>"},"primary_author":{"id":"Ghost__Author__5dd4779bec5ed30038788830","slug":"emile","profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","profileImageSharp":{"publicURL":"/static/6a40281eb2e660036e330ab4e279aa74/68e7fb947bb29dffbd46ac8aae45b6de.jpg","childImageSharp":{"fluid":{"src":"/static/6a40281eb2e660036e330ab4e279aa74/8f7df/68e7fb947bb29dffbd46ac8aae45b6de.jpg","srcSet":"/static/6a40281eb2e660036e330ab4e279aa74/86e11/68e7fb947bb29dffbd46ac8aae45b6de.jpg 100w,\n/static/6a40281eb2e660036e330ab4e279aa74/f836f/68e7fb947bb29dffbd46ac8aae45b6de.jpg 200w,\n/static/6a40281eb2e660036e330ab4e279aa74/8f7df/68e7fb947bb29dffbd46ac8aae45b6de.jpg 250w","sizes":"(max-width: 250px) 100vw, 250px"}}},"name":"Emile Vauge","bio":null,"twitter":"@emilevauge","facebook":null,"website":null},"authors":[{"id":"5dd4779bec5ed30038788830","slug":"emile","profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","profileImageSharp":null,"name":"Emile Vauge","bio":null,"twitter":"@emilevauge","facebook":null,"website":null}],"id":"Ghost__Post__5dd7ee5df1db6f0038c7449a","title":"Traefik 1.6 ‚Äî Get Our Latest tetedemoine!","slug":"traefik-1-6-get-our-latest-tetedemoine-1859164bf521","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/monkshead.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/3e8dd3b9ae78318437039481a8ed57fb/f3583/monkshead.png","srcSet":"/static/3e8dd3b9ae78318437039481a8ed57fb/630fb/monkshead.png 300w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/2a4de/monkshead.png 600w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/f3583/monkshead.png 1200w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/bbee5/monkshead.png 1800w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/7b560/monkshead.png 1931w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.6, codename ‚Äútetedemoine‚Äù.\n\nWe merged 168 pull requests from...","custom_excerpt":"After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.6, codename ‚Äútetedemoine‚Äù.\n\nWe merged 168 pull requests from...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"May 7, 2018","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T14:19:09.000+00:00","published_at":"2018-05-07T14:18:00.000+00:00","updated_at":"2020-05-21T21:53:58.000+00:00","meta_title":"Traefik 1.6 ‚Äî Get Our Latest tetedemoine!","meta_description":"After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.6, codename ‚Äútetedemoine‚Äù.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Monk‚Äôs head [https://en.wikipedia.org/wiki/T%C3%AAte_de_Moine]After 3 months of\ndevelopment, we are thrilled to announce the fresh new release of Traefik: 1.6,\ncodename ‚Äútetedemoine‚Äù.\n\nWe merged 168 pull requests from more than 43 contributors! A huge thanks goes\nout to each of you who helped on this new version üòò.\n\nThe full changelog can be found here\n[https://github.com/containous/traefik/releases/tag/v1.6.0] but here are some\nnew features we want to highlight:\n\nLet‚Äôs Encrypt Wildcard Certificates\nThis was a long-awaited feature; we are proud to announce that we officially\nsupport Let‚Äôs Encrypt wildcard certificates generation, thanks to Nicolas Mengin\n[https://github.com/nmengin] (and thanks to xenolf [https://github.com/xenolf] \nto the initial ACMEv2 support in lego [https://github.com/xenolf/lego]). This\ngreatly simplifies certificate management as it avoids generating multiple\nsub-domains certificates. Now, it‚Äôs possible to generate root domain\ncertificates, which will work for every sub-domain.\n\nNote: ACME wildcard certificates can only be generated thanks to a DNS-01 \nchallenge:\n\n[acme]\n# ...\n[[acme.domains]]\n  main = \"*.local1.com\"\n  sans = [\"local1.com\"]\n[[acme.domains]]\n  main = \"*.local2.com\"\n# ...\n\nNo more Let‚Äôs Encrypt rate limits [https://letsencrypt.org/docs/rate-limits/] :)\n\nOpen Tracing & Zipkin support\nIn microservice architectures, being able to reconstruct the elaborate journeys\nthat transactions take as they propagate across a distributed system has become\na minimum requirement for effective monitoring.\n\n> OpenTracing allows developers of application code, OSS packages, and OSS\nservices to instrument their own code without binding to any particular tracing\nvendor.\nWe received a wonderful gift from Tristan Colgate-McFarlane\n[https://github.com/tcolgate] (with the help of Micha√´l Matur\n[https://github.com/containous/traefik/pull/2587]) who implemented Open Tracing\nsupport, right into Traefik. Have a look at the documentation\n[https://docs.traefik.io/v1.6/configuration/tracing/] to get more details.\n\nNew Web UI\nJan Kuri [https://github.com/jkuri] & Ludovic Fernandez\n[https://github.com/ldez] revamped our web UI, and we love how shiny it is.\nAmazing job!\n\nTLS Certificates in Kubernetes Secrets\nAnother awaited feature, gopenguin [https://github.com/gopenguin] added\nKubernetes Secrets support for fetching TLS certificates. This enables Traefik\nto read the Kubernetes secret defined in an ingress resource via the\n[https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress]\ntls\n[https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress] \nproperty\n[https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress]\n:\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: traefik-ui.minikube\n    http:\n      paths:\n      - backend:\n          serviceName: traefik-web-ui\n          servicePort: 80\n  tls:\n   - secretName: traefik-ui-tls-cert\n\nAccess Logs Filtering\nWith the GDPR [https://en.wikipedia.org/wiki/General_Data_Protection_Regulation] \nbecoming real in EU, logging and storage of (potentially) personally\nidentifiable information now need to be reduced in many organizations.\n\nAfter a public proposal [https://github.com/containous/traefik/issues/2875], \nMicha√´l Matur [https://github.com/containous/traefik/pull/2587] implemented a\nway to filter the content of access logs based on simple rules. Your can now \nkeep, dropor redactfields and headers from your access logs. Take a look at our\ndocumentation [https://docs.traefik.io/v1.6/configuration/logs/#access-logs] to\nget a deeper insight.\n\nLabels Homogenization\nProbably one of the biggest refactoring of all time on Traefik, Ludovic\nFernandez [https://github.com/ldez] changed the way we manage labels internally,\nin order to homogenize labels on all providers. We now support all labels on all\nproviders, no more specific code on this part üéâ\n\nThis will make it a lot easier to maintain, and we will be able to ship new\nfeatures faster on all providers.\n\n\n--------------------------------------------------------------------------------\n\nBut that‚Äôs not all, check the whole changelog\n[https://github.com/containous/traefik/releases/tag/v1.6.0] to get an idea of\nthe awesome work that has been done on this release. Lots of bugs have been\nfixed and we also have been working on background refactoring tasks that will\nhelp us improving Traefik in future releases.\n\n\n--------------------------------------------------------------------------------\n\nGrab the latest binary for Linux, Windows, Mac on Github or get the official\nDocker image!\n\ndocker pull traefik:v1.6.0 (or 1.6.0, v1.6, 1.6, tetedemoine)\ndocker pull traefik:v1.6.0-alpine (or 1.6.0-alpine, v1.6-alpine, 1.6-alpine, tetedemoine-alpine)\n\nThe versioned documentation can be found on https://docs.traefik.io\n[https://docs.traefik.io/].\n\n\n--------------------------------------------------------------------------------\n\nWe are hiring developers and evangelists, try to solve our\npuzzle:containo.us/#jobs !\n\nTraefik is still growing fast, we almost passed 15k stars on Github and 90M\ndownloads!\n\n\n--------------------------------------------------------------------------------\n\nWe would love to hear your feedback on this new release. Join us on GitHub\n[https://github.com/containous/traefik], Twitter\n[https://twitter.com/traefikproxy] or on the Community Forum\n[https://community.containo.us]!","html":"<figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/3862/1*FA-ZxO_2HjFO9sJpBE1SEw.png\" class=\"kg-image\"><figcaption><a href=\"https://en.wikipedia.org/wiki/T%C3%AAte_de_Moine\" class=\"bf cn hz ia ib ic\" target=\"_blank\" rel=\"noopener\" style=\"box-sizing: inherit; color: inherit; text-decoration: none; -webkit-tap-highlight-color: transparent; background-repeat: repeat-x; background-image: url(&quot;data:image/svg+xml;utf8,<svg preserveAspectRatio=\\&quot;none\\&quot; viewBox=\\&quot;0 0 1 1\\&quot; xmlns=\\&quot;http://www.w3.org/2000/svg\\&quot;><line x1=\\&quot;0\\&quot; y1=\\&quot;0\\&quot; x2=\\&quot;1\\&quot; y2=\\&quot;1\\&quot; stroke=\\&quot;rgba(0, 0, 0, 0.84)\\&quot; /></svg>&quot;); background-size: 1px 1px; background-position: 0px calc(1em + 1px);\">Monk‚Äôs head</a></figcaption></figure><p>After 3 months of development, we are thrilled to announce the fresh new release of Traefik: <em><em>1.6</em></em>, codename ‚Äú<em><em>tetedemoine‚Äù</em></em>.</p><p>We merged 168 pull requests from more than 43 contributors! A huge thanks goes out to each of you who helped on this new version üòò.</p><p>The full changelog can be found <a href=\"https://github.com/containous/traefik/releases/tag/v1.6.0\" rel=\"noopener\">here</a> but here are some new features we want to highlight:</p><h2 id=\"let-s-encrypt-wildcard-certificates\">Let‚Äôs Encrypt Wildcard Certificates</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-60.png\" class=\"kg-image\"></figure><p>This was a long-awaited feature; we are proud to announce that we officially support Let‚Äôs Encrypt wildcard certificates generation, thanks to <a href=\"https://github.com/nmengin\" rel=\"noopener\">Nicolas Mengin</a> (and thanks to <a href=\"https://github.com/xenolf\" rel=\"noopener\">xenolf</a> to the initial ACMEv2 support in <a href=\"https://github.com/xenolf/lego\" rel=\"noopener\">lego</a>). This greatly simplifies certificate management as it avoids generating multiple sub-domains certificates. Now, it‚Äôs possible to generate root domain certificates, which will work for every sub-domain.</p><p>Note: ACME wildcard certificates can only be generated thanks to a <code>DNS-01</code> challenge:</p><pre><code class=\"language-toml\">[acme]\n# ...\n[[acme.domains]]\n  main = \"*.local1.com\"\n  sans = [\"local1.com\"]\n[[acme.domains]]\n  main = \"*.local2.com\"\n# ...</code></pre><p>No more <a href=\"https://letsencrypt.org/docs/rate-limits/\" rel=\"noopener\">Let‚Äôs Encrypt rate limits</a> :)</p><h2 id=\"open-tracing-zipkin-support\">Open Tracing &amp; Zipkin support</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-61.png\" class=\"kg-image\"></figure><p>In microservice architectures, being able to reconstruct the elaborate journeys that transactions take as they propagate across a distributed system has become a minimum requirement for effective monitoring.</p><blockquote><em><em>OpenTracing allows developers of application code, OSS packages, and OSS services to instrument their own code without binding to any particular tracing vendor.</em></em></blockquote><p>We received a wonderful gift from <a href=\"https://github.com/tcolgate\" rel=\"noopener\">Tristan Colgate-McFarlane</a> (with the help of <a href=\"https://github.com/containous/traefik/pull/2587\" rel=\"noopener\">Micha√´l Matur</a>) who implemented Open Tracing support, right into Traefik. Have a look at the <a href=\"https://docs.traefik.io/v1.6/configuration/tracing/\" rel=\"noopener\">documentation</a> to get more details.</p><h2 id=\"new-web-ui\">New Web UI</h2><p><a href=\"https://github.com/jkuri\" rel=\"noopener\">Jan Kuri</a> &amp; <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a> revamped our web UI, and we love how shiny it is. Amazing job!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-62.png\" class=\"kg-image\"></figure><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-63.png\" class=\"kg-image\"></figure><h2 id=\"tls-certificates-in-kubernetes-secrets\">TLS Certificates in Kubernetes Secrets</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-64.png\" class=\"kg-image\"></figure><p>Another awaited feature, <a href=\"https://github.com/gopenguin\" rel=\"noopener\">gopenguin</a> added Kubernetes Secrets support for fetching TLS certificates. This enables Traefik to read the Kubernetes secret defined in an ingress resource <a href=\"https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress\" rel=\"noopener\">via the </a><code><a href=\"https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress\" rel=\"noopener\">tls</a></code><a href=\"https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress\" rel=\"noopener\"> property</a>:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: traefik-ui.minikube\n    http:\n      paths:\n      - backend:\n          serviceName: traefik-web-ui\n          servicePort: 80\n  tls:\n   - secretName: traefik-ui-tls-cert</code></pre><h2 id=\"access-logs-filtering\">Access Logs Filtering</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-65.png\" class=\"kg-image\"></figure><p>With the <a href=\"https://en.wikipedia.org/wiki/General_Data_Protection_Regulation\" rel=\"noopener\">GDPR</a> becoming real in EU, logging and storage of (potentially) personally identifiable information now need to be reduced in many organizations.</p><p>After a <a href=\"https://github.com/containous/traefik/issues/2875\" rel=\"noopener\">public proposal</a>, <a href=\"https://github.com/containous/traefik/pull/2587\" rel=\"noopener\">Micha√´l Matur</a> implemented a way to filter the content of access logs based on simple rules. Your can now <code>keep</code>, <code>drop</code>or <code>redact</code>fields and headers from your access logs. Take a look at <a href=\"https://docs.traefik.io/v1.6/configuration/logs/#access-logs\" rel=\"noopener\">our documentation</a> to get a deeper insight.</p><h2 id=\"labels-homogenization\">Labels Homogenization</h2><p>Probably one of the biggest refactoring of all time on Traefik, <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a> changed the way we manage labels internally, in order to homogenize labels on all providers. We now support all labels on all providers, no more specific code on this part üéâ</p><p>This will make it a lot easier to maintain, and we will be able to ship new features faster on all providers.</p><hr><p>But that‚Äôs not all, check the whole <a href=\"https://github.com/containous/traefik/releases/tag/v1.6.0\" rel=\"noopener\">changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we also have been working on background refactoring tasks that will help us improving Traefik in future releases.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on Github or get the official Docker image!</p><pre><code class=\"language-shell\">docker pull traefik:v1.6.0 (or 1.6.0, v1.6, 1.6, tetedemoine)\ndocker pull traefik:v1.6.0-alpine (or 1.6.0-alpine, v1.6-alpine, 1.6-alpine, tetedemoine-alpine)</code></pre><p>The <em><em>versioned</em></em> documentation can be found on <a href=\"https://docs.traefik.io/\" rel=\"noopener\">https://docs.traefik.io</a>.</p><hr><p><strong><strong>We are hiring developers and evangelists, try to solve our puzzle:containo.us/#jobs !</strong></strong></p><p>Traefik is still growing fast, we almost passed <strong><strong>15k stars</strong></strong> on Github and <strong><strong>90M downloads</strong></strong>!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Twitter</a> or on the <a href=\"https://community.containo.us\">Community Forum</a>!</p>","url":"https://containous.ghost.io/blog/traefik-1-6-get-our-latest-tetedemoine-1859164bf521/","canonical_url":null,"uuid":"a95156a1-e434-48e4-bd39-d023e4798bc2","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7ee5df1db6f0038c7449a","reading_time":4},"all_blog_posts":{"edges":[{"node":{"id":"Ghost__Post__5dd800c2f1db6f0038c74612","title":"Traefik 1.0.0 reblochon is out!","slug":"traefik-1-0-0-reblochon-is-out-e6fca002284d","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/reblochon.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/e0d849ac137a3525124f5105bd995065/46604/reblochon.png","srcSet":"/static/e0d849ac137a3525124f5105bd995065/630fb/reblochon.png 300w,\n/static/e0d849ac137a3525124f5105bd995065/46604/reblochon.png 500w","sizes":"(max-width: 500px) 100vw, 500px"}}},"excerpt":"After ten months of development, we are proud to announce the first stable release of Traefik: version 1.0.0, codename reblochon...","custom_excerpt":"After ten months of development, we are proud to announce the first stable release of Traefik: version 1.0.0, codename reblochon...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"July 6, 2016","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T15:37:38.000+00:00","published_at":"2016-07-06T15:37:00.000+00:00","updated_at":"2020-05-22T00:27:04.000+00:00","meta_title":"Traefik 1.0.0 reblochon is out!","meta_description":"After ten months of development, we are proud to announce the first stable release of Traefik: version 1.0.0, codename reblochon...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"After ten months of development, we are proud to announce the first stable\nrelease of Traefik [/traefik/]: version 1.0.0, codename reblochon.\n\n> Tr√¶fik is a modern HTTP reverse proxy and load balancer made to deploy\nmicroservices with ease. It supports several backends (Docker\n[https://www.docker.com/], Swarm [https://docs.docker.com/swarm], Mesos/Marathon\n[https://mesosphere.github.io/marathon/], Kubernetes [http://kubernetes.io/], \nConsul [https://www.consul.io/], Etcd [https://coreos.com/etcd/], Zookeeper\n[https://zookeeper.apache.org/], BoltDB [https://github.com/boltdb/bolt], Rest\nAPI, file‚Ä¶) to manage its configuration automatically and dynamically.\n\n--------------------------------------------------------------------------------\n\nHere a some of the highlight features of this first release:\n\n * Single binary, fast, made with go\n * Docker, Swarm, Mesos/Marathon, Kubernetes, Consul, Etcd, Zookeeper, BoltDB,\n   Rest API, file configuration support\n * Hot-reloading of configuration with true zero-downtime\n * Circuit breakers on backends\n * Clean AngularJS Web UI\n * Websocket support\n * HTTP/2 support\n * Let‚Äôs Encrypt [https://letsencrypt.org/] support (Automatic HTTPS)\n * Available on Linux, MacOS and Windows\n\nA lot of work has been done to make this release: 237 Pull requests have been\nmerged [https://github.com/containous/traefik/pulls?q=is%3Apr+is%3Aclosed], 184 \nissues closed\n[https://github.com/containous/traefik/issues?q=is%3Aissue+is%3Aclosed], by 38 \nawesome contributors [https://github.com/containous/traefik/graphs/contributors]\n:\n\n@jpillora @NicolasGeraud @KevinBusse @kumy @polds @janeczku @danzel\n@Hugues-Antoine @ReadmeCritic @ProPheT777 @gbjk @jonaz @Russell-IO @sample\n@s7anley @antoinecarton @wallies @pborreli @dontrebootme @kevioke @iadvizeponey\n@PierreZ @tayzlor @dylanmei @stongo @fclaeys @tboerger @download13 @keis\n@tooda02 @errm @advait @AlmogBaku @samber @cocap10 @ldez @vdemeester @emilevauge\n\nI would like to give special thanks to @vdemeester\n[https://github.com/vdemeester] who has been helping me maintaining the project\nsince the beginning, and @cocap10 [https://github.com/cocap10] for his great\nwork on staert [https://github.com/containous/staert] and flaeg\n[https://github.com/containous/flaeg]. And we are very pleased to announce that \n@samber [https://github.com/samber], @errm [https://github.com/errm], \n@Russell-IO [https://github.com/Russell-IO] just joined the maintainers team.\nWelcome on board!\n\n\n--------------------------------------------------------------------------------\n\nYou can grab the binaries on GitHub\n[https://github.com/containous/traefik/releases/tag/v1.0.0] or download the\nofficial Docker image [https://hub.docker.com/r/_/traefik]:\n\ndocker pull traefik:v1.0.0\ndocker pull traefik:reblochon // if you prefer cheese ;)\n\nThe documentation can be found on docs.traefik.io [https://docs.traefik.io/].\n\n\n--------------------------------------------------------------------------------\n\nReblochon is a French cheese made in the Alpine region of Savoie. Like all good\nFrenchmen, we love food and especially cheese: it was obvious we had to call\nevery Traefik release with a French cheese name ;)\n\n\n--------------------------------------------------------------------------------\n\nWe would love to hear your feedback on this first major release. Join us on \nGitHub [https://github.com/containous/traefik], Twitter\n[https://twitter.com/traefikproxy] or on the Community Forum\n[https://community.containo.us/]!","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/1000/1*PKlwpne0ePJuncv4Cbxm2A.png\" class=\"kg-image\"></figure><p>After ten months of development, we are proud to announce the first stable release of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>: version <em><em>1.0.0</em></em>, codename <em><em>reblochon</em></em>.</p><blockquote><em><em>Tr√¶f</em>i<em>k is a modern HTTP reverse proxy and load balancer made to deploy microservices with ease. It supports several backends (<a href=\"https://www.docker.com/\" rel=\"noopener\">Docker</a>, <a href=\"https://docs.docker.com/swarm\" rel=\"noopener\">Swarm</a>, <a href=\"https://mesosphere.github.io/marathon/\" rel=\"noopener\">Mesos/Marathon</a>, <a href=\"http://kubernetes.io/\" rel=\"noopener\">Kubernetes</a>, <a href=\"https://www.consul.io/\" rel=\"noopener\">Consul</a>, <a href=\"https://coreos.com/etcd/\" rel=\"noopener\">Etcd</a>, <a href=\"https://zookeeper.apache.org/\" rel=\"noopener\">Zookeeper</a>, <a href=\"https://github.com/boltdb/bolt\" rel=\"noopener\">BoltDB</a>, Rest API, file‚Ä¶) to manage its configuration automatically and dynamically.</em></em></blockquote><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-100.png\" class=\"kg-image\"></figure><hr><p>Here a some of the highlight features of this first release:</p><ul><li>Single binary, fast, made with go</li><li>Docker, Swarm, Mesos/Marathon, Kubernetes, Consul, Etcd, Zookeeper, BoltDB, Rest API, file configuration support</li><li>Hot-reloading of configuration with true zero-downtime</li><li>Circuit breakers on backends</li><li>Clean AngularJS Web UI</li><li>Websocket support</li><li>HTTP/2 support</li><li><a href=\"https://letsencrypt.org/\" rel=\"noopener\">Let‚Äôs Encrypt</a> support (Automatic HTTPS)</li><li>Available on Linux, MacOS and Windows</li></ul><p>A lot of work has been done to make this release: <strong><strong>237</strong></strong> Pull requests <a href=\"https://github.com/containous/traefik/pulls?q=is%3Apr+is%3Aclosed\" rel=\"noopener\">have been merged</a>, <strong><strong>184</strong></strong> issues <a href=\"https://github.com/containous/traefik/issues?q=is%3Aissue+is%3Aclosed\" rel=\"noopener\">closed</a>, by <strong><strong>38</strong></strong> awesome <a href=\"https://github.com/containous/traefik/graphs/contributors\" rel=\"noopener\">contributors</a>:</p><p><em><em>@jpillora @NicolasGeraud @KevinBusse @kumy @polds @janeczku @danzel @Hugues-Antoine @ReadmeCritic @ProPheT777 @gbjk @jonaz @Russell-IO @sample @s7anley @antoinecarton @wallies @pborreli @dontrebootme @kevioke @iadvizeponey @PierreZ @tayzlor @dylanmei @stongo @fclaeys @tboerger @download13 @keis @tooda02 @errm @advait @AlmogBaku @samber @cocap10 @ldez @vdemeester @emilevauge</em></em></p><p>I would like to give special thanks to <a href=\"https://github.com/vdemeester\" rel=\"noopener\"><em><em>@vdemeester</em></em></a> who has been helping me maintaining the project since the beginning, and <a href=\"https://github.com/cocap10\" rel=\"noopener\"><em><em>@cocap10</em></em></a><em><em> </em></em>for his great work on <a href=\"https://github.com/containous/staert\" rel=\"noopener\">staert</a> and <a href=\"https://github.com/containous/flaeg\" rel=\"noopener\">flaeg</a>. And we are very pleased to announce that <a href=\"https://github.com/samber\" rel=\"noopener\"><em><em>@samber</em></em></a><em><em>, </em></em><a href=\"https://github.com/errm\" rel=\"noopener\"><em><em>@errm</em></em></a><em><em>, </em></em><a href=\"https://github.com/Russell-IO\" rel=\"noopener\"><em><em>@Russell-IO</em></em></a><em><em> </em></em>just joined the maintainers team. Welcome on board!</p><hr><p>You can grab the binaries <a href=\"https://github.com/containous/traefik/releases/tag/v1.0.0\" rel=\"noopener\">on GitHub</a> or download the official <a href=\"https://hub.docker.com/r/_/traefik\" rel=\"noopener\">Docker image</a>:</p><pre><code class=\"language-shell\">docker pull traefik:v1.0.0\ndocker pull traefik:reblochon // if you prefer cheese ;)</code></pre><p>The documentation can be found on <a href=\"https://docs.traefik.io/\">docs.traefik.io</a>.</p><hr><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-101.png\" class=\"kg-image\"></figure><p>Reblochon is a French cheese made in the Alpine region of Savoie. Like all good Frenchmen, we love food and especially cheese: it was obvious <strong><strong>we had to</strong></strong> call every Traefik release with a French cheese name ;)</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-102.png\" class=\"kg-image\"></figure><hr><p>We would love to hear your feedback on this first major release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Twitter</a> or on the <a href=\"https://community.containo.us/\">Community Forum</a>!</p>","url":"https://containous.ghost.io/blog/traefik-1-0-0-reblochon-is-out-e6fca002284d/","canonical_url":null,"uuid":"f9d32161-8a0f-44cc-ad37-a03c3e526a5c","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd800c2f1db6f0038c74612","reading_time":2}},{"node":{"id":"Ghost__Post__5dd7fce3f1db6f0038c745f2","title":"Golang Configuration Made Easy With Fl√¶g And St√¶rt","slug":"golang-configuration-made-easy-with-flaeg-and-staert-2818921e78e","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/flaeg.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/ada72671fe3e0047e44e11e1e62cd0ad/9b73b/flaeg.png","srcSet":"/static/ada72671fe3e0047e44e11e1e62cd0ad/630fb/flaeg.png 300w,\n/static/ada72671fe3e0047e44e11e1e62cd0ad/2a4de/flaeg.png 600w,\n/static/ada72671fe3e0047e44e11e1e62cd0ad/9b73b/flaeg.png 710w","sizes":"(max-width: 710px) 100vw, 710px"}}},"excerpt":"There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files...","custom_excerpt":"There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"August 4, 2016","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T15:21:07.000+00:00","published_at":"2016-08-04T15:21:00.000+00:00","updated_at":"2020-05-22T00:17:35.000+00:00","meta_title":"Golang Configuration Made Easy With Fl√¶g And St√¶rt","meta_description":"There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"There are many ways to provide a configuration to a program. Some use Command\nLine Interfaces, others use configuration files. Any setting changes can require\na refactor on many lines of code. The configuration loading process have to be\nvery robust. If not, programs could not work as we expected. Unfortunately \ngolang [https://golang.org/] programs are no exception. For instance, adding a\nnew argument in a CLI requires to create a flag, to parse data, to deal with the\nhelp section, to manage default values and to affect the collected value into\nthe configuration structure.\n\nClose your eyes and imagine a library able to automatically manage all this\nconfiguration process for you. You can open them because we did it :)\n\n\n--------------------------------------------------------------------------------\n\nFl√¶g\nFl√¶g [https://github.com/containous/flaeg/] is a Go package for building\ndynamically a powerful modern Command Line Interface and loading a program\nconfiguration structure from arguments. Go developers don‚Äôt need to worry about\nkeeping flags and commands updated anymore : it works by itself !\n\nFl√¶g package was born from the need of Tr√¶fik [/traefik/], the famous reverse\nproxy created by Emile Vauge [https://github.com/emilevauge]. It was more and\nmore difficult to maintain the list of `flags`: parameters passed in argument\nwhich drive the program.\n\nThanks to Fl√¶g [https://github.com/containous/flaeg/], the maintenance became a\nthing of the past. The `flags` are auto generated from the field names of the\nconfiguration structure. To do that, developers just have to add a StructTag\n[https://golang.org/pkg/reflect/#StructTag] following the field to create a flag\non it. The helper (i.e. what is displayed with -help argument) is generated from\nthe key `description` in the StructTag\n[https://golang.org/pkg/reflect/#StructTag]\n\nHere an example of a complex configuration with StructTag\n[https://golang.org/pkg/reflect/#StructTag] that Fl√¶g can process:\n\nflaegdemo.config.goGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/bbd5672a81175e07492c6c9e7b43aba7]Fl√¶g\n[https://github.com/containous/flaeg/] is able to load the argument values\n‚Äã‚Äãgiven in the configuration structure through reflection\n[https://en.wikipedia.org/wiki/Reflection_(computer_programming)]. The package\nsupports most of field types, but no collections. Hopefully users can add a\ncustom parser on specific types as collections or even whole structures.\n\nLet‚Äôs see how simple it is to use Fl√¶g.\n\nFirst we will create a trivial command which do nothing but print the\nconfiguration:\n\nGolang Configuration Made Easy With Fl√¶g And St√¶rtGolang Configuration Made\nEasy\nWith Fl√¶g And St√¶rt - flaegdemo.cmd.go262588213843476Gist\n[https://gist.github.com/cocap10/600d3491c9f005195c3c8bc9234dfc99]Then, we only\nhave to create a Fl√¶g object and call the function Run :\n\nflaegdemo.use.goGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/69620f12c8fad0953269df5edb3bb58d]Let‚Äôs try this\nprogram. We will first call the helper :\n\nflaegdemo.help.shGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/b8cb3e8f78d1661eefd0f48f46e38e65]As you can\nsee, the generated flags match the fields of the configuration structure with\nsubstructures `DatabaseInfo` and `OwnerInfo`. Default values ‚Äã‚Äãcan be defined\ndirectly in the fields of the configuration structure. These fields will be\nunchanged if their `flags` are not used in argument.\n\nThen, we can try the program:\n\nflaegdemo.try.shGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/090406f9f88d59d89e7dd0f09edcd8eb]Fl√¶g also\nhandles sub-command, like the ‚Äúversion‚Äù command in the example :\n\nflaegdemo.sub.cmd.goGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/2a88cf1605f3d4187c15e129d8b58a1d]\nflaegdemo.version.try.shGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/5112adbf0f83027dc0fb7e30bd5cea80]To learn much\nmore about Fl√¶g, please visit the github project page \nhttps://github.com/containous/flaeg.\n\nThanks to Fl√¶g, we have a nice solution to load the configuration from the\nflags. The maintenance is now way simpler than it used to be, which is\nappreciated on open source projects. But how can we manage merging this CLI\nconfiguration with other sources like configuration files ?\n\n\n--------------------------------------------------------------------------------\n\nSt√¶rt\nThe CLI is not the only way to provide configuration to a program. There are\nother sources of configuration. For instance, Tr√¶fik can take a configuration\nfrom flags, from a config file and from a distributed Key-Value Store.\n\nWe created St√¶rt [https://github.com/containous/staert/] to merge those\nconfiguration sources. So far, only flags (using Fl√¶g\n[https://github.com/containous/flaeg/]), TOML config file and Key-Value Stored\n[https://github.com/containous/staert#kvstore] configuration are implemented,\nbut we did the package in such way that it is easy to add other sources.\n\nSt√¶rt uses the same Command type\n[https://github.com/containous/staert#the-command] as Fl√¶g\n[https://github.com/containous/flaeg].\n\nWe just have to create some sources\n[https://github.com/containous/staert#use-st%C3%A6rt-with-sources] :\n\nstaertdemo.create.sources.goGitHub Gist: instantly share code, notes, and\nsnippets.262588213843476Gist\n[https://gist.github.com/cocap10/d8f1742a119e5f0069790f4fbf230d59]Then, we can\ncreate a St√¶rt [https://github.com/containous/staert] object and use it :\n\nstaertdemo.use.goGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/6742ba6bf48d82b62feae2c6c8f2af4c]St√¶rt will\nload the configuration in the row and overwrite it following precedence order :\n\n * Key-Value Store source\n * Fl√¶g source\n * TOML config file source\n\nHere an example of TOML file :\n\nstaertdemo.try.tomlGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/6273109426155223099407cd9a2624cc]And there is\nthe way to store the Key-Value :\n\nstaertdemo.kv.mdGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/3115098a4c56b4bc13df9cc0182ac556]This was a\nsimple example of what we can do with St√¶rt.\n\nTo conclude, those two packages made us save a lot of time on the Tr√¶fik project\n[https://github.com/containous/traefik]. We can now load and merge several\nconfigurations from different sources. Any changes on the configuration\nstructure are automagically handled.\n\nMore features are described on the Github project pages, please visit :\n\n * Fl√¶g: https://github.com/containous/flaeg/\n * St√¶rt: https://github.com/containous/staert/","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/1420/0*ABKj5V2gw7tezUc5.\" class=\"kg-image\"></figure><p>There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files. Any setting changes can require a refactor on many lines of code. The configuration loading process have to be very robust. If not, programs could not work as we expected. Unfortunately <a href=\"https://golang.org/\" rel=\"noopener\">golang</a> programs are no exception. For instance, adding a new argument in a CLI requires to create a flag, to parse data, to deal with the help section, to manage default values and to affect the collected value into the configuration structure.</p><p>Close your eyes and imagine a library able to automatically manage all this configuration process for you. You can open them because we did it :)</p><hr><h2 id=\"fl-g\">Fl√¶g</h2><p><a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">Fl√¶g</a> is a Go package for building dynamically a powerful modern Command Line Interface and loading a program configuration structure from arguments. Go developers don‚Äôt need to worry about keeping flags and commands updated anymore : it works by itself !</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-99.png\" class=\"kg-image\"></figure><p>Fl√¶g package was born from the need of <a href=\"https://containous.ghost.io/traefik/\">Tr√¶fik</a>, the famous reverse proxy created by <a href=\"https://github.com/emilevauge\" rel=\"noopener\">Emile Vauge</a>. It was more and more difficult to maintain the list of `flags`: parameters passed in argument which drive the program.</p><p>Thanks to <a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">Fl√¶g</a>, the maintenance became a thing of the past. The `flags` are auto generated from the field names of the configuration structure. To do that, developers just have to add a <a href=\"https://golang.org/pkg/reflect/#StructTag\" rel=\"noopener\">StructTag</a> following the field to create a flag on it. The helper (i.e. what is displayed with <em><em>-help</em></em> argument) is generated from the key `description` in the <a href=\"https://golang.org/pkg/reflect/#StructTag\" rel=\"noopener\">StructTag</a></p><p>Here an example of a complex configuration with <a href=\"https://golang.org/pkg/reflect/#StructTag\" rel=\"noopener\">StructTag</a> that Fl√¶g can process:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/bbd5672a81175e07492c6c9e7b43aba7\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.config.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p><a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">Fl√¶g</a> is able to load the argument values ‚Äã‚Äãgiven in the configuration structure through <a href=\"https://en.wikipedia.org/wiki/Reflection_(computer_programming)\" rel=\"noopener\">reflection</a>. The package supports most of field types, but no collections. Hopefully users can add a custom parser on specific types as collections or even whole structures.</p><p>Let‚Äôs see how simple it is to use Fl√¶g.</p><p>First we will create a trivial command which do nothing but print the configuration:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/600d3491c9f005195c3c8bc9234dfc99\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Golang Configuration Made Easy With Fl√¶g And St√¶rt</div><div class=\"kg-bookmark-description\">Golang Configuration Made Easy With Fl√¶g And St√¶rt - flaegdemo.cmd.go</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>Then, we only have to create a Fl√¶g object and call the function Run :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/69620f12c8fad0953269df5edb3bb58d\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.use.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>Let‚Äôs try this program. We will first call the helper :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/b8cb3e8f78d1661eefd0f48f46e38e65\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.help.sh</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>As you can see, the generated flags match the fields of the configuration structure with substructures `DatabaseInfo` and `OwnerInfo`. Default values ‚Äã‚Äãcan be defined directly in the fields of the configuration structure. These fields will be unchanged if their `flags` are not used in argument.</p><p>Then, we can try the program:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/090406f9f88d59d89e7dd0f09edcd8eb\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.try.sh</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>Fl√¶g also handles sub-command, like the ‚Äúversion‚Äù command in the example :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/2a88cf1605f3d4187c15e129d8b58a1d\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.sub.cmd.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/5112adbf0f83027dc0fb7e30bd5cea80\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.version.try.sh</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>To learn much more about Fl√¶g, please visit the github project page <a href=\"https://github.com/containous/flaeg\" rel=\"noopener\">https://github.com/containous/flaeg</a>.</p><p>Thanks to Fl√¶g, we have a nice solution to load the configuration from the flags. The maintenance is now way simpler than it used to be, which is appreciated on open source projects. But how can we manage merging this CLI configuration with other sources like configuration files ?</p><hr><h2 id=\"st-rt\">St√¶rt</h2><p>The CLI is not the only way to provide configuration to a program. There are other sources of configuration. For instance, Tr√¶fik can take a configuration from flags, from a config file and from a distributed Key-Value Store.</p><p>We created <a href=\"https://github.com/containous/staert/\" rel=\"noopener\">St√¶rt</a> to merge those configuration sources. So far, only flags (using <a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">Fl√¶g</a>), TOML config file and <a href=\"https://github.com/containous/staert#kvstore\" rel=\"noopener\">Key-Value Stored</a> configuration are implemented, but we did the package in such way that it is easy to add other sources.</p><p>St√¶rt uses the same <a href=\"https://github.com/containous/staert#the-command\" rel=\"noopener\">Command type</a> as <a href=\"https://github.com/containous/flaeg\" rel=\"noopener\">Fl√¶g</a>.</p><p>We just have to <a href=\"https://github.com/containous/staert#use-st%C3%A6rt-with-sources\" rel=\"noopener\">create some sources</a> :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/d8f1742a119e5f0069790f4fbf230d59\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">staertdemo.create.sources.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>Then, we can create a <a href=\"https://github.com/containous/staert\" rel=\"noopener\">St√¶rt</a> object and use it :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/6742ba6bf48d82b62feae2c6c8f2af4c\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">staertdemo.use.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>St√¶rt will load the configuration in the row and overwrite it following precedence order :</p><ul><li>Key-Value Store source</li><li>Fl√¶g source</li><li>TOML config file source</li></ul><p>Here an example of TOML file :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/6273109426155223099407cd9a2624cc\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">staertdemo.try.toml</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>And there is the way to store the Key-Value :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/3115098a4c56b4bc13df9cc0182ac556\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">staertdemo.kv.md</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>This was a simple example of what we can do with St√¶rt.</p><p>To conclude, those two packages made us save a lot of time on the <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">Tr√¶fik project</a>. We can now load and merge several configurations from different sources. Any changes on the configuration structure are automagically handled.</p><p>More features are described on the Github project pages, please visit :</p><ul><li>Fl√¶g: <a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">https://github.com/containous/flaeg/</a></li><li>St√¶rt: <a href=\"https://github.com/containous/staert/\" rel=\"noopener\">https://github.com/containous/staert/</a></li></ul>","url":"https://containous.ghost.io/blog/golang-configuration-made-easy-with-flaeg-and-staert-2818921e78e/","canonical_url":null,"uuid":"510efcc8-d4ef-4366-abc5-eb4f607702ad","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7fce3f1db6f0038c745f2","reading_time":5}},{"node":{"id":"Ghost__Post__5dd7fc02f1db6f0038c745cc","title":"Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!","slug":"introducing-distributed-cheese-traefik-1-1-camembert-is-out-fb19e05a48c8","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/camembert.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/05b81fe338ed52345cfc19ee0925c001/bdce4/camembert.png","srcSet":"/static/05b81fe338ed52345cfc19ee0925c001/630fb/camembert.png 300w,\n/static/05b81fe338ed52345cfc19ee0925c001/bdce4/camembert.png 527w","sizes":"(max-width: 527px) 100vw, 527px"}}},"excerpt":"After 4 months of development, we are proud to announce the second release of Traefik: version 1.1.0, codename camembert.\nThe full changelog is quite huge...","custom_excerpt":"After 4 months of development, we are proud to announce the second release of Traefik: version 1.1.0, codename camembert.\nThe full changelog is quite huge...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"November 22, 2016","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T15:17:22.000+00:00","published_at":"2016-11-22T15:17:00.000+00:00","updated_at":"2020-05-22T00:19:40.000+00:00","meta_title":"Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!","meta_description":"After 4 months of development, we are proud to announce the second release of Traefik: version 1.1.0, codename camembert. ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Camembert [https://en.wikipedia.org/wiki/Camembert] cheeseAfter 4 months of\ndevelopment, we are proud to announce the second release of Traefik [/traefik/]:\nversion 1.1.0, codename camembert [https://en.wikipedia.org/wiki/Camembert].\n\nThe full changelog is quite huge\n[https://github.com/containous/traefik/releases/tag/v1.1.0] but here are some\nnew features we want to highlight:\n\nSwarm mode support\nIn v1.12, Docker introduced swarm mode [https://docs.docker.com/engine/swarm/],\nfor natively managing a cluster of Docker engines. Traefik is now able to\nconnect to a swarm manager and will discover all services deployed on the swarm.\nThank you diegofernandes [https://github.com/diegofernandes] for your work :)\n\nConstraints\nsamber [https://github.com/samber] initiated the addition of constraints, that\nlimits Traefik scope to a smaller number of routes. It allows to easily deploy\nmultiple instances with specific roles.\nLet‚Äôs give an example and add this line to our TOML configurations:\n\n# traefik instance 1\nconstraints = [‚Äútag==eu-*‚Äù, ‚Äútag==asia-*‚Äù]\n\n# traefik instance 2\nconstraints = [‚Äútag==us-*‚Äù]\n\nThe instance 1 will now route services tagged with eu-* or asia-* (i.e. \neu-backend, eu-frontend, asia-data‚Ä¶) and the instance 2, services tagged with \nus-*.\nYou can use Docker labels, Marathon labels or Consul Catalog tags to tag your\nservices. For example, let‚Äôs deploy a new Docker application and tag it:\n\ndocker run -d -l traefik.tags=eu-frontend emilevauge/whoami\n\n\nThis application will be taken into account by traefik instance 1 and ignored by\ninstance 2.\n\nMesos backend\nPierreLeresteux [https://github.com/PierreLeresteux] & skydjol\n[https://github.com/skydjol] made a great pull request adding universal Mesos\nsupport to Traefik. In addition to Marathon\n[https://mesosphere.github.io/marathon/], Traefik can now be used with any Mesos\nframework (i.e. Chronos, Aurora, custom‚Ä¶). And yeah, the v1.1 codename is \ncamembert because of those Normans [https://en.wikipedia.org/wiki/Normans] guys!\n\nWhy not Saint-Nectaire\n[https://github.com/containous/traefik/pull/353#issuecomment-233914436]?Session\naffinity\nLong awaited [https://github.com/containous/traefik/issues/5#issue-107706542] \nsticky sessions are now supported thanks to owen [https://github.com/owen]! Use\nthem with caution [https://12factor.net/processes] ;)\n\nCluster mode (experimental)\nTraefik now has a cluster mode, which allows to deploy multiple instances\nsharing the same configuration. To do that without copying the same\nconfiguration file on each instance, Traefik uses a distributed Key-Value store\n(Etcd, Consul supported). What is great with cluster mode is that it works with\nLet‚Äôs Encrypt, using the Key-Value database to store the TLS certificates. \nCluster mode [https://docs.traefik.io/] is available in this release as an\nexperimental feature.\n\nOfficial Alpine image\nIn addition to the official ‚Äúfrom scratch‚Äù Docker image, there is now an\nofficial Alpine image tagged v1.1.0-alpine, camembert-alpine. This can be useful\nto get a shell access to a Traefik container for debugging purpose.\n\nExperimental builds\nFor those who want to test bleeding edge features, we introduced experimental\nbuilds. Each time a pull request is merged into master branch, a docker image\nwill be pushed at:\n\ncontainous/traefik:experimental\n\nA specific PR image will also be pushed at:\n\ncontainous/traefik:pr-#\n\n\n--------------------------------------------------------------------------------\n\nGrab the latest binary for Linux, Windows, Mac on Github\n[https://github.com/containous/traefik/releases/tag/v1.1.0] or get the official\nDocker image [https://hub.docker.com/_/traefik/]!\n\ndocker pull traefik:v1.1.0\ndocker pull traefik:v1.1.0-alpine\ndocker pull traefik:camembert\ndocker pull traefik:camembert-alpine\n\nThe documentation can be found on http://docs.traefik.io\n[https://docs.traefik.io/].\n\n\n--------------------------------------------------------------------------------\n\nFinally, we are very pleased to announce that dtomcej\n[https://github.com/dtomcej] and SantoDE [https://github.com/SantoDE] just\njoined the maintainers team. Welcome on board!\n\n\n--------------------------------------------------------------------------------\n\nWe would love to hear your feedback on this new release. Join us on GitHub\n[https://github.com/containous/traefik], Twitter\n[https://twitter.com/traefikproxy] or on the Community Forum\n[https://community.containo.us]!\n\n\n--------------------------------------------------------------------------------\n\nEdit 12/29/2016:\nWe just pushed the first bug-fix release v1.1.1 which deals with Kubernetes and\nSwarm connection issues. The full changelog can be found here\n[https://github.com/containous/traefik/releases/tag/v1.1.1].","html":"<figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/1054/1*b8EYMGIKAOiTn_Gteyn28g.png\" class=\"kg-image\"><figcaption><a href=\"https://en.wikipedia.org/wiki/Camembert\" class=\"bf cn hw hx hy hz\" target=\"_blank\" rel=\"noopener\" style=\"box-sizing: inherit; color: inherit; text-decoration: none; -webkit-tap-highlight-color: transparent; background-repeat: repeat-x; background-image: url(&quot;data:image/svg+xml;utf8,<svg preserveAspectRatio=\\&quot;none\\&quot; viewBox=\\&quot;0 0 1 1\\&quot; xmlns=\\&quot;http://www.w3.org/2000/svg\\&quot;><line x1=\\&quot;0\\&quot; y1=\\&quot;0\\&quot; x2=\\&quot;1\\&quot; y2=\\&quot;1\\&quot; stroke=\\&quot;rgba(0, 0, 0, 0.84)\\&quot; /></svg>&quot;); background-size: 1px 1px; background-position: 0px calc(1em + 1px);\">Camembert</a> cheese</figcaption></figure><p>After 4 months of development, we are proud to announce the second release of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>: version <em><em>1.1.0</em></em>, codename <a href=\"https://en.wikipedia.org/wiki/Camembert\" rel=\"noopener\"><em><em>camembert</em></em></a>.</p><p>The full changelog is <a href=\"https://github.com/containous/traefik/releases/tag/v1.1.0\" rel=\"noopener\">quite huge</a> but here are some new features we want to highlight:</p><h2 id=\"swarm-mode-support\">Swarm mode support</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-94.png\" class=\"kg-image\"></figure><p>In v1.12, Docker introduced <a href=\"https://docs.docker.com/engine/swarm/\" rel=\"noopener\">swarm mode</a>, for natively managing a cluster of Docker engines. Traefik is now able to connect to a swarm manager and will discover all services deployed on the swarm. Thank you <a href=\"https://github.com/diegofernandes\" rel=\"noopener\">diegofernandes</a> for your work :)</p><h2 id=\"constraints\">Constraints</h2><p><a href=\"https://github.com/samber\" rel=\"noopener\">samber</a> initiated the addition of constraints, that limits Traefik scope to a smaller number of routes. It allows to easily deploy multiple instances with specific roles.<br>Let‚Äôs give an example and add this line to our TOML configurations:</p><pre><code class=\"language-toml\"># traefik instance 1\nconstraints = [‚Äútag==eu-*‚Äù, ‚Äútag==asia-*‚Äù]\n\n# traefik instance 2\nconstraints = [‚Äútag==us-*‚Äù]</code></pre><p>The instance 1 will now route services tagged with <em><em>eu-*</em></em> or <em><em>asia-*</em></em> (i.e. <em><em>eu-backend</em></em>, <em><em>eu-frontend</em></em>, <em><em>asia-data</em></em>‚Ä¶) and the instance 2, services tagged with <em><em>us-*</em></em>.<br>You can use Docker labels, Marathon labels or Consul Catalog tags to tag your services. For example, let‚Äôs deploy a new Docker application and tag it:</p><pre><code class=\"language-shell\">docker run -d -l traefik.tags=eu-frontend emilevauge/whoami\n</code></pre><p>This application will be taken into account by traefik instance 1 and ignored by instance 2.</p><h2 id=\"mesos-backend\">Mesos backend</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-95.png\" class=\"kg-image\"></figure><p><a href=\"https://github.com/PierreLeresteux\" rel=\"noopener\">PierreLeresteux</a> &amp; <a href=\"https://github.com/skydjol\" rel=\"noopener\">skydjol</a> made a great pull request adding universal Mesos support to Traefik. In addition to <a href=\"https://mesosphere.github.io/marathon/\" rel=\"noopener\">Marathon</a>, Traefik can now be used with any Mesos framework (i.e. Chronos, Aurora, custom‚Ä¶). And yeah, the <em><em>v1.1</em></em> codename is <em><em>camembert</em></em> because of those <a href=\"https://en.wikipedia.org/wiki/Normans\" rel=\"noopener\">Normans</a> guys!</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-96.png\" class=\"kg-image\"><figcaption>Why not <a href=\"https://github.com/containous/traefik/pull/353#issuecomment-233914436\" rel=\"noopener\">Saint-Nectaire</a>?</figcaption></figure><h2 id=\"session-affinity\">Session affinity</h2><p><a href=\"https://github.com/containous/traefik/issues/5#issue-107706542\" rel=\"noopener\">Long awaited</a> sticky sessions are now supported thanks to <a href=\"https://github.com/owen\" rel=\"noopener\">owen</a>! <a href=\"https://12factor.net/processes\" rel=\"noopener\">Use them with caution</a> ;)</p><h2 id=\"cluster-mode-experimental-\">Cluster mode (experimental)</h2><p>Traefik now has a cluster mode, which allows to deploy multiple instances sharing the same configuration. To do that without copying the same configuration file on each instance, Traefik uses a distributed Key-Value store (Etcd, Consul supported). What is great with <em><em>cluster mode</em></em> is that it works with Let‚Äôs Encrypt, using the Key-Value database to store the TLS certificates. <a href=\"https://docs.traefik.io/\">Cluster mode</a> is available in this release as an experimental feature.</p><h2 id=\"official-alpine-image\">Official Alpine image</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-97.png\" class=\"kg-image\"></figure><p>In addition to the official ‚Äúfrom scratch‚Äù Docker image, there is now an official Alpine image tagged <em><em>v1.1.0-alpine, camembert-alpine. </em></em>This can be useful to get a shell access to a Traefik container for debugging purpose.</p><h2 id=\"experimental-builds\">Experimental builds</h2><p>For those who want to test bleeding edge features, we introduced experimental builds. Each time a pull request is merged into master branch, a docker image will be pushed at:</p><pre><code>containous/traefik:experimental</code></pre><p>A specific PR image will also be pushed at:</p><pre><code>containous/traefik:pr-#</code></pre><hr><p>Grab the latest binary for Linux, Windows, Mac on <a href=\"https://github.com/containous/traefik/releases/tag/v1.1.0\" rel=\"noopener\">Github</a> or get the <a href=\"https://hub.docker.com/_/traefik/\" rel=\"noopener\">official Docker image</a>!</p><pre><code>docker pull traefik:v1.1.0\ndocker pull traefik:v1.1.0-alpine\ndocker pull traefik:camembert\ndocker pull traefik:camembert-alpine</code></pre><p>The documentation can be found on <a href=\"https://docs.traefik.io/\">http://docs.traefik.io</a>.</p><hr><p>Finally, we are very pleased to announce that <a href=\"https://github.com/dtomcej\" rel=\"noopener\">dtomcej</a> and <a href=\"https://github.com/SantoDE\" rel=\"noopener\">SantoDE</a> just joined the maintainers team. Welcome on board!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-98.png\" class=\"kg-image\"></figure><hr><p>We would love to hear your feedback on this new release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Twitter</a> or on the <a href=\"https://community.containo.us\">Community Forum</a>!</p><hr><p><strong><strong>Edit 12/29/2016:</strong></strong><br>We just pushed the first bug-fix release <em><em>v1.1.1</em></em> which deals with Kubernetes and Swarm connection issues. The full changelog can be found <a href=\"https://github.com/containous/traefik/releases/tag/v1.1.1\" rel=\"noopener\">here</a>.</p>","url":"https://containous.ghost.io/blog/introducing-distributed-cheese-traefik-1-1-camembert-is-out-fb19e05a48c8/","canonical_url":null,"uuid":"4aa90b99-0d59-4698-bb12-800c74396d63","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7fc02f1db6f0038c745cc","reading_time":3}},{"node":{"id":"Ghost__Post__5dd7fb33f1db6f0038c745aa","title":"Containous Raises ‚Ç¨1 Million in Seed Round Funding to Develop Traefik","slug":"containous-raises-1-million-in-seed-round-funding-to-develop-traefik-f8238f47d2c7","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/Screenshot-2019-12-02-at-20.04.39.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/62b35feee9f5655e02f7d1ab87940d8d/f3583/Screenshot-2019-12-02-at-20.04.39.png","srcSet":"/static/62b35feee9f5655e02f7d1ab87940d8d/630fb/Screenshot-2019-12-02-at-20.04.39.png 300w,\n/static/62b35feee9f5655e02f7d1ab87940d8d/2a4de/Screenshot-2019-12-02-at-20.04.39.png 600w,\n/static/62b35feee9f5655e02f7d1ab87940d8d/f3583/Screenshot-2019-12-02-at-20.04.39.png 1200w,\n/static/62b35feee9f5655e02f7d1ab87940d8d/4e4b8/Screenshot-2019-12-02-at-20.04.39.png 1347w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"We are proud to announce the closing of ‚Ç¨1 million in seed round led by Elaia Partners, 360 Capital Partners and...","custom_excerpt":"We are proud to announce the closing of ‚Ç¨1 million in seed round led by Elaia Partners, 360 Capital Partners and...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"February 20, 2017","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T15:13:55.000+00:00","published_at":"2017-02-20T15:13:00.000+00:00","updated_at":"2020-05-22T00:13:46.000+00:00","meta_title":"Containous Raises ‚Ç¨1M in Seed Round Funding to Develop Traefik","meta_description":"We are proud to announce the closing of ‚Ç¨1 million in seed round led by Elaia Partners, 360 Capital Partners and...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Our CEO, at office headquarters after the closingWe are proud to announce the\nclosing of ‚Ç¨1 million in seed round led by Elaia Partners\n[https://www.elaia.com/], 360 Capital Partners [https://www.360cap.vc/] and \nKima\nVentures [https://www.kimaventures.com/]!\n\nBased in Lyon, France, Containous is building Traefik [/traefik/], the next\ngeneration reverse-proxy & load-balancer made to deploy microservices with ease.\nIn 2016, Traefik has reached more than 6.500 stars on Github\n[https://github.com/containous/traefik/stargazers] and has been downloaded more\nthan 3M times.\n\nWith the help of our investors, our main vision is to release new cheeses more\nand more often. We already bought a new factory that will double our production\ncapacity. After Traefik 1.0 reblochon and 1.1 camembert in 2016, you can expect\na lot more in the future!\n\nOur release manager inspecting our main cluster> We believe this successful\nfinancing round does not only provide us with capital, but also with stellar\npartners that can help us take load-balancing to the next level. ‚Äî VP Product &\nSales\nVP Product & SalesStay tuned for more announcements ;)","html":"<figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/12/money.gif\" class=\"kg-image\"><figcaption>Our CEO, at office headquarters after the closing</figcaption></figure><p>We are proud to announce the closing of ‚Ç¨1 million in seed round led by <a href=\"https://www.elaia.com/\">Elaia Partners</a>, <a href=\"https://www.360cap.vc/\">360 Capital Partners</a> and <a href=\"https://www.kimaventures.com/\">Kima Ventures</a>!</p><p>Based in Lyon, France, Containous is building <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, the next generation reverse-proxy &amp; load-balancer made to deploy microservices with ease. In 2016, Traefik has reached more than <a href=\"https://github.com/containous/traefik/stargazers\" rel=\"noopener\"><strong><strong>6.500 stars on Github</strong></strong></a> and has been downloaded more than <strong><strong>3M times</strong></strong>.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-92.png\" class=\"kg-image\"></figure><p>With the help of our investors, our main vision is to release new cheeses more and more often. We already bought a new factory that will double our production capacity. After Traefik 1.0 <em><em>reblochon</em></em> and 1.1 <em><em>camembert </em></em>in 2016, you can expect a lot more in the future!</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-93.png\" class=\"kg-image\"><figcaption>Our release manager inspecting our main cluster</figcaption></figure><blockquote><em><em>We believe this successful financing round does not only provide us with capital, but also with stellar partners that can help us take load-balancing to the next level. ‚Äî VP Product &amp; Sales</em></em></blockquote><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/round.gif\" class=\"kg-image\"><figcaption>VP Product &amp; Sales</figcaption></figure><p>Stay tuned for more announcements ;)</p>","url":"https://containous.ghost.io/blog/containous-raises-1-million-in-seed-round-funding-to-develop-traefik-f8238f47d2c7/","canonical_url":null,"uuid":"6baa8e91-6698-4cf0-ad21-6118377f6ef3","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7fb33f1db6f0038c745aa","reading_time":1}},{"node":{"id":"Ghost__Post__5dd7faaef1db6f0038c74593","title":"Traefik 1.2 Morbier is out!","slug":"traefik-1-2-morbier-is-out-8bc304a66ef3","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/morbier.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/8e73d6a386ca10ffb08fa8029d0618db/f3583/morbier.png","srcSet":"/static/8e73d6a386ca10ffb08fa8029d0618db/630fb/morbier.png 300w,\n/static/8e73d6a386ca10ffb08fa8029d0618db/2a4de/morbier.png 600w,\n/static/8e73d6a386ca10ffb08fa8029d0618db/f3583/morbier.png 1200w,\n/static/8e73d6a386ca10ffb08fa8029d0618db/3dfef/morbier.png 1614w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"After 4 months of hard work, we are proud to announce a new release of Traefik: version 1.2.0, codename Morbier. The full changelog can be found...","custom_excerpt":"After 4 months of hard work, we are proud to announce a new release of Traefik: version 1.2.0, codename Morbier. The full changelog can be found...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"March 22, 2017","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T15:11:42.000+00:00","published_at":"2017-03-22T15:11:00.000+00:00","updated_at":"2020-05-22T00:28:13.000+00:00","meta_title":"Traefik 1.2 Morbier is out!","meta_description":"After 4 months of hard work, we are proud to announce a new release of Traefik: version 1.2.0, codename Morbier. The full changelog can be found...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"After 4 months of hard work, we are proud to announce a new release of Traefik:\nversion 1.2.0, codename Morbier [https://en.wikipedia.org/wiki/Morbier_cheese].\n\nThe full changelog can be found here\n[https://github.com/containous/traefik/releases/tag/v1.2.0] but here are some\nnew features we want to highlight:\n\nAmazon EC2 Container Service\nThanks to Luke Petre [https://github.com/lpetre], Traefik now supports Amazon\nEC2 Container Service [https://aws.amazon.com/fr/ecs]. This is a great news for\nAWS fans who need more than an ELB/ALB to manage their inbound traffic.\n\nRancher\nFinally, Traefik gets native Rancher support! Thank you Manuel Laufenberg\n[https://github.com/santode]! It is now a lot simpler to have a specific\nconfiguration backend right into Traefik.\n\nPrometheus\nA lot of people were waiting for it, thanks to Alberto Garcial\n[https://github.com/enxebre], native Prometheus support is now real :) This\nallows you to export internal metrics to Prometheus using a simple flag \n‚Äîweb.metrics.prometheus. More internal metrics will be added soon!\n\nNetflix Eureka\nEureka [https://github.com/Netflix/eureka] is the service registry taken from\nthe Netflix OSS stack. Traefik now supports Eureka as a configuration backend\nthanks to Julien Salleyron [https://github.com/Juliens]!\n\nHealthchecks\nAnother long awaited feature, healthchecks are here! Again, thanks to Julien\nSalleyron [https://github.com/Juliens]. A health check can be configured in\norder to remove a backend from LB rotation as long as it keeps returning HTTP\nstatus codes other than 200 OK.\n\n\n--------------------------------------------------------------------------------\n\nGrab the latest binary for Linux, Windows, Mac on Github\n[https://github.com/containous/traefik/releases/tag/v1.2.0] or get the official\nDocker image [https://hub.docker.com/_/traefik/]!\n\ndocker pull traefik:v1.2.0\ndocker pull traefik:morbier\ndocker pull traefik:v1.2.0-alpine\ndocker pull traefik:morbier-alpine\n\nThe documentation can be found on https://docs.traefik.io\n[https://docs.traefik.io/].\n\n\n--------------------------------------------------------------------------------\n\nIn case you missed it, we just raised $1M\n[/blog/containous-raises-1-million-in-seed-round-funding-to-develop-traefik-f8238f47d2c7/] \n:) You can expect a lot of new features in the coming months, as well as \nbackground work [https://github.com/containous/traefik/issues/1266]. Of course,\nall this will be done involving the community as much as possible.\n\nTraefik is still growing fast, we just passed 7k stars on Github\n[https://github.com/containous/traefik/stargazers] and 3.5M downloads! The\nmaintainer team gains 2 more maintainers, Thomas Recloux\n[https://github.com/trecloux] & Timo Reimann [https://github.com/timoreimann] \nüëã!\n\n\n--------------------------------------------------------------------------------\n\nWe would love to hear your feedback on this new release. Join us on GitHub\n[https://github.com/containous/traefik], Twitter\n[https://twitter.com/traefikproxy] or on the Community Forum\n[https://community.containo.us]!","html":"<p>After 4 months of hard work, we are proud to announce a new release of Traefik: version <em><em>1.2.0</em></em>, codename <a href=\"https://en.wikipedia.org/wiki/Morbier_cheese\" rel=\"noopener\"><em><em>Morbier</em></em></a>.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-88.png\" class=\"kg-image\"></figure><p>The full changelog can be found <a href=\"https://github.com/containous/traefik/releases/tag/v1.2.0\" rel=\"noopener\">here</a> but here are some new features we want to highlight:</p><h2 id=\"amazon-ec2-container-service\">Amazon EC2 Container Service</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-89.png\" class=\"kg-image\"></figure><p>Thanks to <a href=\"https://github.com/lpetre\" rel=\"noopener\">Luke Petre</a>, Traefik now supports <a href=\"https://aws.amazon.com/fr/ecs\" rel=\"noopener\">Amazon EC2 Container Service</a>. This is a great news for AWS fans who need more than an ELB/ALB to manage their inbound traffic.</p><h2 id=\"rancher\">Rancher</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-90.png\" class=\"kg-image\"></figure><p>Finally, Traefik gets native Rancher support! Thank you <a href=\"https://github.com/santode\" rel=\"noopener\">Manuel Laufenberg</a>! It is now a lot simpler to have a specific configuration backend right into Traefik.</p><h2 id=\"prometheus\">Prometheus</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-91.png\" class=\"kg-image\"></figure><p>A lot of people were waiting for it, thanks to <a href=\"https://github.com/enxebre\" rel=\"noopener\">Alberto Garcial</a>, native Prometheus support is now real :) This allows you to export internal metrics to Prometheus using a simple flag <code>‚Äîweb.metrics.prometheus</code>. More internal metrics will be added soon!</p><h2 id=\"netflix-eureka\">Netflix Eureka</h2><p><a href=\"https://github.com/Netflix/eureka\" rel=\"noopener\">Eureka</a> is the service registry taken from the Netflix OSS stack. Traefik now supports Eureka as a configuration backend thanks to <a href=\"https://github.com/Juliens\" rel=\"noopener\">Julien Salleyron</a>!</p><h2 id=\"healthchecks\">Healthchecks</h2><p>Another long awaited feature, healthchecks are here! Again, thanks to <a href=\"https://github.com/Juliens\" rel=\"noopener\">Julien Salleyron</a>. A health check can be configured in order to remove a backend from LB rotation as long as it keeps returning HTTP status codes other than 200 OK.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on <a href=\"https://github.com/containous/traefik/releases/tag/v1.2.0\" rel=\"noopener\">Github</a> or get the <a href=\"https://hub.docker.com/_/traefik/\" rel=\"noopener\">official Docker image</a>!</p><pre><code class=\"language-shell\">docker pull traefik:v1.2.0\ndocker pull traefik:morbier\ndocker pull traefik:v1.2.0-alpine\ndocker pull traefik:morbier-alpine</code></pre><p>The documentation can be found on <a href=\"https://docs.traefik.io/\" rel=\"noopener\">https://docs.traefik.io</a>.</p><hr><p>In case you missed it, we <a href=\"https://containous.ghost.io/blog/containous-raises-1-million-in-seed-round-funding-to-develop-traefik-f8238f47d2c7/\">just raised $1M</a> :) You can expect a lot of new features in the coming months, as well as <a href=\"https://github.com/containous/traefik/issues/1266\" rel=\"noopener\">background work</a>. Of course, all this will be done involving the community as much as possible.</p><p>Traefik is still growing fast, we just passed <a href=\"https://github.com/containous/traefik/stargazers\" rel=\"noopener\">7k stars on Github</a> and 3.5M downloads! The maintainer team gains 2 more maintainers, <a href=\"https://github.com/trecloux\" rel=\"noopener\">Thomas Recloux</a> &amp; <a href=\"https://github.com/timoreimann\" rel=\"noopener\">Timo Reimann</a> üëã!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Twitter</a> or on the <a href=\"https://community.containo.us\">Community Forum</a>!</p>","url":"https://containous.ghost.io/blog/traefik-1-2-morbier-is-out-8bc304a66ef3/","canonical_url":null,"uuid":"6616c93e-4dd7-49e9-8a2e-6fab88069f05","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7faaef1db6f0038c74593","reading_time":2}},{"node":{"id":"Ghost__Post__5dd7f8d2f1db6f0038c74576","title":"Traefik 1.3 ‚Äî Get Some More Raclette !","slug":"traefik-1-3-get-some-more-raclette-1046664d862b","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/raclette.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/5c3dfa83524b8cbbfd67cd6ef17da166/39ef9/raclette.png","srcSet":"/static/5c3dfa83524b8cbbfd67cd6ef17da166/630fb/raclette.png 300w,\n/static/5c3dfa83524b8cbbfd67cd6ef17da166/2a4de/raclette.png 600w,\n/static/5c3dfa83524b8cbbfd67cd6ef17da166/39ef9/raclette.png 611w","sizes":"(max-width: 611px) 100vw, 611px"}}},"excerpt":"We released Traefik 1.2 only two months ago, and we are proud to announce that the fresh new Traefik 1.3, codename raclette is out!\nAs Traefik is getting bigger and bigger...","custom_excerpt":"We released Traefik 1.2 only two months ago, and we are proud to announce that the fresh new Traefik 1.3, codename raclette is out!\nAs Traefik is getting bigger and bigger...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"June 1, 2017","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T15:03:46.000+00:00","published_at":"2017-06-01T15:03:00.000+00:00","updated_at":"2020-05-22T00:29:28.000+00:00","meta_title":"Traefik 1.3 ‚Äî Get Some More Raclette !","meta_description":"We released Traefik 1.2 only two months ago, and we are proud to announce that the fresh new Traefik 1.3, codename raclette is out!","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"We released Traefik 1.2 only two months ago\n[/blog/traefik-1-2-morbier-is-out-8bc304a66ef3/], and we are proud to announce\nthat the fresh new Traefik 1.3, codename raclette\n[https://en.wikipedia.org/wiki/Raclette] is out!\n\nAs Traefik is getting bigger and bigger, we decided to accelerate things and to\nrelease more often. From a 4 months release cycle, you will now have to wait\nonly 2 months between each release.\n\nThe full changelog can be found here\n[https://github.com/containous/traefik/releases/tag/v1.3.0] but here are some\nnew features we want to highlight:\n\nMultiple Rules by Container\nThanks to Florent Benoit [https://github.com/benoitf], Traefik can now manage\nmultiple rules by container, introducing service labels\n[https://github.com/containous/traefik/pull/1257]. You can now easily forward\nmultiple ports from a same container :) Here are all available labels:\n\ntraefik.<service-name>.port\ntraefik.<service-name>.weight\ntraefik.<service-name>.protocol\ntraefik.<service-name>.frontend.backend\ntraefik.<service-name>.frontend.entryPoints\ntraefik.<service-name>.frontend.rule\ntraefik.<service-name>.frontend.passHostHeader\ntraefik.<service-name>.frontend.priority\ntraefik.<service-name>.frontend.rule\n\nAmazon DynamoDB support\nTskinn [https://github.com/tskinn] made a great job on integrating\n[https://github.com/containous/traefik/pull/1158] Traefik with Amazon DynamoDB\n[https://aws.amazon.com/fr/dynamodb/], a flexible NoSQL database service. You\ncan now push your configuration (frontends and backends) into this database and\nTraefik will watch any changes dynamically.\n\nBasic Authentication per Frontend\nAnother awaited feature, Manuel Laufenberg [https://github.com/santode] added \nbasic authentication per frontend\n[https://github.com/containous/traefik/pull/1147] configuration (it was only\nglobally configurable initially). Currently, Docker and Rancher backends are\nsupported, more will be added in the future!\n\nDashboard Filter\nLudovic Fernandez [https://github.com/ldez] added a nice little feature\n[https://github.com/containous/traefik/pull/1437] in the webui: you now can\nfilter frontends and backends. When you have a big configuration with many\nroutes, it‚Äôs really handy to be able to quickly find what you want.\n\nBut that‚Äôs not all, check the whole changelog\n[https://github.com/containous/traefik/releases/tag/v1.3.0] to get an idea of\nthe awesome work that has been done on this release. Lots of bugs have been\nfixed and we have begun a strong background work on our CI infrastructure and\nproject quality in general.\n\n\n--------------------------------------------------------------------------------\n\nGrab the latest binary for Linux, Windows, Mac on Github\n[https://github.com/containous/traefik/releases/tag/v1.2.0] or get the official\nDocker image [https://hub.docker.com/_/traefik/]!\n\ndocker pull traefik:v1.3.0 (or 1.3.0, v1.3, 1.3, raclette)\ndocker pull traefik:v1.3.0-alpine (or 1.3.0-alpine, v1.3-alpine, 1.3-alpine, raclette-alpine)\n\nThe documentation can be found on https://docs.traefik.io\n[https://docs.traefik.io/].\n\n\n--------------------------------------------------------------------------------\n\nFollowing our $1M seed\n[/blog/containous-raises-1-million-in-seed-round-funding-to-develop-traefik-f8238f47d2c7/]\n, 4 new developers joined Containous [/] and are now part of the maintainers\nteam. We are thrilled to welcome Ludovic Fernandez [https://github.com/ldez], \nAttilio Borello [https://github.com/atbore-phx], Julien Salleyron\n[https://github.com/Juliens] and Nicolas Mengin [https://github.com/nmengin] üëã\n!\n\nTraefik is still growing fast, we just passed 8k stars\n[https://github.com/containous/traefik/stargazers] on Github and 7M downloads!\n\n\n--------------------------------------------------------------------------------\n\nWe would love to hear your feedback on this new release. Join us on GitHub\n[https://github.com/containous/traefik], Twitter\n[https://twitter.com/traefikproxy] or on the Community Forum\n[https://community.containo.us]!","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/1222/1*iPjSJPBOsZGGmuijQSQOrw.png\" class=\"kg-image\"></figure><p>We released Traefik <em><em>1.2</em></em> only <a href=\"https://containous.ghost.io/blog/traefik-1-2-morbier-is-out-8bc304a66ef3/\">two months ago</a>, and we are proud to announce that the fresh new Traefik <em><em>1.3</em></em>, codename <a href=\"https://en.wikipedia.org/wiki/Raclette\" rel=\"noopener\"><em><em>raclette</em></em></a> is out!</p><p>As Traefik is getting bigger and bigger, we decided to accelerate things and to release more often. From a 4 months release cycle, you will now have to wait only 2 months between each release.</p><p>The full changelog can be found <a href=\"https://github.com/containous/traefik/releases/tag/v1.3.0\" rel=\"noopener\">here</a> but here are some new features we want to highlight:</p><h2 id=\"multiple-rules-by-container\">Multiple Rules by Container</h2><p>Thanks to <a href=\"https://github.com/benoitf\" rel=\"noopener\">Florent Benoit</a>, Traefik can now manage multiple rules by container, <a href=\"https://github.com/containous/traefik/pull/1257\" rel=\"noopener\">introducing service labels</a>. You can now easily forward multiple ports from a same container :) Here are all available labels:</p><pre><code>traefik.&lt;service-name&gt;.port\ntraefik.&lt;service-name&gt;.weight\ntraefik.&lt;service-name&gt;.protocol\ntraefik.&lt;service-name&gt;.frontend.backend\ntraefik.&lt;service-name&gt;.frontend.entryPoints\ntraefik.&lt;service-name&gt;.frontend.rule\ntraefik.&lt;service-name&gt;.frontend.passHostHeader\ntraefik.&lt;service-name&gt;.frontend.priority\ntraefik.&lt;service-name&gt;.frontend.rule</code></pre><h2 id=\"amazon-dynamodb-support\">Amazon DynamoDB support</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-85.png\" class=\"kg-image\"></figure><p><a href=\"https://github.com/tskinn\" rel=\"noopener\">Tskinn</a> made a great job on <a href=\"https://github.com/containous/traefik/pull/1158\" rel=\"noopener\">integrating</a> Traefik with <a href=\"https://aws.amazon.com/fr/dynamodb/\" rel=\"noopener\">Amazon DynamoDB</a>, a flexible NoSQL database service. You can now push your configuration (frontends and backends) into this database and Traefik will watch any changes dynamically.</p><h2 id=\"basic-authentication-per-frontend\">Basic Authentication per Frontend</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-86.png\" class=\"kg-image\"></figure><p>Another awaited feature, <a href=\"https://github.com/santode\" rel=\"noopener\">Manuel Laufenberg</a> added <a href=\"https://github.com/containous/traefik/pull/1147\" rel=\"noopener\">basic authentication per frontend</a> configuration (it was only globally configurable initially). Currently, Docker and Rancher backends are supported, more will be added in the future!</p><h2 id=\"dashboard-filter\">Dashboard Filter</h2><p><a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a> added <a href=\"https://github.com/containous/traefik/pull/1437\" rel=\"noopener\">a nice little feature</a> in the webui: you now can filter frontends and backends. When you have a big configuration with many routes, it‚Äôs really handy to be able to quickly find what you want.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-87.png\" class=\"kg-image\"></figure><p>But that‚Äôs not all, check the <a href=\"https://github.com/containous/traefik/releases/tag/v1.3.0\" rel=\"noopener\">whole changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we have begun a strong background work on our CI infrastructure and project quality in general.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on <a href=\"https://github.com/containous/traefik/releases/tag/v1.2.0\" rel=\"noopener\">Github</a> or get the <a href=\"https://hub.docker.com/_/traefik/\" rel=\"noopener\">official Docker image</a>!</p><pre><code class=\"language-shell\">docker pull traefik:v1.3.0 (or 1.3.0, v1.3, 1.3, raclette)\ndocker pull traefik:v1.3.0-alpine (or 1.3.0-alpine, v1.3-alpine, 1.3-alpine, raclette-alpine)</code></pre><p>The documentation can be found on <a href=\"https://docs.traefik.io/\" rel=\"noopener\">https://docs.traefik.io</a>.</p><hr><p>Following our <a href=\"https://containous.ghost.io/blog/containous-raises-1-million-in-seed-round-funding-to-develop-traefik-f8238f47d2c7/\">$1M seed</a>, 4 new developers joined <a href=\"https://containous.ghost.io/\" rel=\"noopener\">Containous</a> and are now part of the maintainers team. We are thrilled to welcome <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a>, <a href=\"https://github.com/atbore-phx\" rel=\"noopener\">Attilio Borello</a>, <a href=\"https://github.com/Juliens\" rel=\"noopener\">Julien Salleyron</a> and <a href=\"https://github.com/nmengin\" rel=\"noopener\">Nicolas Mengin</a> üëã !</p><p>Traefik is still growing fast, we just passed <a href=\"https://github.com/containous/traefik/stargazers\" rel=\"noopener\">8k stars</a> on Github and 7M downloads!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Twitter</a> or on the <a href=\"https://community.containo.us\">Community Forum</a>!</p>","url":"https://containous.ghost.io/blog/traefik-1-3-get-some-more-raclette-1046664d862b/","canonical_url":null,"uuid":"4dedafd1-e297-41fc-8cec-57600a5bb7c7","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7f8d2f1db6f0038c74576","reading_time":3}},{"node":{"id":"Ghost__Post__5dd7f800f1db6f0038c74558","title":"Traefik 1.4 ‚Äî Roquefort Is Here, And It‚Äôs Huge!","slug":"traefik-1-4-roquefort-is-here-and-its-huge-c26654aba80f","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/rokefort.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/32b92a60abdec7024b407f34666c1b8f/f3583/rokefort.png","srcSet":"/static/32b92a60abdec7024b407f34666c1b8f/630fb/rokefort.png 300w,\n/static/32b92a60abdec7024b407f34666c1b8f/2a4de/rokefort.png 600w,\n/static/32b92a60abdec7024b407f34666c1b8f/f3583/rokefort.png 1200w,\n/static/32b92a60abdec7024b407f34666c1b8f/bbee5/rokefort.png 1800w,\n/static/32b92a60abdec7024b407f34666c1b8f/ed396/rokefort.png 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"After 4 months of intense development, we are proud to announce the fresh new release of Traefik: 1.4, codename roquefort.\nThis release is quite big...","custom_excerpt":"After 4 months of intense development, we are proud to announce the fresh new release of Traefik: 1.4, codename roquefort.\nThis release is quite big...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"October 17, 2017","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T15:00:16.000+00:00","published_at":"2017-10-17T15:00:00.000+00:00","updated_at":"2020-05-22T00:32:48.000+00:00","meta_title":"Traefik 1.4 ‚Äî Roquefort Is Here, And It‚Äôs Huge!","meta_description":"After 4 months of intense development, we are proud to announce the fresh new release of Traefik: 1.4, codename roquefort.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Rock Fort‚Ä¶After 4 months of intense development, we are proud to announce the\nfresh new release of Traefik: 1.4, codename roquefort\n[https://en.wikipedia.org/wiki/Roquefort].\n\nThis release is quite big: we merged 250\n[https://github.com/containous/traefik/pulls?utf8=%E2%9C%93&q=is%3Apr%20milestone%3A1.4%20is%3Amerged] \npull requests from more than 60 contributors ! Huge thanks goes to all of you\nwho helped on this new version üòò.\n\nThe full changelog can be found here\n[https://github.com/containous/traefik/releases/tag/v1.4.0] but here are some\nnew features we want to highlight:\n\nCustom Headers & Security\nOur awesome Daniel Tomcej [https://github.com/dtomcej] did some hard work on\nheaders. We now have a way to customize headers:\n\n> Custom headers can be configured through the frontends, to add headers to either\nrequests or responses that match the frontend‚Äôs rules. This allows for setting\nheaders such as X-Script-Name to be added to the request, or custom headers to\nbe added to the response.\nIf that was not enough, Daniel added security options on headers:\n\n> Security related headers (HSTS headers, SSL redirection, Browser XSS filter,\netc) can be added and configured per frontend in a similar manner to the custom\nheaders above. This functionality allows for some easy security features to\nquickly be set.\nMulti arch\nThanks to Ludovic Fernandez [https://github.com/ldez], we now provide\n[https://github.com/docker-library/official-images/blob/master/library/traefik] \nthe official Docker image on multiple architectures: amd64, arm64v8, arm32v6.\nThe best part is that as of mid-September, Docker supports transparent\nmulti-arch on official images. This allows to use docker run traefik \ntransparently either on a amd64 or a arm64v8 Docker daemon. We plan to add a\nWindows based official image in the future.\n\nAuthentication Forward\nAs a first step to a generic authentication mechanism\n[https://github.com/containous/traefik/issues/593], Daniel Rampelt\n[https://github.com/drampelt] followed by Ludovic Fernandez\n[https://github.com/ldez], added a way to forward authentication to a delegate\nserver. Have a look at both [https://github.com/containous/traefik/pull/1972] \nPRs [https://github.com/containous/traefik/pull/2132] to get more details on\nthis.\n\nProxy Protocol\nTraefik is often used behind another load-balancer like an ELB\n[https://aws.amazon.com/elasticloadbalancing]. In this case, Traefik now\nsupports Proxy Protocol, that allows to keep client information between the\nchain of proxies. Have a look at the documentation [https://docs.traefik.io/] to\nlearn how to enable and configure safely this feature.\n\nCustom Error Pages\nBen Parli [https://github.com/bparli] did some great job on adding custom error\npages support into Traefik. But instead of rendering html pages, we decided to\ndelegate this task to a backend server. You can now configure Traefik to get\nerror pages from another server, using this syntax:\n\n[frontends]\n  [frontends.website]\n  backend = \"website\"\n  [frontends.website.errors]\n    [frontends.website.errors.network]\n    status = [\"500-599\"]\n    backend = \"error\"\n    query = \"/{status}.html\"\n  [frontends.website.routes.website]\n  rule = \"Host: website.mydomain.com\"\n\n[backends]\n  [backends.website]\n    [backends.website.servers.website]\n    url = \"https://1.2.3.4\"\n  [backends.error]\n    [backends.error.servers.error]\n    url = \"http://2.3.4.5\"\n\nIn this example, if you hit a 502 error, Traefik will ask to the backend server \nhttp://2.3.4.5 for the page 502.html.\n\nDatadog, Statd metrics export\nAlex Antonov [https://github.com/aantono] completed the existing Prometheus\nmetrics export with two famous monitoring services: Datadog and Statd. This\nallows to easily export internal Traefik metrics to monitoring systems and get \nGrafana dashboards [https://grafana.com/dashboards/2240] of your running\ninstances.\n\nIn A Nutshell\nJulien Salleyron [https://github.com/juliens] added GRPC [https://grpc.io/] \nsupport and made a great user guide [https://docs.traefik.io/] on this.\nWe now allow to customize cookie names thanks to Ludovic Fernandez\n[https://github.com/ldez], see the documentation here\n[https://docs.traefik.io/routing/services/].\nDrew Wells [https://github.com/drewwells] added the option passTLSCertto forward\nTLS Client certificates to the backend.\nThe documentation website https://docs.traefik.io [https://docs.traefik.io/] has\nbeen revamped by Ludovic Fernandez [https://github.com/ldez].\n\nBut that‚Äôs not all, check the whole changelog\n[https://github.com/containous/traefik/releases/tag/v1.4.0] to get an idea of\nthe awesome work that has been done on this release. Lots of bugs have been\nfixed and we also have been working on creating\n[https://github.com/containous/gallienii] awesome\n[https://github.com/containous/lobicornis] bots\n[https://github.com/containous/bibikoffi] that\n[https://github.com/containous/aloba] do [https://github.com/traefiker] great\nthings for us.\n\n\n--------------------------------------------------------------------------------\n\nGrab the latest binary for Linux, Windows, Mac on Github\n[https://github.com/containous/traefik/releases/tag/v1.2.0] or get the official\nDocker image [https://hub.docker.com/_/traefik/]!\n\ndocker pull traefik:v1.4.0 (or 1.4.0, v1.4, 1.4, roquefort)\ndocker pull traefik:v1.4.0-alpine (or 1.4.0-alpine, v1.4-alpine, 1.4-alpine, roquefort-alpine)\n\nThe documentation can be found on https://docs.traefik.io\n[https://docs.traefik.io/].\n\n\n--------------------------------------------------------------------------------\n\nWe are thrilled to welcome Michael Matur [https://github.com/mmatur] who joined \nContainous [/] and Marco Jantke [https://github.com/marco-jantke] who joined the\nmaintainers team üëã ! We are hiring developers and evangelists:\ncontaino.us/#jobs !\n\nTraefik is still growing fast, we just passed 10k stars\n[https://github.com/containous/traefik/stargazers] on Github and 22M downloads!\n\n\n--------------------------------------------------------------------------------\n\nWe would love to hear your feedback on this new release. Join us on GitHub\n[https://github.com/containous/traefik], Twitter\n[https://twitter.com/traefikproxy] or on the Community Forum\n[https://community.containo.us]!","html":"<figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/7366/1*2NS3OACEy6JsCzcK8EVwDw.png\" class=\"kg-image\"><figcaption>Rock Fort‚Ä¶</figcaption></figure><p>After 4 months of intense development, we are proud to announce the fresh new release of Traefik: <em><em>1.4</em></em>, codename <a href=\"https://en.wikipedia.org/wiki/Roquefort\" rel=\"noopener\"><em><em>roquefort</em></em></a><em><em>.</em></em></p><p>This release is quite big: we merged <a href=\"https://github.com/containous/traefik/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20milestone%3A1.4%20is%3Amerged\" rel=\"noopener\">250</a> pull requests from more than 60 contributors ! Huge thanks goes to all of you who helped on this new version üòò.</p><p>The full changelog can be found <a href=\"https://github.com/containous/traefik/releases/tag/v1.4.0\" rel=\"noopener\">here</a> but here are some new features we want to highlight:</p><h2 id=\"custom-headers-security\">Custom Headers &amp; Security</h2><p>Our awesome <a href=\"https://github.com/dtomcej\" rel=\"noopener\">Daniel Tomcej</a> did some hard work on headers. We now have a way to customize headers:</p><blockquote><em><em>Custom headers can be configured through the frontends, to add headers to either requests or responses that match the frontend‚Äôs rules. This allows for setting headers such as <code>X-Script-Name</code> to be added to the request, or custom headers to be added to the response.</em></em></blockquote><p>If that was not enough, Daniel added security options on headers:</p><blockquote><em><em>Security related headers (HSTS headers, SSL redirection, Browser XSS filter, etc) can be added and configured per frontend in a similar manner to the custom headers above. This functionality allows for some easy security features to quickly be set.</em></em></blockquote><h2 id=\"multi-arch\">Multi arch</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-82.png\" class=\"kg-image\"></figure><p>Thanks to <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a>, <a href=\"https://github.com/docker-library/official-images/blob/master/library/traefik\" rel=\"noopener\">we now provide</a> the official Docker image on multiple architectures: <em><em>amd64</em></em>, <em><em>arm64v8</em></em>, <em><em>arm32v6</em></em>. The best part is that as of mid-September, Docker supports transparent multi-arch on official images. This allows to use <code>docker run traefik</code> transparently either on a <em><em>amd64 </em></em>or a<em><em> arm64v8 </em></em>Docker daemon. We plan to add a Windows based official image in the future.</p><h2 id=\"authentication-forward\">Authentication Forward</h2><p>As a first step to <a href=\"https://github.com/containous/traefik/issues/593\" rel=\"noopener\">a generic authentication mechanism</a>, <a href=\"https://github.com/drampelt\" rel=\"noopener\">Daniel Rampelt</a> followed by <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a>, added a way to forward authentication to a delegate server. Have a look at <a href=\"https://github.com/containous/traefik/pull/1972\" rel=\"noopener\">both</a> <a href=\"https://github.com/containous/traefik/pull/2132\" rel=\"noopener\">PRs</a> to get more details on this.</p><h2 id=\"proxy-protocol\">Proxy Protocol</h2><p>Traefik is often used behind another load-balancer like an <a href=\"https://aws.amazon.com/elasticloadbalancing\" rel=\"noopener\">ELB</a>. In this case, Traefik now supports Proxy Protocol, that allows to keep client information between the chain of proxies. Have a look at <a href=\"https://docs.traefik.io/\">the documentation</a> to learn how to enable and configure safely this feature.</p><h2 id=\"custom-error-pages\">Custom Error Pages</h2><p><a href=\"https://github.com/bparli\" rel=\"noopener\">Ben Parli</a> did some great job on adding custom error pages support into Traefik. But instead of rendering html pages, we decided to delegate this task to a backend server. You can now configure Traefik to get error pages from another server, using this syntax:</p><pre><code class=\"language-toml\">[frontends]\n  [frontends.website]\n  backend = \"website\"\n  [frontends.website.errors]\n    [frontends.website.errors.network]\n    status = [\"500-599\"]\n    backend = \"error\"\n    query = \"/{status}.html\"\n  [frontends.website.routes.website]\n  rule = \"Host: website.mydomain.com\"\n\n[backends]\n  [backends.website]\n    [backends.website.servers.website]\n    url = \"https://1.2.3.4\"\n  [backends.error]\n    [backends.error.servers.error]\n    url = \"http://2.3.4.5\"</code></pre><p>In this example, if you hit a 502 error, Traefik will ask to the backend server <code>http://2.3.4.5 </code>for the page <code>502.html</code>.</p><h2 id=\"datadog-statd-metrics-export\">Datadog, Statd metrics export</h2><p><a href=\"https://github.com/aantono\" rel=\"noopener\">Alex Antonov</a> completed the existing Prometheus metrics export with two famous monitoring services: Datadog and Statd. This allows to easily export internal Traefik metrics to monitoring systems and get <a href=\"https://grafana.com/dashboards/2240\" rel=\"noopener\">Grafana dashboards</a> of your running instances.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-83.png\" class=\"kg-image\"></figure><h2 id=\"in-a-nutshell\">In A Nutshell</h2><p><a href=\"https://github.com/juliens\" rel=\"noopener\">Julien Salleyron</a> added <a href=\"https://grpc.io/\" rel=\"noopener\">GRPC</a> support and made a <a href=\"https://docs.traefik.io/\">great user guide</a> on this.<br>We now allow to customize cookie names thanks to <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a>, see the documentation <a href=\"https://docs.traefik.io/routing/services/\">here</a>.<br><a href=\"https://github.com/drewwells\" rel=\"noopener\">Drew Wells</a> added the option <code>passTLSCert</code>to forward TLS Client certificates to the backend.<br>The documentation website <a href=\"https://docs.traefik.io/\">https://docs.traefik.io</a> has been revamped by <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a>.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-84.png\" class=\"kg-image\"></figure><p>But that‚Äôs not all, check the <a href=\"https://github.com/containous/traefik/releases/tag/v1.4.0\" rel=\"noopener\">whole changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we also have been working on <a href=\"https://github.com/containous/gallienii\" rel=\"noopener\">creating</a> <a href=\"https://github.com/containous/lobicornis\" rel=\"noopener\">awesome</a> <a href=\"https://github.com/containous/bibikoffi\" rel=\"noopener\">bots</a> <a href=\"https://github.com/containous/aloba\" rel=\"noopener\">that</a> <a href=\"https://github.com/traefiker\" rel=\"noopener\">do</a> great things for us.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on <a href=\"https://github.com/containous/traefik/releases/tag/v1.2.0\" rel=\"noopener\">Github</a> or get the <a href=\"https://hub.docker.com/_/traefik/\" rel=\"noopener\">official Docker image</a>!</p><pre><code class=\"language-shell\">docker pull traefik:v1.4.0 (or 1.4.0, v1.4, 1.4, roquefort)\ndocker pull traefik:v1.4.0-alpine (or 1.4.0-alpine, v1.4-alpine, 1.4-alpine, roquefort-alpine)</code></pre><p>The documentation can be found on <a href=\"https://docs.traefik.io/\">https://docs.traefik.io</a>.</p><hr><p>We are thrilled to welcome <a href=\"https://github.com/mmatur\" rel=\"noopener\">Michael Matur</a> who joined <a href=\"https://containous.ghost.io/\" rel=\"noopener\">Containous</a> and <a href=\"https://github.com/marco-jantke\" rel=\"noopener\">Marco Jantke</a> who joined the maintainers team üëã ! <strong><strong>We are hiring developers and evangelists: containo.us/#jobs !</strong></strong></p><p>Traefik is still growing fast, we just passed <a href=\"https://github.com/containous/traefik/stargazers\" rel=\"noopener\">10k stars</a> on Github and 22M downloads!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Twitter</a> or on the <a href=\"https://community.containo.us\">Community Forum</a>!</p>","url":"https://containous.ghost.io/blog/traefik-1-4-roquefort-is-here-and-its-huge-c26654aba80f/","canonical_url":null,"uuid":"71cfb254-a24e-4a18-854d-c669c8c1c4b1","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7f800f1db6f0038c74558","reading_time":4}},{"node":{"id":"Ghost__Post__5dd7f6a7f1db6f0038c74518","title":"Solving containous/jobs","slug":"solving-containous-jobs-b4a5cae04f3","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/Screenshot-2019-12-02-at-19.58.56-1.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/545cb389b120183dbe3a86f574d6b6cc/fd70c/Screenshot-2019-12-02-at-19.58.56-1.png","srcSet":"/static/545cb389b120183dbe3a86f574d6b6cc/630fb/Screenshot-2019-12-02-at-19.58.56-1.png 300w,\n/static/545cb389b120183dbe3a86f574d6b6cc/fd70c/Screenshot-2019-12-02-at-19.58.56-1.png 533w","sizes":"(max-width: 533px) 100vw, 533px"}}},"excerpt":"Last year, we had this idea to create a little puzzle to hire new engineers on Traefik...","custom_excerpt":"Last year, we had this idea to create a little puzzle to hire new engineers on Traefik...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"November 14, 2017","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T14:54:31.000+00:00","published_at":"2017-11-14T14:54:00.000+00:00","updated_at":"2020-05-22T00:22:30.000+00:00","meta_title":"Solving containous/jobs","meta_description":"Last year, we had this idea to create a little puzzle to hire new engineers on Traefik...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Company","slug":"company","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Last year, we had this idea to create a little puzzle to hire new engineers on \nTraefik [/traefik/].\n\n> ‚ö°Ô∏èWe are hiring‚ö°Ô∏è\n$ docker run containous/jobs\n\n‚Äî Traefik (@traefik) December 15, 2016\n[https://twitter.com/traefik/status/809435733949878272?ref_src=twsrc%5Etfw]\nAs we are deeply linked to Docker on this project, we thought it would be great\nto focus on technical challenges around containers. So we pushed a Docker image:\n\n$ docker run containous/jobs\nDo you like puzzles ?\n\nFew people informed us that our image must have an issue as it was only printing \nDo you like puzzles ?. Yup. That was the whole point. Something was indeed\nhidden here, and you had to find it üòâ\n\nLet‚Äôs jump into it!\n\nFirst of all, how is made containous/job ?\n\nNot really helpful‚Ä¶ But there seems to be two files copied during the build\nprocess. docker inspect containous/jobs shows that /default is the entrypoint.\nAnother file should be hidden there üòÉ\n\nIf we export the container file system using docker export\n[https://docs.docker.com/engine/reference/commandline/export/], we see that\nthere is our /default binary, and there is also, surprisingly, another binary: \n/secret. Wow ! Let‚Äôs test something‚Ä¶\n\n> Lineception‚Ä¶ Kill me‚Ä¶ Just kill me‚Ä¶\nOK, so our container is not exiting anymore, until we press enter and then we\nget Game over :‚Äô(. Hum, not that easy ü§î\n\n> Kill me‚Ä¶ Just kill me‚Ä¶\nIf we try to kill the container, it exits, but this time, without printing Game\nover :‚Äô(. Ha ! Let‚Äôs try with another kill signals then ! After few tries, you\nwill end up using SIGABRT:\n\nA wonderful stack trace is now on the screen. We can see that this binary has\nbeen created using go 1.7, and that the repository of the code is \nbitbucket.org/containous/jobs. Wait a minute‚Ä¶ What ?\n\nWE JUST FOUND WHERE IS HOSTED THE SOURCE CODE !!!\n\nDamn private repository‚Ä¶\n\nLet‚Äôs start from the beginning. If we look closely at each step, we used every\npiece of clue given by our Docker image. Except one:\n\n> Lineception‚Ä¶\nLineception = line + inception\n\nWhich line of our code is called when calling kill with SIGABRT?\n\nbitbucket.org/containous/jobs/cmd/secret/secret.go:15\n\nAnd now:\n\nAnd that‚Äôs it!\n\nIt seems that the final part was a bit too complex as a lot a people found\nalternatives solutions. Many of you discovered a base 64 encoded string right\ninto the binary:\n\nV2VsbCBkb25lIQ0KV2Ugd291bGQgbG92ZSB0byBrbm93IG1vcmUgYWJvdXQgeW91Lg0KUGxlYXNlIHNlbmQgdXMgYSBtYWlsIGF0IGpvYnMgYXQgY29udGFpbm8udXMgYW5kIHRlbGwgdXMgaG93IHlvdSBzb2x2ZWQgdGhpcyBwdXp6bGUgYW5kIHdoeSB5b3Ugd2FudCB0byB3b3JrIGF0IENvbnRhaW5vdXMgOikNCig1MCB3b3JkcyBtYXgpDQo=\n\nAnd yes, once decoded, you get straight away:\n\nWell done!\nWe would love to know more about you.\n...\n\nIn fact, very few people found the right solution using the line number. I would\nlike to congratulate C√©dric Nisio\n[https://medium.com/u/f9295502fb9b?source=post_page-----b4a5cae04f3----------------------] \nwho was the first who solved this puzzle. Well done üëèüëèüëè\n\n\n--------------------------------------------------------------------------------\n\nWe really loved to read your feedback and answers on this little game and we\nthink it‚Äôs now time to try something new üòâ\n\n> Thanks to Vincent Demeester.","html":"<p>Last year, we had this idea to create a little puzzle to hire new engineers on <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">‚ö°Ô∏èWe are hiring‚ö°Ô∏è<br>$ docker run containous/jobs</p>&mdash; Traefik (@traefik) <a href=\"https://twitter.com/traefik/status/809435733949878272?ref_src=twsrc%5Etfw\">December 15, 2016</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><p>As we are deeply linked to Docker on this project, we thought it would be great to focus on technical challenges around containers. So we pushed a Docker image:</p><pre><code class=\"language-shell\">$ docker run containous/jobs\nDo you like puzzles ?</code></pre><p>Few people informed us that our image must have an issue as it was only printing <em><em>Do you like puzzles ?</em></em>. Yup. That was the whole point. Something was indeed hidden here, and you had to find it üòâ</p><p>Let‚Äôs jump into it!</p><p>First of all, how is made <code>containous/job</code> ?</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-72.png\" class=\"kg-image\"></figure><p>Not really helpful‚Ä¶ But there seems to be two files copied during the build process. <code>docker inspect containous/jobs</code> shows that <code>/default</code> is the entrypoint. Another file should be hidden there üòÉ</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-73.png\" class=\"kg-image\"></figure><p>If we export the container file system using <code><a href=\"https://docs.docker.com/engine/reference/commandline/export/\" rel=\"noopener\">docker export</a></code>, we see that there is our <code>/default</code> binary, and there is also, surprisingly, another binary: <code>/secret</code>. Wow ! Let‚Äôs test something‚Ä¶</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-74.png\" class=\"kg-image\"></figure><blockquote><em><em><em>Lineception‚Ä¶ Kill me‚Ä¶ Just kill me‚Ä¶</em></em></em></blockquote><p>OK, so our container is not exiting anymore, until we press enter and then we get <em><em>Game over :‚Äô(</em></em>. Hum, not that easy ü§î</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-75.png\" class=\"kg-image\"></figure><blockquote><em><em><em>Kill me‚Ä¶ Just kill me‚Ä¶</em></em></em></blockquote><p>If we try to kill the container, it exits, but this time, without printing <em><em>Game over :‚Äô(. </em></em>Ha ! Let‚Äôs try with another kill signals then ! After few tries, you will end up using <code>SIGABRT</code>:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-76.png\" class=\"kg-image\"></figure><p>A wonderful stack trace is now on the screen. We can see that this binary has been created using go 1.7, and that the repository of the code is <code>bitbucket.org/containous/jobs.</code> Wait a minute‚Ä¶ What ?</p><p><strong><strong>WE JUST FOUND WHERE IS HOSTED THE SOURCE CODE !!!</strong></strong></p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-77.png\" class=\"kg-image\"></figure><p>Damn private repository‚Ä¶</p><p>Let‚Äôs start from the beginning. If we look closely at each step, we used every piece of clue given by our Docker image. Except one:</p><blockquote><em><em><em>Lineception‚Ä¶</em></em></em></blockquote><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-78.png\" class=\"kg-image\"></figure><p><strong><strong>Lineception = line + inception</strong></strong></p><p>Which line of our code is called when calling kill with <code>SIGABRT</code>?</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-79.png\" class=\"kg-image\"></figure><pre><code>bitbucket.org/containous/jobs/cmd/secret/secret.go:15</code></pre><p>And now:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-80.png\" class=\"kg-image\"></figure><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/bingo.gif\" class=\"kg-image\"></figure><p>And that‚Äôs it!</p><p>It seems that the final part was a bit too complex as a lot a people found alternatives solutions. Many of you discovered a base 64 encoded string right into the binary:</p><pre><code>V2VsbCBkb25lIQ0KV2Ugd291bGQgbG92ZSB0byBrbm93IG1vcmUgYWJvdXQgeW91Lg0KUGxlYXNlIHNlbmQgdXMgYSBtYWlsIGF0IGpvYnMgYXQgY29udGFpbm8udXMgYW5kIHRlbGwgdXMgaG93IHlvdSBzb2x2ZWQgdGhpcyBwdXp6bGUgYW5kIHdoeSB5b3Ugd2FudCB0byB3b3JrIGF0IENvbnRhaW5vdXMgOikNCig1MCB3b3JkcyBtYXgpDQo=</code></pre><p>And yes, once decoded, you get straight away:</p><pre><code>Well done!\nWe would love to know more about you.\n...</code></pre><p>In fact, very few people found the right solution using the line number. I would like to congratulate <a href=\"https://medium.com/u/f9295502fb9b?source=post_page-----b4a5cae04f3----------------------\" rel=\"noopener\">C√©dric Nisio</a> who was the first who solved this puzzle. Well done üëèüëèüëè</p><hr><p>We really loved to read your feedback and answers on this little game and we think it‚Äôs now time to try something new üòâ</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-81.png\" class=\"kg-image\"></figure><blockquote>Thanks to Vincent Demeester.</blockquote>","url":"https://containous.ghost.io/blog/solving-containous-jobs-b4a5cae04f3/","canonical_url":null,"uuid":"ec7ab5b3-08db-4187-a72e-367f021388d3","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7f6a7f1db6f0038c74518","reading_time":3}},{"node":{"id":"Ghost__Post__5dd7f42ef1db6f0038c744ed","title":"Traefik 1.5 ‚Äî Cancoillotte Is Here!","slug":"traefik-1-5-cancoillotte-is-here-7bd6713ae135","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/cancoillote.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/cf79dd685af4acffdc3844ff6e794442/f3583/cancoillote.png","srcSet":"/static/cf79dd685af4acffdc3844ff6e794442/630fb/cancoillote.png 300w,\n/static/cf79dd685af4acffdc3844ff6e794442/2a4de/cancoillote.png 600w,\n/static/cf79dd685af4acffdc3844ff6e794442/f3583/cancoillote.png 1200w,\n/static/cf79dd685af4acffdc3844ff6e794442/60daf/cancoillote.png 1665w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.5, codename cancoillotte.\nWe merged 175 pull requests from...","custom_excerpt":"After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.5, codename cancoillotte.\nWe merged 175 pull requests from...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"January 24, 2018","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T14:43:58.000+00:00","published_at":"2018-01-24T14:40:00.000+00:00","updated_at":"2020-05-22T00:35:30.000+00:00","meta_title":"Traefik 1.5 ‚Äî Cancoillotte Is Here!","meta_description":"After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.5, codename cancoillotte.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Try to pronounce it right [https://www.youtube.com/watch?v=kOnUeb1Ck-8] ;)After\n3 months of development, we are thrilled to announce the fresh new release of\nTraefik: 1.5, codename cancoillotte [https://en.wikipedia.org/wiki/Cancoillotte]\n.\n\nWe merged 175 pull requests from more than 67 contributors ! Huge thanks goes to\nall of you who helped on this new version üòò.\n\nThe full changelog can be found here\n[https://github.com/containous/traefik/releases/tag/v1.5.0] but here are some\nnew features we want to highlight:\n\nLet‚Äôs Encrypt HTTP Challenge\nOn January the 9th, a little surprise appeared on our Twitter timeline:\n\n2018.01.09 Issue with TLS-SNI-01 and Shared Hosting Infrastructure[Update\n2018-01-18: The most up-to-date summary is at IMPORTANT: What you need to know\nabout TLS-SNI validation issues] At approximately 5 p.m. Pacific time on\nJanuary\n9, 2018, we received a report from Frans Ros√©n of Detectify outlining a method\nof exploiting some shared hosting infrastructures to‚Ä¶joshLet's Encrypt\nCommunity\nSupport\n[https://community.letsencrypt.org/t/2018-01-09-issue-with-tls-sni-01-and-shared-hosting-infrastructure/49996?source=post_page-----7bd6713ae135----------------------]\nAnd then:\n\n2018.01.11 Update Regarding ACME TLS-SNI and Shared Hosting Infrastructure\n[Update 2018-01-18: The most up-to-date summary is at IMPORTANT: What you need\nto know about TLS-SNI validation issues] Please see this post for background\ninformation. The last 48 hours have been a busy time for Let‚Äôs Encrypt staff.\nWe‚Äôve been working hard to come up with a plan for ACME TLS-SNI ‚Ä¶joshLet's\nEncrypt Community Support\n[https://community.letsencrypt.org/t/2018-01-11-update-regarding-acme-tls-sni-and-shared-hosting-infrastructure/50188?source=post_page-----7bd6713ae135----------------------]\nTL;DR: Let‚Äôs Encrypt permanently disabled TLS-SNI-0x challenge due to a\nvulnerability.\n\nAnd yes, Traefik was using TLS-SNI-01 challenge by default. Ouch‚Ä¶\n\nEven though we were at the end of a release cycle (1.5.0-rc4 was already out),\nwe decided to push a new release candidate in emergency to add HTTP-01 challenge\nsupport. This fix was big enough to end in the new 1.5 and not as a bug fix on \n1.4 branch. Users will need to enable it with the new acme.httpChallenge \nsection.\n\nStats Collection\nFew months ago, we created a proposal\n[https://github.com/containous/traefik/issues/2369] in which we came up with the\nidea of collecting stats from running Traefik instances:\n\n> As you may know, the Traefik core development team is quite small and as with a\nlot of open source projects, we lack time and resources. As a consequence, we\nhave to carefully choose which tasks and features need our attention. As a\nresult, we usually invest our time on features needed or requested by most of\nthe community. In order to efficiently do this, we have to know how our\ncommunity uses Traefik.\nAs this is a super sensitive topic, we preferred to open a public debate, and\nbuild a transparent and trusted solution with the community. We are excited to\nsay that we quickly reached a consensus, and Ludovic Fernandez\n[https://github.com/ldez] successfully implemented a safe configuration export\nmechanism.\n\nWe chose to make it opt-in, which means that no data will be sent without\nenabling this feature. If enabled, only anonymous configuration options will be\nsent to a collecting server.\n\nWe really hope that all of our efforts will pay off, and that you will help us\nimprove Traefik enabling this feature in your infrastructure:\n\nsendAnonymousUsage = true\n\nWe invite you to read the constructive discussion\n[https://github.com/containous/traefik/issues/2369] that led to this new feature\nand the documentation to get more details. Many thanks to the community for its\npositive feedback!\n\nDynamic TLS Certificates\nNicolas Mengin [https://github.com/nmengin] did a great job at making TLS\ncertificates management dynamic. You can now add or remove TLS certificates\nwhile Traefik is started! In addition to backends and frontends, there is now a\ndedicated tls section in the dynamic configuration. Let‚Äôs declare two new\ncertificates using the file provider, you can now add a new tls section in your\nTOML:\n\n[frontends]\n...\n[backends]\n...\n\n# HTTPS certificates\n[[tls]]\n  entryPoints = [\"https\"]\n  [tls.certificate]\n    certFile = \"path/to/my.cert\"\n    keyFile = \"path/to/my.key\"\n\n[[tls]]\n  entryPoints = [\"https\"]\n  [tls.certificate]\n  certFile = \"path/to/my/other.cert\"\n  keyFile = \"path/to/my/other.key\"\n\nEach change of this file will make Traefik reload its TLS certificates. You can\nalso split your configuration into multiple files if you prefer.\n\nRate Limiting\nWe received a wonderful gift from Ben Parli [https://github.com/bparli] who\nadded rate limiting by frontend. You can even add multiple sets of rates to each\nfrontend. Here is an example taken from the documentation\n[https://docs.traefik.io/]:\n\n[frontends]\n    [frontends.frontend1]\n    entrypoints = [\"http\"]\n    backend = \"backend1\"\n        [frontends.frontend1.routes.test_1]\n        rule = \"Path:/\"\n    [frontends.frontend1.ratelimit]\n    extractorfunc = \"client.ip\"\n        [frontends.frontend1.ratelimit.rateset.rateset1]\n        period = \"10s\"\n        average = 100\n        burst = 200\n        [frontends.frontend1.ratelimit.rateset.rateset2]\n        period = \"3s\"\n        average = 5\n        burst = 10\n\n> In the above example, frontend1 is configured to limit requests by the client‚Äôs\nip address. An average of 5 requests every 3 seconds is allowed and an average\nof 100 requests every 10 seconds. These can ‚Äúburst‚Äù up to 10 and 200 in each\nperiod respectively.\nAzure Service Fabric Support\nLawrence Gripper [https://github.com/lawrencegripper] and Joni Collinge\n[https://github.com/jjcollinge] from Microsoft made a great contribution (with\nthe help of Ludovic Fernandez [https://github.com/ldez]) adding Azure Service\nFabric [https://azure.microsoft.com/en-us/services/service-fabric/] support to\nTraefik.\n\n> Azure Service Fabric is a distributed systems platform that makes it easy to\npackage, deploy, and manage scalable and reliable microservices and containers.\nThis new provider uses labels to configure how services are exposed through\nTraefik using the services ServiceManifest.xml file.\n\nHave a look at the documentation [https://docs.traefik.io/], we will give more\nupdate on this soon!\n\nIn A Nutshell\nDaniel Tomcej [https://github.com/dtomcej] added Kubernetes annotations and\nDocker labels for security headers, Nicolas Mengin [https://github.com/nmengin] \nadded support to etcd v3, our great Manuel Zapf [https://github.com/SantoDE] \nimplemented the redirection to another entryPoint per frontend.\nThanks to Aditya C S [https://github.com/adityacs], Traefik can now export its\nmetrics to InfluxDB. Michael Matur [https://github.com/mmatur] and Ludovic\nFernandez [https://github.com/ldez] did a great job adding multi-versioning to\nour documentation [https://docs.traefik.io/]. Julien Salleyron\n[https://github.com/juliens] refactored the web provider into API/Dashboard,\nping, metric and Rest Provider.\n\nBut that‚Äôs not all, check the whole changelog\n[https://github.com/containous/traefik/releases/tag/v1.5.0] to get an idea of\nthe awesome work that has been done on this release. Lots of bugs have been\nfixed and we also have been working on background refactoring tasks that will\nhelp us improving Traefik in future releases.\n\n\n--------------------------------------------------------------------------------\n\nGrab the latest binary for Linux, Windows, Mac on Github or get the official\nDocker image!\n\ndocker pull traefik:v1.5.0 (or 1.5.0, v1.5, 1.5, cancoillotte)\ndocker pull traefik:v1.5.0-alpine (or 1.5.0-alpine, v1.5-alpine, 1.5-alpine, cancoillotte-alpine)\n\nThe versioned documentation can be found on https://docs.traefik.io\n[https://docs.traefik.io/].\n\n\n--------------------------------------------------------------------------------\n\nWe are hiring developers and evangelists, try to solve our puzzle:\ncontaino.us/#jobs !\n\nTraefik is still growing fast, we just passed 12k stars on Github and 42M\ndownloads!\n\n\n--------------------------------------------------------------------------------\n\nWe would love to hear your feedback on this new release. Join us on GitHub\n[https://github.com/containous/traefik], Twitter\n[https://twitter.com/traefikproxy] or on the Community Forum\n[https://community.containo.us]!","html":"<figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/3330/1*bLR_qbi3qufT5w0EWxVGrg.png\" class=\"kg-image\"><figcaption>Try to <a href=\"https://www.youtube.com/watch?v=kOnUeb1Ck-8\" class=\"bf cn hz ia ib ic\" target=\"_blank\" rel=\"noopener\" style=\"box-sizing: inherit; color: inherit; text-decoration: none; -webkit-tap-highlight-color: transparent; background-repeat: repeat-x; background-image: url(&quot;data:image/svg+xml;utf8,<svg preserveAspectRatio=\\&quot;none\\&quot; viewBox=\\&quot;0 0 1 1\\&quot; xmlns=\\&quot;http://www.w3.org/2000/svg\\&quot;><line x1=\\&quot;0\\&quot; y1=\\&quot;0\\&quot; x2=\\&quot;1\\&quot; y2=\\&quot;1\\&quot; stroke=\\&quot;rgba(0, 0, 0, 0.84)\\&quot; /></svg>&quot;); background-size: 1px 1px; background-position: 0px calc(1em + 1px);\">pronounce it right</a> ;)</figcaption></figure><p>After 3 months of development, we are thrilled to announce the fresh new release of Traefik: <em><em>1.5</em></em>, codename <a href=\"https://en.wikipedia.org/wiki/Cancoillotte\" rel=\"noopener\"><em><em>cancoillotte</em></em></a>.</p><p>We merged 175 pull requests from more than 67 contributors ! Huge thanks goes to all of you who helped on this new version üòò.</p><p>The full changelog can be found <a href=\"https://github.com/containous/traefik/releases/tag/v1.5.0\" rel=\"noopener\">here</a> but here are some new features we want to highlight:</p><h2 id=\"let-s-encrypt-http-challenge\">Let‚Äôs Encrypt HTTP Challenge</h2><p>On January the 9th, a little surprise appeared on our Twitter timeline:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://community.letsencrypt.org/t/2018-01-09-issue-with-tls-sni-01-and-shared-hosting-infrastructure/49996?source=post_page-----7bd6713ae135----------------------\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">2018.01.09 Issue with TLS-SNI-01 and Shared Hosting Infrastructure</div><div class=\"kg-bookmark-description\">[Update 2018-01-18: The most up-to-date summary is at IMPORTANT: What you need to know about TLS-SNI validation issues] At approximately 5 p.m. Pacific time on January 9, 2018, we received a report from Frans Ros√©n of Detectify outlining a method of exploiting some shared hosting infrastructures to‚Ä¶</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://aws1.discourse-cdn.com/letsencrypt/optimized/3X/c/a/ca6c06ea1ea201324bba7048c6841ce60236468d_2_180x180.png\"><span class=\"kg-bookmark-author\">josh</span><span class=\"kg-bookmark-publisher\">Let's Encrypt Community Support</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://aws1.discourse-cdn.com/letsencrypt/original/3X/4/c/4c5760509a18adfc3bc657ba8bd49b301faaa66b.png\"></div></a></figure><p>And then:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://community.letsencrypt.org/t/2018-01-11-update-regarding-acme-tls-sni-and-shared-hosting-infrastructure/50188?source=post_page-----7bd6713ae135----------------------\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">2018.01.11 Update Regarding ACME TLS-SNI and Shared Hosting Infrastructure</div><div class=\"kg-bookmark-description\">[Update 2018-01-18: The most up-to-date summary is at IMPORTANT: What you need to know about TLS-SNI validation issues] Please see this post for background information. The last 48 hours have been a busy time for Let‚Äôs Encrypt staff. We‚Äôve been working hard to come up with a plan for ACME TLS-SNI ‚Ä¶</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://aws1.discourse-cdn.com/letsencrypt/optimized/3X/c/a/ca6c06ea1ea201324bba7048c6841ce60236468d_2_180x180.png\"><span class=\"kg-bookmark-author\">josh</span><span class=\"kg-bookmark-publisher\">Let's Encrypt Community Support</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://aws1.discourse-cdn.com/letsencrypt/original/3X/4/c/4c5760509a18adfc3bc657ba8bd49b301faaa66b.png\"></div></a></figure><p><strong><strong>TL;DR</strong></strong>: Let‚Äôs Encrypt permanently disabled <code>TLS-SNI-0x</code> challenge due to a vulnerability.</p><p>And yes, Traefik was using <code>TLS-SNI-01</code> challenge by default. Ouch‚Ä¶</p><p>Even though we were at the end of a release cycle (<em><em>1.5.0-rc4</em></em> was already out), we decided to push a new release candidate in emergency to add <code>HTTP-01</code> challenge support. This fix was big enough to end in the new <em><em>1.5</em></em> and not as a bug fix on <em><em>1.4</em></em> branch. Users will need to enable it with the new <code>acme.httpChallenge</code> section.</p><h2 id=\"stats-collection\">Stats Collection</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-68.png\" class=\"kg-image\"></figure><p>Few months ago, we created <a href=\"https://github.com/containous/traefik/issues/2369\" rel=\"noopener\">a proposal</a> in which we came up with the idea of collecting stats from running Traefik instances:</p><blockquote><em><em>As you may know, the Traefik core development team is quite small and as with a lot of open source projects, we lack time and resources. As a consequence, we have to carefully choose which tasks and features need our attention. As a result, we usually invest our time on features needed or requested by most of the community. In order to efficiently do this, we have to know how our community uses Traefik.</em></em></blockquote><p>As this is a super sensitive topic, we preferred to open a public debate, and build a transparent and trusted solution with the community. We are excited to say that we quickly reached a consensus, and <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a> successfully implemented a safe configuration export mechanism.</p><p><strong><strong>We chose to make it opt-in</strong></strong>, which means that no data will be sent without enabling this feature. If enabled, <strong><strong>only anonymous configuration</strong></strong> options will be sent to a collecting server.</p><p>We really hope that all of our efforts will pay off, and that you will <strong><strong>help us improve Traefik enabling this feature</strong></strong> in your infrastructure:</p><pre><code>sendAnonymousUsage = true</code></pre><p><em><em>We invite you to read </em></em><a href=\"https://github.com/containous/traefik/issues/2369\" rel=\"noopener\"><em><em>the constructive discussion</em></em></a><em><em> that led to this new feature and the documentation to get more details. Many thanks to the community for its positive feedback!</em></em></p><h2 id=\"dynamic-tls-certificates\">Dynamic TLS Certificates</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-69.png\" class=\"kg-image\"></figure><p><a href=\"https://github.com/nmengin\" rel=\"noopener\">Nicolas Mengin</a> did a great job at making TLS certificates management dynamic. You can now add or remove TLS certificates while Traefik is started! In addition to <code>backends</code> and <code>frontends</code>, there is now a dedicated <code>tls</code> section in the dynamic configuration. Let‚Äôs declare two new certificates using the file provider, you can now add a new <code>tls</code> section in your TOML:</p><pre><code class=\"language-toml\">[frontends]\n...\n[backends]\n...\n\n# HTTPS certificates\n[[tls]]\n  entryPoints = [\"https\"]\n  [tls.certificate]\n    certFile = \"path/to/my.cert\"\n    keyFile = \"path/to/my.key\"\n\n[[tls]]\n  entryPoints = [\"https\"]\n  [tls.certificate]\n  certFile = \"path/to/my/other.cert\"\n  keyFile = \"path/to/my/other.key\"</code></pre><p>Each change of this file will make Traefik reload its TLS certificates. You can also split your configuration into multiple files if you prefer.</p><h2 id=\"rate-limiting\">Rate Limiting</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-70.png\" class=\"kg-image\"></figure><p>We received a wonderful gift from <a href=\"https://github.com/bparli\" rel=\"noopener\">Ben Parli</a> who added rate limiting by frontend. You can even add multiple sets of rates to each frontend. Here is an example taken from <a href=\"https://docs.traefik.io/\">the documentation</a>:</p><pre><code class=\"language-toml\">[frontends]\n    [frontends.frontend1]\n    entrypoints = [\"http\"]\n    backend = \"backend1\"\n        [frontends.frontend1.routes.test_1]\n        rule = \"Path:/\"\n    [frontends.frontend1.ratelimit]\n    extractorfunc = \"client.ip\"\n        [frontends.frontend1.ratelimit.rateset.rateset1]\n        period = \"10s\"\n        average = 100\n        burst = 200\n        [frontends.frontend1.ratelimit.rateset.rateset2]\n        period = \"3s\"\n        average = 5\n        burst = 10</code></pre><blockquote><em><em>In the above example, <code>frontend1</code> is configured to limit requests by the client‚Äôs ip address. An average of 5 requests every 3 seconds is allowed and an average of 100 requests every 10 seconds. These can ‚Äúburst‚Äù up to 10 and 200 in each period respectively.</em></em></blockquote><h2 id=\"azure-service-fabric-support\">Azure Service Fabric Support</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-71.png\" class=\"kg-image\"></figure><p><a href=\"https://github.com/lawrencegripper\" rel=\"noopener\">Lawrence Gripper</a> and <a href=\"https://github.com/jjcollinge\" rel=\"noopener\">Joni Collinge</a> from Microsoft made a great contribution (with the help of <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a>) adding <a href=\"https://azure.microsoft.com/en-us/services/service-fabric/\" rel=\"noopener\">Azure Service Fabric</a> support to Traefik.</p><blockquote><em><em>Azure Service Fabric is a distributed systems platform that makes it easy to package, deploy, and manage scalable and reliable microservices and containers.</em></em></blockquote><p>This new provider uses labels to configure how services are exposed through Traefik using the services <code>ServiceManifest.xml</code> file.</p><p>Have a look at <a href=\"https://docs.traefik.io/\">the documentation</a>, we will give more update on this soon!</p><h2 id=\"in-a-nutshell\">In A Nutshell</h2><p><a href=\"https://github.com/dtomcej\" rel=\"noopener\">Daniel Tomcej</a> added Kubernetes annotations and Docker labels for security headers, <a href=\"https://github.com/nmengin\" rel=\"noopener\">Nicolas Mengin</a> added support to etcd v3, our great <a href=\"https://github.com/SantoDE\" rel=\"noopener\">Manuel Zapf</a> implemented the redirection to another entryPoint per frontend.<br>Thanks to <a href=\"https://github.com/adityacs\" rel=\"noopener\">Aditya C S</a>, Traefik can now export its metrics to InfluxDB. <a href=\"https://github.com/mmatur\" rel=\"noopener\">Michael Matur</a> and <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a> did a great job adding multi-versioning to our <a href=\"https://docs.traefik.io/\">documentation</a>. <a href=\"https://github.com/juliens\" rel=\"noopener\">Julien Salleyron</a> refactored the web provider into API/Dashboard, ping, metric and Rest Provider.</p><p>But that‚Äôs not all, check the whole <a href=\"https://github.com/containous/traefik/releases/tag/v1.5.0\" rel=\"noopener\">changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we also have been working on background refactoring tasks that will help us improving Traefik in future releases.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on Github or get the official Docker image!</p><pre><code class=\"language-shell\">docker pull traefik:v1.5.0 (or 1.5.0, v1.5, 1.5, cancoillotte)\ndocker pull traefik:v1.5.0-alpine (or 1.5.0-alpine, v1.5-alpine, 1.5-alpine, cancoillotte-alpine)</code></pre><p>The <em><em>versioned</em></em> documentation can be found on <a href=\"https://docs.traefik.io/\">https://docs.traefik.io</a>.</p><hr><p><strong><strong>We are hiring developers and evangelists, try to solve our puzzle: containo.us/#jobs !</strong></strong></p><p>Traefik is still growing fast, we just passed <strong><strong>12k stars</strong></strong> on Github and <strong><strong>42M downloads</strong></strong>!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Twitter</a> or on the <a href=\"https://community.containo.us\">Community Forum</a>!</p>","url":"https://containous.ghost.io/blog/traefik-1-5-cancoillotte-is-here-7bd6713ae135/","canonical_url":null,"uuid":"e186e7de-b234-490d-a1b0-4489f46bc2fe","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7f42ef1db6f0038c744ed","reading_time":5}},{"node":{"id":"Ghost__Post__5dd7f2d9f1db6f0038c744d5","title":"Traefik ‚Äî Commercial Support Is Coming!","slug":"commercial-support-is-coming-for-traefik-a28a2caf1e91","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/commercial-support.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/aa4feb04945f3c4eeb4dc5ee8a427edf/47498/commercial-support.jpg","srcSet":"/static/aa4feb04945f3c4eeb4dc5ee8a427edf/9dc27/commercial-support.jpg 300w,\n/static/aa4feb04945f3c4eeb4dc5ee8a427edf/4fe8c/commercial-support.jpg 600w,\n/static/aa4feb04945f3c4eeb4dc5ee8a427edf/47498/commercial-support.jpg 1200w,\n/static/aa4feb04945f3c4eeb4dc5ee8a427edf/52258/commercial-support.jpg 1800w,\n/static/aa4feb04945f3c4eeb4dc5ee8a427edf/7e3e6/commercial-support.jpg 1900w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"At Containous, we‚Äôre excited to share the news ‚Äî Starting today, we‚Äôll provide commercial support for Tr√¶fik.\nWe‚Äôre thrilled because beyond the...","custom_excerpt":"At Containous, we‚Äôre excited to share the news ‚Äî Starting today, we‚Äôll provide commercial support for Tr√¶fik.\nWe‚Äôre thrilled because beyond the...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"April 10, 2018","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T14:38:17.000+00:00","published_at":"2018-04-10T14:38:00.000+00:00","updated_at":"2020-05-22T00:10:52.000+00:00","meta_title":"Traefik ‚Äî Commercial Support Is Coming!","meta_description":"At Containous, we‚Äôre excited to share the news ‚Äî Starting today, we‚Äôll provide commercial support for Tr√¶fik.\nWe‚Äôre thrilled because beyond the...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Season 1, Episode 1\n\nAt Containous, we‚Äôre excited to share the news ‚Äî Starting today, we‚Äôll provide\ncommercial support for Tr√¶fik.\n\nWe‚Äôre thrilled because beyond the mere satisfaction of helping you, it means\nthat Tr√¶fik has reached yet another level of maturity. Not only is Tr√¶fik this\neasy-to-set-up full-fledged incredible reverse proxy; it is now a project we\ndeem stable enough (roadmap-wise) to assure our future customers that we‚Äôll be\nable to back them up when they most need it.\n\nMaking sure that every professional can rely on Tr√¶fik for their infrastructure\nis our top priority.\n\nWe‚Äôve had lots of discussions about the possible plans we could provide to\ncompanies. The SLAs, the price, the ticket system‚Ä¶ so many parameters that have\nstirred the fire of passion in our geek-crowded office.\n\nWe have finally settled on a plan that will fit the needs of most companies that\nalready trust Tr√¶fik (or are about to), and that need this supplementary\ninsurance ‚Äî Yes, our team of experts will now be available to make sure every \nedge case of your specific set-up is handled correctly.\n\nSo, what does this standard plan consist of?\n\n * We will support each major version of Tr√¶fik (we use semantic versioning\n   [https://semver.org/]) for a whole year after the next one is released. For\n   example, once 2.0 is released, we will continue to support 1.n for one year\n   (n being the latest minor version in that branch).\n * During a major release cycle, in addition to supporting the current version,\n   we will support the previous one. For example, once 1.8 is released, we will\n   continue to support 1.7 (but will stop supporting 1.6) until 1.9 or 2.0 is\n   released.\n * We will start working on any question you have within 2 hours of you\n   contacting us (business hours, CET).\n\nNow we see your question coming, ‚ÄúWhat happens to the community support?‚Äù\n\nOur answer cannot be simpler ‚Äî nothing changes.\n\n> Open source drives Tr√¶fik, and we will keep doing our best to make Tr√¶fik one of\nthe most successful open-source projects ever.\nHave we talked about the price yet?\n\nTr√¶fik‚Äòs success is propelled by its simplicity. Simplicity means that it\nreaches a broad audience, from the most straightforward infrastructure to\nintricate clusters with multiple layers of orchestration.\n\nOur goal with the standard plan is to be able to provide support at an\naffordable price so that everyone can benefit from it.\n\nFor this reason, we concurred on a price that will allow a wide range of\ncompanies to subscribe to the standard support plan (without sacrificing other\ninvestments in their program).\n\nStarting at ‚Ç¨1,000 per instance of Tr√¶fik, you‚Äôll benefit from our services for\na whole year.\n\nThe standard plan can go as far as five supported instances of Tr√¶fik running on\nyour infrastructure.\n\nNeed more support?\n\nIf your business requires a customized support plan, you can contact us to\ndiscuss further how we can help.\n\n\n--------------------------------------------------------------------------------\n\nOh ‚Ä¶ by the way ‚Ä¶ you‚Äôll find the form to request support on our new website\n[https://info.containo.us/commercial-services]!\n\nHappy Tr√¶fik!\n\n\n--------------------------------------------------------------------------------\n\nContainous is the company that helps Tr√¶fik be the successful open-source\nproject it is.\n\nFollow Containous [https://twitter.com/containous] & Tr√¶fik\n[https://twitter.com/traefikproxy] on Twitter.\n\nVisit our website. [/]\n\nShare your opinion in the comments section.\n\nAnd don‚Äôt forget, you‚Äôll always be welcome on the Community Forum\n[https://community.containo.us]!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Season 1, Episode 1</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-17.png\" class=\"kg-image\"></figure><p>At Containous, we‚Äôre excited to share the news ‚Äî Starting today, we‚Äôll provide commercial support for Tr√¶fik.</p><p>We‚Äôre thrilled because beyond the mere satisfaction of helping you, it means that Tr√¶fik has reached yet another level of maturity. Not only is Tr√¶fik this easy-to-set-up full-fledged incredible reverse proxy; it is now a project we deem stable enough (roadmap-wise) to assure our future customers that we‚Äôll be able to back them up when they most need it.</p><p><strong><strong>Making sure that every professional can rely on Tr√¶fik for their infrastructure is our top priority.</strong></strong></p><p>We‚Äôve had lots of discussions about the possible plans we could provide to companies. The SLAs, the price, the ticket system‚Ä¶ so many parameters that have stirred the fire of passion in our geek-crowded office.</p><p>We have finally settled on a plan that will fit the needs of most companies that already trust Tr√¶fik (or are about to), and that need this supplementary insurance ‚Äî Yes, our team of experts will now be available to make sure <em><em>every</em></em> edge case of your specific set-up is handled correctly.</p><p>So, what does this standard plan consist of?</p><ul><li>We will support each major version of Tr√¶fik (we use <a href=\"https://semver.org/\" rel=\"noopener\">semantic versioning</a>) for a whole year after the next one is released. For example, once 2.0 is released, we will continue to support 1.n for one year (n being the latest minor version in that branch).</li><li><em><em>During</em></em> a major release cycle, in addition to supporting the current version, we will support the previous one. For example, once 1.8 is released, we will continue to support 1.7 (but will stop supporting 1.6) until 1.9 or 2.0 is released.</li><li>We will start working on any question you have within 2 hours of you contacting us (business hours, CET).</li></ul><p>Now we see your question coming, ‚ÄúWhat happens to the community support?‚Äù</p><p>Our answer cannot be simpler ‚Äî nothing changes.</p><blockquote>Open source drives Tr√¶fik, and we will keep doing our best to make Tr√¶fik one of the most successful open-source projects ever.</blockquote><p><strong><strong>Have we talked about the price yet?</strong></strong></p><p>Tr√¶fik‚Äòs success is propelled by its simplicity. Simplicity means that it reaches a broad audience, from the most straightforward infrastructure to intricate clusters with multiple layers of orchestration.</p><p>Our goal with the standard plan is to be able to provide support at an affordable price so that everyone can benefit from it.</p><p>For this reason, we concurred on a price that will allow a wide range of companies to subscribe to the standard support plan (without sacrificing other investments in their program).</p><p>Starting at ‚Ç¨1,000 per instance of Tr√¶fik, you‚Äôll benefit from our services for a whole year.</p><p>The standard plan can go as far as five supported instances of Tr√¶fik running on your infrastructure.</p><p><strong><strong>Need more support?</strong></strong></p><p>If your business requires a customized support plan, you can contact us to discuss further how we can help.</p><hr><p>Oh ‚Ä¶ by the way ‚Ä¶ you‚Äôll find the form to request support on <a href=\"https://info.containo.us/commercial-services\">our new website</a>!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-67.png\" class=\"kg-image\"></figure><p>Happy Tr√¶fik!</p><hr><p>Containous is the company that helps Tr√¶fik be the successful open-source project it is.</p><p>Follow <a href=\"https://twitter.com/containous\" rel=\"noopener\">Containous</a> &amp; <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Tr√¶fik</a> on Twitter.</p><p><a href=\"https://containous.ghost.io/\">Visit our website.</a></p><p>Share your opinion in the comments section.</p><p>And don‚Äôt forget, you‚Äôll always be welcome on the <a href=\"https://community.containo.us\">Community Forum</a>!</p>","url":"https://containous.ghost.io/blog/commercial-support-is-coming-for-traefik-a28a2caf1e91/","canonical_url":null,"uuid":"a5f429a8-314c-4a41-8a56-729799e565ac","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7f2d9f1db6f0038c744d5","reading_time":3}},{"node":{"id":"Ghost__Post__5dd7f1d5f1db6f0038c744bd","title":"Tr√¶fik Goes to KubeCon Europe 2018!","slug":"traefik-goes-to-kubecon-europe-2018-f89a216b1d95","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/kubecon2018.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/ccf049a8ebfe8a7c1d0095760ce3cd88/47498/kubecon2018.jpg","srcSet":"/static/ccf049a8ebfe8a7c1d0095760ce3cd88/9dc27/kubecon2018.jpg 300w,\n/static/ccf049a8ebfe8a7c1d0095760ce3cd88/4fe8c/kubecon2018.jpg 600w,\n/static/ccf049a8ebfe8a7c1d0095760ce3cd88/47498/kubecon2018.jpg 1200w,\n/static/ccf049a8ebfe8a7c1d0095760ce3cd88/52258/kubecon2018.jpg 1800w,\n/static/ccf049a8ebfe8a7c1d0095760ce3cd88/a41d1/kubecon2018.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Working on an open-source project can be frustrating: we code together but barely see each other.\nSo, this year, we‚Äôre excited to gather the whole team at the next KubeCon Europe...","custom_excerpt":"Working on an open-source project can be frustrating: we code together but barely see each other.\nSo, this year, we‚Äôre excited to gather the whole team at the next KubeCon Europe...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"May 1, 2018","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T14:33:57.000+00:00","published_at":"2018-05-01T14:33:00.000+00:00","updated_at":"2020-05-21T22:28:55.000+00:00","meta_title":"Tr√¶fik Goes to KubeCon Europe 2018!","meta_description":"This year, we‚Äôre excited to gather the whole team at the next KubeCon Europe...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Community","slug":"community","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Along with 200 T-Shirts for you to ‚Äútweet and win‚Äù\n\nWorking on an open-source project [/traefik/] can sometimes be frustrating: we\ncode together but barely see each other.\n\nSo, this year, we‚Äôre excited to gather the whole team at the next KubeCon Europe\n[https://events.linuxfoundation.org/events/kubecon-cloudnativecon-europe-2018/].\nWe can‚Äôt wait to engage in long-postponed debates around our beloved product,\nand we‚Äôre even more eager to spread the word:\n\n> Yes, Tr√¶fik is THAT good of a reverse proxy.\nIf you will be at the conference, come to talk to us there: Containous [/] has\nset up a booth so we can answer your questions. If you were still undecided\nabout attending ‚Äî hesitate no more :-)\n\nOur Demo? A Tweet and Win!\nTo demonstrate the power of Tr√¶fik [https://github.com/containous/traefik],\nwe‚Äôll ask you to create and deploy a container ‚Ä¶ in a Kubernetes cluster ‚Ä¶ that\nwill automatically be exposed on an HTTPS URL ‚Ä¶ personalized with your username\n‚Ä¶ that could win you a T-shirt ‚Ä¶ just by writing a single Tweet! (Yes, 140\ncharacters will be enough, you won‚Äôt even need 280 of them.)\n\nWant to participate? Here‚Äôs how:\n\n 1. Tweet a (nice) message with the #TraefikIsABlast hashtag\n 2. Eagerly wait for our bot‚Äôs (friendly) response\n 3. Click on the provided URL in the message (that looks like\n    https://username.kubecon.containo.us) to see if you‚Äôve won a T-shirt\n 4. If you‚Äôve won, rejoice (without interrupting the current talk) and come\n    claim your prize at our booth\n 5. (Optional) Brag about your trophy and show off\n\nInterested in the Architecture beyond the Demo?\nSo, what just happened?\n\nLet‚Äôs take a look at our architecture from a distance.\n\nBeyond the specific service that scans Tweeter for new messages and deploys the\nmatching containers in Kubernetes, Tr√¶fik already embeds the magic required to\ndynamically expose the result on the internet (on an HTTPS endpoint).\n\nAnd if you think that Tr√¶fik needs a lot of configuration, here is the whole\nfile that does the job:\n\ndefaultEntryPoints = \"https\"\n[entryPoints]\n [entryPoints.https]\n  address = \":443\" # - - - - - - - - - Listens on port 443\n   [entryPoints.https.tls]\n    [acme] # - - - - - - - - - - - - - Certificate configuration\n     email = \"youraccount@domain.dne\"\n     storage = \"/acme/acme.json\"\n     entryPoint = \"https\"\n     [acme.dnsChallenge]\n      provider = \"cloudflare\"\n      delayBeforeCheck = 30\n      [[acme.domains]]\n       main = \"*.kubecon.containo.us\" # Wildcard certificate\n       sans = [\"kubecon.containo.us\"]\n   [kubernetes] # - - - - - - - - - - - Tells Tr√¶fik to listen to Kubernetes\n\nThat‚Äôs it: less than 20 lines that will never be updated whether there are\ndozens or even hundreds (or even thousands!) of deployed services. Tr√¶fik will \nautomatically detect changes in your Kubernetes cluster and will publish them\nfor you, without any further work on your part.\n\nTr√¶fik is all about making your life easier, and is pretty good at its job.\n\nNow, if you want to set up your first Tr√¶fik architecture, you might want to try\nout the official 5-Minute Quick Start [https://docs.traefik.io/].\n\nSee you at our booth! (Or in the comments section below if you can‚Äôt be there)\n\nPS: the demo will be online as soon as the KubeCon Key Note starts.\n\n\n--------------------------------------------------------------------------------\n\nThe demo was written by Michael Matur [https://github.com/mmatur].\n\nContainous is the company that helps Tr√¶fik be the successful open-source\nproject it is.\n\nFollow Containous [https://twitter.com/containous] & Tr√¶fik\n[https://twitter.com/traefikproxy] on Twitter.\n\nVisit our website [/].\n\nAnd don‚Äôt forget, you‚Äôll always be welcome on the Community Forum\n[https://community.containo.us].","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Along with 200 T-Shirts for you to ‚Äútweet and win‚Äù</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-full\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-16.png\" class=\"kg-image\"></figure><p>Working on <a href=\"https://containous.ghost.io/traefik/\">an open-source project</a> can sometimes be frustrating: we code together but barely see each other.</p><p>So, this year, we‚Äôre excited to gather the whole team at the next <a href=\"https://events.linuxfoundation.org/events/kubecon-cloudnativecon-europe-2018/\" rel=\"noopener\">KubeCon Europe</a>. We can‚Äôt wait to engage in long-postponed debates around our beloved product, and we‚Äôre even more eager to spread the word:</p><blockquote>Yes, Tr√¶fik is THAT good of a reverse proxy.</blockquote><p>If you will be at the conference, come to talk to us there: <a href=\"https://containous.ghost.io/\" rel=\"noopener\">Containous</a> has set up a booth so we can answer your questions. If you were still undecided about attending ‚Äî hesitate no more :-)</p><h2 id=\"our-demo-a-tweet-and-win-\">Our Demo? A Tweet and Win!</h2><p>To demonstrate the power of <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">Tr√¶fik</a>, we‚Äôll ask you to create and deploy a container ‚Ä¶ in a Kubernetes cluster ‚Ä¶ that will automatically be exposed on an HTTPS URL ‚Ä¶ personalized with your username ‚Ä¶ that could win you a T-shirt ‚Ä¶ just by writing a single Tweet! (Yes, 140 characters will be enough, you won‚Äôt even need 280 of them.)</p><p>Want to participate? Here‚Äôs how:</p><ol><li>Tweet a (nice) message with the #TraefikIsABlast hashtag</li><li>Eagerly wait for our bot‚Äôs (friendly) response</li><li>Click on the provided URL in the message (that looks like https://username.kubecon.containo.us) to see if you‚Äôve won a T-shirt</li><li>If you‚Äôve won, rejoice (without interrupting the current talk) and come claim your prize at our booth</li><li>(Optional) Brag about your trophy and show off</li></ol><h2 id=\"interested-in-the-architecture-beyond-the-demo\">Interested in the Architecture beyond the Demo?</h2><p>So, what just happened?</p><p>Let‚Äôs take a look at our architecture from a distance.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-66.png\" class=\"kg-image\"></figure><p>Beyond the specific service that scans Tweeter for new messages and deploys the matching containers in Kubernetes, Tr√¶fik already embeds the magic required to dynamically expose the result on the internet (on an HTTPS endpoint).</p><p>And if you think that Tr√¶fik needs a lot of configuration, here is the whole file that does the job:</p><pre><code class=\"language-yaml\">defaultEntryPoints = \"https\"\n[entryPoints]\n [entryPoints.https]\n  address = \":443\" # - - - - - - - - - Listens on port 443\n   [entryPoints.https.tls]\n    [acme] # - - - - - - - - - - - - - Certificate configuration\n     email = \"youraccount@domain.dne\"\n     storage = \"/acme/acme.json\"\n     entryPoint = \"https\"\n     [acme.dnsChallenge]\n      provider = \"cloudflare\"\n      delayBeforeCheck = 30\n      [[acme.domains]]\n       main = \"*.kubecon.containo.us\" # Wildcard certificate\n       sans = [\"kubecon.containo.us\"]\n   [kubernetes] # - - - - - - - - - - - Tells Tr√¶fik to listen to Kubernetes</code></pre><p>That‚Äôs it: less than 20 lines that will never be updated whether there are dozens or even hundreds (or even <em><em>thousands</em></em>!) of deployed services. Tr√¶fik will <em><em>automatically</em></em> detect changes in your Kubernetes cluster and will publish them for you, without <em><em>any</em></em> further work on your part.</p><p>Tr√¶fik is all about making your life easier, and is pretty good at its job.</p><p>Now, if you want to set up your first Tr√¶fik architecture, you might want to try out <a href=\"https://docs.traefik.io/\">the official 5-Minute Quick Start</a>.</p><p>See you at our booth! (Or in the comments section below if you can‚Äôt be there)</p><p>PS: the demo will be online as soon as the KubeCon Key Note starts.</p><hr><p>The demo was written by <a href=\"https://github.com/mmatur\" rel=\"noopener\">Michael Matur</a>.</p><p>Containous is the company that helps Tr√¶fik be the successful open-source project it is.</p><p>Follow <a href=\"https://twitter.com/containous\" rel=\"noopener\">Containous</a> &amp; <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Tr√¶fik</a> on Twitter.</p><p><a href=\"https://containous.ghost.io/\" rel=\"noopener\">Visit our website</a>.</p><p>And don‚Äôt forget, you‚Äôll always be welcome on the <a href=\"https://community.containo.us\">Community Forum</a>.</p>","url":"https://containous.ghost.io/blog/traefik-goes-to-kubecon-europe-2018-f89a216b1d95/","canonical_url":null,"uuid":"0f38569a-224e-4aa9-a37b-e024ab3f89f9","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7f1d5f1db6f0038c744bd","reading_time":3}},{"node":{"id":"Ghost__Post__5dd7ee5df1db6f0038c7449a","title":"Traefik 1.6 ‚Äî Get Our Latest tetedemoine!","slug":"traefik-1-6-get-our-latest-tetedemoine-1859164bf521","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/monkshead.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/3e8dd3b9ae78318437039481a8ed57fb/f3583/monkshead.png","srcSet":"/static/3e8dd3b9ae78318437039481a8ed57fb/630fb/monkshead.png 300w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/2a4de/monkshead.png 600w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/f3583/monkshead.png 1200w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/bbee5/monkshead.png 1800w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/7b560/monkshead.png 1931w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.6, codename ‚Äútetedemoine‚Äù.\n\nWe merged 168 pull requests from...","custom_excerpt":"After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.6, codename ‚Äútetedemoine‚Äù.\n\nWe merged 168 pull requests from...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"May 7, 2018","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T14:19:09.000+00:00","published_at":"2018-05-07T14:18:00.000+00:00","updated_at":"2020-05-21T21:53:58.000+00:00","meta_title":"Traefik 1.6 ‚Äî Get Our Latest tetedemoine!","meta_description":"After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.6, codename ‚Äútetedemoine‚Äù.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Monk‚Äôs head [https://en.wikipedia.org/wiki/T%C3%AAte_de_Moine]After 3 months of\ndevelopment, we are thrilled to announce the fresh new release of Traefik: 1.6,\ncodename ‚Äútetedemoine‚Äù.\n\nWe merged 168 pull requests from more than 43 contributors! A huge thanks goes\nout to each of you who helped on this new version üòò.\n\nThe full changelog can be found here\n[https://github.com/containous/traefik/releases/tag/v1.6.0] but here are some\nnew features we want to highlight:\n\nLet‚Äôs Encrypt Wildcard Certificates\nThis was a long-awaited feature; we are proud to announce that we officially\nsupport Let‚Äôs Encrypt wildcard certificates generation, thanks to Nicolas Mengin\n[https://github.com/nmengin] (and thanks to xenolf [https://github.com/xenolf] \nto the initial ACMEv2 support in lego [https://github.com/xenolf/lego]). This\ngreatly simplifies certificate management as it avoids generating multiple\nsub-domains certificates. Now, it‚Äôs possible to generate root domain\ncertificates, which will work for every sub-domain.\n\nNote: ACME wildcard certificates can only be generated thanks to a DNS-01 \nchallenge:\n\n[acme]\n# ...\n[[acme.domains]]\n  main = \"*.local1.com\"\n  sans = [\"local1.com\"]\n[[acme.domains]]\n  main = \"*.local2.com\"\n# ...\n\nNo more Let‚Äôs Encrypt rate limits [https://letsencrypt.org/docs/rate-limits/] :)\n\nOpen Tracing & Zipkin support\nIn microservice architectures, being able to reconstruct the elaborate journeys\nthat transactions take as they propagate across a distributed system has become\na minimum requirement for effective monitoring.\n\n> OpenTracing allows developers of application code, OSS packages, and OSS\nservices to instrument their own code without binding to any particular tracing\nvendor.\nWe received a wonderful gift from Tristan Colgate-McFarlane\n[https://github.com/tcolgate] (with the help of Micha√´l Matur\n[https://github.com/containous/traefik/pull/2587]) who implemented Open Tracing\nsupport, right into Traefik. Have a look at the documentation\n[https://docs.traefik.io/v1.6/configuration/tracing/] to get more details.\n\nNew Web UI\nJan Kuri [https://github.com/jkuri] & Ludovic Fernandez\n[https://github.com/ldez] revamped our web UI, and we love how shiny it is.\nAmazing job!\n\nTLS Certificates in Kubernetes Secrets\nAnother awaited feature, gopenguin [https://github.com/gopenguin] added\nKubernetes Secrets support for fetching TLS certificates. This enables Traefik\nto read the Kubernetes secret defined in an ingress resource via the\n[https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress]\ntls\n[https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress] \nproperty\n[https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress]\n:\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: traefik-ui.minikube\n    http:\n      paths:\n      - backend:\n          serviceName: traefik-web-ui\n          servicePort: 80\n  tls:\n   - secretName: traefik-ui-tls-cert\n\nAccess Logs Filtering\nWith the GDPR [https://en.wikipedia.org/wiki/General_Data_Protection_Regulation] \nbecoming real in EU, logging and storage of (potentially) personally\nidentifiable information now need to be reduced in many organizations.\n\nAfter a public proposal [https://github.com/containous/traefik/issues/2875], \nMicha√´l Matur [https://github.com/containous/traefik/pull/2587] implemented a\nway to filter the content of access logs based on simple rules. Your can now \nkeep, dropor redactfields and headers from your access logs. Take a look at our\ndocumentation [https://docs.traefik.io/v1.6/configuration/logs/#access-logs] to\nget a deeper insight.\n\nLabels Homogenization\nProbably one of the biggest refactoring of all time on Traefik, Ludovic\nFernandez [https://github.com/ldez] changed the way we manage labels internally,\nin order to homogenize labels on all providers. We now support all labels on all\nproviders, no more specific code on this part üéâ\n\nThis will make it a lot easier to maintain, and we will be able to ship new\nfeatures faster on all providers.\n\n\n--------------------------------------------------------------------------------\n\nBut that‚Äôs not all, check the whole changelog\n[https://github.com/containous/traefik/releases/tag/v1.6.0] to get an idea of\nthe awesome work that has been done on this release. Lots of bugs have been\nfixed and we also have been working on background refactoring tasks that will\nhelp us improving Traefik in future releases.\n\n\n--------------------------------------------------------------------------------\n\nGrab the latest binary for Linux, Windows, Mac on Github or get the official\nDocker image!\n\ndocker pull traefik:v1.6.0 (or 1.6.0, v1.6, 1.6, tetedemoine)\ndocker pull traefik:v1.6.0-alpine (or 1.6.0-alpine, v1.6-alpine, 1.6-alpine, tetedemoine-alpine)\n\nThe versioned documentation can be found on https://docs.traefik.io\n[https://docs.traefik.io/].\n\n\n--------------------------------------------------------------------------------\n\nWe are hiring developers and evangelists, try to solve our\npuzzle:containo.us/#jobs !\n\nTraefik is still growing fast, we almost passed 15k stars on Github and 90M\ndownloads!\n\n\n--------------------------------------------------------------------------------\n\nWe would love to hear your feedback on this new release. Join us on GitHub\n[https://github.com/containous/traefik], Twitter\n[https://twitter.com/traefikproxy] or on the Community Forum\n[https://community.containo.us]!","html":"<figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://miro.medium.com/max/3862/1*FA-ZxO_2HjFO9sJpBE1SEw.png\" class=\"kg-image\"><figcaption><a href=\"https://en.wikipedia.org/wiki/T%C3%AAte_de_Moine\" class=\"bf cn hz ia ib ic\" target=\"_blank\" rel=\"noopener\" style=\"box-sizing: inherit; color: inherit; text-decoration: none; -webkit-tap-highlight-color: transparent; background-repeat: repeat-x; background-image: url(&quot;data:image/svg+xml;utf8,<svg preserveAspectRatio=\\&quot;none\\&quot; viewBox=\\&quot;0 0 1 1\\&quot; xmlns=\\&quot;http://www.w3.org/2000/svg\\&quot;><line x1=\\&quot;0\\&quot; y1=\\&quot;0\\&quot; x2=\\&quot;1\\&quot; y2=\\&quot;1\\&quot; stroke=\\&quot;rgba(0, 0, 0, 0.84)\\&quot; /></svg>&quot;); background-size: 1px 1px; background-position: 0px calc(1em + 1px);\">Monk‚Äôs head</a></figcaption></figure><p>After 3 months of development, we are thrilled to announce the fresh new release of Traefik: <em><em>1.6</em></em>, codename ‚Äú<em><em>tetedemoine‚Äù</em></em>.</p><p>We merged 168 pull requests from more than 43 contributors! A huge thanks goes out to each of you who helped on this new version üòò.</p><p>The full changelog can be found <a href=\"https://github.com/containous/traefik/releases/tag/v1.6.0\" rel=\"noopener\">here</a> but here are some new features we want to highlight:</p><h2 id=\"let-s-encrypt-wildcard-certificates\">Let‚Äôs Encrypt Wildcard Certificates</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-60.png\" class=\"kg-image\"></figure><p>This was a long-awaited feature; we are proud to announce that we officially support Let‚Äôs Encrypt wildcard certificates generation, thanks to <a href=\"https://github.com/nmengin\" rel=\"noopener\">Nicolas Mengin</a> (and thanks to <a href=\"https://github.com/xenolf\" rel=\"noopener\">xenolf</a> to the initial ACMEv2 support in <a href=\"https://github.com/xenolf/lego\" rel=\"noopener\">lego</a>). This greatly simplifies certificate management as it avoids generating multiple sub-domains certificates. Now, it‚Äôs possible to generate root domain certificates, which will work for every sub-domain.</p><p>Note: ACME wildcard certificates can only be generated thanks to a <code>DNS-01</code> challenge:</p><pre><code class=\"language-toml\">[acme]\n# ...\n[[acme.domains]]\n  main = \"*.local1.com\"\n  sans = [\"local1.com\"]\n[[acme.domains]]\n  main = \"*.local2.com\"\n# ...</code></pre><p>No more <a href=\"https://letsencrypt.org/docs/rate-limits/\" rel=\"noopener\">Let‚Äôs Encrypt rate limits</a> :)</p><h2 id=\"open-tracing-zipkin-support\">Open Tracing &amp; Zipkin support</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-61.png\" class=\"kg-image\"></figure><p>In microservice architectures, being able to reconstruct the elaborate journeys that transactions take as they propagate across a distributed system has become a minimum requirement for effective monitoring.</p><blockquote><em><em>OpenTracing allows developers of application code, OSS packages, and OSS services to instrument their own code without binding to any particular tracing vendor.</em></em></blockquote><p>We received a wonderful gift from <a href=\"https://github.com/tcolgate\" rel=\"noopener\">Tristan Colgate-McFarlane</a> (with the help of <a href=\"https://github.com/containous/traefik/pull/2587\" rel=\"noopener\">Micha√´l Matur</a>) who implemented Open Tracing support, right into Traefik. Have a look at the <a href=\"https://docs.traefik.io/v1.6/configuration/tracing/\" rel=\"noopener\">documentation</a> to get more details.</p><h2 id=\"new-web-ui\">New Web UI</h2><p><a href=\"https://github.com/jkuri\" rel=\"noopener\">Jan Kuri</a> &amp; <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a> revamped our web UI, and we love how shiny it is. Amazing job!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-62.png\" class=\"kg-image\"></figure><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-63.png\" class=\"kg-image\"></figure><h2 id=\"tls-certificates-in-kubernetes-secrets\">TLS Certificates in Kubernetes Secrets</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-64.png\" class=\"kg-image\"></figure><p>Another awaited feature, <a href=\"https://github.com/gopenguin\" rel=\"noopener\">gopenguin</a> added Kubernetes Secrets support for fetching TLS certificates. This enables Traefik to read the Kubernetes secret defined in an ingress resource <a href=\"https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress\" rel=\"noopener\">via the </a><code><a href=\"https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress\" rel=\"noopener\">tls</a></code><a href=\"https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress\" rel=\"noopener\"> property</a>:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: traefik-web-ui\n  namespace: kube-system\n  annotations:\n    kubernetes.io/ingress.class: traefik\nspec:\n  rules:\n  - host: traefik-ui.minikube\n    http:\n      paths:\n      - backend:\n          serviceName: traefik-web-ui\n          servicePort: 80\n  tls:\n   - secretName: traefik-ui-tls-cert</code></pre><h2 id=\"access-logs-filtering\">Access Logs Filtering</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-65.png\" class=\"kg-image\"></figure><p>With the <a href=\"https://en.wikipedia.org/wiki/General_Data_Protection_Regulation\" rel=\"noopener\">GDPR</a> becoming real in EU, logging and storage of (potentially) personally identifiable information now need to be reduced in many organizations.</p><p>After a <a href=\"https://github.com/containous/traefik/issues/2875\" rel=\"noopener\">public proposal</a>, <a href=\"https://github.com/containous/traefik/pull/2587\" rel=\"noopener\">Micha√´l Matur</a> implemented a way to filter the content of access logs based on simple rules. Your can now <code>keep</code>, <code>drop</code>or <code>redact</code>fields and headers from your access logs. Take a look at <a href=\"https://docs.traefik.io/v1.6/configuration/logs/#access-logs\" rel=\"noopener\">our documentation</a> to get a deeper insight.</p><h2 id=\"labels-homogenization\">Labels Homogenization</h2><p>Probably one of the biggest refactoring of all time on Traefik, <a href=\"https://github.com/ldez\" rel=\"noopener\">Ludovic Fernandez</a> changed the way we manage labels internally, in order to homogenize labels on all providers. We now support all labels on all providers, no more specific code on this part üéâ</p><p>This will make it a lot easier to maintain, and we will be able to ship new features faster on all providers.</p><hr><p>But that‚Äôs not all, check the whole <a href=\"https://github.com/containous/traefik/releases/tag/v1.6.0\" rel=\"noopener\">changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we also have been working on background refactoring tasks that will help us improving Traefik in future releases.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on Github or get the official Docker image!</p><pre><code class=\"language-shell\">docker pull traefik:v1.6.0 (or 1.6.0, v1.6, 1.6, tetedemoine)\ndocker pull traefik:v1.6.0-alpine (or 1.6.0-alpine, v1.6-alpine, 1.6-alpine, tetedemoine-alpine)</code></pre><p>The <em><em>versioned</em></em> documentation can be found on <a href=\"https://docs.traefik.io/\" rel=\"noopener\">https://docs.traefik.io</a>.</p><hr><p><strong><strong>We are hiring developers and evangelists, try to solve our puzzle:containo.us/#jobs !</strong></strong></p><p>Traefik is still growing fast, we almost passed <strong><strong>15k stars</strong></strong> on Github and <strong><strong>90M downloads</strong></strong>!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefikproxy\" rel=\"noopener\">Twitter</a> or on the <a href=\"https://community.containo.us\">Community Forum</a>!</p>","url":"https://containous.ghost.io/blog/traefik-1-6-get-our-latest-tetedemoine-1859164bf521/","canonical_url":null,"uuid":"a95156a1-e434-48e4-bd39-d023e4798bc2","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7ee5df1db6f0038c7449a","reading_time":4}},{"node":{"id":"Ghost__Post__5dcdb7431127150038885858","title":"Traefik 1.7 ‚Äî Yet Another Slice of Awesomeness","slug":"traefik-1-7-yet-another-slice-of-awesomeness-2a9c99737889","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/Traefik1-7-1.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/2039570fe141a74b6f4932f9698477a3/f3583/Traefik1-7-1.png","srcSet":"/static/2039570fe141a74b6f4932f9698477a3/630fb/Traefik1-7-1.png 300w,\n/static/2039570fe141a74b6f4932f9698477a3/2a4de/Traefik1-7-1.png 600w,\n/static/2039570fe141a74b6f4932f9698477a3/f3583/Traefik1-7-1.png 1200w,\n/static/2039570fe141a74b6f4932f9698477a3/bbee5/Traefik1-7-1.png 1800w,\n/static/2039570fe141a74b6f4932f9698477a3/0ef64/Traefik1-7-1.png 2400w,\n/static/2039570fe141a74b6f4932f9698477a3/5a4ce/Traefik1-7-1.png 2715w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Releases keep rolling! After three months of development and five release candidates, we are proud to announce the release of Traefik 1.7, codename ‚Äúmaroilles‚Äù.\n","custom_excerpt":"Releases keep rolling! After three months of development and five release candidates, we are proud to announce the release of Traefik 1.7, codename ‚Äúmaroilles‚Äù.\n","visibility":"public","created_at_pretty":"14 November, 2019","published_at_pretty":"September 25, 2018","updated_at_pretty":"21 May, 2020","created_at":"2019-11-14T20:21:23.000+00:00","published_at":"2018-09-25T08:00:00.000+00:00","updated_at":"2020-05-21T21:59:05.000+00:00","meta_title":"Traefik 1.7 ‚Äî Yet Another Slice of Awesomeness","meta_description":"Releases keep rolling! After three months of development and five release candidates, we are proud to announce the release of Traefik 1.7.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Traefik Maroilles [https://en.wikipedia.org/wiki/Maroilles_cheese]Releases keep\nrolling! After three months of development and five release candidates, we are\nproud to announce the release of Traefik 1.7, codename ‚Äúmaroilles\n[https://en.wikipedia.org/wiki/Maroilles_cheese]‚Äù.\n\nWe‚Äôve merged more pull requests than ever\n[https://github.com/containous/traefik/milestone/9?closed=1] from our\never-growing community of contributors that has reached more than 300\nindividuals. Thanks go to every one of you; we are in awe before your enthusiasm\nat improving Traefik.\n\nThe full changelog is available here\n[https://github.com/containous/traefik/releases/tag/v1.7.0], but we wanted to\nhighlight our favorite features.\n\nLet‚Äôs Encrypt & The New TLS Challenge in Town\nLet‚Äôs Encrypt integration is one of the most praised features of Traefik, so\nwhen Let‚Äôs Encrypt faced the TLS-SNI-01 challenge incident\n[https://community.letsencrypt.org/t/2018-01-09-issue-with-tls-sni-01-and-shared-hosting-infrastructure/49996]\n, some of our users were left with few (yet satisfactory) alternatives. But when \nthey introduced the TLS ALPN Challenge\n[https://community.letsencrypt.org/t/tls-alpn-validation-method/63814], Ludovic\nFernandez [https://github.com/ldez] was pleased to make it available right away\nso the community could once again pick a TLS based challenge.\n\n[acme] \n   # ‚Ä¶ \n   entryPoint = \"https\" \n   [acme.tlsChallenge] #enables the TLS ALPN Challenge\n\n\nOne of the advantage of TLS based challenges? They only require port 443 to be\nopen.\n\nA Docker Image for Windows\nBecause we didn‚Äôt want to let down our Windows user base, Traefik now has its\nofficial Windows Docker image [https://hub.docker.com/_/traefik/]!\n\nThat‚Äôs correct: no more tinkering with custom builds, you‚Äôll get your Traefik\ninstance right out of the box on your Windows Server infrastructure.\n\nFor compatibility reasons, our image is currently based on Windows \nnanoserver-sac2016, but rest assured that more recent nano server images are on\ntheir way.\n\nOur thanks go to Stefan Scherer [https://github.com/StefanScherer] who harnessed\nhis expertise to make this happen, and to Damien Duportal\n[https://github.com/dduportal] who fearlessly dove into the subject.\n\nH2C Support\nJulien Salleyron [https://github.com/Juliens] would explain it better than I do,\nbut basically, H2C is a way to do HTTP2 without certificates.\n\n> Wait ‚Ä¶ why is that useful?\nWell, when you have lots of gRPC services on your infrastructure (that by\ndefault use TLS), not having to handle a certificate for each service is a\nsimplification you will probably welcome.\n\nThis is why Traefik now supports incoming H2C requests, either by upgrading\nHTTP1 connections or dealing with ‚ÄúPrior Knowledge‚Äù requests.\n\nYou can also tell Traefik that your backend servers support H2C (using the \ntraefik.protocol=h2c label or the relevant option for your provider), in which\ncase Traefik will send HTTP2 requests (with prior knowledge) to them.\n\nTo make things even better, Traefik accepts both H2C requests and HTTP1 requests\non the same entrypoint (port). No need to separate your workload.\n\nAWS Fargate\nReleased worldwide earlier this year, Amazon has deployed AWS Fargate ‚Äî a\ncompute engine for Amazon ECS that allows you to run containers without having\nto manage servers or clusters.\n\nAs always, you can count on Traefik to support your favorite cluster technology!\nIn case you decide to run mixed clusters with EC2 and Fargate components,\nTraefik will seamlessly detect them and work with them with no additional\nefforts on your part (since Michael Matur [https://github.com/mmatur] already\ndid the job).\n\nAuth in Frontends\nYou can now configure authentication on the frontend layer, which provides\nfine-grain control on what needs to be secured.\n\nThanks go to Zatte [https://github.com/Zatte] who provided the feature for the\nKubernetes provider (and the idea itself).\n\nExcerpts from the documentation for the file provider:\n\n[frontends.myfrontend.auth]\n   headerField = \"X-WebAuth-User\"\n \n   [frontends.myfrontend.auth.basic] \n      users = [ \"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\",\n                \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\",]\n\n\nYou can also check the new authentication options available for the K8S Ingress\nprovider to get a better idea of what‚Äôs possible.\n\nSecurity\nTraefik has become a critical component for many, and we want Traefik to be safe\nfor everyone. To help us ensure that, even though these actions are not ‚Äúper se‚Äù\nnew features, we have created a new security mailing list (\nsecurity+subscribe@traefik.io\n[https://groups.google.com/a/traefik.io/forum/#!forum/security]) you can\nsubscribe to. We will use this mailing list in case there is a security issue\nthat requires your attention.\n\nAnother significant step toward making Traefik as safe as possible is the new\nform you can use to report a vulnerability [https://security.traefik.io/] you\nmight discover. By using this form, you will alert us first and give us the\nopportunity to fix a potential problem before it impacts others in a negative\nway.\n\nWe really appreciate your help on this sensitive topic.\n\nAnd Much, Much More‚Ä¶\nDaniel Tomcej [https://github.com/dtomcej] improved the TLS handshake, Andrew\nStucki [https://github.com/andrewstucki] added constraints support on ECS and \nallowed the binding of ECS container port, Michael Arenzon\n[https://github.com/marenzo] added support for stale reads from Consul catalog, \nOndrej Flidr [https://github.com/SniperCZE] tweaked the health check to add\nsupport for 3xx codes, Jesse Haka [https://github.com/zetaab] added HTTP headers\nto the healthcheck, Kim Min [https://github.com/yue9944882] made it possible to\nspecify backend servers‚Äô weight in Kubernetes, Ryarnya\n[https://github.com/ryarnyah] enabled an async option to improve log\nperformances, Rodrigo D√≠ez [https://github.com/rodrigodiez] (for his first PR!)\nadded a duration filter for the logs, Timo Reimann\n[https://github.com/timoreimann] added support for multi-port services in K8s,\nand the list goes on.\n\nOnce again, we improved many things behind the curtain and kept working to make\nTraefik better for everyone. You can check the whole changelog\n[https://github.com/containous/traefik/releases/tag/v1.7.0] to catch a glimpse\nof the awesome work that has been done on this release.\n\n\n--------------------------------------------------------------------------------\n\nBefore You Go: The Future Has Begun!\nEven if the spoiler season has not yet begun, some of our dedicated contributors\nhave noticed ‚Äî things are brewing in the master branch, things we‚Äôve been\nwilling to do for a long time, things that have been postponed until now and\nthat we‚Äôre excited to work on.\n\nYes, for now I agree that this cryptic message won‚Äôt help you find out what‚Äôs\ncoming next, but we‚Äôre sure that you‚Äôve already guessed that the next version\nwill be huge.\n\nWe‚Äôve decided to unlock all the constraints we had with the stable branch and to\nwork on features we couldn‚Äôt easily implement because of the current\narchitecture (and because of compatibility reasons). Our goal with the next\nversion is to set everything up so we can welcome an endless panel of new\nfeatures, so we can provide greater flexibility to our users (yes, you‚Äôll soon\nbe able to go even further when defining your routes).\n\nTo this day, we‚Äôve only updated the code base to get rid of the deprecated\nelements, but we‚Äôll soon need to introduce breaking changes to test our ideas.\nWhat matters here is that we want to share our vision with you so we can hear\nyour feedback. These changes will not be final choices; they will be proposals\nput to the trial of the community ‚Äî features matter only if they match your\nneeds.\n\nWhat does that mean?\nIt means that the master branch will drift apart from the current stable branch\nto become the future branch. However, until the future is now, it will remain in\nconstant evolution and prone to change with little notice.\n\nThis is the reason why we encourage our users and contributors to not use the\nmaster branch for their production system. This is also the reason why, in the\nmeantime, we‚Äôll be pickier with features introduced in the current branch and\noften redirect you to the master branch: so you can also be involved in the big\nnext.\n\n> Traefik is an open source project at its core, and we want to keep it this way ‚Äî\nthank you for being part of its success!\n\n--------------------------------------------------------------------------------\n\nGrab the latest binaries for Linux, Windows, and Mac on Github or get the\nofficial Docker image!\n\ndocker pull traefik:v1.7.0 (or 1.7.0, v1.7, 1.7, maroilles)\ndocker pull traefik:v1.7.0-alpine (or 1.7.0-alpine, v1.7-alpine, 1.7-alpine, maroilles-alpine)\ndocker pull traefik:1.7-nanoserver\n\n\nThe versioned documentation can be found on https://docs.traefik.io\n[https://docs.traefik.io/].\n\n\n--------------------------------------------------------------------------------\n\nBy the way, if you want to join an incredible team so you can express your every\ntalent: We are hiring! Check our available positions [/careers]!\n\nTraefik adoption rate is astounding! We‚Äôve reached 17k+ stars on Github and \n200M+ downloads!\n\n\n--------------------------------------------------------------------------------\n\nWe would love to hear your feedback on this new release. Join us on GitHub\n[https://github.com/containous/traefik], Twitter [https://twitter.com/traefik] \nor on the Community Forum [https://community.containo.us]!","html":"<figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-15.png\" class=\"kg-image\"><figcaption>Traefik <a href=\"https://en.wikipedia.org/wiki/Maroilles_cheese\" rel=\"noopener\">Maroilles</a></figcaption></figure><p>Releases keep rolling! After three months of development and five release candidates, we are proud to announce the release of Traefik <em><em>1.7</em></em>, codename ‚Äú<a href=\"https://en.wikipedia.org/wiki/Maroilles_cheese\" rel=\"noopener nofollow\"><em><em>maroilles</em></em></a><em><em>‚Äù</em></em>.</p><p>We‚Äôve merged <a href=\"https://github.com/containous/traefik/milestone/9?closed=1\" rel=\"noopener nofollow\">more pull requests than ever</a> from our ever-growing community of contributors that has reached more than 300 individuals. Thanks go to every one of you; we are in awe before your enthusiasm at improving Traefik.</p><p>The full changelog is available <a href=\"https://github.com/containous/traefik/releases/tag/v1.7.0\" rel=\"noopener nofollow\">here</a>, but we wanted to highlight our favorite features.</p><h2 id=\"let-s-encrypt-the-new-tls-challenge-in-town\">Let‚Äôs Encrypt &amp; The New TLS Challenge in Town</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/letsEncrypt.png\" class=\"kg-image\"></figure><p>Let‚Äôs Encrypt integration is one of the most praised features of Traefik, so when Let‚Äôs Encrypt faced the <a href=\"https://community.letsencrypt.org/t/2018-01-09-issue-with-tls-sni-01-and-shared-hosting-infrastructure/49996\" rel=\"noopener nofollow\">TLS-SNI-01 challenge incident</a>, some of our users were left with few (yet satisfactory) alternatives. But when <a href=\"https://community.letsencrypt.org/t/tls-alpn-validation-method/63814\" rel=\"noopener nofollow\">they introduced the TLS ALPN Challenge</a>, <a href=\"https://github.com/ldez\" rel=\"noopener nofollow\">Ludovic Fernandez</a> was pleased to make it available right away so the community could once again pick a TLS based challenge.</p><!--kg-card-begin: markdown--><pre><code>[acme] \n   # ‚Ä¶ \n   entryPoint = &quot;https&quot; \n   [acme.tlsChallenge] #enables the TLS ALPN Challenge\n</code></pre>\n<!--kg-card-end: markdown--><p>One of the advantage of TLS based challenges? They only require port 443 to be open.</p><h2 id=\"a-docker-image-for-windows\">A Docker Image for Windows</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/DockerImageForWindows.png\" class=\"kg-image\"></figure><p>Because we didn‚Äôt want to let down our Windows user base, Traefik now has its official <a href=\"https://hub.docker.com/_/traefik/\" rel=\"noopener nofollow\">Windows Docker image</a>!</p><p>That‚Äôs correct: no more tinkering with custom builds, you‚Äôll get your Traefik instance right out of the box on your Windows Server infrastructure.</p><p>For compatibility reasons, our image is currently based on Windows <code>nanoserver-sac2016</code>, but rest assured that more recent nano server images are on their way.</p><p>Our thanks go to <a href=\"https://github.com/StefanScherer\" rel=\"noopener nofollow\">Stefan Scherer</a> who harnessed his expertise to make this happen, and to <a href=\"https://github.com/dduportal\" rel=\"noopener nofollow\">Damien Duportal</a> who fearlessly dove into the subject.</p><h2 id=\"h2c-support\">H2C Support</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/HTTP2.png\" class=\"kg-image\"></figure><p><a href=\"https://github.com/Juliens\" rel=\"noopener nofollow\">Julien Salleyron</a> would explain it better than I do, but basically, H2C is a way to do HTTP2 <em><em>without</em></em> certificates.</p><blockquote><em><em>Wait ‚Ä¶ why is that useful?</em></em></blockquote><p>Well, when you have lots of gRPC services on your infrastructure (that by default use TLS), <em><em>not</em></em> having to handle a certificate for each service is a simplification you will probably welcome.</p><p>This is why Traefik now supports incoming H2C requests, either by upgrading HTTP1 connections or dealing with ‚ÄúPrior Knowledge‚Äù requests.</p><p>You can also tell Traefik that your backend servers support H2C (using the <code>traefik.protocol=h2c</code> label or the relevant option for your provider), in which case Traefik will send HTTP2 requests (with prior knowledge) to them.</p><p>To make things even better, Traefik accepts <em><em>both</em></em> H2C requests <em><em>and</em></em> HTTP1 requests on the <em><em>same</em></em> entrypoint (port). No need to separate your workload.</p><h2 id=\"aws-fargate\">AWS Fargate</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/AWSFargate.png\" class=\"kg-image\"></figure><p>Released worldwide earlier this year, Amazon has deployed AWS Fargate ‚Äî <em><em>a compute engine for Amazon ECS that allows you to run containers without having to manage servers or clusters.</em></em></p><p>As always, you can count on Traefik to support your favorite cluster technology! In case you decide to run mixed clusters with EC2 and Fargate components, Traefik will seamlessly detect them and work with them with no additional efforts on your part (since <a href=\"https://github.com/mmatur\" rel=\"noopener nofollow\">Michael Matur</a> already did the job).</p><h2 id=\"auth-in-frontends\">Auth in Frontends</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/AuthInFrontends.jpeg\" class=\"kg-image\"></figure><p>You can now configure authentication on the frontend layer, which provides fine-grain control on what needs to be secured.</p><p>Thanks go to <a href=\"https://github.com/Zatte\" rel=\"noopener nofollow\">Zatte</a> who provided the feature for the Kubernetes provider (and the idea itself).</p><p>Excerpts from the documentation for the file provider:</p><!--kg-card-begin: markdown--><pre><code>[frontends.myfrontend.auth]\n   headerField = &quot;X-WebAuth-User&quot;\n \n   [frontends.myfrontend.auth.basic] \n      users = [ &quot;test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/&quot;,\n                &quot;test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0&quot;,]\n</code></pre>\n<!--kg-card-end: markdown--><p>You can also check the new authentication options available for the K8S Ingress provider to get a better idea of what‚Äôs possible.</p><h2 id=\"security\">Security</h2><p>Traefik has become a critical component for many, and we want Traefik to be safe for everyone. To help us ensure that, even though these actions are not ‚Äúper se‚Äù new features, we have created a new security mailing list (<a href=\"https://groups.google.com/a/traefik.io/forum/#!forum/security\" rel=\"noopener nofollow\">security+subscribe@traefik.io</a>) you can subscribe to. We will use this mailing list in case there is a security issue that requires your attention.</p><p>Another significant step toward making Traefik as safe as possible is the new form you can use to <a href=\"https://security.traefik.io/\" rel=\"noopener nofollow\">report a vulnerability</a> you might discover. By using this form, you will alert us first and give us the opportunity to fix a potential problem before it impacts others in a negative way.</p><p>We really appreciate your help on this sensitive topic.</p><h2 id=\"and-much-much-more-\">And Much, Much More‚Ä¶</h2><p><a href=\"https://github.com/dtomcej\" rel=\"noopener nofollow\">Daniel Tomcej</a> improved the TLS handshake, <a href=\"https://github.com/andrewstucki\" rel=\"noopener nofollow\">Andrew Stucki</a> added constraints support on ECS <em><em>and</em></em> allowed the binding of ECS container port, <a href=\"https://github.com/marenzo\" rel=\"noopener nofollow\">Michael Arenzon</a> added support for stale reads from Consul catalog, <a href=\"https://github.com/SniperCZE\" rel=\"noopener nofollow\">Ondrej Flidr</a> tweaked the health check to add support for 3xx codes, <a href=\"https://github.com/zetaab\" rel=\"noopener nofollow\">Jesse Haka</a> added HTTP headers to the healthcheck, <a href=\"https://github.com/yue9944882\" rel=\"noopener nofollow\">Kim Min</a> made it possible to specify backend servers‚Äô weight in Kubernetes, <a href=\"https://github.com/ryarnyah\" rel=\"noopener nofollow\">Ryarnya</a> enabled an async option to improve log performances, <a href=\"https://github.com/rodrigodiez\" rel=\"noopener nofollow\">Rodrigo D√≠ez</a> (for his first PR!) added a duration filter for the logs, <a href=\"https://github.com/timoreimann\" rel=\"noopener nofollow\">Timo Reimann</a> added support for multi-port services in K8s, and the list goes on.</p><p>Once again, we improved many things behind the curtain and kept working to make Traefik better for everyone. You can check the whole <a href=\"https://github.com/containous/traefik/releases/tag/v1.7.0\" rel=\"noopener nofollow\">changelog</a> to catch a glimpse of the awesome work that has been done on this release.</p><hr><h2 id=\"before-you-go-the-future-has-begun-\">Before You Go: The Future Has Begun!</h2><p>Even if the spoiler season has not yet begun, some of our dedicated contributors have noticed ‚Äî <em><em>things</em></em> are brewing in the master branch, <em><em>things</em></em> we‚Äôve been willing to do for a long time, <em><em>things</em></em> that have been postponed until now and that we‚Äôre excited to work on.</p><p>Yes, for now I agree that this cryptic message won‚Äôt help you find out what‚Äôs coming next, but we‚Äôre sure that you‚Äôve already guessed that the next version will be huge.</p><p>We‚Äôve decided to unlock all the constraints we had with the stable branch and to work on features we couldn‚Äôt easily implement because of the current architecture (and because of compatibility reasons). Our goal with the next version is to set everything up so we can welcome an endless panel of new features, so we can provide greater flexibility to our users (yes, you‚Äôll soon be able to go even further when defining your routes).</p><p>To this day, we‚Äôve only updated the code base to get rid of the deprecated elements, but we‚Äôll soon need to introduce breaking changes to test our ideas. What matters here is that we want to share our vision with you so we can hear your feedback. These changes will not be final choices; they will be proposals put to the trial of the community ‚Äî features matter only if they match your needs.</p><h3 id=\"what-does-that-mean\">What does that mean?</h3><p>It means that the master branch will drift apart from the current stable branch to become the <em><em>future</em></em> branch. However, until the <em><em>future</em></em> is now, it will remain in constant evolution and prone to change with little notice.</p><p>This is the reason why we encourage our users and contributors to <em><em>not</em></em> use the master branch for their production system. This is also the reason why, in the meantime, we‚Äôll be pickier with features introduced in the current branch and often redirect you to the master branch: so you can also be involved in the <em><em>big next</em></em>.</p><blockquote><em><em>Traefik is an open source project at its core, and we want to keep it this way ‚Äî thank you for being part of its success!</em></em></blockquote><hr><p>Grab the latest binaries for Linux, Windows, and Mac on Github or get the official Docker image!</p><!--kg-card-begin: markdown--><pre><code>docker pull traefik:v1.7.0 (or 1.7.0, v1.7, 1.7, maroilles)\ndocker pull traefik:v1.7.0-alpine (or 1.7.0-alpine, v1.7-alpine, 1.7-alpine, maroilles-alpine)\ndocker pull traefik:1.7-nanoserver\n</code></pre>\n<!--kg-card-end: markdown--><p>The <em><em>versioned</em></em> documentation can be found on <a href=\"https://docs.traefik.io/\" rel=\"noopener nofollow\">https://docs.traefik.io</a>.</p><hr><p>By the way, if you want to join an incredible team so you can express your every talent:<strong><strong> We are hiring! </strong></strong>Check <a href=\"https://containous.ghost.io/careers\" rel=\"noopener nofollow\">our available positions</a>!</p><p>Traefik adoption rate is astounding! We‚Äôve reached <strong><strong>17k+ stars</strong></strong> on Github and <strong><strong>200M+ downloads</strong></strong>!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener nofollow\">GitHub</a>, <a href=\"https://twitter.com/traefik\" rel=\"noopener nofollow\">Twitter</a> or on the <a href=\"https://community.containo.us\">Community Forum</a>!</p>","url":"https://containous.ghost.io/blog/traefik-1-7-yet-another-slice-of-awesomeness-2a9c99737889/","canonical_url":null,"uuid":"aa619476-2180-482f-8a05-08eb3c1515f3","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dcdb7431127150038885858","reading_time":6}},{"node":{"id":"Ghost__Post__5dd7ec91f1db6f0038c74462","title":"Spread the Love!","slug":"spread-the-love-ba5a40aa72e7","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/traefik-stickers.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/4ec6d432415ed44b8445ae39fc79e44b/47498/traefik-stickers.jpg","srcSet":"/static/4ec6d432415ed44b8445ae39fc79e44b/9dc27/traefik-stickers.jpg 300w,\n/static/4ec6d432415ed44b8445ae39fc79e44b/4fe8c/traefik-stickers.jpg 600w,\n/static/4ec6d432415ed44b8445ae39fc79e44b/47498/traefik-stickers.jpg 1200w,\n/static/4ec6d432415ed44b8445ae39fc79e44b/52258/traefik-stickers.jpg 1800w,\n/static/4ec6d432415ed44b8445ae39fc79e44b/a41d1/traefik-stickers.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Hi everyone! I hope you‚Äôre enjoying Traefik as much as we enjoy building it with you.\nToday, while browsing the web...","custom_excerpt":"Hi everyone! I hope you‚Äôre enjoying Traefik as much as we enjoy building it with you.\nToday, while browsing the web...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"October 29, 2018","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T14:11:29.000+00:00","published_at":"2018-10-29T14:11:00.000+00:00","updated_at":"2020-05-22T00:24:50.000+00:00","meta_title":"Spread the Love!","meta_description":"Hi everyone! I hope you‚Äôre enjoying Traefik as much as we enjoy building it with you.\nToday, while browsing the web...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Community","slug":"community","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"And Say It with Stickers :-)\n\nOur Beloved GopherHi everyone! I hope you‚Äôre enjoying Traefik [/traefik/] as much as we enjoy\nbuilding it with you.\n\nToday, while browsing the web (even though I had better things to do), I\nrealized how many of you have shown love by giving talks\n[https://events.docker.com/events/details/docker-blacksburg-presents-container-orchestration-migrating-to-the-cloud-using-docker-and-traefik#/] \n(or by writing blog posts\n[https://medium.com/@yanick.witschi/automated-kubernetes-deployments-with-gitlab-helm-and-traefik-4e54bec47dcf]\n) which show how you leverage Traefik to enable dazzling architectures.\n\nThen, as I was staring into space (thinking about how that cat video would have\nbeen much cooler with a gopher), I saw my colleagues‚Äô laptops ‚Ä¶ covered with\nstickers ‚Ä¶ and it clicked.\n\n> We should help our fans spread the word with swag to distribute!\nYes, I know that it‚Äôs not as mind blowing as the new features we‚Äôll soon talk\nabout, but it‚Äôs a start, right?\n\nSo, if you‚Äôre a Traefik fan (which makes us your fans!), and since the gopher in\nour logo is adorable (not to say utterly, hypnotically handsome), perhaps you‚Äôd\nlike some stickers to distribute to your audience at your talks! ‚Äî They are a\n‚Äúnice to have‚Äù we developers enjoy üòâ\n\nIf you‚Äôd like us to send you some stickers, please fill out this form\n[https://docs.google.com/forms/d/e/1FAIpQLSfzLUboLnb5sajJfoYNT34Jiqe_4f71kE0DsUqloWZdaC6UWg/viewform?usp=sf_link] \nand we will ship some to you right away. The form will ask you all the necessary\ndetails we need to help you promote the event. (And give you swag!)\n\nWe are so proud to spread the word with you ‚Äî Thank you for contributing and\nsharing the value of Traefik.\n\n \n[https://docs.google.com/forms/d/e/1FAIpQLSfzLUboLnb5sajJfoYNT34Jiqe_4f71kE0DsUqloWZdaC6UWg/viewform?usp=sf_link]\n\n> You can use the form to show us your best blog posts too ‚Ä¶ our favorites will\nget their swag!\n\n--------------------------------------------------------------------------------\n\nAlso, since we‚Äôre talking about‚Ä¶ talking about Traefik (did that make sense?),\nthere is one more thing I want to mention. We‚Äôre looking for you, a talented\ndeveloper advocate eager to join an incredible team. Check out the role here: \nDeveloper Advocate @ Containous [/careers/].\n\nAnd if you‚Äôre interested, well, you know what you have to do. (Apply!)","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">And Say It with Stickers :-)</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-full kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-14.png\" class=\"kg-image\"><figcaption>Our Beloved Gopher</figcaption></figure><p>Hi everyone! I hope you‚Äôre enjoying <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> as much as we enjoy building it with you.</p><p>Today, while browsing the web (even though I had better things to do), I realized how many of you have shown love by giving <a href=\"https://events.docker.com/events/details/docker-blacksburg-presents-container-orchestration-migrating-to-the-cloud-using-docker-and-traefik#/\" rel=\"noopener\">talks</a> (or by writing <a href=\"https://medium.com/@yanick.witschi/automated-kubernetes-deployments-with-gitlab-helm-and-traefik-4e54bec47dcf\" rel=\"noopener\">blog posts</a>) which show how you leverage Traefik to enable dazzling architectures.</p><p>Then, as I was staring into space (thinking about how that cat video would have been much cooler with a gopher), I saw my colleagues‚Äô laptops ‚Ä¶ covered with stickers ‚Ä¶ and it clicked.</p><blockquote>We should help our fans spread the word with swag to distribute!</blockquote><p>Yes, I know that it‚Äôs not as mind blowing as the new features we‚Äôll soon talk about, but it‚Äôs a start, right?</p><p>So, if you‚Äôre a Traefik fan (which makes us <em><em>your</em></em> fans!), and since the gopher in our logo is adorable (not to say utterly, hypnotically handsome), perhaps you‚Äôd like some stickers to distribute to your audience at your talks! ‚Äî They are a ‚Äúnice to have‚Äù we developers enjoy üòâ</p><p>If you‚Äôd like us to send you some stickers, please fill out <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSfzLUboLnb5sajJfoYNT34Jiqe_4f71kE0DsUqloWZdaC6UWg/viewform?usp=sf_link\" rel=\"noopener\">this form</a> and we will ship some to you right away. The form will ask you all the necessary details we need to help you promote the event. (And give you swag!)</p><p>We are so proud to spread the word with you ‚Äî Thank you for contributing and sharing the value of Traefik.</p><!--kg-card-begin: markdown--><p><a href=\"https://docs.google.com/forms/d/e/1FAIpQLSfzLUboLnb5sajJfoYNT34Jiqe_4f71kE0DsUqloWZdaC6UWg/viewform?usp=sf_link\"><img src=\"https://containous.ghost.io/content/images/2019/11/iwantswag.png\" alt=\"iwantswag\"></a></p>\n<!--kg-card-end: markdown--><blockquote>You can use the form to show us your best blog posts too ‚Ä¶ our favorites will get their swag!</blockquote><hr><p>Also, since we‚Äôre talking about‚Ä¶ talking about Traefik (did that make sense?), there is one more thing I want to mention. We‚Äôre looking for <em><em>you,</em></em> a talented developer advocate eager to join an incredible team. Check out the role here: <a href=\"https://containous.ghost.io/careers/\">Developer Advocate @ Containous</a>.</p><p>And if you‚Äôre interested, well, you know what you have to do. (Apply!)</p>","url":"https://containous.ghost.io/blog/spread-the-love-ba5a40aa72e7/","canonical_url":null,"uuid":"5fd7f3cf-06d7-4cb7-a944-160a3a227585","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7ec91f1db6f0038c74462","reading_time":2}},{"node":{"id":"Ghost__Post__5dd7eb67f1db6f0038c74435","title":"Traefik ‚Äî Spoiler Season ‚Äî Episode 1","slug":"traefik-spoiler-season-episode-1-3dbcb1f5d8b9","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/wip-traefik.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/bf6dc1c716dac26a7c9c89d237a4e47e/9c108/wip-traefik.png","srcSet":"/static/bf6dc1c716dac26a7c9c89d237a4e47e/630fb/wip-traefik.png 300w,\n/static/bf6dc1c716dac26a7c9c89d237a4e47e/9c108/wip-traefik.png 585w","sizes":"(max-width: 585px) 100vw, 585px"}}},"excerpt":"Hi everyone! Today is a very special day: we‚Äôre here to talk about changes. Yes, the changes we‚Äôve been playing around with, the changes we talked about in...","custom_excerpt":"Hi everyone! Today is a very special day: we‚Äôre here to talk about changes. Yes, the changes we‚Äôve been playing around with, the changes we talked about in...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"November 19, 2018","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T14:06:31.000+00:00","published_at":"2018-11-19T14:06:00.000+00:00","updated_at":"2020-05-22T00:48:26.000+00:00","meta_title":"Traefik ‚Äî Spoiler Season ‚Äî Episode 1","meta_description":"Today is a very special day: we‚Äôre here to talk about changes. Yes, the changes we‚Äôve been playing around with, the changes we talked about in...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"The Story of the Configuration Structure\n\nHi everyone! Today is a very special day: we‚Äôre here to talk about changes.\n\nYes, the changes we‚Äôve been playing around with, the changes we talked about in \nthe latest release note\n[/blog/traefik-1-7-yet-another-slice-of-awesomeness-2a9c99737889/], the changes\nwe‚Äôre looking forward to bringing to the next version of Traefik.\n\nBut like in every spoiler undertaking, we won‚Äôt disclose everything (where would\nbe the fun in that?).\n\nToday we‚Äôre going to discuss the configuration structure ‚Äî the infamous \nentrypoints, frontends, and backends and how they interact together.\n\n\n--------------------------------------------------------------------------------\n\nNote: In the article, we‚Äôll use the file provider to talk about the changes.\nThis provider best exposes the structure of the configuration and is the\nfoundation for the other label / annotation-driven providers. Of course,\neverything that applies to the file provider should apply to the\nlabel/annotation based providers.\n\nNote 2: In this article, we‚Äôll assume that you‚Äôre a knowledgeable Traefik\nenthusiast.\n\nNote 3: Nope, no note 3, I‚Äôm good, let‚Äôs move on.\n\n\n--------------------------------------------------------------------------------\n\nIt All Started with‚Ä¶\nTo this day, Traefik‚Äôs configuration is quite simple and accounts for a great\npart of its success.\n\nEntrypoints accept the incoming requests (for the most part: ports & certificate\nmanagement), frontends analyze the requests to determine what should handle\nthem, and backends are responsible for forwarding the requests to your system\n(your both beloved and hated microservices).\n\nSince everyone loves diagrams (at least I do), below is the magic happening.\n\nThis architecture works like a charm because you can configure everything you\nneed, from authentication to redirects, to circuit breaker mechanisms, to retry\nmechanisms, to custom errors, to HTTPS, to load-balancing, to whatever you need.\nAnd better, it works with many providers (k8s, docker, AWS, mesos, ‚Ä¶).\n\nBut ‚Ä¶ (always a but) ‚Ä¶ sometimes people were confused about where to configure\nthese options. Other times, people were confused because some options were\nmagically applied in a predetermined order they could not easily change (and no,\nhacking our way into the bowels of Traefik is not literally easy).\n\nBecause so many options were added since Traefik‚Äôs initial launch, we‚Äôre in a\nsituation where the magic comes along with a cost: things are less obvious than\nbefore, and it becomes a problem when you need to fine-tune the routing for\nspecific requests.\n\nAlso, since we‚Äôre complaining about the configuration, I have to say that I hate\nto repeat myself ‚Äî which was sometimes a problem when (for example) I wanted to\nput the same auth mechanism on several frontends (but not every one of them).\n\n‚Ä¶ And It Will Become\nSo we took a step back, gave it some thought, and came up with our first\nproposal ‚Ä¶ What if we wrote‚Ä¶\n\nEntrypoints accept the incoming requests, routers analyze the requests to\ndetermine what should handle them, and services are responsible for handling the\nrequests and ultimately forwarding them to your system (your both beloved and\nhated microservices).\n\n> D√©j√† vu?\nSee? SO different! It‚Äôs even more obvious in the following diagram.\n\nAre You Kidding?\nWell, we‚Äôre not.\n\nAt first sight, apart from the vocabulary update, we agree that nothing has \nobviously changed: same sequence of operations.\n\nWhat really changed is what‚Äôs happening inside.\n\nMiddleware ‚Äî The (Almost) Newcomer\nIf you look closely to the new diagram, you‚Äôll notice that something is missing,\nand then you‚Äôll realize that this something is quite important.\n\nYou can pause here, go back to the diagram and keep reading once you‚Äôve figured\nit out, but for the impatient amongst us, here it is: In the diagram, nothing \nupdates the request, nothing checks the credentials, nothing tweaks the path or\nthe domain. In the diagram, a whole block of features is missing.\n\nBut how come this crucial element isn‚Äôt shouting its absence from the diagram?\nIt‚Äôs simply because the configuration for these updates/tweaks/behaviors used to\nbe spread across the existing components (entrypoints, frontends, and backends).\n\nSoon, they will be configured in dedicated pieces of middleware and referred to\nfrom entrypoints, routers, and services. What‚Äôs more important ‚Äî You will decide\nhow, when, and in which order.\n\n> Yes, you will have full control.\nBefore / After (The TL;DR you‚Äôre looking for)\nWe Want Examples!\nThat‚Äôs a legitimate request ‚Äî let‚Äôs start with a super basic example with a\nfrontend, a backend, and no additional fluff.\n\n> A frontend (router), a backend (service), and no additional fluff\nbefore\n[frontends]\n   [frontends.my-frontend]\n      entrypoint = [\"http\"]\n      backend = my-backend\n      [frontend.my-frontend.routes.route1]\n         rule = \"Host:myhost.com\"\n\n[backends]\n   [backends.my-backend]\n      [backends.my-backend1.servers]          \n         [backends.backend1.servers.server-1]\n            url = \"http://xx.xx.xx.xx\"\n\nafter\n[routers]\n   [routers.my-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost.com\"\n      service = my-service\n\n[services]\n   [services.my-service.load-balancer]\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"\n\nApart from the vocabulary difference, this one brings nothing new to the table.\n(Yes, I‚Äôll behave as if there was no additional .load-balancer type for the\nservice because this will be for another episode.)\n\nIf we wanted to have another server, of course, we would write:\n\n[routers]\n   [routers.my-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost.com\"\n      service = my-service\n\n[services]\n   [services.my-service.load-balancer]\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"\n\n> Now, let‚Äôs add basic authentication!\nbefore\n[frontends]\n   [frontends.my-frontend]\n      entrypoint = [\"http\"]\n      backend = my-backend\n      [frontend.my-frontend.routes.route1]\n         rule = \"Host:myhost.com\"\n      [frontend.my-frontend.auth]\n         [frontend.my-frontend.auth.basic]\n            users = [\"admin:xxx\",\"super-admin:xxx\",]\n\n[backends]\n   [backends.my-backend]\n      [backends.my-backend1.servers]          \n         [backends.backend1.servers.server-1]\n            url = \"http://xx.xx.xx.xx\"\n\nafter\n[routers]\n   [routers.my-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost.com\"\n      middlewares = [\"admins-only\"]\n      service = my-service\n\n[middlewares]\n   [middlewares.admins-only.basicauth]\n      users = [\"admin:xxx\",\"super-admin:xxx\",]\n\n[services]\n   [services.my-service.load-balancer]\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"\n\nThe basic authentication middleware is no longer configured inside the router\nbut in a dedicated middleware section. The good news, besides readability, is\nthat you can now reuse the same middleware in a different router, along with\nother middlewares.\n\n[routers]\n   [routers.my-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost.com\"\n      middlewares = [\"admins-only\"]\n      service = my-service\n   \n   [routers.my-other-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost2.com\"\n      middlewares = [\"admins-only\", \"retry-std\"]\n      service = my-service\n\n[middlewares]\n   [middlewares.admins-only.basicauth]\n      users = [\"admin:xxx\",\"super-admin:xxx\",]\n   [middlewares.retry-std.retry]\n      attempts = 2\n\n[services]\n   [services.my-service.load-balancer]\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"\n\nAlso, another benefit you probably have noticed ‚Äî you can now have many separate\nconfigurations for some features (like retry) and choose the one that fits for\nyour routers.\n\nBehind the scenes, many other things have already changed (not yet obvious), but\nwe‚Äôd like to tease with more episodes!\n\nBesides, we‚Äôve decided to show you one ‚Äúwork in progress‚Äù feature at a time ‚Äî\nthis gives time to listen to your feedback!\n\n\n--------------------------------------------------------------------------------\n\nTraefik is a project driven by the community! We are more grateful than ever for\nyour feedback on the project. We‚Äôve reached 18k+ stars on Github, and the\nproduct has been downloaded more than 350 million times!\n\n\n--------------------------------------------------------------------------------\n\nJoin us on GitHub [https://github.com/containous/traefik], Twitter\n[https://twitter.com/traefik], on the Community Forum\n[https://community.containo.us], or in the comments below so we can hear your\nvoice!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">The Story of the Configuration Structure</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-13.png\" class=\"kg-image\"></figure><p>Hi everyone! Today is a very special day: we‚Äôre here to talk about changes.</p><p>Yes, <em><em>the</em></em> changes we‚Äôve been playing around with, the changes we talked about in <a href=\"https://containous.ghost.io/blog/traefik-1-7-yet-another-slice-of-awesomeness-2a9c99737889/\">the latest release note</a>, the changes we‚Äôre looking forward to bringing to the next version of Traefik.</p><p>But like in every spoiler undertaking, we won‚Äôt disclose everything (where would be the fun in that?).</p><p>Today we‚Äôre going to discuss the configuration <em><em>structure ‚Äî</em></em> the infamous <code>entrypoints</code>, <code>frontends</code>, and <code>backends</code> and how they interact together<em><em>.</em></em></p><hr><p><strong><strong><em><em>Note:</em></em></strong></strong><em><em> In the article, we‚Äôll use the </em></em><code><em><em>file</em></em></code><em><em> provider to talk about the changes. This provider best exposes the structure of the configuration and is the foundation for the other label / annotation-driven providers. Of course, everything that applies to the </em></em><code><em><em>file</em></em></code><em><em> provider should apply to the label/annotation based providers.</em></em></p><p><strong><strong>Note 2:</strong></strong> In this article, we‚Äôll assume that you‚Äôre a knowledgeable Traefik enthusiast.</p><p><strong><strong>Note 3:</strong></strong> Nope, no note 3, I‚Äôm good, let‚Äôs move on.</p><hr><h2 id=\"it-all-started-with-\">It All Started with‚Ä¶</h2><p>To this day, Traefik‚Äôs configuration is quite simple and accounts for a great part of its success.</p><p><code>Entrypoints</code> accept the incoming requests (for the most part: ports &amp; certificate management), <code>frontends</code> analyze the requests to determine what should handle them, and <code>backends</code> are responsible for forwarding the requests to your system (your both beloved and hated microservices).</p><p>Since everyone loves diagrams (at least I do), below is the magic happening.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-56.png\" class=\"kg-image\"></figure><p>This architecture works like a charm because you can configure everything you need, from authentication to redirects, to circuit breaker mechanisms, to retry mechanisms, to custom errors, to HTTPS, to load-balancing, to whatever you need. And better, it works with many providers (k8s, docker, AWS, mesos, ‚Ä¶).</p><p>But ‚Ä¶ (always a but) ‚Ä¶ sometimes people were confused about where to configure these options. Other times, people were confused because some options were magically applied in a predetermined order they could not easily change (and no, hacking our way into the bowels of Traefik is not literally easy).</p><p>Because so many options were added since Traefik‚Äôs initial launch, we‚Äôre in a situation where the magic comes along with a cost: things are less obvious than before, and it becomes a problem when you need to fine-tune the routing for specific requests.</p><p>Also, since we‚Äôre complaining about the configuration, I have to say that I hate to repeat myself ‚Äî which was sometimes a problem when (for example) I wanted to put the same auth mechanism on several frontends (but not every one of them).</p><h2 id=\"-and-it-will-become\">‚Ä¶ And It Will Become</h2><p>So we took a step back, gave it some thought, and came up with our first proposal ‚Ä¶ What if we wrote‚Ä¶</p><p><code>Entrypoints</code> accept the incoming requests, <code>routers</code> analyze the requests to determine what should handle them, and <code>services</code> are responsible for handling the requests and ultimately forwarding them to your system (your both beloved and hated microservices).</p><blockquote><em><em><em>D√©j√† vu?</em></em></em></blockquote><p>See? <em><em>SO</em></em> different! It‚Äôs even more obvious in the following diagram.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-57.png\" class=\"kg-image\"></figure><h3 id=\"are-you-kidding\">Are You Kidding?</h3><p>Well, we‚Äôre not.</p><p>At first sight, apart from the vocabulary update, we agree that nothing has <em><em>obviously</em></em> changed: same sequence of operations.</p><p>What really changed is what‚Äôs happening <em><em>inside</em></em>.</p><h3 id=\"middleware-the-almost-newcomer\">Middleware ‚Äî The (Almost) Newcomer</h3><p>If you look closely to the new diagram, you‚Äôll notice that <em><em>something</em></em> is missing, and then you‚Äôll realize that this <em><em>something</em></em> is quite important.</p><p>You can pause here, go back to the diagram and keep reading once you‚Äôve figured it out, but for the impatient amongst us, here it is: In the diagram, <em><em>nothing</em></em> updates the request, <em><em>nothing</em></em> checks the credentials, <em><em>nothing</em></em> tweaks the path or the domain. In the diagram, a whole block of features is missing.</p><p>But how come this crucial element isn‚Äôt shouting its absence from the diagram? It‚Äôs simply because the configuration for these updates/tweaks/behaviors used to be spread across the existing components (<code>entrypoints</code>, <code>frontends</code>, and <code>backends</code>).</p><p>Soon, they will be configured in dedicated pieces of <code>middleware</code> and referred to from <code>entrypoints</code>, <code>routers</code>, and <code>services</code>. What‚Äôs more important ‚Äî <em><em>You</em></em> will decide how, when, and in which order.</p><blockquote><em><em>Yes, you will have full control.</em></em></blockquote><h2 id=\"before-after-the-tl-dr-you-re-looking-for-\">Before / After (The TL;DR you‚Äôre looking for)</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-58.png\" class=\"kg-image\"></figure><h2 id=\"we-want-examples-\">We Want Examples!</h2><p>That‚Äôs a legitimate request ‚Äî let‚Äôs start with a super basic example with a frontend, a backend, and no additional fluff.</p><blockquote>A frontend (router), a backend (service), and no additional fluff</blockquote><h3 id=\"before\">before</h3><pre><code class=\"language-toml\">[frontends]\n   [frontends.my-frontend]\n      entrypoint = [\"http\"]\n      backend = my-backend\n      [frontend.my-frontend.routes.route1]\n         rule = \"Host:myhost.com\"\n\n[backends]\n   [backends.my-backend]\n      [backends.my-backend1.servers]          \n         [backends.backend1.servers.server-1]\n            url = \"http://xx.xx.xx.xx\"</code></pre><h3 id=\"after\">after</h3><pre><code class=\"language-toml\">[routers]\n   [routers.my-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost.com\"\n      service = my-service\n\n[services]\n   [services.my-service.load-balancer]\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"</code></pre><p>Apart from the vocabulary difference, this one brings nothing new to the table. (Yes, I‚Äôll behave <em><em>as if</em></em> there was no additional <code>.load-balancer</code> type for the service because this will be for another episode.)</p><p>If we wanted to have another server, of course, we would write:</p><pre><code class=\"language-toml\">[routers]\n   [routers.my-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost.com\"\n      service = my-service\n\n[services]\n   [services.my-service.load-balancer]\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"</code></pre><blockquote>Now, let‚Äôs add basic authentication!</blockquote><h3 id=\"before-1\">before</h3><pre><code class=\"language-toml\">[frontends]\n   [frontends.my-frontend]\n      entrypoint = [\"http\"]\n      backend = my-backend\n      [frontend.my-frontend.routes.route1]\n         rule = \"Host:myhost.com\"\n      [frontend.my-frontend.auth]\n         [frontend.my-frontend.auth.basic]\n            users = [\"admin:xxx\",\"super-admin:xxx\",]\n\n[backends]\n   [backends.my-backend]\n      [backends.my-backend1.servers]          \n         [backends.backend1.servers.server-1]\n            url = \"http://xx.xx.xx.xx\"</code></pre><h3 id=\"after-1\">after</h3><pre><code class=\"language-toml\">[routers]\n   [routers.my-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost.com\"\n      middlewares = [\"admins-only\"]\n      service = my-service\n\n[middlewares]\n   [middlewares.admins-only.basicauth]\n      users = [\"admin:xxx\",\"super-admin:xxx\",]\n\n[services]\n   [services.my-service.load-balancer]\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"</code></pre><p>The basic authentication middleware is no longer configured inside the router but in a dedicated middleware section. The good news, besides readability, is that you can now reuse the same middleware in a different router, along with other middlewares.</p><pre><code class=\"language-toml\">[routers]\n   [routers.my-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost.com\"\n      middlewares = [\"admins-only\"]\n      service = my-service\n   \n   [routers.my-other-router]\n      entrypoint = [\"http\"]\n      rule = \"Host:myhost2.com\"\n      middlewares = [\"admins-only\", \"retry-std\"]\n      service = my-service\n\n[middlewares]\n   [middlewares.admins-only.basicauth]\n      users = [\"admin:xxx\",\"super-admin:xxx\",]\n   [middlewares.retry-std.retry]\n      attempts = 2\n\n[services]\n   [services.my-service.load-balancer]\n      [[services.my-services.load-balancer.servers]]\n         url = \"http://xx.xx.xx.xx\"</code></pre><p>Also, another benefit you probably have noticed ‚Äî you can now have many separate configurations for some features (like retry) and choose the one that fits for your routers.</p><p>Behind the scenes, many other things have already changed (not yet obvious), but we‚Äôd like to tease with more episodes!</p><p>Besides, we‚Äôve decided to show you one ‚Äúwork in progress‚Äù feature at a time ‚Äî this gives time to listen to your feedback!</p><hr><p>Traefik is a project driven by the community! We are more grateful than ever for your feedback on the project. We‚Äôve reached <strong><strong>18k+ stars</strong></strong> on Github, and the product has been downloaded more than <strong><strong>350 million</strong></strong> times!</p><hr><p>Join us on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">GitHub</a>, <a href=\"https://twitter.com/traefik\" rel=\"noopener\">Twitter</a>, on the <a href=\"https://community.containo.us\">Community Forum</a>, or in the comments below so we can hear your voice!</p>","url":"https://containous.ghost.io/blog/traefik-spoiler-season-episode-1-3dbcb1f5d8b9/","canonical_url":null,"uuid":"8422082b-acf9-4d2a-a429-2d1f34259003","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7eb67f1db6f0038c74435","reading_time":5}},{"node":{"id":"Ghost__Post__5dd7ea61f1db6f0038c74413","title":"Introducing Traefik Enterprise Edition","slug":"introducing-traefik-enterprise-edition-83b78d09efeb","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/ee-1.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/6a61f59bb594a837dfeec781fa0238ee/fe3a8/ee-1.png","srcSet":"/static/6a61f59bb594a837dfeec781fa0238ee/630fb/ee-1.png 300w,\n/static/6a61f59bb594a837dfeec781fa0238ee/2a4de/ee-1.png 600w,\n/static/6a61f59bb594a837dfeec781fa0238ee/fe3a8/ee-1.png 1035w","sizes":"(max-width: 1035px) 100vw, 1035px"}}},"excerpt":"Containous, the company behind Traefik, is announcing Traefik Enterprise Edition, a new platform built on top of Traefik, designed for business-critical deployments.","custom_excerpt":"Containous, the company behind Traefik, is announcing Traefik Enterprise Edition, a new platform built on top of Traefik, designed for business-critical deployments.","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"December 11, 2018","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T14:02:09.000+00:00","published_at":"2018-12-11T14:02:00.000+00:00","updated_at":"2020-05-21T23:49:46.000+00:00","meta_title":"Introducing Traefik Enterprise Edition","meta_description":"Containous is announcing Traefik Enterprise Edition, a new platform built on top of Traefik, designed for business-critical deployments.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"We Made It Distributed\n\nContainous [/], the company behind Traefik [/traefik/], is announcing Traefik\nEnterprise Edition ‚Äî TraefikEE ‚Äî a new platform built on top of Traefik,\ndesigned for business-critical deployments.\n\nIn just three years, Traefik, the Cloud Native Edge Router, has become a key\nplayer in microservices infrastructures. With more than 19,000 stars on Github\nand 400,000,000 downloads on DockerHub, Traefik is widely used by major\ncompanies in their production environments.\n\nToday, we are proud to announce that TraefikEE, our new commercial product, has\nreached public beta. TraefikEE allows you to deploy distributed Traefik\ninstances across your infrastructure, providing a scalable and reliable edge\nrouting platform. Split into a control plane and a data plane, Traefik cluster\nnodes are easily deployed and operated using the TraefikEE CLI. Implementing the\nRaft consensus, TraefikEE can safely store and replicate configurations and TLS\ncertificates across the nodes.\n\nLet‚Äôs take a look at how TraefikEE works.\n\nTraefikEE ‚Äî Overview\nTraefikEE ArchitectureTraefikEE is built on top of Traefik and adds clustering features to satisfy the\nneeds of Enterprise customers. All Traefik concepts apply to TraefikEE, so if\nyou‚Äôre already a Traefik user, you‚Äôre in familiar territory.\n\nIt runs on the edge of your platform to route the traffic to your applications,\nand is composed of two elements:\n\n * The data plane: horizontally scalable nodes, which forward ingress traffic to\n   your services\n * The control plane: distributed nodes, implementing the raft consensus, which\n   watch your platform and its services, stores topology changes, and\n   reconfigure the data plane to adapt ingress routing dynamically\n\nA TraefikEE cluster natively supports raft consensus between control nodes to\nsafely store and replicate configurations. No external Key-Value Store nor\nthird-party tool needed.\n\nThis distributed architecture is the cornerstone of TraefikEE‚Äôs strengths:\nnatively highly available, scalable and secure.\n\nHighly Available\nThe control plane is a key component of TraefikEE. It is responsible for storing\nall cluster data, including events, TLS certificates, and Traefik configuration.\nIt is also in charge of connecting to the orchestrator to generate the data\nplane routing configuration.\n\nSince it is such a critical part of your system, TraefikEE is designed from the\nground up to be fault tolerant: the control plane runs natively in cluster mode\nwithout any extra configuration or external Key Value Store. It ensures your\ndata is always available and safe by using an internal distributed store,\nimplemented with raft.\n\nScalable\nThe data plane is in charge of forwarding the incoming requests to the\napplications. It has been designed to scale horizontally at a glance in order to\nface irregular network loads.\n\nTraefikEE handles high loads in a blink: just add more nodes to the data plane\nto handle the additional requests. When the peak is gone, shrink the number of\nnodes to save resources. Of course, this process can be done automatically using\nauto-scaling tools.\n\nSecure\nBy splitting responsibilities between two components, TraefikEE follows the\nprinciple of ‚ÄúSeparation of Concerns.‚Äù\n\nTo ensure that sensitive information only runs on a closed and safe environment,\nthe control plane is not exposed to the outside. As a result, any malicious\naction from external traffic will stay stuck in the data plane and your platform\nwill stay safe.\n\nMoreover, TraefikEE only relies on encrypted communications between nodes, to\nadd an extra layer of security.\n\nSmooth Operations\nInstalling and managing a raft based application is usually a painful\nexperience. Since Traefik was made popular thanks to its usability and\nrefreshing user experience, we have extended those benefits to TraefikEE.\n\nFor this reason, TraefikEE comes with an additional CLI that manages to deploy\nand operate a cluster with several nodes in only one command line. Currently,\nKubernetes and Docker Swarm Mode are supported. More platforms will be added\nsoon. Teams will love to use this time-saving tool, traefikeectl (pronounced\n‚Äútraefikee-cuddle‚Äù).\n\nTraefikEE comes with a dashboard to visualize your cluster nodes configuration\nand status, in addition to aggregated data plane metrics.\n\nCommercial support is bundled with TraefikEE. The Traefik engineering team\nimmediately investigates and resolves any critical issues which may arise.\n\nEarly Access\nTraefikEE is available in early access starting today. The registration process\nis as simple and automated as possible, so don‚Äôt fear endless registration forms\nnor crowded waiting queues before trying it out. Visit our website at \nhttps://containo.us/traefikee [/traefikee/] and get your license key in less\nthan a minute!\n\nTraefik Stays Open\nTraefikEE is built on top of Traefik, that means that Traefik continues to\nevolve and will stay open source. Nothing changes! We are firm believers in open\nsource, and Traefik will continue to be our main priority and a community-driven\nproject. We are working on significant changes to Traefik, and recently have\nshared details [/blog/traefik-spoiler-season-episode-1-3dbcb1f5d8b9/] on what we\nhave been doing so far. Please stay tuned for full disclosure.\n\nAbout Containous\nContainous is the company that supports the development of Traefik. We provide\nprofessional services to ensure businesses get the most out of the solution.\n\nWith this new product, Containous continues to innovate and define new ways to\naccess microservice platforms, pushing the limits of automation and scalability.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">We Made It Distributed</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-12.png\" class=\"kg-image\"></figure><p><em><em><a href=\"https://containous.ghost.io/\">Containous</a></em></em>, the company behind <em><em><a href=\"https://containous.ghost.io/traefik/\">Traefik</a></em></em>, is announcing Traefik Enterprise Edition ‚Äî <em><em>TraefikEE</em></em> ‚Äî a new platform built on top of <em><em>Traefik</em></em>, designed for business-critical deployments.</p><p>In just three years, <em><em>Traefik</em></em>, the Cloud Native Edge Router, has become a key player in microservices infrastructures. With more than 19,000 stars on Github and 400,000,000 downloads on DockerHub, <em><em>Traefik</em></em> is widely used by major companies in their production environments.</p><p>Today, we are proud to announce that <em><em>TraefikEE</em></em>, our new commercial product, has reached public beta. <em><em>TraefikEE</em></em> allows you to deploy distributed Traefik instances across your infrastructure, providing a scalable and reliable edge routing platform. Split into a control plane and a data plane, <em><em>Traefik</em></em> cluster nodes are easily deployed and operated using the <em><em>TraefikEE</em></em> CLI. Implementing the Raft consensus, <em><em>TraefikEE</em></em> can safely store and replicate configurations and TLS certificates across the nodes.</p><p>Let‚Äôs take a look at how <em><em>TraefikEE</em></em> works.</p><h2 id=\"traefikee-overview\">TraefikEE ‚Äî Overview</h2><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-54.png\" class=\"kg-image\"><figcaption>TraefikEE Architecture</figcaption></figure><p><em><em>TraefikEE</em></em> is built on top of <em><em>Traefik</em></em> and adds clustering features to satisfy the needs of Enterprise customers. All <em><em>Traefik</em></em> concepts apply to <em><em>TraefikEE</em></em>, so if you‚Äôre already a <em><em>Traefik</em></em> user, you‚Äôre in familiar territory.</p><p>It runs on the edge of your platform to route the traffic to your applications, and is composed of two elements:</p><ul><li><strong><strong>The data plane</strong></strong>: horizontally scalable nodes, which forward ingress traffic to your services</li><li><strong><strong>The control plane</strong></strong>: distributed nodes, implementing the raft consensus, which watch your platform and its services, stores topology changes, and reconfigure the data plane to adapt ingress routing dynamically</li></ul><p>A <em><em>TraefikEE</em></em> cluster natively supports raft consensus between control nodes to safely store and replicate configurations. No external Key-Value Store nor third-party tool needed.</p><p>This distributed architecture is the cornerstone of <em><em>TraefikEE</em></em>‚Äôs strengths: natively <strong><strong>highly available</strong></strong>, <strong><strong>scalable</strong></strong> and <strong><strong>secure</strong></strong>.</p><h2 id=\"highly-available\">Highly Available</h2><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/bsl05RVuMtM?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure><p>The control plane is a key component of <em><em>TraefikEE</em></em>. It is responsible for storing all cluster data, including events, TLS certificates, and <em><em>Traefik </em></em>configuration. It is also in charge of connecting to the orchestrator to generate the data plane routing configuration.</p><p>Since it is such a critical part of your system,<em><em> TraefikEE</em></em> is designed from the ground up to be fault tolerant: the control plane runs natively in cluster mode without any extra configuration or external Key Value Store. It ensures your data is always available and safe by using an internal distributed store, implemented with raft.</p><h2 id=\"scalable\">Scalable</h2><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/YNKMcussMrM?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure><p>The data plane is in charge of forwarding the incoming requests to the applications. It has been designed to scale horizontally at a glance in order to face irregular network loads.</p><p><em><em>TraefikEE</em></em> handles high loads in a blink: just add more nodes to the data plane to handle the additional requests. When the peak is gone, shrink the number of nodes to save resources. Of course, this process can be done automatically using auto-scaling tools.</p><h2 id=\"secure\">Secure</h2><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/rPAcKSiidUo?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure><p>By splitting responsibilities between two components, <em><em>TraefikEE</em></em> follows the principle of ‚ÄúSeparation of Concerns.‚Äù</p><p>To ensure that sensitive information only runs on a closed and safe environment, the control plane is not exposed to the outside. As a result, any malicious action from external traffic will stay stuck in the data plane and your platform will stay safe.</p><p>Moreover, <em><em>TraefikEE</em></em> only relies on encrypted communications between nodes, to add an extra layer of security.</p><h2 id=\"smooth-operations\">Smooth Operations</h2><p>Installing and managing a raft based application is usually a painful experience. Since <em><em>Traefik</em></em> was made popular thanks to its usability and refreshing user experience, we have extended those benefits to TraefikEE.</p><p>For this reason, <em><em>TraefikEE</em></em> comes with an additional CLI that manages to deploy and operate a cluster with several nodes in only one command line. Currently, Kubernetes and Docker Swarm Mode are supported. More platforms will be added soon. Teams will love to use this time-saving tool, <em><em>traefikeectl</em></em> (pronounced ‚Äútraefikee-cuddle‚Äù).</p><p><em><em>TraefikEE</em></em> comes with a dashboard to visualize your cluster nodes configuration and status, in addition to aggregated data plane metrics.</p><p>Commercial support is bundled with TraefikEE. The Traefik engineering team immediately investigates and resolves any critical issues which may arise.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-55.png\" class=\"kg-image\"></figure><h2 id=\"early-access\">Early Access</h2><p>TraefikEE is available in early access starting today. The registration process is as simple and automated as possible, so don‚Äôt fear endless registration forms nor crowded waiting queues before trying it out. Visit our website at <a href=\"https://containous.ghost.io/traefikee/\">https://containo.us/traefikee</a> and get your license key in less than a minute!</p><h2 id=\"traefik-stays-open\">Traefik Stays Open</h2><p><em><em>TraefikEE</em></em> is built on top of <em><em>Traefik</em></em>, that means that Traefik continues to evolve and will stay open source. Nothing changes! We are firm believers in open source, and <em><em>Traefik</em></em> will continue to be our main priority and a community-driven project. We are working on significant changes to Traefik, and <a href=\"https://containous.ghost.io/blog/traefik-spoiler-season-episode-1-3dbcb1f5d8b9/\">recently have shared details</a> on what we have been doing so far. Please stay tuned for full disclosure.</p><h2 id=\"about-containous\">About Containous</h2><p>Containous is the company that supports the development of Traefik. We provide professional services to ensure businesses get the most out of the solution.</p><p>With this new product, Containous continues to innovate and define new ways to access microservice platforms, pushing the limits of automation and scalability.</p>","url":"https://containous.ghost.io/blog/introducing-traefik-enterprise-edition-83b78d09efeb/","canonical_url":null,"uuid":"dd190b78-8f67-41dd-a7f4-6655c3565988","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7ea61f1db6f0038c74413","reading_time":4}},{"node":{"id":"Ghost__Post__5dd7e9cff1db6f0038c743f4","title":"The Journey to Traefik Enterprise Edition: Join the Free ‚ÄúEarly Access‚Äù Program","slug":"the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/ee.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/6a61f59bb594a837dfeec781fa0238ee/fe3a8/ee.png","srcSet":"/static/6a61f59bb594a837dfeec781fa0238ee/630fb/ee.png 300w,\n/static/6a61f59bb594a837dfeec781fa0238ee/2a4de/ee.png 600w,\n/static/6a61f59bb594a837dfeec781fa0238ee/fe3a8/ee.png 1035w","sizes":"(max-width: 1035px) 100vw, 1035px"}}},"excerpt":"Welcome to the first post of our journey with Traefik Enterprise Edition!\nThis post guides you through the first steps of your TraefikEE discovery journey...","custom_excerpt":"Welcome to the first post of our journey with Traefik Enterprise Edition!\nThis post guides you through the first steps of your TraefikEE discovery journey...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"January 14, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T13:59:43.000+00:00","published_at":"2019-01-14T13:59:00.000+00:00","updated_at":"2020-05-21T23:47:33.000+00:00","meta_title":"The Journey to TraefikEE: Join the Free ‚ÄúEarly Access‚Äù Program","meta_description":"Welcome to the first post of our journey with Traefik Enterprise Edition!\nThis post guides you through the first steps of your TraefikEE discovery journey..","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the first post of our journey with Traefik Enterprise Edition\n[/traefikee/]!\n\nTraefikEE (Enterprise Edition) is available here\n[https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days] for\nfree.\n\nThis post guides you through the first steps of your TraefikEE discovery\njourney: From requesting the ‚Äúearly access‚Äù to obtaining your license key and\ngetting started.\n\nTraefikEE: Traefik, for the Enterprise World\nIntroduced during KubeCon US 2018 (check out the ‚ÄúIntroducing Traefik\nEnterprise\nEdition‚Äù blog post [/blog/introducing-traefik-enterprise-edition-83b78d09efeb/]\n), TraefikEE is built on top of Traefik and adds clustering features to satisfy\nthe needs of Enterprise customers. All Traefik concepts apply to TraefikEE, so\nif you already are a Traefik user, you‚Äôre in familiar territory.\n\nTraefikEE runs on the edge of your platform to route the traffic to your\napplications.\n\nGlobal Architecture of Traefik Enterprise EditionTraefikEE is composed of two\nplanes:\n\n * The data plane: horizontally scalable nodes, which forward ingress traffic to\n   your services\n * The control plane: distributed nodes, implementing the raft consensus\n   [http://thesecretlivesofdata.com/raft/], which watch your platform and its\n   services, stores topology changes, and reconfigure the data plane to adapt\n   ingress routing dynamically\n\nThis distributed architecture is the cornerstone of TraefikEE‚Äôs strengths:\nnatively highly available, scalable, and secure.\n\nSupport Account and License\nThe journey begins by visiting the TraefikEE website at \nhttps://containo.us/traefikee [/traefikee/], and opting in to the program by\nclicking the ‚ÄúFree Trial‚Äù form.\n\n> (A voice in the background): I‚Äôve been told it is free. Why should I give you my\npersonal information?\n> Containous: We need a way to communicate together, so the form creates a\n‚ÄúSupport Account‚Äù for you in our ticketing system. So you can raise requests if\nyou get any issue with TraefikEE, and we can send you information about update.\nOnce you‚Äôve filled out the form, look for a ‚ÄúWelcome to Containous‚Äù e-mail sent\nfrom support@containous.zendesk.com in your mail‚Äôs inbox (or, possibly junk\nfolder). Click on the link it contains to validate your account. You will be\nprompted to set a (strong) password: you know the story [https://xkcd.com/936/].\n\nOnce your account is validated with a (strong) password, the system will\ngenerate a TraefikEE license and send you an e-mail entitled ‚ÄúYour license key‚Äù\n(it may take a couple minutes) which will contain instructions.\n\nKnock, knock, you got an email!> (A voice in the background): I never received the email. It‚Äôs probably tagged as\nspam by my organization‚Äôs mail system.\n> Containous: Instead of the email, you can also browse the customer portal at \nhttps://support.containo.us/\n[https://containous.zendesk.com/hc/en-us/restricted?return_to=https%3A%2F%2Fcontainous.zendesk.com%2Fhc%2Fen-us]\n, select the button ‚ÄúCheck my existing requests / License‚Äù and open the request\nnamed ‚ÄúYour license key‚Äù.\nGet your license and put it somewhere ‚Äúsecure‚Äù (e.g. an encrypted system). For\nthis post series, we store the license in a file, encrypted into a Keybase.io\n[https://keybase.io/] volume:\n\n$ cat /keybase/private/dduportal/traefikee-license\nxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n\nThat‚Äôs all folks, you can get started with the installation from the\ndocumentation [https://docs.containo.us/].\n\nOn the next post ‚ÄúThe Journey to Traefik Enterprise Edition: Product\nEvaluation‚Äù, we will install TraefikEE on your machine and take a tour of its\nfeatures.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-11.png\" class=\"kg-image\"></figure><p>Welcome to the first post of our journey with <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition</a>!</p><p>TraefikEE (Enterprise Edition) is available <a href=\"https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days\">here</a> for free.</p><p>This post guides you through the first steps of your TraefikEE discovery journey: From requesting the ‚Äúearly access‚Äù to obtaining your license key and getting started.</p><h2 id=\"traefikee-traefik-for-the-enterprise-world\">TraefikEE: Traefik, for the Enterprise World</h2><p>Introduced during KubeCon US 2018 (<a href=\"https://containous.ghost.io/blog/introducing-traefik-enterprise-edition-83b78d09efeb/\">check out the ‚ÄúIntroducing Traefik Enterprise Edition‚Äù blog post</a>), TraefikEE is built on top of Traefik and adds clustering features to satisfy the needs of Enterprise customers. All Traefik concepts apply to TraefikEE, so if you already are a Traefik user, you‚Äôre in familiar territory.</p><p>TraefikEE runs on the edge of your platform to route the traffic to your applications.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-51.png\" class=\"kg-image\"><figcaption>Global Architecture of Traefik Enterprise Edition</figcaption></figure><p>TraefikEE is composed of two planes:</p><ul><li>The <strong><strong>data plane</strong></strong>: horizontally scalable nodes, which forward ingress traffic to your services</li><li>The <strong><strong>control plane</strong></strong>: distributed nodes, implementing <a href=\"http://thesecretlivesofdata.com/raft/\" rel=\"noopener\">the raft consensus</a>, which watch your platform and its services, stores topology changes, and reconfigure the data plane to adapt ingress routing dynamically</li></ul><p>This distributed architecture is the cornerstone of TraefikEE‚Äôs strengths: natively <strong><strong>highly available</strong></strong>, <strong><strong>scalable</strong></strong>, and <strong><strong>secure</strong></strong>.</p><h2 id=\"support-account-and-license\">Support Account and License</h2><p>The journey begins by visiting the TraefikEE website at <a href=\"https://containous.ghost.io/traefikee/\">https://containo.us/traefikee</a>, and opting in to the program by clicking the ‚ÄúFree Trial‚Äù form.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I‚Äôve been told it is free. Why should I give you my personal information?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> We need a way to communicate together, so the form creates a ‚ÄúSupport Account‚Äù for you in our ticketing system. So you can raise requests if you get any issue with TraefikEE, and we can send you information about update.</em></em></blockquote><p>Once you‚Äôve filled out the form, look for a ‚ÄúWelcome to Containous‚Äù e-mail sent from <a href=\"mailto:support@containous.zendesk.com\" rel=\"noopener\">support@containous.zendesk.com</a> in your mail‚Äôs inbox (or, possibly junk folder). Click on the link it contains to validate your account. You will be prompted to set a (strong) password: <a href=\"https://xkcd.com/936/\" rel=\"noopener\">you know the story</a>.</p><p>Once your account is validated with a (strong) password, the system will generate a TraefikEE license and send you an e-mail entitled ‚ÄúYour license key‚Äù (it may take a couple minutes) which will contain instructions.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-53.png\" class=\"kg-image\"><figcaption>Knock, knock, you got an email!</figcaption></figure><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I never received the email. It‚Äôs probably tagged as spam by my organization‚Äôs mail system.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Instead of the email, you can also browse the customer portal at</em> </em><a href=\"https://containous.zendesk.com/hc/en-us/restricted?return_to=https%3A%2F%2Fcontainous.zendesk.com%2Fhc%2Fen-us\">https://support.containo.us/</a><em><em>, select the button ‚ÄúCheck my existing requests / License‚Äù and open the request named ‚ÄúYour license key‚Äù.</em></em></blockquote><p>Get your license and put it somewhere ‚Äúsecure‚Äù (e.g. an encrypted system). For this post series, we store the license in a file, encrypted into a <a href=\"https://keybase.io/\" rel=\"noopener\">Keybase.io</a> volume:</p><pre><code class=\"language-shell\">$ cat /keybase/private/dduportal/traefikee-license\nxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></pre><p>That‚Äôs all folks, you can <a href=\"https://docs.containo.us/\">get started with the installation from the documentation</a>.</p><p>On the next post ‚ÄúThe Journey to Traefik Enterprise Edition: Product Evaluation‚Äù, we will install TraefikEE on your machine and take a tour of its features.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/","canonical_url":null,"uuid":"ba5a6dc5-e17f-4c5a-ace8-c1c2b1bb61c9","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7e9cff1db6f0038c743f4","reading_time":3}},{"node":{"id":"Ghost__Post__5dd7e6ebf1db6f0038c7437f","title":"The Journey to Traefik Enterprise Edition: Product Evaluation","slug":"the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/ee-evaluation.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b5028e39443bd90d0ac061a694e3e926/f3583/ee-evaluation.png","srcSet":"/static/b5028e39443bd90d0ac061a694e3e926/630fb/ee-evaluation.png 300w,\n/static/b5028e39443bd90d0ac061a694e3e926/2a4de/ee-evaluation.png 600w,\n/static/b5028e39443bd90d0ac061a694e3e926/f3583/ee-evaluation.png 1200w,\n/static/b5028e39443bd90d0ac061a694e3e926/bbee5/ee-evaluation.png 1800w,\n/static/b5028e39443bd90d0ac061a694e3e926/0ef64/ee-evaluation.png 2400w,\n/static/b5028e39443bd90d0ac061a694e3e926/5363e/ee-evaluation.png 2450w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Welcome to the second post of our journey towards Traefik Enterprise Edition . Let‚Äôs continue our journey by quickly evaluating the product on your local machine...","custom_excerpt":"Welcome to the second post of our journey towards Traefik Enterprise Edition . Let‚Äôs continue our journey by quickly evaluating the product on your local machine...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"January 22, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T13:47:23.000+00:00","published_at":"2019-01-22T13:47:00.000+00:00","updated_at":"2020-05-21T23:32:20.000+00:00","meta_title":"The Journey to Traefik Enterprise Edition: Product Evaluation","meta_description":"Welcome to the second post of our journey towards Traefik Enterprise Edition . Let‚Äôs continue our journey by quickly evaluating the product.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the second post of our journey towards Traefik Enterprise Edition\n[/traefikee/] .\n\nAfter our first step (Join the‚ÄúEarly Access‚Äù Program\n[/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/]\n), let‚Äôs continue by doing a quick evaluation the product on your local machine.\n\n> (A voice in the background): But, the shiny website says that it is a \ndistributed version. How can we assess this on a single machine?\n> (Another voice in the background): A developer machine is not a production\nenvironment!\n> Containous: These assertions are 100% right dear users! Following the core\nprinciples of Traefik, we want to keep things simple and start by getting\nTraefikEE up and running on a ‚Äútesting system‚Äù. Don‚Äôt worry: next steps of the\njourney are coming, to cover other topics from high availability, to\ninstallation on production systems.\nTraefikEE Installation\nThe next step of the journey is to install TraefikEE: Let‚Äôs follow the provided \ndocumentation [https://docs.containo.us/]!\n\n‚ÄúTraefikEE-Cuddle‚Äù\n\nThe ‚ÄúGetting Started with Installation\n[https://docs.containo.us/getting-started/]‚Äù page recommends to use the command\nline traefikeectl and guides you on installing this command:\n\n$ curl -sSL -o /usr/local/bin/traefikeectl https://get-the-link-for-your-operating-system/traefikeectl\n\n$ shasum -a256 /usr/local/bin/traefikeectl # Check against the SHA256 checksums for your release\n\n$ chmod a+x /usr/local/bin/traefikeectl # Make it executable\n\n$ traefikeectl version\nVersion:      v1.0.0-beta16\nCodename:     Gewurztraminer\nGo version:   go1.11.4\nBuilt:        2019-01-21_06:00:54PM\nOS/Arch:      darwin/amd64\n\nKubernetes Time!\n\nTraefikEE can be installed on different platforms but, this example uses \nKubernetes [https://kubernetes.io/].\n\n> (A voice in the background): I don‚Äôt know Kubernetes\nContainous: You don‚Äôt have to for this evaluation. But you can learn it from \nhttps://kubernetes.io/docs/tutorials/kubernetes-basics/\nA Kubernetes installation is required. Don‚Äôt worry, we are not yak shaving\n[https://en.wiktionary.org/wiki/yak_shaving] to select where and how install\nKubernetes.\n\nInstead we‚Äôll use the awesome ‚ÄúKinD‚Äù (Kubernetes inside Docker)\n[https://github.com/kubernetes-sigs/kind] tool providing a disposable Kubernetes\nlocally.\n\n> (From https://github.com/kubernetes-sigs/kind), kind is a tool for running local\nKubernetes clusters using Docker container \"nodes\".\nkind is primarily designed for testing Kubernetes 1.11+, initially targeting the\nconformance tests. If you have Go [https://golang.org/] and Docker\n[https://www.docker.com/] installed go get sigs.k8s.io/kind && kind create\ncluster is all you need\nInstall your Kubernetes cluster for the evaluation:\n\n$ kind create cluster --name=traefikee\nCreating cluster 'kind-traefikee' ...\n‚úì Ensuring node image (kindest/node:v1.12.3) üñº\n‚úì [kind-traefikee-control-plane] Creating node container üì¶\n‚úì [kind-traefikee-control-plane] Fixing mounts üóª\n‚úì [kind-traefikee-control-plane] Starting systemd üñ•\n‚úì [kind-traefikee-control-plane] Waiting for docker to be ready üêã\n‚úì [kind-traefikee-control-plane] Starting Kubernetes (this may take a minute) ‚ò∏\n\nCluster creation complete. You can now use the cluster with:\nexport KUBECONFIG=\"$(kind get kubeconfig-path --name=\"traefikee\")\"\nkubectl cluster-info\n\n$ export KUBECONFIG=\"$(kind get kubeconfig-path --name=\"traefikee\")\"\n\n$ kubectl cluster-info\nKubernetes master is running at https://localhost:55243\n\n# We have a Kubernetes cluster ready to use!\n\nPlease note that any local Kubernetes installation passing the conformance tests\ncan be used for the evaluation (as Docker4Mac or Docker4Windows).\n\nTrafikEE Installation\n\nFollowing the official documentation [https://docs.containo.us], you may install\nTraefikEE in one line, using traefikeectl . It might take a few minute to\ndownload all the required resources:\n\n$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n...\n\nYou can access the dashboard with the following credentials:\n\nUsername: admin\nPassword: 4087abf2354666d9\n\n‚úî Installation successful\n\nCongratulations, your TraefikEE cluster is installed locally!\n\nA Tour of TraefikEE\nTraefikEE is installed, now what?\n\nFirst, we have to open access from your web-browser to the cluster:\n\n# Forward TraefikEE data plane's port 80 to your localhost:8000\nkubectl port-forward -n traefikee \"$(kubectl get pod -n traefikee | awk '{print $1}' | grep data-node)\" 8000:80 &\n\nTraefikEE is now exposed on your machine on the following URL:\nhttp://localhost:8000 .\n\n> On a production-grade Kubernetes installation, you would use your external Load\nBalancer‚Äôs public hostname and port.\nWeb Dashboard\n\nLet‚Äôs start the tour with the Web Dashboard, which is enabled because we used\nthe flag--dashboard during the installation.\n\nOpen the URL http://localhost:8000 and authenticate with the username and\npassword credentials from the traefikeectl install command‚Äôs output from\nearlier.\n\n> In this example, the username is admin and the password is d4087abf2354666d9dsds\n. These credentials are generated automatically during the installation.\nYou can see the default section named ‚ÄúProviders‚Äù which shows you the\nTraefikEE‚Äôs routing configuration, generated from Kubernetes:\n\nLooks like Traefik‚Äôs WebUIUsing the top bar, navigate to the ‚ÄúMetrics‚Äù section\nto get an overview of the incoming request‚Äôs metrics.\n\n> (A voice in the background): Traefik also provides a ‚ÄúMetrics‚Äù page, what is the\nvalue of this one?\nContainous: It‚Äôs the same, except that metrics are aggregated from all the data\nplane‚Äôs nodes.\nLook, someone forgot its password and got HTTP/401 responsesIt‚Äôs time to get an\noverview of the cluster. Browse to the ‚ÄúCluster‚Äù section to check that you have\na Control Plane of 3 nodes, and a Data Plane of 1 node.\n\n> (A voice in the background): Wait, isn‚Äôt TraefikEE distributed? Why only 1 node\nin the data plane?\nContainous: By default, there is 1 ‚ÄúTraefikEE Data Node‚Äù per Kubernetes node. We\nare using a single-node Kubernetes hence 1 data node. Wait for the next blog to\nlearn more about the distribution.\nIt‚Äôs a nice cluster that you have thereOperations with traefikeectl\n\nNext step of this tour is the ‚ÄúSmooth Operations‚Äù feature. We know that\nEngineers love automation. So we made a command line, traefikeectlto automate\nall the operations on your TraefikEE clusters.\n\nYou already tasted traefikeectl. Let‚Äôs do another example of operation by\nlisting all the cluster‚Äôs nodes with traefikeectl:\n\n$ traefikeectl list-nodes\n\nName                                 Role\n----                                 ----\ndata-node-traefikee-data-node-5fplw  DATA NODE\ntraefikee-control-node-0             CONTROL NODE (Current Leader)\ntraefikee-control-node-2             CONTROL NODE\ntraefikee-control-node-1             CONTROL NODE\n\nThe next section shows another example, but you can already check the \ntraefikeectl ‚Äòs Command Line Reference Documentation\n[https://docs.containo.us/installing/teectl-cli/] to learn more about the\noperations features.\n\nDeploy an application\n\nTraefikEE is an edge router, which main goal is to route incoming request into\nyour applications.\n\n> (A voice in the background): Did you just say ‚Äúapplications‚Äù? But there are no\napplications deployed into this Kubernetes, only TraefikEE.\nContainous: Patience, there is an example below. But let that sink in: Isn‚Äôt the\nDashboard an application with incoming traffic?\nLet‚Äôs deploy an example application. It‚Äôs an HTTP web service, based on\ngithub.com/containous/whoami, which responds an HTML page with the headers of\nyour request.\n\n$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/8b87143b084c612f86d66f587df7c058c7fa1aa0/whoami.yaml\n\nCheck the dashboard again. After a few seconds, the routing configuration for\nthe application ‚Äúwhoami‚Äù is automatically picked by TraefikEE from Kubernetes: a\nfrontend and 2 associated backends (the 2 replicas).\n\nThe application is reachable at the URL localhost:8000/whoami. As the ‚Äúwhoami‚Äù\napplication is scaled to 2 instances, try to reload the page multiple time to\nsee the field ‚ÄúHostname‚Äù changing, due to the Load Balancing.\n\nSuch Web, Much Text\n--------------------------------------------------------------------------------\n\nThat‚Äôs all for today and this first quick tour. On the next post ‚ÄúThe Journey\nto\nTraefik Enterprise Edition: High Availability\n[/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n‚Äù, we‚Äôll cover the distributed features of TraefikEE.","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-10.png\" class=\"kg-image\"></figure><p>Welcome to the second post of our journey towards <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition</a> .</p><p>After our first step (<em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/\">Join the‚ÄúEarly Access‚Äù Program</a></em></em>), let‚Äôs continue by doing a quick evaluation the product on your local machine.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> But, the shiny website says that it is a <strong><strong>distributed</strong></strong> version. How can we assess this on a single machine?</em></em></blockquote><blockquote><em><em><strong><strong>(Another voice in the background):</strong></strong> A developer machine is <strong><strong>not</strong></strong> a production environment!</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> These assertions are 100% right dear users! Following the core principles of Traefik, we want to keep things simple and start by getting TraefikEE up and running on a ‚Äútesting system‚Äù. Don‚Äôt worry: next steps of the journey are coming, to cover other topics from high availability, to installation on production systems.</em></em></blockquote><h2 id=\"traefikee-installation\">TraefikEE Installation</h2><p>The next step of the journey is to install TraefikEE: Let‚Äôs follow the provided <a href=\"https://docs.containo.us/\">documentation</a>!</p><p><strong><strong><em><em>‚ÄúTraefikEE-Cuddle‚Äù</em></em></strong></strong></p><p>The ‚Äú<a href=\"https://docs.containo.us/getting-started/\">Getting Started with Installation</a>‚Äù page recommends to use the command line <code>traefikeectl</code> and guides you on installing this command:</p><pre><code class=\"language-shell\">$ curl -sSL -o /usr/local/bin/traefikeectl https://get-the-link-for-your-operating-system/traefikeectl\n\n$ shasum -a256 /usr/local/bin/traefikeectl # Check against the SHA256 checksums for your release\n\n$ chmod a+x /usr/local/bin/traefikeectl # Make it executable\n\n$ traefikeectl version\nVersion:      v1.0.0-beta16\nCodename:     Gewurztraminer\nGo version:   go1.11.4\nBuilt:        2019-01-21_06:00:54PM\nOS/Arch:      darwin/amd64</code></pre><p><strong><strong><em><em>Kubernetes Time!</em></em></strong></strong></p><p>TraefikEE can be installed on different platforms but, this example uses <a href=\"https://kubernetes.io/\" rel=\"noopener\">Kubernetes</a>.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I don‚Äôt know Kubernetes</em></em><br><em><em><strong><strong>Containous:</strong></strong> You don‚Äôt have to for this evaluation. But you can learn it from <a href=\"https://kubernetes.io/docs/tutorials/kubernetes-basics/\" rel=\"noopener\">https://kubernetes.io/docs/tutorials/kubernetes-basics/</a></em></em></blockquote><p>A Kubernetes installation is required. Don‚Äôt worry, we are not <a href=\"https://en.wiktionary.org/wiki/yak_shaving\" rel=\"noopener\">yak shaving</a> to select where and how install Kubernetes.</p><p>Instead we‚Äôll use the awesome <a href=\"https://github.com/kubernetes-sigs/kind\" rel=\"noopener\">‚ÄúKinD‚Äù (Kubernetes inside Docker)</a> tool providing a disposable Kubernetes locally.</p><blockquote><em><em>(From <a href=\"https://github.com/kubernetes-sigs/kind\" rel=\"noopener\">https://github.com/kubernetes-sigs/kind</a></em>), <em><code><em>kind</em></code> is a tool for running local Kubernetes clusters using Docker container \"nodes\".</em></em><br><em><em><code><em>kind</em></code> is primarily designed for testing Kubernetes 1.11+, initially targeting the conformance tests.</em> <em>If you have <a href=\"https://golang.org/\" rel=\"noopener\">Go</a> and <a href=\"https://www.docker.com/\" rel=\"noopener\">Docker</a> installed <code><em>go get sigs.k8s.io/kind &amp;&amp; kind create cluster</em></code> is all you need</em></em></blockquote><p>Install your Kubernetes cluster for the evaluation:</p><pre><code class=\"language-shell\">$ kind create cluster --name=traefikee\nCreating cluster 'kind-traefikee' ...\n‚úì Ensuring node image (kindest/node:v1.12.3) üñº\n‚úì [kind-traefikee-control-plane] Creating node container üì¶\n‚úì [kind-traefikee-control-plane] Fixing mounts üóª\n‚úì [kind-traefikee-control-plane] Starting systemd üñ•\n‚úì [kind-traefikee-control-plane] Waiting for docker to be ready üêã\n‚úì [kind-traefikee-control-plane] Starting Kubernetes (this may take a minute) ‚ò∏\n\nCluster creation complete. You can now use the cluster with:\nexport KUBECONFIG=\"$(kind get kubeconfig-path --name=\"traefikee\")\"\nkubectl cluster-info\n\n$ export KUBECONFIG=\"$(kind get kubeconfig-path --name=\"traefikee\")\"\n\n$ kubectl cluster-info\nKubernetes master is running at https://localhost:55243\n\n# We have a Kubernetes cluster ready to use!</code></pre><p><em><em>Please note that any local Kubernetes installation passing the conformance tests can be used for the evaluation (as Docker4Mac or Docker4Windows).</em></em></p><p><strong><strong><em><em>TrafikEE Installation</em></em></strong></strong></p><p>Following the <a href=\"https://docs.containo.us\">official documentation</a>, you may install TraefikEE in one line, using <code>traefikeectl</code> . It might take a few minute to download all the required resources:</p><pre><code class=\"language-shell\">$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n...\n\nYou can access the dashboard with the following credentials:\n\nUsername: admin\nPassword: 4087abf2354666d9\n\n‚úî Installation successful</code></pre><p>Congratulations, your TraefikEE cluster is installed locally!</p><h2 id=\"a-tour-of-traefikee\">A Tour of TraefikEE</h2><p>TraefikEE is installed, now what?</p><p>First, we have to open access from your web-browser to the cluster:</p><pre><code class=\"language-shell\"># Forward TraefikEE data plane's port 80 to your localhost:8000\nkubectl port-forward -n traefikee \"$(kubectl get pod -n traefikee | awk '{print $1}' | grep data-node)\" 8000:80 &amp;</code></pre><p>TraefikEE is now exposed on your machine on the following URL: http://localhost:8000 .</p><blockquote><em><em>On a production-grade Kubernetes installation, you would use your external Load Balancer‚Äôs public hostname and port.</em></em></blockquote><p><strong><strong><em><em>Web Dashboard</em></em></strong></strong></p><p>Let‚Äôs start the tour with the Web Dashboard, which is enabled because we used the flag<code>--dashboard</code> during the installation.</p><p>Open the URL http://localhost:8000 and authenticate with the username and password credentials from the <code>traefikeectl install</code> command‚Äôs output from earlier.</p><blockquote><em><em>In this example, the username is <code><em>admin</em></code> and the password is <code><em>d4087abf2354666d9dsds</em></code>. These credentials are generated automatically during the installation.</em></em></blockquote><p>You can see the default section named ‚ÄúProviders‚Äù which shows you the TraefikEE‚Äôs routing configuration, generated from Kubernetes:</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-46.png\" class=\"kg-image\"><figcaption>Looks like Traefik‚Äôs WebUI</figcaption></figure><p>Using the top bar, navigate to the ‚ÄúMetrics‚Äù section to get an overview of the incoming request‚Äôs metrics.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Traefik also provides a ‚ÄúMetrics‚Äù page, what is the value of this one?</em></em><br><em><em><strong><strong>Containous:</strong></strong> It‚Äôs the same, except that metrics are aggregated from all the data plane‚Äôs nodes.</em></em></blockquote><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-47.png\" class=\"kg-image\"><figcaption>Look, someone forgot its password and got HTTP/401 responses</figcaption></figure><p>It‚Äôs time to get an overview of the cluster. Browse to the ‚ÄúCluster‚Äù section to check that you have a Control Plane of 3 nodes, and a Data Plane of 1 node.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Wait, isn‚Äôt TraefikEE distributed? Why only 1 node in the data plane?</em></em><br><em><em><strong><strong>Containous:</strong></strong> By default, there is 1 ‚ÄúTraefikEE Data Node‚Äù per Kubernetes node. We are using a single-node Kubernetes hence 1 data node. Wait for the next blog to learn more about the distribution.</em></em></blockquote><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-48.png\" class=\"kg-image\"><figcaption>It‚Äôs a nice cluster that you have there</figcaption></figure><p><strong><strong><em><em>Operations with traefikeectl</em></em></strong></strong></p><p>Next step of this tour is the ‚ÄúSmooth Operations‚Äù feature. We know that Engineers love automation. So we made a command line, <code>traefikeectl</code>to automate all the operations on your TraefikEE clusters.</p><p>You already tasted <code>traefikeectl</code>. Let‚Äôs do another example of operation by listing all the cluster‚Äôs nodes with <code>traefikeectl</code>:</p><pre><code class=\"language-shell\">$ traefikeectl list-nodes\n\nName                                 Role\n----                                 ----\ndata-node-traefikee-data-node-5fplw  DATA NODE\ntraefikee-control-node-0             CONTROL NODE (Current Leader)\ntraefikee-control-node-2             CONTROL NODE\ntraefikee-control-node-1             CONTROL NODE</code></pre><p>The next section shows another example, but you can already check the <code>traefikeectl</code> ‚Äòs <a href=\"https://docs.containo.us/installing/teectl-cli/\">Command Line Reference Documentation</a> to learn more about the operations features.</p><p><strong><strong><em><em>Deploy an application</em></em></strong></strong></p><p>TraefikEE is an edge router, which main goal is to route incoming request into your applications.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Did you just say ‚Äúapplications‚Äù? But there are no applications deployed into this Kubernetes, only TraefikEE.</em></em><br><em><em><strong><strong>Containous:</strong></strong> Patience, there is an example below. But let that sink in: Isn‚Äôt the Dashboard an application with incoming traffic?</em></em></blockquote><p>Let‚Äôs deploy an example application. It‚Äôs an HTTP web service, based on github.com/containous/whoami, which responds an HTML page with the headers of your request.</p><pre><code class=\"language-shell\">$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/8b87143b084c612f86d66f587df7c058c7fa1aa0/whoami.yaml</code></pre><p>Check the dashboard again. After a few seconds, the routing configuration for the application ‚Äúwhoami‚Äù is automatically picked by TraefikEE from Kubernetes: a frontend and 2 associated backends (the 2 replicas).</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-49.png\" class=\"kg-image\"></figure><p>The application is reachable at the URL localhost:8000/whoami. As the ‚Äúwhoami‚Äù application is scaled to 2 instances, try to reload the page multiple time to see the field ‚ÄúHostname‚Äù changing, due to the Load Balancing.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-50.png\" class=\"kg-image\"><figcaption>Such Web, Much Text</figcaption></figure><hr><p>That‚Äôs all for today and this first quick tour. On the next post ‚Äú<a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">The Journey to Traefik Enterprise Edition: High Availability</a>‚Äù, we‚Äôll cover the distributed features of TraefikEE.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/","canonical_url":null,"uuid":"63024ef7-edc2-4641-ad1c-3774332c9c49","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7e6ebf1db6f0038c7437f","reading_time":5}},{"node":{"id":"Ghost__Post__5dd7c361f1db6f0038c74326","title":"The Journey to Traefik Enterprise Edition: High Availability","slug":"the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/ee-ha.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/9c0b9ef78b45492064f94ebc3a717c59/a8378/ee-ha.png","srcSet":"/static/9c0b9ef78b45492064f94ebc3a717c59/630fb/ee-ha.png 300w,\n/static/9c0b9ef78b45492064f94ebc3a717c59/2a4de/ee-ha.png 600w,\n/static/9c0b9ef78b45492064f94ebc3a717c59/a8378/ee-ha.png 1024w","sizes":"(max-width: 1024px) 100vw, 1024px"}}},"excerpt":"Welcome to the third step of our journey towards Traefik Enterprise Edition . Let‚Äôs evaluate TraefikEE‚Äôs high availability feature with...","custom_excerpt":"Welcome to the third step of our journey towards Traefik Enterprise Edition . Let‚Äôs evaluate TraefikEE‚Äôs high availability feature with...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"January 28, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T11:15:45.000+00:00","published_at":"2019-01-28T11:15:00.000+00:00","updated_at":"2020-05-21T23:37:43.000+00:00","meta_title":"The Journey to Traefik Enterprise Edition: High Availability","meta_description":"Welcome to the third step of our journey towards Traefik Enterprise Edition . Let‚Äôs evaluate TraefikEE‚Äôs high availability feature.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the third step of our journey towards Traefik Enterprise Edition\n[/traefikee/] .\n\nAfter the two first posts Join the‚ÄúEarly Access‚Äù Program\n[/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/https://containo.us/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/]\n, and Product Evaluation\n[/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/]\n), let‚Äôs get real and evaluate TraefikEE‚Äôs high availability feature.\n\nThe previous post described how to install TraefikEE on a local machine, which\nis not a realistic environment. Today, we‚Äôll use a Kubernetes multi-node cluster\ndeployed in Amazon EC2 as a more realistic platform for running TraefikEE.\n\nCreating a Kubernetes Cluster with kops\nThe first step is to get a multi-node Kubernetes cluster up and running\nsomewhere in the cloud.\n\nkops (aka. ‚ÄúKubernetes Operations‚Äù) is a tool provided by the Kubernetes\ncommunity. It provides a command line to create and manage Kubernetes clusters\non cloud infrastructures as Amazon EC2 [https://aws.amazon.com/ec2/], Google\nCompute Engine [https://cloud.google.com/compute/?hl=fr] or Digital Ocean\n[https://www.digitalocean.com/].\n\nUsing the kops tutorial for AWS, we have the following requirements set up:\n\n * The aws command line tool installed\n * AWS API access credentials loaded (check this project\n   [https://github.com/mmatur/aws-mfa] from Michael MATUR\n   [https://medium.com/u/c01753d22e74?source=post_page-----7421718be2d8----------------------] \n   if you need MFA)\n * The kops command line tool installed\n * One of the 3 DNS scenarios configured\n * An AWS S3 bucket created to store kops configuration\n\nWe can create a Kubernetes cluster with 3 masters and 6 worker nodes. The worker\nnodes are a t2.large [https://aws.amazon.com/ec2/instance-types/t2/] types, with\n2 CPUs and 8 Gb memory each:\n\n$ export NAME=traefikee-demo.containous.cloud\n$ export KOPS_STATE_STORE=s3://<YOUR BUCKET>\n$ export ROUTE53_ZONE_ID=<ROUTE53_ZONE_ID>\n\n$ kops create cluster \\\n  --zones us-east-1a \\\n  --dns-zone=\"${ROUTE53_ZONE_ID}\" \\\n  --node-size=\"t2.large\" \\\n  --master-count=3 \\\n  --node-count=6 \\\n\"${NAME}\"\n\nOnce the cluster is created, validate its state with kops, and verify the access\nto the Kubernetes API with the kubectl:\n\n$ kops validate cluster --name=\"${NAME}\"\nValidating cluster traefikee-demo.containous.cloud\n...\n\nYour cluster traefikee-demo.containous.cloud is ready\n\n$ kubectl get nodes\nNAME STATUS ROLES AGE VERSION\nip-172‚Äì20‚Äì33‚Äì152.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì37‚Äì195.ec2.internal Ready master 1d v1.11.6\nip-172‚Äì20‚Äì38‚Äì193.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì42‚Äì46.ec2.internal Ready master 1d v1.11.6\nip-172‚Äì20‚Äì44‚Äì104.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì52‚Äì184.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì60‚Äì90.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì61‚Äì254.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì62‚Äì134.ec2.internal Ready master 1d v1.11.6\n\nWe can now proceed to install TraefikEE on this cluster.\n\nTraefikEE Installation\nWe expect that the command line traefikeectl command is already installed on\nyour machine. If you haven‚Äôt done it yet, check the \"Install traefikeectl\"\nsection of the Installation Guide [https://docs.containo.us].\n\n$ traefikeectl version\nVersion: v1.0.0-beta17\nCodename: Gewurztraminer\nGo version: go1.11.4\nBuilt: 2019-01-22_10:12:50AM\nOS/Arch: darwin/amd64\n\nNext step: installation of TraefikEE in one line, using traefikeectl, as covered\non the previous blog post\n[/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/]\n.\n\n> Don‚Äôt forget it takes some time to download all the required resources\n$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/‚Ä¶/traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n\n# ...\n\nYou can access the dashboard with the following credentials:\n\nUsername: admin\nPassword: 384bae9a1fe11670\n\n‚úî Installation successful\n\n> Don‚Äôt forget to write down the password for later.\nCongratulations, your TraefikEE cluster is installed locally! The last step is\nto check the topology of the TraefikEE cluster:\n\n$ traefikeectl list-nodes\nName                                 Role\n----                                 ----\ndata-node-traefikee-data-node-864tl  DATA NODE\ndata-node-traefikee-data-node-jptsq  DATA NODE\ndata-node-traefikee-data-node-rn4x8  DATA NODE\ntraefikee-control-node-1             CONTROL NODE\ndata-node-traefikee-data-node-l6x2s  DATA NODE\ndata-node-traefikee-data-node-wmm6n  DATA NODE\ndata-node-traefikee-data-node-h2pgb  DATA NODE\ntraefikee-control-node-2             CONTROL NODE (Current Leader)\ntraefikee-control-node-0             CONTROL NODE\n\nAs expected we have:\n\n * A Control Plane composed of 3 nodes, which is the default\n * A Data Plane composed of 6 nodes, which is the default behavior (see the\n   flag\n   ‚Äú ‚Äî datanodes‚Äù) [https://docs.containo.us/installing/teectl-cli/] . TraefikEE\n   sets up 1 data node per worker node of the Kubernetes cluster. It uses a \n   Kubernetes Daemon Set\n   [https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/] under\n   the hood.\n\nAccessing the Web Dashboard\nOn the previous post, we used the kubectl port-forward command to access the\ndashboard by forwarding a port locally\n[https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/]\n.\n\nAs this Kubernetes cluster is available from the outside, we want to use a\npublic hostname to access it instead, so the end users can access your\napplications from anywhere.\n\nUsing the command line kubectl, fetch the public hostname of the Amazon Elastic\nLoad-Balancer allocated during the installation (column EXTERNAL-IP):\n\n$ kubectl get svc -n traefikee traefikee-lb\n\nNAME          TYPE         EXTERNAL-IP\ntraefikee-lb  LoadBalancer a277b89-820.us-east-1.elb.amazonaws.com\n\nYou can now access the dashboard on the URL http://<EXTERNAL-IP>/dashboard/ .\n\nAll your nodes are belong to us> (A voice in the background): My Kubernetes Cluster does not show any\nEXTERNAL-IP. How can I reach the dashboard (and applications)?\n> Containous: Most of Kubernetes providers propose out of the box implementation\nfor the Service of type ‚ÄúLoadBalancer‚Äù\n[https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer].\nIf it is not your case, take a look at https://metallb.universe.tf/.\nDeploy an Application\nAs we did on the previous post, we deploy an application based on \nhttps://github.com/containous/whoami. \n\n$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/0ff70f9ae50d7930a9fa6c06bdc15253c81b8af4/whoami.yaml\n\nThe dashboard updates itself once the application is deployed:\n\nYou can now reach the application at the URL http://<EXTERNAL-IP>/whoami :\n\nHigh Availability\nWhat happens if one of the 6 worker node goes down by accident or for \nmaintenance\n[https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/]?\n\n * 1 of the 6 data nodes goes down (or is rescheduled). The load balancer\n   forwards the traffic to the 5 remaining nodes: no request are lost!\n * If 1 of the control nodes was running on this worker node, the remaining\n   nodes elect a new leader and take care of the configuration, until the node\n   comes up.\n\n> (A voice in the background): Aren‚Äôt the control node part of a Raft cluster? If\nyes, then what happens if only 2 control nodes are up?\n> Containous: The workload handled by the failed node is distributed to the 2\nothers, so the cluster does not loose data and continues to work as expected.\nHowever if the failed node does not comes back, then you are not tolerant to\nanother failure. You can run a TraefikEE of 5 control nodes to be fault tolerant\nto 2 failures. You can get more information on the TraefikEE documentation or\nchek how the Raft consensus work here [http://thesecretlivesofdata.com/raft/].\nTo demonstrate this high-availability behavior, we will:\n\n * Run a load test on the ‚Äúwhoami‚Äù application served by TraefikEE\n * Restart 1 of the 6 Kubernetes worker node\n * Verify that no requests are lost\n * Validate that the cluster comes back in an healthy state once the Kubernetes\n   worker node is restarted\n\nLoad Testing the whoami Application\nWe‚Äôll use ‚Äúslapper‚Äù (https://github.com/ikruglov/slapper), a go command line\nproviding a real-time view of the load test in the console.\n\n# You need go - https://golang.org/dl/\n\n$ go get -u github.com/ikruglov/slapper\n...\n\n$ which slapper\n\"${GOPATH}/bin/slapper\"\n\nSlapper requires a ‚Äútarget file\n[https://github.com/ikruglov/slapper#targets-syntax]‚Äù which is a text file\ndescribing the load-testing scenario. Our load-testing scenario is simple: we\nwant to emit HTTP GET requests to the URL of the whoami application.\n\n$ cat whoami.target\nGET http://a277bd4f21fde11e9b5150ea2ab8b589-823458350.us-east-1.elb.amazonaws.com/whoami\n\nLet‚Äôs start the load testing for 30s, with 50 requests per seconds, and with an\nadapted scale (with an example output):\n\n$ slapper -targets ./whoami.target -minY 100ms -maxY 800ms -timeout 30s -rate 50\n\nsent: 198    in-flight: 6  rate:   50/50 RPS responses: [200]: 192\n\n100-101 ms: [     0/     0]\n101-102 ms: [     0/     0]\n102-103 ms: [     0/     0]\n103-105 ms: [     0/     0]\n105-106 ms: [     0/     0]\n106-108 ms: [    13/     0] **************************\n108-110 ms: [   112/     0] ************************************\n110-113 ms: [    40/     0] ****************************************\n113-115 ms: [    10/     0] ********************\n115-118 ms: [     3/     0] ******\n118-121 ms: [     4/     0] ********\n121-125 ms: [     2/     0] ****\n125-129 ms: [     0/     0]\n129-133 ms: [     0/     0]\n133-138 ms: [     0/     0]\n138-144 ms: [     0/     0]\n144-150 ms: [     0/     0]\n...\n800+ ms: [     0/     0]\n\nReboot a Worker Node\nUsing the aws and kubectlcommand lines, we get the EC2 instance ID of a worker\nnode, and restart it:\n\n# Select one of the 6 Kubernetes nodes\n$ kubectl get nodes\nNAME STATUS ROLES AGE VERSION\n...\nip-172‚Äì20‚Äì38‚Äì193.ec2.internal Ready node 1d v1.11.6\n...\n\n# Get the EC2 instance ID\n$ aws ec2 describe-instances --filters \"Name=private-dns-name,Values=ip-172-20-38-193.ec2.internal\" | grep InstanceId\n\"InstanceId\": \"i-0fdc6a4f95908a2ba\",\n\n# Restart the instance\n$ aws ec2 reboot-instances --instance-ids=i-0fdc6a4f95908a2ba\n\nThe Dashboard immediately reports that a control node and a data node are\nunhealthy ( traefikee-control-node-0 and data-node-traefikee-wmm6n in this\ncase):\n\nValidate High Availability\nIf you check back the load testing, you can see that no requests have been lost\nor in error. You might see, however, a punctual growth on the response time (+-\n100ms):\n\nsent: 25736  in-flight: 2 rate:   50/50 RPS responses: [200]: 25734\n\nAs soon as the EC2 instance has restarted, all the failed nodes (Kubernetes and\nTraefikEE) are going back online:\n\nTraefikEE cluster back to nominal stateCheck this video of a the load test\nrunning with a worker node randomly killed:\n\nThat‚Äôs all for today! We demonstrated the high availability feature of\nTraefikEE. Oh, and don‚Äôt forget to clean your cluster:\n\nkops delete cluster --name=\"${NAME}\"\n\n\n--------------------------------------------------------------------------------\n\nOn the next post ‚ÄúThe Journey to Traefik Enterprise Edition: HTTPS for everyone\n[/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/]\n‚Äù, we‚Äôll focus on how to use TraefikEE with Let‚Äôs Encrypt to get HTTPS by\ndefault.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-9.png\" class=\"kg-image\"></figure><p>Welcome to the third step of our journey towards<a href=\"https://containous.ghost.io/traefikee/\"> Traefik Enterprise Edition</a> .</p><p>After the two first posts <em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/https://containo.us/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/\">Join the‚ÄúEarly Access‚Äù Program</a></em></em>, and <em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">Product Evaluation</a></em></em>), let‚Äôs get real and evaluate TraefikEE‚Äôs high availability feature.</p><p>The previous post described how to install TraefikEE on a local machine, which is not a realistic environment. Today, we‚Äôll use a Kubernetes multi-node cluster deployed in Amazon EC2 as a more realistic platform for running TraefikEE.</p><h2 id=\"creating-a-kubernetes-cluster-with-kops\">Creating a Kubernetes Cluster with kops</h2><p>The first step is to get a multi-node Kubernetes cluster up and running somewhere in the cloud.</p><p><code>kops</code> (aka. ‚ÄúKubernetes Operations‚Äù) is a tool provided by the Kubernetes community. It provides a command line to create and manage Kubernetes clusters on cloud infrastructures as <a href=\"https://aws.amazon.com/ec2/\" rel=\"noopener\">Amazon EC2</a>, <a href=\"https://cloud.google.com/compute/?hl=fr\" rel=\"noopener\">Google Compute Engine</a> or <a href=\"https://www.digitalocean.com/\" rel=\"noopener\">Digital Ocean</a>.</p><p>Using the kops tutorial for AWS, we have the following requirements set up:</p><ul><li>The <code>aws</code> command line tool installed</li><li>AWS API access credentials loaded (<a href=\"https://github.com/mmatur/aws-mfa\" rel=\"noopener\">check this project</a> from <a href=\"https://medium.com/u/c01753d22e74?source=post_page-----7421718be2d8----------------------\" rel=\"noopener\">Michael MATUR</a> if you need MFA)</li><li>The <code>kops</code> command line tool installed</li><li>One of the 3 DNS scenarios configured</li><li>An AWS S3 bucket created to store kops configuration</li></ul><p>We can create a Kubernetes cluster with 3 masters and 6 worker nodes. The worker nodes are a <a href=\"https://aws.amazon.com/ec2/instance-types/t2/\" rel=\"noopener\">t2.large</a> types, with 2 CPUs and 8 Gb memory each:</p><pre><code class=\"language-shell\">$ export NAME=traefikee-demo.containous.cloud\n$ export KOPS_STATE_STORE=s3://&lt;YOUR BUCKET&gt;\n$ export ROUTE53_ZONE_ID=&lt;ROUTE53_ZONE_ID&gt;\n\n$ kops create cluster \\\n  --zones us-east-1a \\\n  --dns-zone=\"${ROUTE53_ZONE_ID}\" \\\n  --node-size=\"t2.large\" \\\n  --master-count=3 \\\n  --node-count=6 \\\n\"${NAME}\"</code></pre><p>Once the cluster is created, validate its state with <code>kops</code>, and verify the access to the Kubernetes API with the <code>kubectl</code>:</p><pre><code class=\"language-shell\">$ kops validate cluster --name=\"${NAME}\"\nValidating cluster traefikee-demo.containous.cloud\n...\n\nYour cluster traefikee-demo.containous.cloud is ready\n\n$ kubectl get nodes\nNAME STATUS ROLES AGE VERSION\nip-172‚Äì20‚Äì33‚Äì152.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì37‚Äì195.ec2.internal Ready master 1d v1.11.6\nip-172‚Äì20‚Äì38‚Äì193.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì42‚Äì46.ec2.internal Ready master 1d v1.11.6\nip-172‚Äì20‚Äì44‚Äì104.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì52‚Äì184.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì60‚Äì90.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì61‚Äì254.ec2.internal Ready node 1d v1.11.6\nip-172‚Äì20‚Äì62‚Äì134.ec2.internal Ready master 1d v1.11.6</code></pre><p>We can now proceed to install TraefikEE on this cluster.</p><h2 id=\"traefikee-installation\">TraefikEE Installation</h2><p>We expect that the command line <code>traefikeectl</code> command is already installed on your machine. If you haven‚Äôt done it yet, check the \"Install traefikeectl\" section of the <a href=\"https://docs.containo.us\">Installation Guide</a>.</p><pre><code class=\"language-shell\">$ traefikeectl version\nVersion: v1.0.0-beta17\nCodename: Gewurztraminer\nGo version: go1.11.4\nBuilt: 2019-01-22_10:12:50AM\nOS/Arch: darwin/amd64</code></pre><p>Next step: installation of TraefikEE in one line, using <code>traefikeectl</code>, as covered on <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">the previous blog post</a>.</p><blockquote><em><em>Don‚Äôt forget it takes some time to download all the required resources</em></em></blockquote><pre><code class=\"language-shell\">$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/‚Ä¶/traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n\n# ...\n\nYou can access the dashboard with the following credentials:\n\nUsername: admin\nPassword: 384bae9a1fe11670\n\n‚úî Installation successful</code></pre><blockquote>Don‚Äôt forget to write down the password for later.</blockquote><p>Congratulations, your TraefikEE cluster is installed locally! The last step is to check the topology of the TraefikEE cluster:</p><pre><code class=\"language-shell\">$ traefikeectl list-nodes\nName                                 Role\n----                                 ----\ndata-node-traefikee-data-node-864tl  DATA NODE\ndata-node-traefikee-data-node-jptsq  DATA NODE\ndata-node-traefikee-data-node-rn4x8  DATA NODE\ntraefikee-control-node-1             CONTROL NODE\ndata-node-traefikee-data-node-l6x2s  DATA NODE\ndata-node-traefikee-data-node-wmm6n  DATA NODE\ndata-node-traefikee-data-node-h2pgb  DATA NODE\ntraefikee-control-node-2             CONTROL NODE (Current Leader)\ntraefikee-control-node-0             CONTROL NODE</code></pre><p>As expected we have:</p><ul><li>A Control Plane composed of <strong><strong>3</strong></strong> nodes, which is the default</li><li>A Data Plane composed of <strong><strong>6</strong></strong> nodes, which is <a href=\"https://docs.containo.us/installing/teectl-cli/\">the default behavior (see the flag ‚Äú ‚Äî datanodes‚Äù)</a> . TraefikEE sets up 1 data node per worker node of the Kubernetes cluster. It uses a <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/\" rel=\"noopener\">Kubernetes Daemon Set</a> under the hood.</li></ul><h2 id=\"accessing-the-web-dashboard\">Accessing the Web Dashboard</h2><p>On the previous post, we used the <code>kubectl port-forward</code> command to access the dashboard by <a href=\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\" rel=\"noopener\">forwarding a port locally</a>.</p><p>As this Kubernetes cluster is available from the outside, we want to use a public hostname to access it instead, so the end users can access your applications from anywhere.</p><p>Using the command line <code>kubectl</code>, fetch the public hostname of the Amazon Elastic Load-Balancer allocated during the installation (column <code>EXTERNAL-IP</code>):</p><pre><code class=\"language-shell\">$ kubectl get svc -n traefikee traefikee-lb\n\nNAME          TYPE         EXTERNAL-IP\ntraefikee-lb  LoadBalancer a277b89-820.us-east-1.elb.amazonaws.com</code></pre><p>You can now access the dashboard on the URL <code>http://&lt;EXTERNAL-IP&gt;/dashboard/</code> .</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-41.png\" class=\"kg-image\"><figcaption>All your nodes are belong to us</figcaption></figure><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> My Kubernetes Cluster does not show any EXTERNAL-IP. How can I reach the dashboard (and applications)?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Most of Kubernetes providers propose out of the box implementation for the <a href=\"https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer\" rel=\"noopener\">Service of type ‚ÄúLoadBalancer‚Äù</a>. If it is not your case, take a look at <a href=\"https://metallb.universe.tf/\" rel=\"noopener\">https://metallb.universe.tf/</a>.</em></em></blockquote><h2 id=\"deploy-an-application\">Deploy an Application</h2><p>As we did on the previous post, we deploy an application based on <a href=\"https://github.com/containous/whoami\" rel=\"noopener\">https://github.com/containous/whoami</a>. </p><pre><code class=\"language-shell\">$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/0ff70f9ae50d7930a9fa6c06bdc15253c81b8af4/whoami.yaml</code></pre><p>The dashboard updates itself once the application is deployed:</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-42.png\" class=\"kg-image\"></figure><p>You can now reach the application at the URL <code>http://&lt;EXTERNAL-IP&gt;/whoami</code> :</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-43.png\" class=\"kg-image\"></figure><h2 id=\"high-availability\">High Availability</h2><p>What happens if one of the 6 worker node goes down by accident or for <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/\" rel=\"noopener\">maintenance</a>?</p><ul><li>1 of the 6 data nodes goes down (or is rescheduled). The load balancer forwards the traffic to the 5 remaining nodes: no request are lost!</li><li>If 1 of the control nodes was running on this worker node, the remaining nodes elect a new leader and take care of the configuration, until the node comes up.</li></ul><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Aren‚Äôt the control node part of a Raft cluster? If yes, then what happens if only 2 control nodes are up?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> The workload handled by the failed node is distributed to the 2 others, so the cluster does not loose data and continues to work as expected. However if the failed node does not comes back, then you are not tolerant to another failure. You can run a TraefikEE of 5 control nodes to be fault tolerant to 2 failures. You can get more information on the TraefikEE documentation or chek how the Raft consensus work <a href=\"http://thesecretlivesofdata.com/raft/\" rel=\"noopener\">here</a>.</em></em></blockquote><p>To demonstrate this high-availability behavior, we will:</p><ul><li>Run a load test on the ‚Äú<em><em>whoami</em></em>‚Äù application served by TraefikEE</li><li>Restart 1 of the 6 Kubernetes worker node</li><li>Verify that no requests are lost</li><li>Validate that the cluster comes back in an healthy state once the Kubernetes worker node is restarted</li></ul><h2 id=\"load-testing-the-whoami-application\">Load Testing the whoami Application</h2><p>We‚Äôll use ‚Äúslapper‚Äù (<a href=\"https://github.com/ikruglov/slapper\" rel=\"noopener\">https://github.com/ikruglov/slapper</a>), a go command line providing a real-time view of the load test in the console.</p><pre><code class=\"language-shell\"># You need go - https://golang.org/dl/\n\n$ go get -u github.com/ikruglov/slapper\n...\n\n$ which slapper\n\"${GOPATH}/bin/slapper\"</code></pre><p>Slapper requires a ‚Äú<a href=\"https://github.com/ikruglov/slapper#targets-syntax\" rel=\"noopener\">target file</a>‚Äù which is a text file describing the load-testing scenario. Our load-testing scenario is simple: we want to emit HTTP GET requests to the URL of the <em><em>whoami</em></em> application.</p><pre><code class=\"language-shell\">$ cat whoami.target\nGET http://a277bd4f21fde11e9b5150ea2ab8b589-823458350.us-east-1.elb.amazonaws.com/whoami</code></pre><p>Let‚Äôs start the load testing for 30s, with 50 requests per seconds, and with an adapted scale (with an example output):</p><pre><code class=\"language-shell\">$ slapper -targets ./whoami.target -minY 100ms -maxY 800ms -timeout 30s -rate 50\n\nsent: 198    in-flight: 6  rate:   50/50 RPS responses: [200]: 192\n\n100-101 ms: [     0/     0]\n101-102 ms: [     0/     0]\n102-103 ms: [     0/     0]\n103-105 ms: [     0/     0]\n105-106 ms: [     0/     0]\n106-108 ms: [    13/     0] **************************\n108-110 ms: [   112/     0] ************************************\n110-113 ms: [    40/     0] ****************************************\n113-115 ms: [    10/     0] ********************\n115-118 ms: [     3/     0] ******\n118-121 ms: [     4/     0] ********\n121-125 ms: [     2/     0] ****\n125-129 ms: [     0/     0]\n129-133 ms: [     0/     0]\n133-138 ms: [     0/     0]\n138-144 ms: [     0/     0]\n144-150 ms: [     0/     0]\n...\n800+ ms: [     0/     0]</code></pre><h2 id=\"reboot-a-worker-node\">Reboot a Worker Node</h2><p>Using the <code>aws</code> and <code>kubectl</code>command lines, we get the EC2 instance ID of a worker node, and restart it:</p><pre><code class=\"language-shell\"># Select one of the 6 Kubernetes nodes\n$ kubectl get nodes\nNAME STATUS ROLES AGE VERSION\n...\nip-172‚Äì20‚Äì38‚Äì193.ec2.internal Ready node 1d v1.11.6\n...\n\n# Get the EC2 instance ID\n$ aws ec2 describe-instances --filters \"Name=private-dns-name,Values=ip-172-20-38-193.ec2.internal\" | grep InstanceId\n\"InstanceId\": \"i-0fdc6a4f95908a2ba\",\n\n# Restart the instance\n$ aws ec2 reboot-instances --instance-ids=i-0fdc6a4f95908a2ba</code></pre><p>The Dashboard immediately reports that a control node and a data node are unhealthy ( <code>traefikee-control-node-0</code> and <code>data-node-traefikee-wmm6n</code> in this case):</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-44.png\" class=\"kg-image\"></figure><h2 id=\"validate-high-availability\">Validate High Availability</h2><p>If you check back the load testing, you can see that no requests have been lost or in error. You might see, however, a punctual growth on the response time (+- 100ms):</p><pre><code class=\"language-shell\">sent: 25736  in-flight: 2 rate:   50/50 RPS responses: [200]: 25734</code></pre><p>As soon as the EC2 instance has restarted, all the failed nodes (Kubernetes and TraefikEE) are going back online:</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-45.png\" class=\"kg-image\"><figcaption>TraefikEE cluster back to nominal state</figcaption></figure><p>Check this video of a the load test running with a worker node randomly killed:</p><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/ghYsR5CuNiQ?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure><p>That‚Äôs all for today! We demonstrated the high availability feature of TraefikEE. Oh, and don‚Äôt forget to clean your cluster:</p><pre><code class=\"language-shell\">kops delete cluster --name=\"${NAME}\"</code></pre><hr><p>On the next post ‚Äú<a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/\">The Journey to Traefik Enterprise Edition: HTTPS for everyone</a>‚Äù, we‚Äôll focus on how to use TraefikEE with Let‚Äôs Encrypt to get HTTPS by default.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/","canonical_url":null,"uuid":"68a2548b-36b0-4fe7-9993-4eba958e6280","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7c361f1db6f0038c74326","reading_time":7}},{"node":{"id":"Ghost__Post__5dd7c250f1db6f0038c7430f","title":"Getting to Know Vincent Pineau","slug":"getting-to-know-vincent-pineau-25b75bda1019","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/vincent.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/f2e9504d873b3110b0afaa830a588e17/46604/vincent.png","srcSet":"/static/f2e9504d873b3110b0afaa830a588e17/630fb/vincent.png 300w,\n/static/f2e9504d873b3110b0afaa830a588e17/46604/vincent.png 500w","sizes":"(max-width: 500px) 100vw, 500px"}}},"excerpt":"We recently welcomed new leadership to the Containous team. His name is Vincent Pineau, a tech veteran who has...","custom_excerpt":"We recently welcomed new leadership to the Containous team. His name is Vincent Pineau, a tech veteran who has...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"February 20, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T11:11:12.000+00:00","published_at":"2019-02-20T11:11:00.000+00:00","updated_at":"2020-05-22T00:16:30.000+00:00","meta_title":"Getting to Know Vincent Pineau","meta_description":"We recently welcomed new leadership to the Containous team. His name is Vincent Pineau, a tech veteran who has...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Patricia Dugan ","slug":"patricia","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/01/me-looking-cute.JPG","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Patricia Dugan ","slug":"patricia","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/01/me-looking-cute.JPG","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Company","slug":"company","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"An Interview with New Leadership at Containous\n\nWe recently welcomed new leadership to the Containous [/] team. His name is \nVincent Pineau [https://www.linkedin.com/in/vincent-pineau-143898/], a tech\nveteran who has successfully lead two companies to the win. One, Talend, the\nthird French company to make it to the NASDAQ, and the second, Influans, a\ncompany recently acquired. Vincent joined our small and dedicated leadership\nteam as CCO, standing alongside Emile Vauge [https://twitter.com/emilevauge],\nfounder and CEO of Containous, and the inventor of Traefik [/traefik/], a world\nclass, cloud native edge router.\n\nVincent and I have a highly collaborative relationship around my marketing\nefforts. Here, I ask him questions to better understand his vision for the\ncompany, and how he‚Äôll lead us to becoming globally recognized, and trusted for\nour brand, products and customer service. Please read on.\n\n\n--------------------------------------------------------------------------------\n\nThe Interview\nVincent Pineau, Chief Customer Officer, ContainousPatricia: What is your title at Containous, and function does this role play?\n\nVincent: I am the new ‚ÄúCCO,‚Äù which stands for Chief Customer Officer, although\ntitles aren‚Äôt very important to us. More meaningful than a title is a person‚Äôs\nfocus. My focus is to extend Containous from the amazing open source company\nthat it is, to an open source business. I am responsible for putting together\nand to oversee, the appropriate programs and services to grow the business. I\nwill enable our expansion, from a customer support, sales and marketing\nstandpoint.\n\nPatricia: What does such an expansion look like?\n\nVincent: First, we will continue to develop products which are easy and relevant\nto the quickly evolving IT infrastructure world. Then, we‚Äôll hone in on what our\ncustomers, and the open source community needs to drive the most value out of\nour products. Commercial support, expertise consulting, advanced training,\nspecific ‚Äúenterprise grade‚Äù capabilities, those are the key variables that I‚Äôve\nseen leveraged in the past to build sustainable open source companies‚Ä¶which is\nexactly what Containous will become.\n\nPatricia: Wait. So. What‚Äôs your background?\n\nVincent: As a quick study, I was part of the founding team that grew one company\nto an IPO on the NASDAQ, and co-founder of another company which was acquired\nlate 2018. To give you the full story, we have to go back a little bit and\nexplain my journey in tech. I had my first computer when I was 10. You know my\nage, so that takes us back a while.\n\nPatricia: Do I know your age? I don‚Äôt.\n\nVincent: I just turned 50 in January. I had a computer in ‚Äô79, and I was\nprobably one of the first dozen in the area of Lyon to have a computer. As a\ncurious kid, I started tinkering with computers. I came to have several of them\nand then as a teenager, had to choose a major. After some deliberation, I chose\nto focus on mechanics.\n\nThe computers, everything IT related, became a passion, but I earned my major in\nmechanical engineering. The team at my first job figured out very quickly that\nmy value was in IT, not acting as a mechanical engineer. Eventually, I became\nthe IT Director there. I implemented an ERP solution, and was quickly hired by\nthe vendor to become a consultant.\n\nThat‚Äôs when I discovered the ‚Äúvendor‚Äù side, which quickly brought me to the U.S.\nAfter about a decade working for traditional enterprise vendors, I was\nintroduced to a French open source company, Talend, and given the opportunity to\nlaunch it globally. That meant taking an open source company which was having a\nfair amount of organic traction, acting as an evangelist, and bringing attention\nto the company, with the goal of turning existing users into customers.\n\nThat journey started in 2007, when commercial open source was still being\nestablished in the U.S.\n\nDuring that time frame, I spent a lot of time explaining to customers the\nadvantages of open source.\n\n> I don‚Äôt believe in open source being at odds with proprietary software.\nGenerally, I believe that open source is superior, because it is the result of a\ncommunity driven focus.\nYou benefit from lots of brains ‚Äî which brings stability, an edge in creativity,\nan edge in time to market. Those elements together are superior.\n\nPatricia: What does the future hold for Traefik?\n\nVincent: I see wonderful opportunities here. When I was with Talend, we had a\nsimilar opportunity with similar challenges. We started as a small team in\nFrance, with a small amount of funding. We became serious about bringing the\nproduct to market, and my charter was to raise awareness to a global\nmarketplace, not just Europe.\n\nWe have a similar story with Containous, in that it has substantial organic\ngrowth and humble beginnings. Now, we going for the gold by dedicating more\ndeveloper, marketing and community resources to growing the company. We will\nbring not just Traefik open source edition more visibility, but expose the value\nof Traefik Enterprise Edition [/traefikee/] to a worldwide audience.\n\nI am excited to create an evolution. Containous is a mind blowing company with a\nthoroughness that the team is proving through the development of high quality\nsoftware.\n\n> We will show why we‚Äôre worth getting to know.\nWe are creating a technical evolution, beginning with Traefik and Traefik\nEnterprise Edition. I‚Äôm excited to lead us into creating it.\n\n\n--------------------------------------------------------------------------------\n\nFor those interested in free early access to Traefik Enterprise Edition,\n[/traefikee/] and to those already using Traefik in production who wish to share\nyour stories, please email me: patricia at containo.us.\n\nThank you.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">An Interview with New Leadership at Containous</p><!--kg-card-end: html--><p>We recently welcomed new leadership to the <a href=\"https://containous.ghost.io/\" rel=\"noopener\">Containous</a> team. His name is <a href=\"https://www.linkedin.com/in/vincent-pineau-143898/\" rel=\"noopener\">Vincent Pineau</a>, a tech veteran who has successfully lead two companies to the win. One, Talend, the third French company to make it to the NASDAQ, and the second, Influans, a company recently acquired. Vincent joined our small and dedicated leadership team as CCO, standing alongside <a href=\"https://twitter.com/emilevauge\" rel=\"noopener\">Emile Vauge</a>, founder and CEO of Containous, and the <em><em>inventor</em></em> of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, a <em><em>world class, cloud native edge router.</em></em></p><p>Vincent and I have a highly collaborative relationship around my marketing efforts. Here, I ask him questions to better understand his vision for the company, and how he‚Äôll lead us to becoming globally recognized, and <em><em>trusted for our brand, products and customer service</em></em>. Please read on.</p><hr><h2 id=\"the-interview\">The Interview</h2><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-40.png\" class=\"kg-image\"><figcaption>Vincent Pineau, Chief Customer Officer, Containous</figcaption></figure><p><strong><strong>Patricia: </strong></strong>What is your title at Containous, and function does this role play?</p><p><strong><strong>Vincent: </strong></strong>I am the new ‚ÄúCCO,‚Äù which stands for <em><em>Chief Customer Officer</em></em>, although titles aren‚Äôt very important to us. More meaningful than a title is a person‚Äôs focus. My focus is to extend Containous from the amazing open source company that it is, to an open source business. I am responsible for putting together and to oversee, the appropriate programs and services to grow the business. I will enable our expansion, from a customer support, sales and marketing standpoint.</p><p><strong><strong>Patricia: </strong></strong>What does such an expansion look like?</p><p><strong><strong>Vincent: </strong></strong>First, we will continue to develop products which are easy and relevant to the quickly evolving IT infrastructure world. Then, we‚Äôll hone in on what our customers, and the open source community needs to drive the most value out of our products. Commercial support, expertise consulting, advanced training, specific ‚Äúenterprise grade‚Äù capabilities, those are the key variables that I‚Äôve seen leveraged in the past to build sustainable open source companies‚Ä¶which is exactly what Containous will become.</p><p><strong><strong>Patricia: </strong></strong>Wait. So. What‚Äôs your background?</p><p><strong><strong>Vincent: </strong></strong>As a quick study, I was part of the founding team that grew one company to an IPO on the NASDAQ, and co-founder of another company which was acquired late 2018. To give you the full story, we have to go back a little bit and explain my journey in tech. I had my first computer when I was 10. You know my age, so that takes us back a while.</p><p><strong><strong>Patricia:</strong></strong> Do I know your age? I don‚Äôt.</p><p><strong><strong>Vincent: </strong></strong>I just turned 50 in January. I had a computer in ‚Äô79, and I was probably one of the first dozen in the area of Lyon to have a computer. As a curious kid, I started tinkering with computers. I came to have several of them and then as a teenager, had to choose a major. After some deliberation, I chose to focus on mechanics.</p><p>The computers, everything IT related, became a passion, but I earned my major in mechanical engineering. The team at my first job figured out very quickly that my value was in IT, not acting as a mechanical engineer. Eventually, I became the IT Director there. I implemented an ERP solution, and was quickly hired by the vendor to become a consultant.</p><p>That‚Äôs when I discovered the ‚Äúvendor‚Äù side, which quickly brought me to the U.S. After about a decade working for traditional enterprise vendors, I was introduced to a French <em><em>open source company</em></em>, Talend, and given the opportunity to launch it globally. That meant taking an open source company which was having a fair amount of organic traction, acting as an evangelist, and bringing attention to the company, with the goal of turning existing users into customers.</p><p>That journey started in 2007, when commercial open source was still being established in the U.S.</p><p>During that time frame, I spent a lot of time explaining to customers the advantages of open source.</p><blockquote>I don‚Äôt believe in open source being at odds with proprietary software. Generally, I believe that open source is superior, because it is the result of a community driven focus.</blockquote><p>You benefit from lots of brains ‚Äî which brings stability, an edge in creativity, an edge in time to market. Those elements together are superior.</p><p><strong><strong>Patricia: </strong></strong>What does the future hold for Traefik?</p><p><strong><strong>Vincent:</strong></strong> I see wonderful opportunities here. When I was with Talend, we had a similar opportunity with similar challenges. We started as a small team in France, with a small amount of funding. We became serious about bringing the product to market, and my charter was to raise awareness to a global marketplace, not just Europe.</p><p>We have a similar story with Containous, in that it has substantial organic growth and humble beginnings. Now, we going for the gold by dedicating more developer, marketing and community resources to growing the company. We will bring not just Traefik open source edition more visibility, but expose the value of <a href=\"https://containous.ghost.io/traefikee/\" rel=\"noopener\">Traefik Enterprise Edition</a> to a worldwide audience.</p><p>I am excited to create an <em><em>evolution.</em></em> Containous is a mind blowing company with a thoroughness that the team is proving through the development of high quality software.</p><blockquote>We will show <em>why</em> we‚Äôre worth getting to know.</blockquote><p>We are creating a technical evolution, beginning with Traefik and Traefik Enterprise Edition. I‚Äôm excited to lead us into creating it.</p><hr><p>For those interested in <a href=\"https://containous.ghost.io/traefikee/\" rel=\"noopener\">free early access to Traefik Enterprise Edition,</a> and to those already using Traefik in production who wish to share your stories, please email me: patricia at containo.us.</p><p>Thank you.</p>","url":"https://containous.ghost.io/blog/getting-to-know-vincent-pineau-25b75bda1019/","canonical_url":null,"uuid":"e322033f-4946-417b-80d5-250d9dc8282a","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7c250f1db6f0038c7430f","reading_time":4}},{"node":{"id":"Ghost__Post__5dd7bc8af1db6f0038c742d5","title":"The Journey to Traefik Enterprise Edition: HTTPS for Everyone","slug":"the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/ee-tls-le.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/27079133642b20968c4b4d4fe242c032/ee604/ee-tls-le.png","srcSet":"/static/27079133642b20968c4b4d4fe242c032/630fb/ee-tls-le.png 300w,\n/static/27079133642b20968c4b4d4fe242c032/2a4de/ee-tls-le.png 600w,\n/static/27079133642b20968c4b4d4fe242c032/ee604/ee-tls-le.png 800w","sizes":"(max-width: 800px) 100vw, 800px"}}},"excerpt":"Welcome to the fourth step of our journey towards Traefik Enterprise Edition.\nToday, we‚Äôll focus on how to use TraefikEE with Let‚Äôs Encrypt to get HTTPS by default...","custom_excerpt":"Welcome to the fourth step of our journey towards Traefik Enterprise Edition.\nToday, we‚Äôll focus on how to use TraefikEE with Let‚Äôs Encrypt to get HTTPS by default...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"February 25, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T10:46:34.000+00:00","published_at":"2019-02-25T10:45:00.000+00:00","updated_at":"2020-05-21T23:28:53.000+00:00","meta_title":"The Journey to Traefik Enterprise Edition: HTTPS for Everyone","meta_description":"Welcome to the 4th step of our journey towards Traefik Enterprise. We‚Äôll focus on how to use TraefikEE with Let‚Äôs Encrypt to get HTTPS for everyone.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the fourth step of our journey towards Traefik Enterprise Edition\n[/traefikee/].\n\nBefore jumping in, you should check the previous posts:\n\n * Join the‚ÄúEarly Access‚Äù Program\n   [/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/]\n * Product Evaluation\n   [/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/]\n * High Availability\n   [/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n\nToday, we‚Äôll focus on how to use TraefikEE with Let‚Äôs Encrypt to get HTTPS by\ndefault, for your application.\n\nCreate a Kubernetes Cluster with kops\nFollowing the same steps as the previous blog post (‚ÄúCreate a cluster with\nkops‚Äù)\n[/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n, start a kops cluster with one Kubernetes manager and three Kubernetes nodes:\n\n$ export NAME=traefikee-demo.containous.cloud\n$ export KOPS_STATE_STORE=s3://<YOUR BUCKET>\n$ export ROUTE53_ZONE_ID=<ROUTE53_ZONE_ID>\n$ export NB_MASTER_NODE=1\n$ export NB_WORKER_NODE=3\n\n$ kops create cluster \\\n    --zones us-east-1a \\\n    --dns-zone=\"${ROUTE53_ZONE_ID}\" \\\n    --node-size=\"t2.large\" \\\n    --master-count=\"${NB_MASTER_NODE}\" \\\n    --node-count=\"${NB_WORKER_NODE}\" \\\n    --yes \\\n    \"${NAME}\"\n\nAfter a few minutes, your cluster is started with four Kubernetes nodes:\n\n$ kubectl get nodes\nNAME                            STATUS   ROLES    AGE   VERSION\nip-172-20-34-251.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-49-209.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-53-165.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-56-217.ec2.internal   Ready    master   3m    v1.11.6\n\nPick a Public Domain Name\nIn the previous blog post, we used a domain name generated by Amazon Web\nServices\n[/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/] \nas the main entry point to reach our platform.\n\nYou cannot use this ‚Äúgenerated‚Äù public hostname, because Let‚Äôs Encrypt has a\n‚Äúforbidden domains list.‚Äù Some domains are considered too risky, and any request\nfor issuing certificates under these domains is automatically refused. It‚Äôs the\ncase with domains in\n[https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2]\n*.amazonaws.com\n[https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2]\n.\n\nTo solve this challenge, let‚Äôs pick a custom public domain name. Any domain or\nsub-domain (like test.company.org ) can be used. You have to be able to create\nDNS records of type CNAME on this domain.\n\n> (A voice in the background): I don‚Äôt want to pay for a domain used for\nevaluating a product. Maybe later if it goes further, but not now.\n> Containous: You can get free DNS using Dot-T-K\n[http://www.dot.tk/en/index.html?lang=en], or even cheap ones using NameCheap\n[https://www.namecheap.com/].\nFor the next steps, we‚Äôll pick the domain demo.containo.us .\n\nInstall TraefikEE\nThen, install a simple TraefikEE cluster, without dashboard, as we did on the\nprevious blog post\n[/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n:\n\n$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/‚Ä¶/traefikee-license)\" \\\n  --kubernetes\n...\n\n‚úî Installation successful\n\nOnce the installation succeeded, verify that the TraefikEE cluster is composed\nof six nodes, three control nodes and three data nodes, as expected:\n\n$ traefikeectl list-nodes\n...\nName                                 Role\n----                                 ----\ntraefikee-control-node-0             CONTROL NODE\ndata-node-traefikee-data-node-9ndbp  DATA NODE\ndata-node-traefikee-data-node-vqgzr  DATA NODE\ntraefikee-control-node-1             CONTROL NODE\ntraefikee-control-node-2             CONTROL NODE (Current Leader)\ndata-node-traefikee-data-node-5w66x  DATA NODE\n\nConfigure the Domain DNS Records\nThe next step is to create a CNAME DNS record, on the public domain name,\npointing to the Load Balancer‚Äôs hostname, created during TraefikEE‚Äôs\ninstallation.\n\nGet the load balancer‚Äôs public hostname with the following command (field\nEXTERNAL-IP):\n\n$ kubectl get svc -n traefikee traefikee-lb\nNAME          TYPE         EXTERNAL-IP\ntraefikee-lb  LoadBalancer a16ff-456.us-east-1.elb.amazonaws.com\n\nThen, create the DNS CNAME record to this hostname (choose a short TTL):\n\nIN  CNAME  demo.containo.us a16ff-456.us-east-1.elb.amazonaws.com\n\nThe DNS propagation takes some time, due to the ‚ÄúTTL‚Äù. Verify that your computer\ncan resolve the DNS name with tools asdig , drillor nslookup :\n\n$ dig CNAME demo.containo.us\n...\n;; QUESTION SECTION:\n;demo.containo.us.       IN      CNAME\n\n;; ANSWER SECTION:\ndemo.containo.us. 60     IN      CNAME   a16ff-456.us-east-1.elb.amazonaws.com.\n\n;; Query time: 38 msec\n;; SERVER: 212.224.255.252#53(212.224.255.252)\n;; WHEN: Wed Feb 06 11:21:25 CET 2019\n;; MSG SIZE  rcvd: 136\n\nConfigure TraefikEE for HTTPS\nThen, we configure TraefikEE to enable HTTPS and Let‚Äôs Encrypt for certificate\non HTTPS. The configuration is the same as Traefik‚Äôs (check Traefik's\ndocumentation [https://docs.traefik.io] for more details):\n\n### Configure 2 entrypoints for https and https\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  \n### Enable ACME protocol for the HTTPS entry point\n  --acme.entryPoint=https \\\n  \n### Set up ACME protocol for Let's Encrypt TLS-APLN-01 Challenge\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  \n### Tell Traefik to get certificate's hostname from backend's rules\n  --acme.onHostRule=true\n\n> (A voice in the background): When using Traefik with Let‚Äôs Encrypt, I often get\ncertificates requests failures because of the rate limit on Let‚Äôs Encrypt side\n[https://letsencrypt.org/docs/rate-limits/].\n> Containous: Traefik allows to test your HTTPS configuration with the ‚Äústaging‚Äù\nenvironment [https://letsencrypt.org/docs/staging-environment/], without rate\nlimiting, but with untrusted certificates . It‚Äôs useful to validate\nconfiguration before switching to ‚Äúproduction‚Äù certificates. Add the flag \n--acme.caServer='https://acme-staging-v02.api.letsencrypt.org/directory' to the\nconfiguration.\nBe careful! You cannot change the caServer unless you reinstall TraefikEE.\nThe main difference from using Traefik here, is that TraefikEE is a distributed\nsystem, so you need to specify the configuration after TraefikEE‚Äôs installation.\n\nThe traefikeectl tool provides a command named deploy to send any routing\nconfiguration to the TraefikEE cluster. You can read more on this topic on the \nreference documentation for routing configurations [https://docs.containo.us].\n\nNow, let‚Äôs deploy the following configuration to the TraefikEE cluster and\nthat‚Äôs all!\n\ntraefikeectl deploy --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true\n\n> (A voice in the background): Why is there a ‚Äî-kubernetes flag in this\nconfiguration?\n> Containous: This flag tells TraefikEE to watch for any Kubernetes Ingress. It‚Äôs\nthe same directive as the one in Traefik.\nDeploy an Application\nAs we previously did on the post, ‚ÄúA Tour of TraefikEE‚Äù, we deploy a test\napplication based on https://github.com/containous/whoami.\n\nYou can reuse the same YAML file, but you have to change the directive host in\nthe ingress, and map it to your public domain name. I‚Äôm using the following\none-line shell command for this:\n\n$ curl --location --silent --show-error https://bit.ly/2WE5XFk \\\n  | sed 's/localhost/demo.damienduportal.org/g' \\\n  | kubectl apply -f -\n\ndeployment.extensions/whoami created\ningress.extensions/whoami created\nservice/whoami created\n\nYou can check that Kubernetes is using the right domain name by checking the\ningress ‚Äúwhoami‚Äù:\n\n$ kubectl get ingress whoami --namespace=traefikee\nNAME     HOSTS                     ADDRESS   PORTS   AGE\nwhoami   demo.damienduportal.org             80      9m\n\nThe page https://demo.damienduportal.org/whoami is now, (after a few seconds,\nrequired for issuing certificates), securely served over HTTPS, with a valid\ncertificate, issued by Let‚Äôs Encrypt:\n\nGreen Lock for Everyone> If you try to access\nhttp://demo.damienduportal.org/whoami, then you are redirected to\nhttps://demo.damienduportal.org/whoami as expected.\nThat‚Äôs all for today, you are ready to use HTTPS on your applications!\nYou can now clean your kops cluster with:\n\nkops delete cluster --name=\"${NAME}\"\n\n\n--------------------------------------------------------------------------------\n\nOn the next post, ‚ÄúThe Journey to Traefik Enterprise Edition: Smooth\nOperations,‚Äù we‚Äôll focus on how to configure and operate TraefikEE remotely with\nthe traefikeectl command line.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-8.png\" class=\"kg-image\"></figure><p>Welcome to the fourth step of our journey towards <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition</a>.</p><p>Before jumping in, you should check the previous posts:</p><ul><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/\">Join the‚ÄúEarly Access‚Äù Program</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">Product Evaluation</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">High Availability</a></em></em></li></ul><p>Today, we‚Äôll focus on how to use TraefikEE with Let‚Äôs Encrypt to get HTTPS by default, for your application.</p><h2 id=\"create-a-kubernetes-cluster-with-kops\">Create a Kubernetes Cluster with kops</h2><p>Following the same steps as <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">the previous blog post (‚ÄúCreate a cluster with kops‚Äù)</a>, start a kops cluster with one Kubernetes manager and three Kubernetes nodes:</p><pre><code class=\"language-shell\">$ export NAME=traefikee-demo.containous.cloud\n$ export KOPS_STATE_STORE=s3://&lt;YOUR BUCKET&gt;\n$ export ROUTE53_ZONE_ID=&lt;ROUTE53_ZONE_ID&gt;\n$ export NB_MASTER_NODE=1\n$ export NB_WORKER_NODE=3\n\n$ kops create cluster \\\n    --zones us-east-1a \\\n    --dns-zone=\"${ROUTE53_ZONE_ID}\" \\\n    --node-size=\"t2.large\" \\\n    --master-count=\"${NB_MASTER_NODE}\" \\\n    --node-count=\"${NB_WORKER_NODE}\" \\\n    --yes \\\n    \"${NAME}\"</code></pre><p>After a few minutes, your cluster is started with four Kubernetes nodes:</p><pre><code class=\"language-shell\">$ kubectl get nodes\nNAME                            STATUS   ROLES    AGE   VERSION\nip-172-20-34-251.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-49-209.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-53-165.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-56-217.ec2.internal   Ready    master   3m    v1.11.6</code></pre><h2 id=\"pick-a-public-domain-name\">Pick a Public Domain Name</h2><p>In the previous blog post, we used <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">a domain name generated by Amazon Web Services</a> as the main entry point to reach our platform.</p><p>You cannot use this ‚Äúgenerated‚Äù public hostname, because Let‚Äôs Encrypt has a ‚Äúforbidden domains list.‚Äù Some domains are considered too risky, and any request for issuing certificates under these domains is automatically refused. <a href=\"https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2\" rel=\"noopener\">It‚Äôs the case with domains in </a><code><a href=\"https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2\" rel=\"noopener\">*.amazonaws.com</a>.</code></p><p>To solve this challenge, let‚Äôs pick a custom public domain name. Any domain or sub-domain (like <code>test.company.org</code> ) can be used. You have to be able to create DNS records of type <code>CNAME</code> on this domain.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I don‚Äôt want to pay for a domain used for evaluating a product. Maybe later if it goes further, but not now.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> You can get free DNS using <a href=\"http://www.dot.tk/en/index.html?lang=en\" rel=\"noopener\">Dot-T-K</a>, or even cheap ones using <a href=\"https://www.namecheap.com/\" rel=\"noopener\">NameCheap</a>.</em></em></blockquote><p>For the next steps, we‚Äôll pick the domain <code>demo.containo.us</code> .</p><h2 id=\"install-traefikee\">Install TraefikEE</h2><p>Then, install a simple TraefikEE cluster, without dashboard, as we did on <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">the previous blog post</a>:</p><pre><code class=\"language-shell\">$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/‚Ä¶/traefikee-license)\" \\\n  --kubernetes\n...\n\n‚úî Installation successful</code></pre><p>Once the installation succeeded, verify that the TraefikEE cluster is composed of six nodes, three control nodes and three data nodes, as expected:</p><pre><code class=\"language-shell\">$ traefikeectl list-nodes\n...\nName                                 Role\n----                                 ----\ntraefikee-control-node-0             CONTROL NODE\ndata-node-traefikee-data-node-9ndbp  DATA NODE\ndata-node-traefikee-data-node-vqgzr  DATA NODE\ntraefikee-control-node-1             CONTROL NODE\ntraefikee-control-node-2             CONTROL NODE (Current Leader)\ndata-node-traefikee-data-node-5w66x  DATA NODE</code></pre><h2 id=\"configure-the-domain-dns-records\">Configure the Domain DNS Records</h2><p>The next step is to create a <code>CNAME</code> DNS record, on the public domain name, pointing to the Load Balancer‚Äôs hostname, created during TraefikEE‚Äôs installation.</p><p>Get the load balancer‚Äôs public hostname with the following command (field EXTERNAL-IP):</p><pre><code class=\"language-shell\">$ kubectl get svc -n traefikee traefikee-lb\nNAME          TYPE         EXTERNAL-IP\ntraefikee-lb  LoadBalancer a16ff-456.us-east-1.elb.amazonaws.com</code></pre><p>Then, create the DNS CNAME record to this hostname (choose a short TTL):</p><pre><code class=\"language-shell\">IN  CNAME  demo.containo.us a16ff-456.us-east-1.elb.amazonaws.com</code></pre><p>The DNS propagation takes some time, due to the ‚ÄúTTL‚Äù. Verify that your computer can resolve the DNS name with tools as<code>dig</code> , <code>drill</code>or <code>nslookup</code> :</p><pre><code class=\"language-shell\">$ dig CNAME demo.containo.us\n...\n;; QUESTION SECTION:\n;demo.containo.us.       IN      CNAME\n\n;; ANSWER SECTION:\ndemo.containo.us. 60     IN      CNAME   a16ff-456.us-east-1.elb.amazonaws.com.\n\n;; Query time: 38 msec\n;; SERVER: 212.224.255.252#53(212.224.255.252)\n;; WHEN: Wed Feb 06 11:21:25 CET 2019\n;; MSG SIZE  rcvd: 136</code></pre><h2 id=\"configure-traefikee-for-https\">Configure TraefikEE for HTTPS</h2><p>Then, we configure TraefikEE to enable HTTPS and Let‚Äôs Encrypt for certificate on HTTPS. The configuration is the same as Traefik‚Äôs (check <a href=\"https://docs.traefik.io\">Traefik's documentation</a> for more details):</p><pre><code class=\"language-shell\">### Configure 2 entrypoints for https and https\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  \n### Enable ACME protocol for the HTTPS entry point\n  --acme.entryPoint=https \\\n  \n### Set up ACME protocol for Let's Encrypt TLS-APLN-01 Challenge\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  \n### Tell Traefik to get certificate's hostname from backend's rules\n  --acme.onHostRule=true</code></pre><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> When using Traefik with Let‚Äôs Encrypt, I often get certificates requests failures because of <a href=\"https://letsencrypt.org/docs/rate-limits/\" rel=\"noopener\">the rate limit on Let‚Äôs Encrypt side</a>.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Traefik allows to test your HTTPS configuration with <a href=\"https://letsencrypt.org/docs/staging-environment/\" rel=\"noopener\">the ‚Äústaging‚Äù environment</a>, without rate limiting, but with untrusted certificates . It‚Äôs useful to validate configuration before switching to ‚Äúproduction‚Äù certificates. Add the flag <code>--acme.caServer='https://acme-staging-v02.api.letsencrypt.org/directory<em>'</em></code><em> to the configuration.</em></em></em><br><em><em><em>Be careful! You cannot change the caServer unless you reinstall TraefikEE.</em></em></em></blockquote><p>The main difference from using Traefik here, is that TraefikEE is a distributed system, so you need to specify the configuration <strong><strong>after</strong></strong> TraefikEE‚Äôs installation.</p><p>The <code>traefikeectl</code> tool provides a command named <code>deploy</code> to send any routing configuration to the TraefikEE cluster. You can read more on this topic on the <a href=\"https://docs.containo.us\">reference documentation for routing configurations</a>.</p><p>Now, let‚Äôs deploy the following configuration to the TraefikEE cluster and that‚Äôs all!</p><pre><code class=\"language-shell\">traefikeectl deploy --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true</code></pre><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Why is there a <code>‚Äî-kubernetes</code> flag in this configuration?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> This flag tells TraefikEE to watch for any Kubernetes Ingress. It‚Äôs the same directive as the one in Traefik.</em></em></blockquote><h2 id=\"deploy-an-application\">Deploy an Application</h2><p>As we previously did on the post, ‚ÄúA Tour of TraefikEE‚Äù, we deploy a test application based on <a href=\"https://github.com/containous/whoami\" rel=\"noopener\">https://github.com/containous/whoami</a>.</p><p>You can reuse the same YAML file, but you have to change the directive <code>host</code> in the ingress, and map it to your public domain name. I‚Äôm using the following one-line shell command for this:</p><pre><code class=\"language-shell\">$ curl --location --silent --show-error https://bit.ly/2WE5XFk \\\n  | sed 's/localhost/demo.damienduportal.org/g' \\\n  | kubectl apply -f -\n\ndeployment.extensions/whoami created\ningress.extensions/whoami created\nservice/whoami created</code></pre><p>You can check that Kubernetes is using the right domain name by checking the ingress ‚Äúwhoami‚Äù:</p><pre><code class=\"language-shell\">$ kubectl get ingress whoami --namespace=traefikee\nNAME     HOSTS                     ADDRESS   PORTS   AGE\nwhoami   demo.damienduportal.org             80      9m</code></pre><p>The page https://demo.damienduportal.org/whoami is now, (after a few seconds, required for issuing certificates), securely served over HTTPS, with a valid certificate, issued by Let‚Äôs Encrypt:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-39.png\" class=\"kg-image\"><figcaption>Green Lock for Everyone</figcaption></figure><blockquote><em><em>If you try to access http://demo.damienduportal.org/whoami, then you are redirected to https://demo.damienduportal.org/whoami as expected.</em></em></blockquote><p>That‚Äôs all for today, you are ready to use HTTPS on your applications!<br>You can now clean your kops cluster with:</p><pre><code class=\"language-shell\">kops delete cluster --name=\"${NAME}\"</code></pre><hr><p>On the next post, ‚ÄúThe Journey to Traefik Enterprise Edition: Smooth Operations,‚Äù we‚Äôll focus on how to configure and operate TraefikEE remotely with the <code>traefikeectl</code> command line.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/","canonical_url":null,"uuid":"f89e17d3-fb94-408b-a240-ff3f036d382b","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7bc8af1db6f0038c742d5","reading_time":5}},{"node":{"id":"Ghost__Post__5dd7badbf1db6f0038c74299","title":"The Journey to Traefik Enterprise Edition: Smooth Operations","slug":"the-journey-to-traefik-enterprise-edition-smooth-operations-2591bb7ff1fe","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/smooth-ops.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/3e8dd3b9ae78318437039481a8ed57fb/f3583/smooth-ops.png","srcSet":"/static/3e8dd3b9ae78318437039481a8ed57fb/630fb/smooth-ops.png 300w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/2a4de/smooth-ops.png 600w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/f3583/smooth-ops.png 1200w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/bbee5/smooth-ops.png 1800w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/7b560/smooth-ops.png 1931w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Welcome to the fifth step of our journey towards Traefik Enterprise Edition.\nThis post focuses on the experience of operating TraefikEE...","custom_excerpt":"Welcome to the fifth step of our journey towards Traefik Enterprise Edition.\nThis post focuses on the experience of operating TraefikEE...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"March 18, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T10:39:23.000+00:00","published_at":"2019-03-18T10:39:00.000+00:00","updated_at":"2020-05-21T23:40:43.000+00:00","meta_title":"The Journey to Traefik Enterprise Edition: Smooth Operations","meta_description":"Welcome to the fifth step of our journey towards Traefik Enterprise Edition.\nThis post focuses on the experience of operating TraefikEE...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the fifth step of our journey towards Traefik Enterprise Edition\n[/traefikee/].\n\nThis post focuses on the experience of operating TraefikEE using the \ntraefikeectl command line. You should already feel at ease with TraefikEE‚Äôs\none-line installation and concepts. If you are not, then you can check the\nprevious posts of the ‚ÄúJourney to TraefikEE:‚Äù\n\n * Join the‚ÄúEarly Access‚Äù Program\n   [/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/]\n * Product Evaluation\n   [/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/]\n * High Availability\n   [/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n * HTTPS for Everyone\n   [/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/]\n\nToday, we‚Äôll focus on traefikeectl, the command-line tool used to install,\nconfigure and operate all your TraefikEE installations, in a lean and repeatable\nway, independently of your platform.\n\nOne Command-Line to Rule Them All\n> (A voice in the background): I used Traefik because it‚Äôs really simple to use.\nI‚Äôm interested by TraefikEE for its high availability features. But distributed\nsystems are really hard. How to deal with this intrinsic complexity?\n> Containous: Let us introduce traefikeectl (also known as ‚ÄúTraefikEE-cuddle‚Äù),\nthe command-line tool which abstracts most of this complexity.\nTraefikEE is designed from the ground up to be platform agnostic. From\ninstallation to any operation, the workflow is the same on each platform.\n\nAll the operations are managed by the command line traefikeectl following this\nworkflow, whichever platform you are using:\n\n * Install Phase: Installs a TraefikEE cluster (with traefikeectl install or\n   manually),\n * Connect Phase: Make your local traefikeectl aware of an existing TraefikEE\n   cluster allowing multi-cluster management,\n * Deploy Phase: Deploy a ‚Äúrouting configuration‚Äù to this TraefikEE instance.\n\nInstall Phase\nPlatform-Specific\nDo you remember the ‚ÄúOne Line Installation for Kubernetes‚Äù\n[/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/] \nfrom previous posts (and the related documentation [https://docs.containo.us])?\n\ntraefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n  # ...\n\nWhat if you want to install on a Docker Swarm cluster instead?\n\nWell, the answer is to use the flag ‚Äî-swarm instead of --kubernetes , as\ndescribed on the ‚ÄúOne Line Installation guide for Swarm‚Äù:\n\ntraefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --swarm\n  # ...\n\nEach ‚Äúagnostic‚Äù feature is then provided by the commandtraefikeectl when\nrequired, as --kubernetes.namespace or --swarm.networkname .\n\nCustomize Installation\nWe‚Äôll now dig on how to customize installation for Kubernetes.\n\n> (A voice in the background): We are not able to use traefikeectl for\ninstallation in our Kubernetes cluster, because the default configuration does\nnot fit our needs.\n> Containous: The install command of traefikeectl allows you to customize\ninstallation. With Kubernetes, you can provide a YAML file to specify custom\nvalues.\nFollowing the reference values from the documentation, let‚Äôs consider that you\nwant to specify the following elements during the installation:\n\n * A custom URL for accessing the dashboard, as \n   http(s)://private.mycompany.org/traefikee,\n * Limiting the resources used for each node to 2Gb of memory and 2 CPUs (See\n   the article ‚ÄúManaging Compute Resources for Containers\n   [https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/]\n   ‚Äù Kubernetes Documentation for reference).\n\nBefore installation, create the following YAML file to specify these values:\n\n## File \"traefikee-values.yaml\"\n\n# Expose dashboard at http(s)://private.mycompany.org/traefikee\ndashboard:\n  host: \"private.mycompany.org\"\n  path: \"/traefikee\"\n\n# Restrict resources usage for each TraefikEE node\nresources:\n  cpus: \"2\"\n  memory: \"2G\"\n\nYou can now proceed to the ‚ÄúOne Line Installation‚Äù, by adding the flag \n--kubernetes.helmvaluespath to use the YAML value file:\n\ntraefikeectl install --kubernetes \\\n  --licensekey=XXXXXXX \\\n  --dashboard \\\n  --kubernetes.helmvaluespath=./traefikee-values.yaml\n\nAs no one is perfect, traefikeectl might not provide some specific settings\nrequired for your platform to work correctly. In this case, you still can ‚Äúpatch\n[https://kubernetes.io/docs/reference/kubectl/cheatsheet/#patching-resources]‚Äù , \n‚Äúedit‚Äù\n[https://kubernetes.io/docs/reference/kubectl/cheatsheet/#editing-resources] or\neven ‚Äúannotate‚Äù\n[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#annotate] \nthe Kubernetes resources created by traefikee install.\n\nConnect Phase\nThe next step is to ensure that your traefikeectl command has knowledge of the\ncluster you want to operate.\n\n> Please note that this step is not required if you used a ‚ÄúOne Line Installation‚Äù\nwith traefikeectl install, as it is automatically done.\nThe scenario is the following:\n\n * A TraefikEE cluster, designated astraefikee-staging, is running on your\n   remote Kubernetes platform, in the namespace traefikee-ingress,\n * You want to set up an administration machine (your computer, a freshly\n   onboarded team member, etc.) to operate this cluster,\n * This machine is already configured to reach the Kubernetes cluster.\n\nThe connect phase is easy:\n\ntraefikeectl connect --clustername=traefikee-staging \\\n  --kubernetes \\\n  --kubernetes.namespace=traefikee-ingress\n\nThat‚Äôs all: traefikeectl is now aware of this cluster and can operate it:\n\n\ntraefikeectl list-nodes\n\ntraefikeectl logs\n\n# ...\n\nUnder the hood, traefikeectl stored the cluster connection information in a TOML\nfile named after the cluster name. These files are located in ${TRAEFIKEE_HOME},\nwhich defaults to the directory ${HOME}/.config/traefikee (XDG_CONFIG folder\n[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html]).\n\n> Please note that if you do not provide the option --clustername , the default\nvalue traefikee is used.\nIt means that you can manage multiple TraefikEE clusters from the same \ntraefikeectl, so you are free to split per environment (staging/production, or\nevent external/internal, etc.).\n\nDeploy Phase\nThe last step of the workflow is to deploy a ‚Äúrouting configuration‚Äù.\n\n> (A voice in the background): We followed the previous blog post, and we were\nable to install TraefikEE on our platform. Now, we want to enable HTTPS and\nMetrics collection with Prometheus [https://prometheus.io/]. Do we have to\ninstall the cluster again to update the configuration as we did for Traefik?\n> Containous: Fortunately, you don‚Äôt have to reinstall the cluster. Unlike\nTraefik, TraefikEE lets you update the configuration at runtime.\nLet‚Äôs say that you want to set up TraefikEE with the following routing\nconfiguration:\n\n * Enable TLS termination on the port 443 (defining a new ‚Äúentrypoint‚Äù named \n   https),\n * Auto-generate TLS certificates using Let‚Äôs Encrypt for this new https \n   ‚Äúentrypoint‚Äù . The host names for these certificates are determined from the\n   backend applications (either Ingresses on Kubernetes or labels on Docker\n   Swarm),\n * Enable the Prometheus metric exporter,\n * Enable redirection from http to https for any incoming request.\n\nWith Traefik, you would have passed the following options (and restarted Traefik\nto apply the configuration):\n\n## Traefik Configuration References:\n# Entrypoints: https://docs.traefik.io/configuration/entrypoints/\n# Metrics: https://docs.traefik.io/configuration/metrics/\n# ACME/Let's Encrypt: https://docs.traefik.io/configuration/acme/\n\ntraefik --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true \\\n  --metrics.prometheus\n\nWith TraefikEE, the same configuration is passed to the traefikeectl deploy \ncommand. It‚Äôs sent to the TraefikEE control plane through the traefikeectl API,\nstored on the TraefikEE Control Plane and then applied to all the TraefikEE Data\nNodes (which are hot-reloaded).\n\ntraefikeectl deploy --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true \\\n  --metrics.prometheus\n\nIf you prefer using TOML file instead of command-line flags:\n\n# File \"traefik.toml\"\n\ndefaultEntryPoints = [\"https\",\"http\"]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \":80\"\n    [entryPoints.http.redirect]\n    entryPoint = \"https\"\n  [entryPoints.https]\n  address = \":443\"\n  [entryPoints.https.tls]\n\n[kubernetes]\n\n[acme]\nemail = \"damien@containo.us\"\nstorage = \"acme.json\"\nentryPoint = \"https\"\nonHostRule = true\n[acme.tlsChallenge]\n\ntraefikeectl deploy --configfile=./traefik.toml\n\n\n--------------------------------------------------------------------------------\n\nThat‚Äôs all for today: we installed a customized cluster, connected a remote\nmachine to operate with traefikeectl, and deployed the same configuration as the\none you could have used for Traefik, but without taking down the cluster, and\nwithout loosing any requests!\n\nYou can learn more about the traefikeectl command line on the reference\ndocumentation [https://docs.containo.us/installing/teectl-cli/].","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-7.png\" class=\"kg-image\"></figure><p>Welcome to the fifth step of our journey towards <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition</a>.</p><p>This post focuses on the experience of operating TraefikEE using the <code>traefikeectl</code> command line. You should already feel at ease with TraefikEE‚Äôs one-line installation and concepts. If you are not, then you can check the previous posts of the ‚ÄúJourney to TraefikEE:‚Äù</p><ul><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/\">Join the‚ÄúEarly Access‚Äù Program</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">Product Evaluation</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">High Availability</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/\">HTTPS for Everyone</a></em></em></li></ul><p>Today, we‚Äôll focus on <code>traefikeectl</code>, the command-line tool used to install, configure and operate all your TraefikEE installations, in a lean and repeatable way, independently of your platform.</p><h2 id=\"one-command-line-to-rule-them-all\">One Command-Line to Rule Them All</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-38.png\" class=\"kg-image\"></figure><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I used Traefik because it‚Äôs really simple to use. I‚Äôm interested by TraefikEE for its high availability features. But distributed systems are really hard. How to deal with this intrinsic complexity?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Let us introduce <code><em>traefikeectl</em></code> (also known as ‚ÄúTraefikEE-cuddle‚Äù), the command-line tool which abstracts most of this complexity.</em></em></blockquote><p>TraefikEE is designed from the ground up to be platform agnostic. From installation to any operation, the workflow is the same on each platform.</p><p>All the operations are managed by the command line <code>traefikeectl</code> following this workflow, whichever platform you are using:</p><ul><li><strong><strong>Install Phase:</strong></strong> Installs a TraefikEE cluster (with <code>traefikeectl install</code> or manually),</li><li><strong><strong>Connect Phase: </strong></strong>Make your local <code>traefikeectl</code> aware of an existing TraefikEE cluster allowing multi-cluster management,</li><li><strong><strong>Deploy Phase:</strong></strong> Deploy a ‚Äúrouting configuration‚Äù to this TraefikEE instance.</li></ul><h2 id=\"install-phase\">Install Phase</h2><h3 id=\"platform-specific\">Platform-Specific</h3><p>Do you remember the <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">‚ÄúOne Line Installation for Kubernetes‚Äù</a> from previous posts (and the <a href=\"https://docs.containo.us\">related documentation</a>)?</p><pre><code class=\"language-shell\">traefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n  # ...</code></pre><p>What if you want to install on a Docker Swarm cluster instead?</p><p>Well, the answer is to use the flag <code>‚Äî-swarm</code> instead of <code>--kubernetes</code> , as described on the ‚ÄúOne Line Installation guide for Swarm‚Äù:</p><pre><code class=\"language-shell\">traefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --swarm\n  # ...</code></pre><p>Each ‚Äúagnostic‚Äù feature is then provided by the command<code>traefikeectl</code> when required, as <code>--kubernetes.namespace</code> or <code>--swarm.networkname</code> .</p><h3 id=\"customize-installation\">Customize Installation</h3><p>We‚Äôll now dig on how to customize installation for Kubernetes.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> We are not able to use <code><em>traefikeectl</em></code> for installation in our Kubernetes cluster, because the default configuration does not fit our needs.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> The <code><em>install</em></code> command of <code><em>traefikeectl</em></code> allows you to customize installation. With Kubernetes, you can provide a YAML file to specify custom values.</em></em></blockquote><p>Following the reference values from the documentation, let‚Äôs consider that you want to specify the following elements during the installation:</p><ul><li>A custom URL for accessing the dashboard, as <code>http(s)://private.mycompany.org/traefikee</code>,</li><li>Limiting the resources used for each node to <code>2Gb</code> of memory and <code>2 CPUs</code> (See the article ‚Äú<a href=\"https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/\" rel=\"noopener\">Managing Compute Resources for Containers</a>‚Äù Kubernetes Documentation for reference).</li></ul><p>Before installation, create the following YAML file to specify these values:</p><pre><code class=\"language-yaml\">## File \"traefikee-values.yaml\"\n\n# Expose dashboard at http(s)://private.mycompany.org/traefikee\ndashboard:\n  host: \"private.mycompany.org\"\n  path: \"/traefikee\"\n\n# Restrict resources usage for each TraefikEE node\nresources:\n  cpus: \"2\"\n  memory: \"2G\"</code></pre><p>You can now proceed to the ‚ÄúOne Line Installation‚Äù, by adding the flag <code>--kubernetes.helmvaluespath</code> to use the YAML value file:</p><pre><code class=\"language-shell\">traefikeectl install --kubernetes \\\n  --licensekey=XXXXXXX \\\n  --dashboard \\\n  --kubernetes.helmvaluespath=./traefikee-values.yaml</code></pre><p>As no one is perfect, <code>traefikeectl</code> might not provide some specific settings required for your platform to work correctly. In this case, you still can ‚Äú<a href=\"https://kubernetes.io/docs/reference/kubectl/cheatsheet/#patching-resources\" rel=\"noopener\">patch</a>‚Äù , <a href=\"https://kubernetes.io/docs/reference/kubectl/cheatsheet/#editing-resources\" rel=\"noopener\">‚Äúedit‚Äù</a> or even <a href=\"https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#annotate\" rel=\"noopener\">‚Äúannotate‚Äù</a> the Kubernetes resources created by <code>traefikee install</code>.</p><h2 id=\"connect-phase\">Connect Phase</h2><p>The next step is to ensure that your <code>traefikeectl</code> command has knowledge of the cluster you want to operate.</p><blockquote><em><em>Please note that this step is not required if you used a ‚ÄúOne Line Installation‚Äù with <code>traefikeectl install</code>, as it is automatically done.</em></em></blockquote><p>The scenario is the following:</p><ul><li>A TraefikEE cluster, designated as<code>traefikee-staging</code>, is running on your remote Kubernetes platform, in the namespace <code>traefikee-ingress</code>,</li><li>You want to set up an administration machine (your computer, a freshly onboarded team member, etc.) to operate this cluster,</li><li>This machine is already configured to reach the Kubernetes cluster.</li></ul><p>The connect phase is easy:</p><pre><code class=\"language-shell\">traefikeectl connect --clustername=traefikee-staging \\\n  --kubernetes \\\n  --kubernetes.namespace=traefikee-ingress</code></pre><p>That‚Äôs all: <code>traefikeectl</code> is now aware of this cluster and can operate it:</p><pre><code class=\"language-shell\">\ntraefikeectl list-nodes\n\ntraefikeectl logs\n\n# ...</code></pre><p>Under the hood, <code>traefikeectl</code> stored the cluster connection information in a TOML file named after the cluster name. These files are located in <code>${TRAEFIKEE_HOME}</code>, which defaults to the directory <code>${HOME}/.config/traefikee</code> (<a href=\"https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\" rel=\"noopener\">XDG_CONFIG folder</a>).</p><blockquote><em><em>Please note that if you do not provide the option <code>--clustername</code> , the default value <code>traefikee</code> is used.</em></em></blockquote><p>It means that you can manage multiple TraefikEE clusters from the same <code>traefikeectl</code>, so you are free to split per environment (staging/production, or event external/internal, etc.).</p><h2 id=\"deploy-phase\">Deploy Phase</h2><p>The last step of the workflow is to deploy a ‚Äúrouting configuration‚Äù.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> We followed the previous blog post, and we were able to install TraefikEE on our platform. Now, we want to enable HTTPS and Metrics collection with <a href=\"https://prometheus.io/\" rel=\"noopener\">Prometheus</a>. Do we have to install the cluster again to update the configuration as we did for Traefik?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Fortunately, you don‚Äôt have to reinstall the cluster. Unlike Traefik, TraefikEE lets you update the configuration at runtime.</em></em></blockquote><p>Let‚Äôs say that you want to set up TraefikEE with the following routing configuration:</p><ul><li>Enable TLS termination on the port 443 (defining a new ‚Äúentrypoint‚Äù named <code>https</code>),</li><li>Auto-generate TLS certificates using Let‚Äôs Encrypt for this new <code>https</code> ‚Äúentrypoint‚Äù . The host names for these certificates are determined from the backend applications (either Ingresses on Kubernetes or labels on Docker Swarm),</li><li>Enable the Prometheus metric exporter,</li><li>Enable redirection from <code>http</code> to <code>https</code> for any incoming request.</li></ul><p>With Traefik, you would have passed the following options (and restarted Traefik to apply the configuration):</p><pre><code class=\"language-shell\">## Traefik Configuration References:\n# Entrypoints: https://docs.traefik.io/configuration/entrypoints/\n# Metrics: https://docs.traefik.io/configuration/metrics/\n# ACME/Let's Encrypt: https://docs.traefik.io/configuration/acme/\n\ntraefik --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true \\\n  --metrics.prometheus</code></pre><p>With TraefikEE, the same configuration is passed to the <code>traefikeectl deploy</code> command. It‚Äôs sent to the TraefikEE control plane through the traefikeectl API, stored on the TraefikEE Control Plane and then applied to <strong><strong>all</strong></strong> the TraefikEE Data Nodes (which are hot-reloaded).</p><pre><code class=\"language-shell\">traefikeectl deploy --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true \\\n  --metrics.prometheus</code></pre><p>If you prefer using TOML file instead of command-line flags:</p><pre><code class=\"language-toml\"># File \"traefik.toml\"\n\ndefaultEntryPoints = [\"https\",\"http\"]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \":80\"\n    [entryPoints.http.redirect]\n    entryPoint = \"https\"\n  [entryPoints.https]\n  address = \":443\"\n  [entryPoints.https.tls]\n\n[kubernetes]\n\n[acme]\nemail = \"damien@containo.us\"\nstorage = \"acme.json\"\nentryPoint = \"https\"\nonHostRule = true\n[acme.tlsChallenge]</code></pre><pre><code class=\"language-shell\">traefikeectl deploy --configfile=./traefik.toml</code></pre><hr><p>That‚Äôs all for today: we installed a customized cluster, connected a remote machine to operate with <code>traefikeectl</code>, and deployed the same configuration as the one you could have used for Traefik, but without taking down the cluster, and without loosing any requests!</p><p>You can learn more about the <code>traefikeectl</code> command line on <a href=\"https://docs.containo.us/installing/teectl-cli/\">the reference documentation</a>.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-smooth-operations-2591bb7ff1fe/","canonical_url":null,"uuid":"34907a2a-bbdd-4139-84dd-26a5ca4ad805","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7badbf1db6f0038c74299","reading_time":5}},{"node":{"id":"Ghost__Post__5dd6b3d9b6de2b00381d405f","title":"Back to Traefik 2.0","slug":"back-to-traefik-2-0-2f9aa17be305","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/back-traefik-2.0.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/eab1b698154eba0f1712590325d76538/f3583/back-traefik-2.0.png","srcSet":"/static/eab1b698154eba0f1712590325d76538/630fb/back-traefik-2.0.png 300w,\n/static/eab1b698154eba0f1712590325d76538/2a4de/back-traefik-2.0.png 600w,\n/static/eab1b698154eba0f1712590325d76538/f3583/back-traefik-2.0.png 1200w,\n/static/eab1b698154eba0f1712590325d76538/bbee5/back-traefik-2.0.png 1800w,\n/static/eab1b698154eba0f1712590325d76538/ed396/back-traefik-2.0.png 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Today, we‚Äôre announcing Traefik 2.0 alpha, the edge router built with the future in mind.\nThe new core is here, help us finalize...","custom_excerpt":"Today, we‚Äôre announcing Traefik 2.0 alpha, the edge router built with the future in mind.\nThe new core is here, help us finalize...","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"March 19, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-21T15:57:13.000+00:00","published_at":"2019-03-19T15:57:00.000+00:00","updated_at":"2020-05-22T00:04:04.000+00:00","meta_title":"Back to Traefik 2.0","meta_description":"Today, we‚Äôre announcing Traefik 2.0 alpha, the edge router built with the future in mind.\nThe new core is here, help us finalize...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Gigawatts of Routing Power\n\nBack in 2015, a revolution was under way. We were moving from manual,\nhandcrafted infrastructures, to container-based, industrial, and human-free\nplatforms. In those dark ages of orchestration, edge traffic was remarkably\ndifficult to manage. On one side, we had traditional reverse-proxies that were\nbuilt for static infrastructures, on the other side, we were building dynamic\nclusters made to deploy and manage thousands of microservices. The idea of\nhaving a simple and automatic edge router, all in one binary, was appealing, but\nalso idealistic. The foundation of Traefik [/traefik/] was laid that year,\npaving the way to building a project with strong values: simplicity of\nconfiguration, modern features, and open to the community. A few years later,\nthe project has reached 21k stars on Github\n[https://github.com/containous/traefik], and more than 600 millions downloads. \nInsane.\n\nSince then, the ecosystem around containers has changed a lot: Docker has become\na de-facto standard, and Kubernetes has shown itself to be the clear winner in\nthe battle for the best orchestration platform. Because of this, the CNCF\nlandscape [https://landscape.cncf.io/] has exploded, with hundreds of components\nto choose from.\n\n> The time has come to work on something new for Traefik.\nFor several months, the maintainer team has been working on a deep refactoring\nof the codebase to provide the firm foundations for the next iteration of\nTraefik, and we are ready to share this vision with you.\n\nToday, we‚Äôre announcing Traefik 2.0 alpha, the edge router built with the future\nin mind.\n\nThe new core is here, help us finalize Traefik with the features you want!\n\n\n--------------------------------------------------------------------------------\n\nWe Want Features!\nLet‚Äôs see what we have in store.\n\nVocabulary Clarification\nNot a feature per se, but we still wanted to make it easier for newcomers to\nunderstand the core concepts at work in Traefik. We wanted every word to have a\nclear and unique meaning throughout the code and documentation.\n\nWelcome providers, entrypoints, routers, middleware, and services.\n\n * Providers are the cluster technologies you already use (Kubernetes, Docker,\n   Consul, Mesos, Rancher‚Ä¶). Traefik uses your provider‚Äôs API to discover the\n   routes to your services.\n * Entrypoints, in their most basic forms, are the open ports where requests\n   will land.\n * Services represent the software hosted on your infrastructure. Traefik knows\n   how to deal with multiple instances of your programs (currently supporting\n   multiple load balancing capabilities), and use the services configuration to\n   determine how to reach the actual program.\n * Routers connect incoming requests to your services. They hold the rules that\n   decide which service handles the request.\n * Finally, pieces of middleware [https://docs.traefik.io/middlewares/overview/] \n    are components that may update the request before it is handled by a\n   service. Out of the box, Traefik comes with middleware to manage\n   authentication, rate limiting, circuit breaker, whitelisting, buffering, and\n   so on.\n\nConfiguration Structure\nDespite our best efforts, and because so many features have been added to\nTraefik since its first launch, we needed to polish things up and make sure\nevery configuration option belonged in its place.\n\nHere, it was a menial job that needed to be done, and we‚Äôll spare you the\ndetails.\n\nLet Us Be Clear ‚Ä¶ We Want ACTUAL Features!\nSo, let‚Äôs remove the mystery, since we‚Äôve teased you enough. Here are the\nfeatures we‚Äôve added!\n\nTCP Support!\nThat‚Äôs right! It‚Äôs time to say goodbye to Issue #10\n[https://github.com/containous/traefik/issues/10]!\n\nYes, three years later, after a lot of work\n[https://github.com/containous/traefik/pull/4587] (as foretold\n[https://github.com/containous/traefik/issues/10#issuecomment-142835077]), and a\nlot of discussions, Traefik now fully supports the TCP protocol\n[https://docs.traefik.io/routing/routers/#configuring-tcp-routers].\n\nWant to see an example? Let‚Äôs use the File Provider, and redirect every request\non port27010 to your database service!\n\n[entrypoints]\n   [entrypoints.web]\n      address = \":80\"\n\n[entrypoints.mongo-port]\n      address = \":27017\"\n\n[tcp] # YAY!\n   [tcp.routers]\n      [tcp.routers.everything-to-mongo]\n         entrypoints = [\"mongo-port\"]\n         rule = \"HostSNI(`*`)\" # Catches every request       \n         service = \"database\"\n\nThe best part? Traefik supports routing based on SNIs\n[https://en.wikipedia.org/wiki/Server_Name_Indication]!\n\n[entrypoints]\n   [entrypoints.web]\n      address = \":80\"\n\n[entrypoints.mongo-port]\n      address = \":27017\"\n\n[tcp] # YAY!\n   [tcp.routers]\n      [tcp.routers.to-db-1]\n         entrypoints = [\"mongo-port\"]\n         rule = \"HostSNI(`db-1.domain`)\"       \n         service = \"db-1\"\n         [tcp.routers.to-db-1.tls] # The route is for TLS requests only\n      \n      [tcp.routers.to-db-2]\n         entrypoints = [\"mongo-port\"]\n         rule = \"HostSNI(`db-2.domain`)\"       \n         service = \"db-2\"\n         [tcp.routers.to-db-2.tls] # The route is for TLS requests only\n\nWhat‚Äôs even better? Traefik can go crazy, and support both HTTP and TCP on the \nsame port.\n\n> Yes, multiple protocols on the same entrypoint!\n[entrypoints]\n   [entrypoints.the-one]\n      address = \":443\"\n\n[tcp]\n   [tcp.routers]\n      [tcp.routers.to-db-1]\n         rule = \"HostSNI(`db-1.domain`)\"       \n         service = \"db-1\"\n         [tcp.routers.to-db-1.tls] # The route is for TLS requests only\n\n[http]\n   [http.routers]\n      [http.routers.my-api]\n         rule = \"Host(`api.domain`)\"       \n         service = \"my-api\"\n\nIn its first alpha version, Traefik only enables TCP routes in the File\nProvider, but stay tuned because it will (very) soon be available for other\nproviders!\n\nMiddleware to Update the Requests\nMany features used to be magically embedded in Traefik, with room for\ncustomization but no option for fine-tuning.\n\nMiddlewares fill the gap and give you the possibility to enable/configure any\nfeature you‚Äôd like, per router if you wish.\n\nMiddlewares are components that act on the request before it is actually\nforwarded to the services, and can even decide to not forward the request if a\nrequired condition isn‚Äôt met.\n\nAt release, Traefik comes with the following middlewares: AddPrefix\n[https://docs.traefik.io/middlewares/addprefix/] (to add a prefix to the request\npath), BasicAuth [https://docs.traefik.io/middlewares/basicauth/] & DigestAuth\n[https://docs.traefik.io/middlewares/digestauth/], ForwardAuth\n[https://docs.traefik.io/middlewares/forwardauth/] (to delegate authentication\nto a third-party service), Buffering\n[https://docs.traefik.io/middlewares/buffering/], Chain\n[https://docs.traefik.io/middlewares/chain/] (to define reusable sets of\nmiddlewares), CircuitBreaker\n[https://docs.traefik.io/middlewares/circuitbreaker/] (to avoid calling broken\nservices), Compress [https://docs.traefik.io/middlewares/compress/], Errors\n[https://docs.traefik.io/middlewares/errorpages/] (to provide custom error\npages), Headers [https://docs.traefik.io/middlewares/headers/], IpWhitelist\n[https://docs.traefik.io/middlewares/ipwhitelist/], MaxConn (to limit the number\nof simultaneous connections to a service), PassTLSClientCert\n[https://docs.traefik.io/middlewares/passtlsclientcert/], RateLimit\n[https://docs.traefik.io/middlewares/ratelimit/] (to limit the number of\nrequests to a service within a given period of time), RedirectRegex\n[https://docs.traefik.io/middlewares/redirectregex/] and RedirectScheme\n[https://docs.traefik.io/middlewares/redirectscheme/], and ReplacePath\n[https://docs.traefik.io/middlewares/replacepath/] (to update the query path\nbefore forwarding it to the service).\n\nAnd more importantly, we‚Äôve re-architectured the code to make it easier to\nprovide additional middlewares in the near future.\n\nKubernetes & CRD\nIn the past two years, the community has been discussing (a lot) around ‚Äúbetter\ningress,‚Äù and looking at our previous Kubernetes provider, we agreed that there\nwas room for improvement. With v2, it became obvious that if we wanted to let\nour Kubernetes fans benefit from every feature (like TCP and middleware) without\nbeing swarmed by a clutter of annotations, we had to propose an alternative.\n\nAmong the alternatives, CRD\n[https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/]\ns are more and more popular since they solve shortcomings of the ingress\nspecification. Inspired by what Heptio did in Contour with IngressRoute, we\nextended the specification to implement every Traefik feature.\n\nWe firmly believe that a consensus can emerge from those proposals and lead to\nthe next Ingress specification in Kubernetes.\n\nBelow is an example of this specification.\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.crd\n  namespace: default\nspec:\n  entrypoints:\n    - web\n    - web-secure\n  routes:\n    - match: Host(`traefik.io`) && PathPrefix(`/foo`)\n      kind: Rule\n      services:\n        - name: whoami1\n          port: 80\n          strategy: RoundRobin\n      middlewares:\n        - name: stripprefix\n        - name: addprefix\n          namespace: foo\n    - match: Host(`containo.us`) && Method(`POST`)\n      kind: Rule\n      services:\n        - name: whoami2\n          port: 80\n  tls:\n    secretName: supersecret\n\nNew Expressive Routing Rule Syntax\nTraefik now supports an expressive syntax to define the router rules, with and, \nor, and parenthesis!\n\nThe available matchers [https://docs.traefik.io/routing/routers/#rule] being \nHeaders, HeadersRegexp, Host, HostRegexp, Method, Path, PathPrefix, and Query.\n\nSince TCP is a whole different world, for now, it only supports a dedicated\nmatcher: HostSNI.\n\nWant to see examples?\n\nrule = (Host(`api.domain`) && PathPrefix(`/v2`)) \n  || Host(`api-v2.domain`)\n\nrule = (Method(`DELETE`) || (Method(`POST`) \n  && Query(`action`, `delete`))) && Host('api.domain')\n\nCross-Provider Support\nTraefik has always been compatible with multiple providers, which is one of its\ngreater strengths: whatever your infrastructure is, from bare metal to\norchestrators and clusters, Traefik just works!\n\nBut with v2, we‚Äôve gone a little further and allowed users to declare elements\n(middlewares, services, routers) in a provider, and to use them from a different\none.\n\nLet‚Äôs take a look at the following example, that declares an authentication\nmiddleware in a configuration file (the File Provider), which is being used from\na Docker label (the Docker Provider).\n\n# somewhere in a configuration file for the file provider\n[http.middlewares.my-users.basicauth]\n   users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \n            \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"]\n\n\n--------------------------------------------------------------------------------\n\n# somewhere in a docker compose file\n\nyour-container:\n    image: your-docker-image\n    \n    labels:\n      - \"traefik.http.routers.my-router.middlewares=file.my-users\"\n\nAnd of course, you could declare a router in a provider that points to services\ndeclared by another.\n\nTLS Termination per Route\nWhile adding TCP support to Traefik, we had to re-think almost everything,\nstarting with the entrypoint itself ‚Äî the very door to your cluster.\n\nOur first idea was to dedicate entrypoints (and as a consequence port numbers)\nto a type of ‚Äúprotocol.‚Äù Unfortunately, in some cases, especially when people\nused Traefik to route requests for multiple clusters, we deemed it too\nrestrictive. As a consequence, we allowed multiple protocols per entrypoint.\n\nThen, as debates were still going on, we kept looking for ways to better control\nhow users would configure TLS termination or passthrough. The idea of enabling\nTLS on the Router level won the brainstorming, and then passed the tests of\nproof of concept (we have quite a fan [https://github.com/juliens] of proof of\nconcept branches on the team, to the point it has almost become a meme).\n\nHere is an example with three routers listening on the same entrypoint, the\nfirst router terminates TLS connections (on HTTPS), the second router terminates\nTLS connections (on TCP), and the third router passes through, leaving the\ndetails of the TLS connection to be handled by the service itself.\n\n[entrypoints]\n   [entrypoints.web-secure]\n      address = \":443\"\n\n[http]\n   [http.routers.to-service-1]\n      rule = \"Host(`domain-1`)\"\n      service = \"service-1\"\n      [http.routers.to-service-1.tls]\n         # terminates the tls connection and sends clear data\n         # to service 1\n\n[tcp]\n   [tcp.routers.to-service-2]\n      rule = \"HostSNI(`domain-2`)\"\n      service = \"service-2\"\n      [tcp.routers.to-service-2.tls]\n         # terminates the tls connection and sends clear data\n         # to service 2\n\n[tcp.routers.to-service-3]\n      rule = \"HostSNI(`domain-3`)\"\n      service = \"service-3\"\n      [tcp.routers.to-service-3.tls]\n         passthrough = true # sends encrypted data \"as is\" to service-3\n\nLabels, Key-Value Configuration, Tags, ‚Ä¶\nA small tweak on the surface, but quite an impact in the code, we‚Äôve re-written\nthe configuration parser. This new system ensures that every option in Traefik\nhas the same path, whether expressed in TOML [something.that.is.here], a label\nattached to a container something.that.is.there, a key (as in key-value store) \nsomething/that/is/somewhere, or anything that might be available in the future.\n\nRevamped Documentation\nWe‚Äôve updated the documentation [https://docs.traefik.io/] structure to help new\nusers quickly understand how to use and configure Traefik. At the same time, we\ncame up with an outline that mirrored the configuration structure, making it\neasier for expert users to learn more about specific configuration details.\n\n\n--------------------------------------------------------------------------------\n\nThe Road to the Final Version\nYes, more (much more) is on the way, but we were so eager to share the work that\nwe couldn‚Äôt wait a minute longer than we already did.\n\n> New WebUI, remaining providers, metrics, UDP, YAML, TLS stores & options,\ncanary, more documentation ‚Äî everything is possible.\nApart from re-enabling other providers (alpha comes with file, Docker, and k8s\nonly), and enabling TCP for all of them (currently file only), the roadmap is\nfull of features.\n\nFirst, the most visible one, a contributor is actively working on a revamped\nWebUI, and from the mockups we saw, it looks very promising. We expect this new\nUI to help you navigate seamlessly through hundreds of routes.\n\nSecond, we‚Äôre working on improvements for TLS configuration, with stores and\noptions, which will deserve its own explanation.\n\nThird, now that we have tried our hand on a new protocol, well, we might as well\nadd others (like UDP).\n\nIf you want to discuss or even help us implementing these features, please join\nus on the community forum [https://community.containo.us/] or on Github\n[https://github.com/containous/traefik], the maintainer team is always open to\nyour contributions.\n\nBut the options don‚Äôt stop there ‚Äî Traefik is a community-driven project, and we\nnever know what is going to happen! We can‚Äôt wait to see what you‚Äôll do with\nthis new architecture.\n\n\n--------------------------------------------------------------------------------\n\nTo be continued‚Ä¶\n> The community is at the center of our attention.\nWe‚Äôve scheduled an online meet-up\n[/resources/the-traefik-2-0-online-meetup-100-community-driven/] where the\nmaintainer team will exclusively talk about Traefik v2.0! If you were looking\nfor an opportunity to ask questions or see a live demo, here it is.\n\nProbably the most important, we need your feedback. Tell us what you think,\nvoice your opinion! The alpha stage is the perfect timing to include disruptive\nchanges. Go crazy with pull requests, tests, and ideas.\n\nAnd finally, of course, our goal is to release the final as soon as possible!\n\n> We hope you enjoy Traefik as much as we enjoy building it with you!\n\n--------------------------------------------------------------------------------\n\nGrab the latest binaries\n[https://github.com/containous/traefik/releases/tag/v2.0.0-alpha1] for Linux,\nWindows, and Mac on Github or get the official Docker image!\n\ndocker pull traefik:v2.0.0-alpha1 (or 2.0.0-alpha1, v2.0, 2.0, faisselle)\ndocker pull traefik:v2.0.0-alpha1-alpine\ndocker pull traefik:v2.0.0-alpha1-nanoserver\n\nThe documentation can be found here [https://docs.traefik.io/] and the huge \nchangelog is here\n[https://github.com/containous/traefik/blob/master/CHANGELOG.md#v200-alpha1-2019-03-18]\n.\n\n\n--------------------------------------------------------------------------------\n\nThank you G√©rald Cro√´s\n[https://medium.com/u/520ac88c453e?source=post_page-----2f9aa17be305----------------------] \nfor your major contribution on this blog post and congrats to all the team\nmembers that have been working so hard on this alpha release üëè","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Gigawatts of Routing Power</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-full\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-6.png\" class=\"kg-image\"></figure><p>Back in 2015, a revolution was under way. We were moving from manual, handcrafted infrastructures, to container-based, industrial, and human-free platforms. In those dark ages of orchestration, edge traffic was remarkably difficult to manage. On one side, we had traditional reverse-proxies that were built for static infrastructures, on the other side, we were building dynamic clusters made to deploy and manage thousands of microservices. The idea of having a simple and automatic edge router, all in one binary, was appealing, but also idealistic. The foundation of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> was laid that year, paving the way to building a project with strong values: <em><em>simplicity of configuration</em></em>, <em><em>modern features</em></em>, and <em><em>open to the community</em></em>. A few years later, the project has reached <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">21k stars on Github</a>, and more than 600 millions downloads. <em><em>Insane</em></em>.</p><p>Since then, the ecosystem around containers has changed a lot: Docker has become a de-facto standard, and Kubernetes has shown itself to be the clear winner in the battle for the best orchestration platform. Because of this, the <a href=\"https://landscape.cncf.io/\" rel=\"noopener\">CNCF landscape</a> has exploded, with hundreds of components to choose from.</p><blockquote>The time has come to work on something new for Traefik.</blockquote><p>For several months, the maintainer team has been working on a deep refactoring of the codebase to provide the firm foundations for the next iteration of Traefik, and we are ready to share this vision with you.</p><p>Today, we‚Äôre announcing Traefik 2.0 alpha, the edge router built with the future in mind.</p><p>The new core is here, help us finalize Traefik with the features you want!</p><hr><h2 id=\"we-want-features-\">We Want Features!</h2><p>Let‚Äôs see what we have in store.</p><h3 id=\"vocabulary-clarification\">Vocabulary Clarification</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-27.png\" class=\"kg-image\"></figure><p>Not a feature per se, but we still wanted to make it easier for newcomers to understand the core concepts at work in Traefik. We wanted every word to have a clear and unique meaning throughout the code and documentation.</p><p>Welcome p<em><em>roviders</em></em>, e<em><em>ntrypoints</em></em>, r<em><em>outers</em></em>, m<em><em>iddleware</em></em>, and s<em><em>ervices</em></em>.</p><ul><li><em><em>Providers</em></em> are the cluster technologies you already use (Kubernetes, Docker, Consul, Mesos, Rancher‚Ä¶). Traefik uses your provider‚Äôs API to discover the routes to your services.</li><li><em><em>Entrypoints</em></em>, in their most basic forms, are the open ports where requests will land.</li><li><em><em>Services</em></em> represent the software hosted on your infrastructure. Traefik knows how to deal with multiple instances of your programs (currently supporting multiple load balancing capabilities), and use the s<em><em>ervices</em></em> configuration to determine how to reach the actual program.</li><li><em><em>Routers</em></em> connect incoming requests to your s<em><em>ervices. </em></em>They<em><em> </em></em>hold<em><em> </em></em>the rules that decide which service handles the request.</li><li>Finally, pieces of <em><em><a href=\"https://docs.traefik.io/middlewares/overview/\">middleware</a> </em></em>are components that may update the request before it is handled by a service. Out of the box, Traefik comes with middleware to manage authentication, rate limiting, circuit breaker, whitelisting, buffering, and so on.</li></ul><h3 id=\"configuration-structure\">Configuration Structure</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-28.png\" class=\"kg-image\"></figure><p>Despite our best efforts, and because so many features have been added to Traefik since its first launch, we needed to polish things up and make sure every configuration option belonged in its place.</p><p>Here, it was a menial job that needed to be done, and we‚Äôll spare you the details.</p><h2 id=\"let-us-be-clear-we-want-actual-features-\">Let Us Be Clear ‚Ä¶ We Want ACTUAL Features!</h2><p>So, let‚Äôs remove the mystery, since we‚Äôve teased you enough. Here are the features we‚Äôve added!</p><h3 id=\"tcp-support-\">TCP Support!</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-29.png\" class=\"kg-image\"></figure><p>That‚Äôs right! It‚Äôs time to say goodbye to <a href=\"https://github.com/containous/traefik/issues/10\" rel=\"noopener\">Issue #10</a>!</p><p>Yes, three years later, after <a href=\"https://github.com/containous/traefik/pull/4587\" rel=\"noopener\">a lot of work</a> (<a href=\"https://github.com/containous/traefik/issues/10#issuecomment-142835077\" rel=\"noopener\">as foretold</a>), and a lot of discussions, <a href=\"https://docs.traefik.io/routing/routers/#configuring-tcp-routers\">Traefik now fully supports the TCP protocol</a>.</p><p>Want to see an example? Let‚Äôs use the File Provider, and redirect every request on port<code>27010</code> to your database service!</p><pre><code class=\"language-toml\">[entrypoints]\n   [entrypoints.web]\n      address = \":80\"\n\n[entrypoints.mongo-port]\n      address = \":27017\"\n\n[tcp] # YAY!\n   [tcp.routers]\n      [tcp.routers.everything-to-mongo]\n         entrypoints = [\"mongo-port\"]\n         rule = \"HostSNI(`*`)\" # Catches every request       \n         service = \"database\"</code></pre><p>The best part? Traefik supports routing based on <a href=\"https://en.wikipedia.org/wiki/Server_Name_Indication\" rel=\"noopener\">SNIs</a>!</p><pre><code class=\"language-toml\">[entrypoints]\n   [entrypoints.web]\n      address = \":80\"\n\n[entrypoints.mongo-port]\n      address = \":27017\"\n\n[tcp] # YAY!\n   [tcp.routers]\n      [tcp.routers.to-db-1]\n         entrypoints = [\"mongo-port\"]\n         rule = \"HostSNI(`db-1.domain`)\"       \n         service = \"db-1\"\n         [tcp.routers.to-db-1.tls] # The route is for TLS requests only\n      \n      [tcp.routers.to-db-2]\n         entrypoints = [\"mongo-port\"]\n         rule = \"HostSNI(`db-2.domain`)\"       \n         service = \"db-2\"\n         [tcp.routers.to-db-2.tls] # The route is for TLS requests only</code></pre><p>What‚Äôs even better? Traefik can go crazy, and support <em><em>both</em></em> HTTP <em><em>and</em></em> TCP on the <em><em>same</em></em> port.</p><blockquote>Yes, multiple protocols on the same entrypoint!</blockquote><pre><code class=\"language-toml\">[entrypoints]\n   [entrypoints.the-one]\n      address = \":443\"\n\n[tcp]\n   [tcp.routers]\n      [tcp.routers.to-db-1]\n         rule = \"HostSNI(`db-1.domain`)\"       \n         service = \"db-1\"\n         [tcp.routers.to-db-1.tls] # The route is for TLS requests only\n\n[http]\n   [http.routers]\n      [http.routers.my-api]\n         rule = \"Host(`api.domain`)\"       \n         service = \"my-api\"</code></pre><p>In its first alpha version, Traefik only enables TCP routes in the File Provider, but stay tuned because it will (very) soon be available for other providers!</p><h3 id=\"middleware-to-update-the-requests\">Middleware to Update the Requests</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-30.png\" class=\"kg-image\"></figure><p>Many features used to be magically embedded in Traefik, with room for customization but no option for fine-tuning.</p><p>Middlewares fill the gap and give you the possibility to enable/configure any feature you‚Äôd like, per router if you wish.</p><p>Middlewares are components that act on the request before it is actually forwarded to the services, and can even decide to <em><em>not</em></em> forward the request if a required condition isn‚Äôt met.</p><p>At release, Traefik comes with the following middlewares: <a href=\"https://docs.traefik.io/middlewares/addprefix/\">AddPrefix</a> (to add a prefix to the request path), <a href=\"https://docs.traefik.io/middlewares/basicauth/\">BasicAuth</a> &amp; <a href=\"https://docs.traefik.io/middlewares/digestauth/\">DigestAuth</a>, <a href=\"https://docs.traefik.io/middlewares/forwardauth/\">ForwardAuth</a> (to delegate authentication to a third-party service), <a href=\"https://docs.traefik.io/middlewares/buffering/\">Buffering</a>, <a href=\"https://docs.traefik.io/middlewares/chain/\">Chain</a> (to define reusable sets of middlewares), <a href=\"https://docs.traefik.io/middlewares/circuitbreaker/\">CircuitBreaker</a> (to avoid calling broken services), <a href=\"https://docs.traefik.io/middlewares/compress/\">Compress</a>, <a href=\"https://docs.traefik.io/middlewares/errorpages/\">Errors</a> (to provide custom error pages), <a href=\"https://docs.traefik.io/middlewares/headers/\">Headers</a>, <a href=\"https://docs.traefik.io/middlewares/ipwhitelist/\">IpWhitelist</a>, MaxConn (to limit the number of simultaneous connections to a service), <a href=\"https://docs.traefik.io/middlewares/passtlsclientcert/\">PassTLSClientCert</a>, <a href=\"https://docs.traefik.io/middlewares/ratelimit/\">RateLimit</a> (to limit the number of requests to a service within a given period of time), <a href=\"https://docs.traefik.io/middlewares/redirectregex/\">RedirectRegex</a> and <a href=\"https://docs.traefik.io/middlewares/redirectscheme/\">RedirectScheme</a>, and <a href=\"https://docs.traefik.io/middlewares/replacepath/\">ReplacePath</a> (to update the query path before forwarding it to the service).</p><p>And more importantly, we‚Äôve re-architectured the code to make it easier to provide additional middlewares in the near future.</p><h3 id=\"kubernetes-crd\">Kubernetes &amp; CRD</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-31.png\" class=\"kg-image\"></figure><p>In the past two years, the community has been discussing (a lot) around ‚Äúbetter ingress,‚Äù and looking at our previous Kubernetes provider, we agreed that there was room for improvement. With v2, it became obvious that if we wanted to let our Kubernetes fans benefit from every feature (like TCP and middleware) without being swarmed by a clutter of annotations, we had to propose an alternative.</p><p>Among the alternatives, <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/\" rel=\"noopener\">CRD</a>s are more and more popular since they solve shortcomings of the ingress specification. Inspired by what Heptio did in Contour with IngressRoute, we extended the specification to implement every Traefik feature.</p><p>We firmly believe that a consensus can emerge from those proposals and lead to the next Ingress specification in Kubernetes.</p><p>Below is an example of this specification.</p><pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.crd\n  namespace: default\nspec:\n  entrypoints:\n    - web\n    - web-secure\n  routes:\n    - match: Host(`traefik.io`) &amp;&amp; PathPrefix(`/foo`)\n      kind: Rule\n      services:\n        - name: whoami1\n          port: 80\n          strategy: RoundRobin\n      middlewares:\n        - name: stripprefix\n        - name: addprefix\n          namespace: foo\n    - match: Host(`containo.us`) &amp;&amp; Method(`POST`)\n      kind: Rule\n      services:\n        - name: whoami2\n          port: 80\n  tls:\n    secretName: supersecret</code></pre><h3 id=\"new-expressive-routing-rule-syntax\">New Expressive Routing Rule Syntax</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-32.png\" class=\"kg-image\"></figure><p>Traefik now supports an expressive syntax to define the router rules, with <code>and</code>, <code>or</code>, and <code>parenthesis</code>!</p><p>The available <a href=\"https://docs.traefik.io/routing/routers/#rule\">matchers</a> being <code>Headers</code>, <code>HeadersRegexp</code>, <code>Host</code>, <code>HostRegexp</code>, <code>Method</code>, <code>Path</code>, <code>PathPrefix</code>, and <code>Query</code>.</p><p>Since TCP is a whole different world, for now, it only supports a dedicated matcher: <code>HostSNI</code>.</p><p>Want to see examples?</p><pre><code class=\"language-toml\">rule = (Host(`api.domain`) &amp;&amp; PathPrefix(`/v2`)) \n  || Host(`api-v2.domain`)\n\nrule = (Method(`DELETE`) || (Method(`POST`) \n  &amp;&amp; Query(`action`, `delete`))) &amp;&amp; Host('api.domain')</code></pre><h3 id=\"cross-provider-support\">Cross-Provider Support</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-33.png\" class=\"kg-image\"></figure><p>Traefik has always been compatible with multiple providers, which is one of its greater strengths: whatever your infrastructure is, from bare metal to orchestrators and clusters, Traefik just works!</p><p>But with v2, we‚Äôve gone a little further and allowed users to declare elements (middlewares, services, routers) in a provider, and to use them from a different one.</p><p>Let‚Äôs take a look at the following example, that declares an authentication middleware in a configuration file (the File Provider), which is being used from a Docker label (the Docker Provider).</p><pre><code class=\"language-toml\"># somewhere in a configuration file for the file provider\n[http.middlewares.my-users.basicauth]\n   users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \n            \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"]</code></pre><hr><pre><code class=\"language-yaml\"># somewhere in a docker compose file\n\nyour-container:\n    image: your-docker-image\n    \n    labels:\n      - \"traefik.http.routers.my-router.middlewares=file.my-users\"</code></pre><p>And of course, you could declare a router in a provider that points to services declared by another.</p><h3 id=\"tls-termination-per-route\">TLS Termination per Route</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-34.png\" class=\"kg-image\"></figure><p>While adding TCP support to Traefik, we had to re-think almost everything, starting with the e<em><em>ntrypoint</em></em> itself ‚Äî the very door to your cluster.</p><p>Our first idea was to dedicate e<em><em>ntrypoints</em></em> (and as a consequence port numbers) to a type of ‚Äúprotocol.‚Äù Unfortunately, in some cases, especially when people used Traefik to route requests for multiple clusters, we deemed it too restrictive. As a consequence, we allowed multiple protocols per e<em><em>ntrypoint</em></em>.</p><p>Then, as debates were still going on, we kept looking for ways to better control how users would configure TLS <em><em>termination</em></em> or <em><em>passthrough. </em></em>The idea of enabling TLS on the <em><em>Router</em></em> level won the brainstorming, and then passed the tests of proof of concept (we have <a href=\"https://github.com/juliens\" rel=\"noopener\">quite a fan</a> of proof of concept branches on the team, to the point it has almost become a meme).</p><p>Here is an example with three routers listening on the same e<em><em>ntrypoint</em></em>, the first router terminates TLS connections (on HTTPS), the second router terminates TLS connections (on TCP), and the third router passes through, leaving the details of the TLS connection to be handled by the s<em><em>ervice </em></em>itself.</p><pre><code class=\"language-toml\">[entrypoints]\n   [entrypoints.web-secure]\n      address = \":443\"\n\n[http]\n   [http.routers.to-service-1]\n      rule = \"Host(`domain-1`)\"\n      service = \"service-1\"\n      [http.routers.to-service-1.tls]\n         # terminates the tls connection and sends clear data\n         # to service 1\n\n[tcp]\n   [tcp.routers.to-service-2]\n      rule = \"HostSNI(`domain-2`)\"\n      service = \"service-2\"\n      [tcp.routers.to-service-2.tls]\n         # terminates the tls connection and sends clear data\n         # to service 2\n\n[tcp.routers.to-service-3]\n      rule = \"HostSNI(`domain-3`)\"\n      service = \"service-3\"\n      [tcp.routers.to-service-3.tls]\n         passthrough = true # sends encrypted data \"as is\" to service-3</code></pre><h3 id=\"labels-key-value-configuration-tags-\">Labels, Key-Value Configuration, Tags, ‚Ä¶</h3><p>A small tweak on the surface, but quite an impact in the code, we‚Äôve re-written the configuration parser. This new system ensures that every option in Traefik has the same path, whether expressed in TOML <code>[something.that.is.here]</code>, a label attached to a container <code>something.that.is.there</code>, a key (as in key-value store) <code>something/that/is/somewhere</code>, or anything that might be available in the future.</p><h3 id=\"revamped-documentation\">Revamped Documentation</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-35.png\" class=\"kg-image\"></figure><p>We‚Äôve updated the <a href=\"https://docs.traefik.io/\">documentation</a> structure to help new users quickly understand how to use and configure Traefik. At the same time, we came up with an outline that mirrored the configuration structure, making it easier for expert users to learn more about specific configuration details.</p><hr><h2 id=\"the-road-to-the-final-version\">The Road to the Final Version</h2><p>Yes, more (<em><em>much</em></em> more) is on the way, but we were so eager to share the work that we couldn‚Äôt wait a minute longer than we already did.</p><blockquote>New WebUI, remaining providers, metrics, UDP, YAML, TLS stores &amp; options, canary, more documentation ‚Äî everything is possible.</blockquote><p>Apart from re-enabling other providers (alpha comes with file, Docker, and k8s only), and enabling TCP for all of them (currently file only), the roadmap is full of features.</p><p>First, the most visible one, a contributor is actively working on a revamped WebUI, and from the mockups we saw, it looks <em><em>very</em></em> promising. We expect this new UI to help you navigate seamlessly through hundreds of routes.</p><p>Second, we‚Äôre working on improvements for TLS configuration, with stores and options, which will deserve its own explanation.</p><p>Third, now that we have tried our hand on a new protocol, well, we might as well add others (like UDP).</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-36.png\" class=\"kg-image\"></figure><p>If you want to discuss or even help us implementing these features, please join us on the <a href=\"https://community.containo.us/\">community forum</a> or on <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">Github</a>, the maintainer team is always open to your contributions.</p><p>But the options don‚Äôt stop there ‚Äî Traefik is a community-driven project, and we never know what is going to happen! We can‚Äôt wait to see what you‚Äôll do with this new architecture.</p><hr><h2 id=\"to-be-continued-\">To be continued‚Ä¶</h2><blockquote>The community is at the center of our attention.</blockquote><p>We‚Äôve scheduled <a href=\"https://containous.ghost.io/resources/the-traefik-2-0-online-meetup-100-community-driven/\">an online meet-up</a> where the maintainer team will exclusively talk about Traefik v2.0! If you were looking for an opportunity to ask questions or see a live demo, here it is.</p><p>Probably the most important, we <em><em>need</em></em> your feedback. Tell us what you think, voice your opinion! The alpha stage is the perfect timing to include disruptive changes. Go crazy with pull requests, tests, and ideas.</p><p>And finally, of course, our goal is to release the final as soon as possible!</p><blockquote>We hope you enjoy Traefik as much as we enjoy building it with you!</blockquote><hr><p>Grab the <a href=\"https://github.com/containous/traefik/releases/tag/v2.0.0-alpha1\" rel=\"noopener\">latest binaries</a> for Linux, Windows, and Mac on Github or get the official Docker image!</p><pre><code class=\"language-shell\">docker pull traefik:v2.0.0-alpha1 (or 2.0.0-alpha1, v2.0, 2.0, faisselle)\ndocker pull traefik:v2.0.0-alpha1-alpine\ndocker pull traefik:v2.0.0-alpha1-nanoserver</code></pre><p>The documentation can be found <a href=\"https://docs.traefik.io/\">here</a> and the <em><em>huge</em></em> changelog is <a href=\"https://github.com/containous/traefik/blob/master/CHANGELOG.md#v200-alpha1-2019-03-18\" rel=\"noopener\">here</a>.</p><hr><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-37.png\" class=\"kg-image\"></figure><p><em><em>Thank you </em></em><a href=\"https://medium.com/u/520ac88c453e?source=post_page-----2f9aa17be305----------------------\" rel=\"noopener\"><em><em>G√©rald Cro√´s</em></em></a><em><em> for your major contribution on this blog post and congrats to all the team members that have been working so hard on this alpha release üëè</em></em></p>","url":"https://containous.ghost.io/blog/back-to-traefik-2-0-2f9aa17be305/","canonical_url":null,"uuid":"393d57dd-4c65-4b3b-9705-07f64521802c","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd6b3d9b6de2b00381d405f","reading_time":10}},{"node":{"id":"Ghost__Post__5dd6b329b6de2b00381d4043","title":"Back to Traefik 2.0, the Online Meetup","slug":"back-to-traefik-2-0-the-online-meet-up-4e4b6411fbfa","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/back-traefik-2.0-meetup.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/d61a6d2fbcfa83c47c6ab94a7c65ad21/f3583/back-traefik-2.0-meetup.png","srcSet":"/static/d61a6d2fbcfa83c47c6ab94a7c65ad21/630fb/back-traefik-2.0-meetup.png 300w,\n/static/d61a6d2fbcfa83c47c6ab94a7c65ad21/2a4de/back-traefik-2.0-meetup.png 600w,\n/static/d61a6d2fbcfa83c47c6ab94a7c65ad21/f3583/back-traefik-2.0-meetup.png 1200w,\n/static/d61a6d2fbcfa83c47c6ab94a7c65ad21/bbee5/back-traefik-2.0-meetup.png 1800w,\n/static/d61a6d2fbcfa83c47c6ab94a7c65ad21/ed396/back-traefik-2.0-meetup.png 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Just after the Traefik 2.0 announcement, we aired an Online Meetup to talk about our treasured features...","custom_excerpt":"Just after the Traefik 2.0 announcement, we aired an Online Meetup to talk about our treasured features...","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"April 1, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-21T15:54:17.000+00:00","published_at":"2019-04-01T15:54:00.000+00:00","updated_at":"2020-05-22T00:07:38.000+00:00","meta_title":"Back to Traefik 2.0, the Online Meetup","meta_description":"Just after the Traefik 2.0 announcement, we aired an Online Meetup to talk about our treasured features...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Community","slug":"community","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Now Available on YouTube!\n\nWhat a week, everyone! Just after the Traefik 2.0 announcement\n[/blog/back-to-traefik-2-0-2f9aa17be305/https://containo.us/blog/back-to-traefik-2-0-2f9aa17be305/]\n, driven by the relentless enthusiasm of our Head of Community (who did quite \nthe show introducing the team), we aired an Online Meetup to talk about our\ntreasured features in the next iteration of our favorite\nreverse-proxy/edge-router.\n\nI know this is a question we haven‚Äôt been asked (but, we‚Äôll answer it anyway) ‚Äî\nYes, we (the developer team) were a bit nervous. Because, even though we often\ntalk to the community In Real Life, we were unfamiliar with the \nwe-don‚Äôt-see-you-while-we-talk format of the online Meetup. And, here is another\nanswer to a question you didn‚Äôt ask, but, again, we‚Äôll answer ‚Äî Yes, we enjoyed\nthis moment with you, and would do it again.\n\nChances are you‚Äôre here for the video only, and not the story behind the movie,\nso let‚Äôs proceed!\n\nThe slides are available here\n[https://docs.google.com/presentation/d/e/2PACX-1vS3_WzHd4vOA7pqzFL1YTIom-_t9OrvmKwV3_GuBvqQeWV1jfxFml18M2miCpinL2PP-od5kv1NaN-m/pub?start=false&loop=true&delayms=3000]\n, and code for the demos is available on Github\n[https://github.com/containous/slides/tree/online-meetup-v2/demo/v2-tcp].‚ÄúQ&A\nTime (Excerpts)‚Äù\nAbout TCP (and UDP)\n> Can the TCP entry point use Let‚Äôs Encrypt [https://letsencrypt.org/]? Could you\nhave HTTP and TCP endpoints using the same hostname? Is it ready for UDP?\nWe loved bringing TCP support to Traefik [/traefik/], and we wanted it to come\nalong with features our users would expect ‚Äî one of them being Let‚Äôs Encrypt\nsupport (so yes, TCP in Traefik supports Let‚Äôs Encrypt for automatic\ncertificates, like with HTTP).\n\nWe also wanted Traefik to be able to route TCP and HTTP requests\n[/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/] \non the same entry points, which was quite a challenge. This was made possible\nwith a simple trick ‚Äî the use of the SNI in TLS connections. But this comes with\na limitation: you won‚Äôt be able to route both HTTP and TCP requests on the same \nhost+port combination. If for the same domain you‚Äôd like to route TCP and HTTP\nrequests, we encourage you to use two different ports.\n\nTCP was made possible by the re-architectured core. This new core also enables\nus to bring UDP support, and even if it is not written yet, it‚Äôs a matter of\nweeks before it‚Äôs out.\n\nAbout Middleware\n> Do middleware always applied from left to right? Can a service be a middleware\nCan custom middlewares be created? Can we use middlewares on TCP endpoints? Can\nwe use middleware on the response? Is middleware for ingress only?\nSo middleware [https://docs.traefik.io/middlewares/overview/] is a concept we\nintroduced to enable you to fine-tune the life cycle of the requests. They will\noften act before the request is forwarded to the services\n[https://docs.traefik.io/routing/services/], and can also operate on the\nresponse you get from the services (like the headers\n[https://docs.traefik.io/middlewares/headers/] middleware does). Pieces of\nmiddleware are applied from left to right on the request, and from right to left\non the response. Since you define the order, and since you can define as many \nchains [https://docs.traefik.io/middlewares/chain/] or attach as many pieces of\nmiddleware to your routers [https://docs.traefik.io/routing/routers/] as you\nwant, you have total control. There are currently no available middleware for\nTCP routers, but it‚Äôs something we‚Äôre looking into (if you have ideas, let us\nknow!). And regarding custom middleware, even though we know our user base is\nlooking for it, it won‚Äôt fit in the 2.0 scope (which is already big!).\n\nAbout KV Stores & Distributed Let‚Äôs Encrypt\n> Current (pre-2.0) traefik can store ACME certificates in a file or a KV store.\nThe latter helps with running a cluster of traefik, but the storage is\nrestricted to 512kb of certificate information when using Consul. Will this\nimprove? (storing in a key per certificate instead of a single key for all, for\nexample)\nWhile working on 2.0, we decided it was time to rework this part. Sticking with\nthe Unix Philosophy, ‚ÄúMake each program do one thing well,‚Äù Traefik is getting\nback to be a good old single-instance pure data plane. At the same time,\nclustering has been redesigned from scratch using a production-proven rock-solid\nraft-based implementation, shipped with Traefik Enterprise Edition (see how\n[/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/]\n). Distributed features (like Let‚Äôs Encrypt) can now rely on this advanced\ncluster technology for these use cases. But hey! You can still use multiple\nTraefik instances with your favorite KV store, we only removed the unstable and\nexperimental part :)\n\nAbout the Final Release\n> When will the final 2.0 be available?\nShort answer: When it‚Äôs ready!\n\nReal answer: We wish we could tell. Even though we can estimate how much time we\nwill need to develop the missing features\n[https://github.com/containous/traefik/projects/3], we don‚Äôt know fore sure how\nmuch feedback you‚Äôll provide, or how many features contributors will be tackling\n(and, as Damien pointed out ‚Äî we‚Äôre ready to help any [new/returning/existing]\ncontributors eager to participate in the project!). Anyways, all we can say is,\n‚Äústay tuned for updates!‚Äù\n\nAbout Other Things‚Ä¶\nYou‚Äôll find other (more specific) questions (and answers) here\n[https://gist.github.com/dduportal/13874113cf5fa1d0901655e3367c31e5]!\n\n\n--------------------------------------------------------------------------------\n\nDon‚Äôt Miss the Next Meet-Ups!\nIf you enjoyed the meet-up and would like to be notified of upcoming online\nevents and receive the videos from our previous sessions, sign up here\n[http://eepurl.com/gfN5Aj]!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Now Available on YouTube!</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-full\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-5.png\" class=\"kg-image\"></figure><p>What a week, everyone! Just after the <a href=\"https://containous.ghost.io/blog/back-to-traefik-2-0-2f9aa17be305/https://containo.us/blog/back-to-traefik-2-0-2f9aa17be305/\">Traefik 2.0 announcement</a>, driven by the relentless enthusiasm of our Head of Community (who did quite <em><em>the</em></em> show introducing the team), we aired an Online Meetup to talk about our treasured features in the next iteration of our favorite reverse-proxy/edge-router.</p><p>I know this is a question we haven‚Äôt been asked (but, we‚Äôll answer it anyway) ‚Äî Yes, we (the developer team) were a bit nervous. Because, even though we often talk to the community <em><em>In Real Life,</em></em> we were unfamiliar with the <em><em>we-don‚Äôt-see-you-while-we-talk</em></em> format of the online Meetup. And, here is another answer to a question you didn‚Äôt ask, but, again, we‚Äôll answer ‚Äî Yes, we enjoyed this moment with you, and would do it again.</p><p>Chances are you‚Äôre here for the video only, and <em><em>not</em></em> the story behind the movie, so let‚Äôs proceed!</p><figure class=\"kg-card kg-embed-card kg-card-hascaption\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/s8qYWPC6YdI?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe><figcaption>The slides are <a href=\"https://docs.google.com/presentation/d/e/2PACX-1vS3_WzHd4vOA7pqzFL1YTIom-_t9OrvmKwV3_GuBvqQeWV1jfxFml18M2miCpinL2PP-od5kv1NaN-m/pub?start=false&amp;loop=true&amp;delayms=3000\" rel=\"noopener\">available here</a>, and code for the demos is available <a href=\"https://github.com/containous/slides/tree/online-meetup-v2/demo/v2-tcp\" rel=\"noopener\">on Github</a>.</figcaption></figure><h2 id=\"-qa-time-excerpts-\">‚ÄúQ&amp;A Time (Excerpts)‚Äù</h2><h3 id=\"about-tcp-and-udp-\">About TCP (and UDP)</h3><blockquote><em><em>Can the TCP entry point use <a href=\"https://letsencrypt.org/\" rel=\"noopener\">Let‚Äôs Encrypt</a>? Could you have HTTP and TCP endpoints using the same hostname? Is it ready for UDP?</em></em></blockquote><p>We loved bringing TCP support to <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, and we wanted it to come along with features our users would expect ‚Äî one of them being Let‚Äôs Encrypt support (so yes, TCP in Traefik supports Let‚Äôs Encrypt for automatic certificates, like with HTTP).</p><p>We also wanted Traefik to be able to route TCP and <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/\">HTTP requests</a> on the same entry points, which was quite a challenge. This was made possible with a simple trick ‚Äî the use of the SNI in TLS connections. But this comes with a limitation: you won‚Äôt be able to route both HTTP and TCP requests on the <em><em>same</em></em> <code>host+port</code> combination. If for the <em><em>same domain</em></em> you‚Äôd like to route TCP and HTTP requests, we encourage you to use two different ports.</p><p>TCP was made possible by the re-architectured core. This new core also enables us to bring UDP support, and even if it is not written yet, it‚Äôs a matter of weeks before it‚Äôs out.</p><h3 id=\"about-middleware\">About Middleware</h3><blockquote><em><em>Do middleware always applied from left to right? Can a service be a middleware Can custom middlewares be created? Can we use middlewares on TCP endpoints? Can we use middleware on the response? Is middleware for ingress only?</em></em></blockquote><p>So <a href=\"https://docs.traefik.io/middlewares/overview/\">middleware</a> is a concept we introduced to enable you to fine-tune the life cycle of the requests. They will often act <em><em>before</em></em> the request is forwarded to the <a href=\"https://docs.traefik.io/routing/services/\">services</a>, and can also operate on the response you get from the services (like the <a href=\"https://docs.traefik.io/middlewares/headers/\">headers</a> middleware does). Pieces of middleware are applied from left to right on the request, and from right to left on the response. Since you define the order, and since you can define as many <a href=\"https://docs.traefik.io/middlewares/chain/\">chains</a> or attach as many pieces of middleware to your <a href=\"https://docs.traefik.io/routing/routers/\">routers</a> as you want, you have total control. There are currently no available middleware for TCP routers, but it‚Äôs something we‚Äôre looking into (if you have ideas, let us know!). And regarding custom middleware, even though we know our user base is looking for it, it won‚Äôt fit in the 2.0 scope (which is already big!).</p><h3 id=\"about-kv-stores-distributed-let-s-encrypt\">About KV Stores &amp; Distributed Let‚Äôs Encrypt</h3><blockquote><em><em>Current (pre-2.0) traefik can store ACME certificates in a file or a KV store. The latter helps with running a cluster of traefik, but the storage is restricted to 512kb of certificate information when using Consul. Will this improve? (storing in a key per certificate instead of a single key for all, for example)</em></em></blockquote><p>While working on 2.0, we decided it was time to rework this part. Sticking with the Unix Philosophy, ‚ÄúMake each program do one thing well,‚Äù Traefik is getting back to be a good old single-instance pure data plane. At the same time, clustering has been redesigned from scratch using a production-proven rock-solid raft-based implementation, shipped with Traefik Enterprise Edition (<a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/\">see how</a>). Distributed features (like Let‚Äôs Encrypt) can now rely on this advanced cluster technology for these use cases. But hey! You can still use multiple Traefik instances with your favorite KV store, we only removed the unstable and experimental part :)</p><h3 id=\"about-the-final-release\">About the Final Release</h3><blockquote><em><em>When will the final 2.0 be available?</em></em></blockquote><p>Short answer: When it‚Äôs ready!</p><p>Real answer: We wish we could tell. Even though we can estimate how much time we will need to develop the <a href=\"https://github.com/containous/traefik/projects/3\" rel=\"noopener\">missing features</a>, we don‚Äôt know fore sure how much feedback you‚Äôll provide, or how many features contributors will be tackling (and, as Damien pointed out ‚Äî we‚Äôre ready to help any [new/returning/existing] contributors eager to participate in the project!). Anyways, all we can say is, ‚Äústay tuned for updates!‚Äù</p><h3 id=\"about-other-things-\">About Other Things‚Ä¶</h3><p>You‚Äôll find other (more specific) questions (and answers) <a href=\"https://gist.github.com/dduportal/13874113cf5fa1d0901655e3367c31e5\" rel=\"noopener\">here</a>!</p><hr><h2 id=\"don-t-miss-the-next-meet-ups-\">Don‚Äôt Miss the Next Meet-Ups!</h2><p>If you enjoyed the meet-up and would like to be notified of upcoming online events and receive the videos from our previous sessions, <a href=\"http://eepurl.com/gfN5Aj\" rel=\"noopener\">sign up here</a>!</p>","url":"https://containous.ghost.io/blog/back-to-traefik-2-0-the-online-meet-up-4e4b6411fbfa/","canonical_url":null,"uuid":"d8358245-b2ef-4cfa-bc8a-0f7cc5b785cc","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd6b329b6de2b00381d4043","reading_time":4}},{"node":{"id":"Ghost__Post__5dd6a624b6de2b00381d402a","title":"Announcing General Availability of Traefik Enterprise Edition","slug":"announcing-general-availability-of-traefik-enterprise-edition-9c9aad363ce","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/traefikee-1.0.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/f7d078eb75d0acd3d1d4a3a942a97917/f3583/traefikee-1.0.png","srcSet":"/static/f7d078eb75d0acd3d1d4a3a942a97917/630fb/traefikee-1.0.png 300w,\n/static/f7d078eb75d0acd3d1d4a3a942a97917/2a4de/traefikee-1.0.png 600w,\n/static/f7d078eb75d0acd3d1d4a3a942a97917/f3583/traefikee-1.0.png 1200w,\n/static/f7d078eb75d0acd3d1d4a3a942a97917/54967/traefikee-1.0.png 1400w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Containous Inc, the company behind Traefik, is proud to announce the general availability of Traefik Enterprise Edition, a new platform built on top of...","custom_excerpt":"Containous Inc, the company behind Traefik, is proud to announce the general availability of Traefik Enterprise Edition, a new platform built on top of...","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"April 18, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-21T14:58:44.000+00:00","published_at":"2019-04-18T14:58:00.000+00:00","updated_at":"2020-05-21T23:23:16.000+00:00","meta_title":"Announcing General Availability of Traefik Enterprise Edition","meta_description":"Containous is proud to announce the general availability of Traefik Enterprise, a new platform designed for business-critical deployments.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Traefik Made Distributed\n\nContainous Inc [/], the company behind the popular open source cloud native edge\nrouter, Traefik [/traefik/], is proud to announce the general availability of\nTraefik Enterprise Edition, a new platform built on top of Traefik, designed for\nbusiness-critical deployments.\n\nIn just three years, Traefik, the Cloud Native Edge Router, has become a key\nplayer in microservices infrastructures. With more than 21,000 stars on Github\nand 650,000,000 downloads on DockerHub, Traefik is widely used by major\ncompanies in their production environments.\n\nIn the latter part of 2018, Containous released the early access of TraefikEE\n[/blog/introducing-traefik-enterprise-edition-83b78d09efeb/] to a select group\nof users, allowing them to refine the software. Today, Containous is proud to\nannounce that TraefikEE has reached the 1.0 milestone, and is ready for\nproduction.\n\nOverview\nTraefikEE is built on top of Traefik and adds clustering features to satisfy the\nneeds of enterprise customers. All Traefik concepts apply to TraefikEE, so if\nyou‚Äôre already a Traefik user, you‚Äôre in familiar territory.\n\nIt runs on the edge of your platform to route the traffic to your applications,\nand is composed of two elements:\n\n * The data plane: horizontally scalable nodes, which forwards ingress traffic\n   to your services\n * The control plane: distributed nodes, implementing the raft consensus, which\n   watch your platform and its services, store topology changes, and reconfigure\n   the data plane to adapt ingress routing dynamically\n\nA TraefikEE cluster natively supports raft consensus between control nodes to\nsafely store and replicate configurations. No external Key-Value Store nor\nthird-party tool needed.\n\nThis distributed architecture is the cornerstone of TraefikEE‚Äôs strengths:\nnatively highly available, scalable and secure.\n\nHere is a 5 minute introduction video of TraefikEE:\n\nQuickstart\nStart your free trial with TraefikEE today. Visit our website at \nhttps://containo.us/traefikee [/traefikee/], and get your trial license key in\nless than a minute!\n\nOur documentation [https://docs.containo.us/] and our awesome CLI will help you\nbootstrap a TraefikEE cluster within a second. You can even request a demo\n[https://info.containo.us/request-demo-traefikeehttps://info.containo.us/request-demo-traefikee] \non our website to set up a session with the core team.\n\nDon‚Äôt hesitate to talk to our sales team\n[https://info.containo.us/contact-sales], they will find the best way to help\nyour company deploying a powerful edge routing solution.\n\nTraefik Stays Open\nTraefikEE is built on top of Traefik, that means that Traefik continues to\nevolve and will stay open source. Nothing changes! We are firm believers in open\nsource, and Traefik will continue to be our main priority and a community-driven\nproject. We are working on significant changes to Traefik, and recently have\nshared details [/blog/back-to-traefik-2-0-2f9aa17be305/] on the Traefik 2.0\nroadmap and released the first alphas\n[https://github.com/containous/traefik/releases/tag/v2.0.0-alpha4]. We won‚Äôt lie\nsaying it‚Äôs going to be huge.\n\nAbout Containous\nContainous is the company that supports the development of Traefik, the popular\nopen source cloud native edge router. Traefik is widely used around the globe\nwith over 650 million downloads. Containous brings the future of software\narchitecture by offering the most powerful tools to ease the deployment of your\nmodern IT environments.\n\nFind out more about Containous at containo.us [/] and follow @containous\n[https://twitter.com/containous] on Twitter.\n\nWith this new product, Containous continues to innovate and define new ways to\naccess microservice platforms, pushing the limits of automation and scalability.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Traefik Made Distributed</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-1.png\" class=\"kg-image\"></figure><p><a href=\"https://containous.ghost.io/\" rel=\"noopener\"><em><em>Containous Inc</em></em></a>, the company behind the popular open source cloud native edge router, <em><em><a href=\"https://containous.ghost.io/traefik/\">Traefik</a></em></em>, is proud to announce the general availability of Traefik Enterprise Edition, a new platform built on top of <em><em>Traefik</em></em>, designed for business-critical deployments.</p><p>In just three years, <em><em>Traefik</em></em>, the Cloud Native Edge Router, has become a key player in microservices infrastructures. With more than 21,000 stars on Github and 650,000,000 downloads on DockerHub, <em><em>Traefik</em></em> is widely used by major companies in their production environments.</p><p>In the latter part of 2018, Containous released <a href=\"https://containous.ghost.io/blog/introducing-traefik-enterprise-edition-83b78d09efeb/\">the early access of TraefikEE</a> to a select group of users, allowing them to refine the software. Today, Containous is proud to announce that TraefikEE has reached the <strong><strong>1.0</strong></strong> milestone, and is <strong><strong>ready for production</strong></strong>.</p><h2 id=\"overview\">Overview</h2><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-25.png\" class=\"kg-image\"></figure><p><em><em>TraefikEE</em></em> is built on top of <em><em>Traefik</em></em> and adds clustering features to satisfy the needs of enterprise customers. All <em><em>Traefik</em></em> concepts apply to <em><em>TraefikEE</em></em>, so if you‚Äôre already a <em><em>Traefik</em></em> user, you‚Äôre in familiar territory.</p><p>It runs on the edge of your platform to route the traffic to your applications, and is composed of two elements:</p><ul><li><strong><strong>The data plane</strong></strong>: horizontally scalable nodes, which forwards ingress traffic to your services</li><li><strong><strong>The control plane</strong></strong>: distributed nodes, implementing the raft consensus, which watch your platform and its services, store topology changes, and reconfigure the data plane to adapt ingress routing dynamically</li></ul><p>A <em><em>TraefikEE</em></em> cluster natively supports raft consensus between control nodes to safely store and replicate configurations. No external Key-Value Store nor third-party tool needed.</p><p>This distributed architecture is the cornerstone of <em><em>TraefikEE</em></em>‚Äôs strengths: natively <strong><strong>highly available</strong></strong>, <strong><strong>scalable</strong></strong> and <strong><strong>secure</strong></strong>.</p><p>Here is a 5 minute introduction video of <em><em>TraefikEE</em></em>:</p><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/znFQLLGCB3U?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure><h2 id=\"quickstart\">Quickstart</h2><p>Start your free trial with TraefikEE today. Visit our website at <a href=\"https://containous.ghost.io/traefikee/\">https://containo.us/traefikee</a>, and get your trial license key in less than a minute!</p><p>Our <a href=\"https://docs.containo.us/\" rel=\"noopener\">documentation</a> and our awesome CLI will help you bootstrap a TraefikEE cluster within a second. You can even <a href=\"https://info.containo.us/request-demo-traefikeehttps://info.containo.us/request-demo-traefikee\">request a demo</a> on our website to set up a session with the core team.</p><p>Don‚Äôt hesitate to <a href=\"https://info.containo.us/contact-sales\">talk to our sales team</a>, they will find the best way to help your company deploying a powerful edge routing solution.</p><h2 id=\"traefik-stays-open\">Traefik Stays Open</h2><p><em><em>TraefikEE</em></em> is built on top of <em><em>Traefik</em></em>, that means that Traefik continues to evolve and will stay open source. Nothing changes! We are firm believers in open source, and <em><em>Traefik</em></em> will continue to be our main priority and a community-driven project. We are working on significant changes to Traefik, and <a href=\"https://containous.ghost.io/blog/back-to-traefik-2-0-2f9aa17be305/\">recently have shared details</a> on the <em><em>Traefik</em></em> 2.0 roadmap and released <a href=\"https://github.com/containous/traefik/releases/tag/v2.0.0-alpha4\" rel=\"noopener\">the first alphas</a>. We won‚Äôt lie saying it‚Äôs going to be huge.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-26.png\" class=\"kg-image\"></figure><h2 id=\"about-containous\">About Containous</h2><p>Containous is the company that supports the development of Traefik, the popular open source cloud native edge router. Traefik is widely used around the globe with over 650 million downloads. Containous brings the future of software architecture by offering the most powerful tools to ease the deployment of your modern IT environments.</p><p>Find out more about Containous at <a href=\"https://containous.ghost.io/\">containo.us</a> and follow <a href=\"https://twitter.com/containous\" rel=\"noopener\">@containous</a> on Twitter.</p><p>With this new product, Containous continues to innovate and define new ways to access microservice platforms, pushing the limits of automation and scalability.</p>","url":"https://containous.ghost.io/blog/announcing-general-availability-of-traefik-enterprise-edition-9c9aad363ce/","canonical_url":null,"uuid":"7d8408db-70d8-47e2-be30-abd880f19b93","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd6a624b6de2b00381d402a","reading_time":3}},{"node":{"id":"Ghost__Post__5dd6a50ab6de2b00381d3ff2","title":"TraefikEE, Now Docker Certified!","slug":"traefikee-now-dockeree-certified-d926bf7255a4","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/traefikee-certified.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/a04be38b2397bcaa594686d082a0fd5f/47498/traefikee-certified.jpg","srcSet":"/static/a04be38b2397bcaa594686d082a0fd5f/9dc27/traefikee-certified.jpg 300w,\n/static/a04be38b2397bcaa594686d082a0fd5f/4fe8c/traefikee-certified.jpg 600w,\n/static/a04be38b2397bcaa594686d082a0fd5f/47498/traefikee-certified.jpg 1200w,\n/static/a04be38b2397bcaa594686d082a0fd5f/52258/traefikee-certified.jpg 1800w,\n/static/a04be38b2397bcaa594686d082a0fd5f/f691d/traefikee-certified.jpg 1833w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"TraefikEE is a production-grade, distributed, and highly available routing solution, and today we‚Äôre proud to announce that it is certified as such...","custom_excerpt":"TraefikEE is a production-grade, distributed, and highly available routing solution, and today we‚Äôre proud to announce that it is certified as such...","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"April 30, 2019","updated_at_pretty":"01 October, 2020","created_at":"2019-11-21T14:54:02.000+00:00","published_at":"2019-04-30T14:53:00.000+00:00","updated_at":"2020-10-01T05:07:23.000+00:00","meta_title":"Traefik Enterprise Edition, Now Docker Certified!","meta_description":"TraefikEE is a production-grade, distributed, and highly available routing solution, and today we‚Äôre proud to announce that it is certified as such...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Michael Matur","slug":"michael","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/michael.png","twitter":"@michaelmatur","facebook":null,"website":null}],"primary_author":{"name":"Michael Matur","slug":"michael","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/michael.png","twitter":"@michaelmatur","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Ready for the Future\n\nBuilding business critical solutions often requires more than leveraging the\nbest tools available ‚Äî it requires partners to rely on.\n\nTraefik, as one of the most acclaimed open source edge routers, benefits from a\nvibrant and supportive community. With the enterprise edition, not only did we\nadd business-centric features to improve user experience, security,\navailability, and scalability. Additionally, we also made premium support a\nreality.\n\nTraefikEE is a production-grade, distributed, and highly available routing\nsolution, and today we‚Äôre proud to announce that it is certified as such\n[https://store.docker.com/_/traefikee]!\n\nWhat Does it Mean?\n\nTraefikEE has been tested and is supported by Docker Enterprise. It complies\nwith Docker best practices guidelines, has proven provenance, and has been\nscanned for security vulnerabilities.\n\nSee It in Action!\nTest It!\n> Note: If you don‚Äôt have your license key yet, request your free trial\n[https://traefik.io/traefik-enterprise] on our website and download traefikeectl\n[https://docs.containo.us/installing/teectl-cli/].\nInstallation\nHere is a Swarm One Line Installation:\n\ntraefikeectl install \\\n  --swarm \\\n  --dashboard \\\n  --licensekey=\"${TRAEFIKEE_LICENSE_KEY}\" \\\n  --clustername=traefikee-swarm\n\n> You can learn more about the command-line options used on the traefikeectl\ninstall Reference Guide [https://docs.containo.us/installing/teectl-cli/]\nConfiguration\nManage the cluster with traefikeectl: \n\ntraefikeectl list-nodes --clustername=traefikee-swarm\n\ntraefikeectl backup --clustername=traefikee-swarm\n\n# ...\n\n\n\nDeploy a customized routing configuration to create the Traefik entrypoints:\n\ntraefikeectl deploy --clustername=traefikee-swarm \\\n \t--docker.swarmmode \\\n \t--entryPoints='Name:http Address::80' \\\n \t--entryPoints='Name:https Address::443 TLS' \\\n \t--defaultentrypoints=https,http\n\n> Note: TraefikEE uses the `80` and `443` ports internally, hence these values for\nthe entrypoints.\nDeploy a Demo Application\nYou can deploy applications in Docker Swarm using labels:\n\nversion: '3.4'\nnetworks:\n  traefikee_net:\n    external: true\nservices:\n  whoami:\n    image: containous/whoami\n  deploy:\n    mode: replicated\n    replicas: 2\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.frontend.rule=Host:your.cluster.dns.org\"\n      - \"traefik.port=80\"\n      - \"traefik.backend=whoami\"\n  networks:\n    - traefikee_net\n\n> Note: In the above example, your.cluster.dns.org is the DNS to reach your\ncluster.\nDeploy the application with the following command:\n\ndocker stack deploy whoami --compose-file=./whoami-stack.yaml\n\nWith docker service ls, check that the application deployment status is `2/2`\nreplicas ready. Then you can verify that your requests are routed by TraefikEE\nto the whoami application!\n\ncurl http://your.cluster.dns.org\n\n> Note: Once checked, you can of course cleanup the whoami application with docker\nstack rm whoami.\n\n--------------------------------------------------------------------------------\n\nWant to Go Further?\nThe TraefikEE image is available on the Docker store\n[https://store.docker.com/_/traefikee] with detailed setup instructions\n[https://store.docker.com/_/traefikee/plans/e4082b3e-9d65-425b-a21f-5f1b7b156f2e?tab=instructions]\n. Don‚Äôt hesitate to give it a try for free\n[https://traefik.io/traefik-enterprise]!\n\n> Huge thanks goes to Brent Salisbury [https://twitter.com/networkstatic] for his\nhelp during the Docker certification process.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Ready for the Future</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/12/image.png\" class=\"kg-image\" alt></figure><p>Building business critical solutions often requires more than leveraging the best tools available ‚Äî it requires partners to rely on.</p><p>Traefik, as one of the most acclaimed open source edge routers, benefits from a vibrant and supportive community. With the enterprise edition, not only did we add business-centric features to improve user experience, security, availability, and scalability. Additionally, we also made premium support a reality.</p><p>TraefikEE is a production-grade, distributed, and highly available routing solution, and today we‚Äôre proud to announce that it is <a href=\"https://store.docker.com/_/traefikee\" rel=\"noopener\">certified as such</a>!</p><p><strong><strong>What Does it Mean?</strong></strong></p><p>TraefikEE has been tested and is supported by Docker Enterprise. It complies with Docker best practices guidelines, has proven provenance, and has been scanned for security vulnerabilities.</p><h2 id=\"see-it-in-action-\">See It in Action!</h2><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/joOuUy1ZD7E?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure><h2 id=\"test-it-\">Test It!</h2><blockquote><em><em><strong><strong>Note</strong></strong>: If you don‚Äôt have your license key yet, request <a href=\"https://traefik.io/traefik-enterprise\">your free trial</a> on our website and download <a href=\"https://docs.containo.us/installing/teectl-cli/\">traefikeectl</a>.</em></em></blockquote><h3 id=\"installation\">Installation</h3><p>Here is a Swarm One Line Installation:</p><pre><code class=\"language-bash\">traefikeectl install \\\n  --swarm \\\n  --dashboard \\\n  --licensekey=\"${TRAEFIKEE_LICENSE_KEY}\" \\\n  --clustername=traefikee-swarm</code></pre><blockquote><em><em>You can learn more about the command-line options used on the <code>traefikeectl install</code> <a href=\"https://docs.containo.us/installing/teectl-cli/\">Reference Guide</a></em></em></blockquote><h3 id=\"configuration\">Configuration</h3><p>Manage the cluster with <code>traefikeectl</code>:<em><em> </em></em></p><pre><code class=\"language-bash\">traefikeectl list-nodes --clustername=traefikee-swarm\n\ntraefikeectl backup --clustername=traefikee-swarm\n\n# ...\n</code></pre><p><br>Deploy a customized routing configuration to create the Traefik entrypoints:</p><pre><code class=\"language-bash\">traefikeectl deploy --clustername=traefikee-swarm \\\n \t--docker.swarmmode \\\n \t--entryPoints='Name:http Address::80' \\\n \t--entryPoints='Name:https Address::443 TLS' \\\n \t--defaultentrypoints=https,http</code></pre><blockquote><em><em><strong><strong>Note:</strong></strong> TraefikEE uses the `80` and `443` ports internally, hence these values for the entrypoints.</em></em></blockquote><h3 id=\"deploy-a-demo-application\">Deploy a Demo Application</h3><p>You can deploy applications in Docker Swarm using labels:</p><pre><code class=\"language-yaml\">version: '3.4'\nnetworks:\n  traefikee_net:\n    external: true\nservices:\n  whoami:\n    image: containous/whoami\n  deploy:\n    mode: replicated\n    replicas: 2\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.frontend.rule=Host:your.cluster.dns.org\"\n      - \"traefik.port=80\"\n      - \"traefik.backend=whoami\"\n  networks:\n    - traefikee_net</code></pre><blockquote><em><em><strong><strong>Note</strong></strong>: In the above example, <code>your.cluster.dns.org</code> is the DNS to reach your cluster.</em></em></blockquote><p>Deploy the application with the following command:</p><pre><code class=\"language-bash\">docker stack deploy whoami --compose-file=./whoami-stack.yaml</code></pre><p>With <code><em><em>docker service ls</em></em></code>, check that the application deployment status is `2/2` replicas ready. Then you can verify that your requests are routed by TraefikEE to the <code><em><em>whoami</em></em></code> application!</p><pre><code class=\"language-bash\">curl http://your.cluster.dns.org</code></pre><blockquote><em><em><strong><strong>Note</strong></strong>: Once checked, you can of course cleanup the <code><em>whoami</em></code> application with <code><em>docker stack rm whoami</em></code><em>.</em></em></em></blockquote><hr><h2 id=\"want-to-go-further\">Want to Go Further?</h2><p>The TraefikEE image is available on the <a href=\"https://store.docker.com/_/traefikee\" rel=\"noopener\">Docker store</a> with <a href=\"https://store.docker.com/_/traefikee/plans/e4082b3e-9d65-425b-a21f-5f1b7b156f2e?tab=instructions\" rel=\"noopener\">detailed setup instructions</a>. Don‚Äôt hesitate to give it a<a href=\"https://traefik.io/traefik-enterprise\"> try for free</a>!</p><blockquote>Huge thanks goes to <a href=\"https://twitter.com/networkstatic\" rel=\"noopener\">Brent Salisbury</a> for his help during the Docker certification process.</blockquote>","url":"https://containous.ghost.io/blog/traefikee-now-dockeree-certified-d926bf7255a4/","canonical_url":null,"uuid":"e3a24b5f-ac2c-41ca-bfac-357f8138b09b","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd6a50ab6de2b00381d3ff2","reading_time":2}},{"node":{"id":"Ghost__Post__5dd6a3a8b6de2b00381d3fbf","title":"Canary Releases with Traefik on GKE at HolidayCheck","slug":"canary-releases-with-traefik-on-gke-at-holidaycheck-d3c0928f1e02","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/canary.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/4c2bbcade8901a28828ba71afaa01bc5/619a6/canary.jpg","srcSet":"/static/4c2bbcade8901a28828ba71afaa01bc5/9dc27/canary.jpg 300w,\n/static/4c2bbcade8901a28828ba71afaa01bc5/4fe8c/canary.jpg 600w,\n/static/4c2bbcade8901a28828ba71afaa01bc5/619a6/canary.jpg 1068w","sizes":"(max-width: 1068px) 100vw, 1068px"}}},"excerpt":"In this post, I would like to introduce you into how Traefik helped us shape our cloud ecosystem at HolidayCheck...","custom_excerpt":"In this post, I would like to introduce you into how Traefik helped us shape our cloud ecosystem at HolidayCheck...","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"May 21, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-21T14:48:08.000+00:00","published_at":"2019-05-21T14:47:00.000+00:00","updated_at":"2020-05-22T00:09:11.000+00:00","meta_title":"Canary Releases with Traefik on GKE at HolidayCheck","meta_description":"In this post, I would like to introduce you into how Traefik helped us shape our cloud ecosystem at HolidayCheck...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Case Studies","slug":"case-studies","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":"Learn from our users and customers why they choose Traefik and TraefikEE as a modern load balancer to manage network traffic.","meta_title":"Case studies | Containous","visibility":"public"}],"plaintext":"In this post, I would like to introduce you into how Traefik [/traefik/] helped\nus shape our cloud ecosystem at HolidayCheck\n[https://www.holidaycheckgroup.com/?lang=en]. In particular, I will give a brief\nin-depth introduction on how we implemented our canary release process for our\nmicroservice architecture with Traefik on Google Kubernetes Engine (GKE).\n\nAbout HolidayCheck\nHolidayCheck AG operates the biggest independent hotel review and booking portal\nin the German-speaking area. Our vision is to become the most Urlauber*-friendly\ncompany in the world! Our business portfolio has full package (flight, hotel,\ninsurance), hotel-only, and cruise offerings. In addition to that, we are a\nplatform which shares hotel reviews and pictures.\n\n * Urlauber: German term for holidaymaker, vacationer\n\nBackground\nOur teams strive to keep a high level of urgency for delivery. Therefore they\nmaintain their delivery pipelines themselves. An inquiry across our continuous\ndelivery (CD) pipelines showed that our teams use one of the following designs:\n\n * Production follows Staging: This is the most classic design among all. It\n   prevails in services with older staged workflows where changes are tested in\n   an isolated staging environment without real user traffic.\n * Production with Feature Flags: This workflow is in place for a constant high\n   pace of changes, especially with UX impact.\n * Production with A/B Tests: Another variation of the last design is to keep\n   multiple versions of the system online (e.g., A and B version) and split user\n   traffic manually by an operator.\n\nAlthough all three designs have a positive impact on our release quality\nalready, they are still very tedious to operate or widen the human error vector.\nTo minimize toil and human errors, we introduced another complementary release\nstrategy ‚Äî canary releases.\n\nCanary Releases: Our Design\nIn short canary releases is an automation extension for our CD pipelines to\ncompare a new release (the canary group) against the previous version. Ideally,\nthe old deployment (the main group) is not touched by this operation. Instead, a\nnew deployment with the old configuration, the control group, is created at the\nsame time as the canary.\n\nOur design is based upon a strict set of decisions:\n\n 1. User traffic needs to be split across the main deployment and the other two\n    groups, whereas canary and control need an equal traffic share to keep\n    comparisons sane.\n 2. The CD pipeline needs a data source (e.g., metrics, logs, etc.) to evaluate\n    the canary soundness in comparison to the control instance. The decisions\n    can vary from shifting more traffic to the canary/control group, take canary\n    down or replace the current main with the canary.\n 3. The three instance groups need to operate independently from each other in\n    isolation.\n\nEnter Traefik Splitting\nOne of the significant benefits to using Traefik is that we can rely on building\non low-entry barrier features. Although our platform is hosted on GKE, we still\nneed to tailor features according to our use cases. Canary releases being one of\nthem requires us to split traffic across deployments.\n\nTraefik being our single proxy to route traffic to our deployments, has a\nbuilt-in feature to split traffic across deployment groups through a single\nIngress. Therefore a canary deployment can be accomplished with the following\nIngress specification:\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-service: 60%\n      my-service-canary: 20%\n      my-service-control: 20%\n  name: my-service\nspec:\n  rules:\n  - http:\n      paths:\n      - backend:\n          serviceName: my-service\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-service-canary\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-service-control\n          servicePort: 80\n        path: /\n\nOur Canary Workflow\nDespite that traffic splitting is a cornerstone to enable canary releases, it is\nnot sufficient. We still need to handle our canary deployments on GKE\nautomatically. Our CDs should be able to automatically make one of the following\ndecisions by comparing the canary with the control group:\n\n 1. Split more traffic from the main group to the canary and control groups.\n 2. Demote the canary and control groups because of an unacceptable error rate\n    and shift full traffic back to the main group.\n 3. Promote the canary group to become the new main group and remove the control\n    and old main groups.\n\nFurthermore, before traffic splitting we need to provide resources for our\ncanary and control deployments. On the one hand, this ensures that an\nappropriate replica count exists to handle the traffic. On the other hand,\ntraffic splitting can only happen from a third-party inside Kubernetes that can\nobserve the replica count of the canary and control deployments.\n\nIn short, the above CD decisions are accomplished by sending updates for the\ncanary and control deployments to the Kubernetes API server. A separate canary\ncontroller handles the rest.\n\nThe Canary Controller\nAfter sending the updates to Kubernetes the deployments of the canary and\ncontrol groups, as well as the Ingress object, will be reconciled by a canary\ncontroller. The controller is responsible for the following actions:\n\n * Scale the canary and control deployments:\n   The number of replicas for the canary and control deployments is based on the\n   traffic share\n\ncanaryReplicas = controlGroupReplicas =\n  ceil(appReplicas * canaryTrafficPercent / 100)\n\n * Enable the canary and control deployments: This means to identify the Ingress\n   object of the main deployment and add the service weights annotation for each\n   deployment.\n * Disable the canary and control deployments: In case of promotion/demotion of\n   the canary release, the controller removes the service weights from the\n   Ingress object.\n\nA Canary Release from Kubernetes Perspective\nIf you are using Kubernetes, a simple deployment can contain multiple\nannotations to express use case specific information. Thus, our CD pipelines\ncommunicate each action by updating the annotations of the required deployment\nspecifications. These annotations declare the requested state of our canary\nrelease, which in turn is reconciled by the canary controller.\n\nOur canary release implementation requires the following annotations to express\nthe state, as well as the Traefik service weight per deployment:\n\n * holidaycheck.com/canary-active: bool: Represents the current state of the\n   canary release in each canary and control deployment.\n * holidaycheck.com/canary-percent: float: Represents the service weight which\n   should be applied for each the canary and control deployment.\n\nLet‚Äôs say we have a service my-service at version v1.6:\n\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: my-service\n  namespace: my-namespace\nspec:\n  replicas: 10\n  template:\n      name: my-service\n    spec:\n      automountServiceAccountToken: false\n      containers:\n      - image: our-registry/my-service:v1.6\n        imagePullPolicy: IfNotPresent\n\nWe want to evaluate a newer version v1.7 of this service with a canary release,\ne.g.:\n\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  annotations:\n    holidaycheck.com/canary-active: \"false\"\n    holidaycheck.com/canary-percent: \"20.0\"\n  name: my-service-canary\n  namespace: my-namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: my-service-canary\n    spec:\n      containers:\n      - image: our-registry/my-service:v1.7\n\nAccordingly, a control deployment will be an almost identical copy of the main\ndeployment specification. The only addition here is the extra annotations, e.g.:\n\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  annotations:\n    holidaycheck.com/canary-active: \"false\"\n    holidaycheck.com/canary-percent: \"20.0\"\n  name: my-service-control\n  namespace: my-namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: my-service-control\n    spec:\n      containers:\n      - image: our-registry/my-service:v1.6\n\nNext, the canary controller will reconcile the state of our three deployments to\nadhere to our replica count specification. Therefore splitting 20% of our\ntraffic from a deployment with ten replicas results in canary and control\ndeployments with two replicas each.\n\nFinally, the controller will translate the canary annotation canary-percent for\neach deployment to the appropriate Traefik service weights annotation in the\nIngress object. Also the canary-active will be set to true for the canary and\ncontrol deployments:\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-service: 60%\n      my-service-control: 20%\n      my-service-canary: 20%\n  name: my-service\n\nNote: To minimize toil creating the above specifications, our teams use a small\nCLI tool that generates and applies those for them to Kubernetes.\n\nChallenges\nOne challenge remains, namely how to separate Traefik backend metrics per\nendpoint. The current Traefik v1.7implementation does not provide a distinction\nof metrics per backend endpoint. However, you can circumvent this issue by\nrelying on application level metrics, which can be separated by custom labels\nfor the canary, control, and main group accordingly.\n\nConclusion\nI hope this article has been helpful and will help you to tailor your canary\nrelease workflow for your platform based on Traefik‚Äôs excellent features.\n\nIn summary, we met our main goal to build a slim solution for canary releases\nwith Traefik without introducing the complexity of a full service mesh.\n\nThe above implementation is based on:\n\n * Traefik v1.7\n * Kubernetes v1.12","html":"<p>In this post, I would like to introduce you into how <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> helped us shape our cloud ecosystem at <a href=\"https://www.holidaycheckgroup.com/?lang=en\" rel=\"noopener\">HolidayCheck</a>. In particular, I will give a brief in-depth introduction on how we implemented our canary release process for our microservice architecture with Traefik on Google Kubernetes Engine (GKE).</p><h2 id=\"about-holidaycheck\">About HolidayCheck</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-22.png\" class=\"kg-image\"></figure><p>HolidayCheck AG operates the biggest independent hotel review and booking portal in the German-speaking area. Our vision is to become the most Urlauber*-friendly company in the world! Our business portfolio has full package (flight, hotel, insurance), hotel-only, and cruise offerings. In addition to that, we are a platform which shares hotel reviews and pictures.</p><ul><li><em><em>Urlauber: German term for holidaymaker, vacationer</em></em></li></ul><h2 id=\"background\">Background</h2><p>Our teams strive to keep a high level of urgency for delivery. Therefore they maintain their delivery pipelines themselves. An inquiry across our continuous delivery (CD) pipelines showed that our teams use one of the following designs:</p><ul><li><em><em>Production follows Staging</em></em>: This is the most classic design among all. It prevails in services with older staged workflows where changes are tested in an isolated staging environment without real user traffic.</li><li><em><em>Production with Feature Flags</em></em>: This workflow is in place for a constant high pace of changes, especially with UX impact.</li><li><em><em>Production with A/B Tests</em></em>: Another variation of the last design is to keep multiple versions of the system online (e.g., A and B version) and split user traffic manually by an operator.</li></ul><p>Although all three designs have a positive impact on our release quality already, they are still very tedious to operate or widen the human error vector. To minimize toil and human errors, we introduced another complementary release strategy ‚Äî canary releases.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-23.png\" class=\"kg-image\"></figure><h2 id=\"canary-releases-our-design\">Canary Releases: Our Design</h2><p>In short canary releases is an automation extension for our CD pipelines to compare a new release (<em><em>the canary group</em></em>) against the previous version. Ideally, the old deployment (<em><em>the main group</em></em>) is not touched by this operation. Instead, a new deployment with the old configuration, <em><em>the control group</em></em>, is created at the same time as the canary.</p><p>Our design is based upon a strict set of decisions:</p><ol><li>User traffic needs to be split across the main deployment and the other two groups, whereas canary and control need an equal traffic share to keep comparisons sane.</li><li>The CD pipeline needs a data source (e.g., metrics, logs, etc.) to evaluate the canary soundness in comparison to the control instance. The decisions can vary from shifting more traffic to the canary/control group, take canary down or replace the current main with the canary.</li><li>The three instance groups need to operate independently from each other in isolation.</li></ol><h2 id=\"enter-traefik-splitting\">Enter Traefik Splitting</h2><p>One of the significant benefits to using Traefik is that we can rely on building on low-entry barrier features. Although our platform is hosted on GKE, we still need to tailor features according to our use cases. Canary releases being one of them requires us to split traffic across deployments.</p><p>Traefik being our single proxy to route traffic to our deployments, has a built-in feature to split traffic across deployment groups through a single Ingress. Therefore a canary deployment can be accomplished with the following Ingress specification:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-service: 60%\n      my-service-canary: 20%\n      my-service-control: 20%\n  name: my-service\nspec:\n  rules:\n  - http:\n      paths:\n      - backend:\n          serviceName: my-service\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-service-canary\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-service-control\n          servicePort: 80\n        path: /</code></pre><h2 id=\"our-canary-workflow\">Our Canary Workflow</h2><p>Despite that traffic splitting is a cornerstone to enable canary releases, it is not sufficient. We still need to handle our canary deployments on GKE automatically. Our CDs should be able to automatically make one of the following decisions by comparing the canary with the control group:</p><ol><li>Split more traffic from the main group to the canary and control groups.</li><li>Demote the canary and control groups because of an unacceptable error rate and shift full traffic back to the main group.</li><li>Promote the canary group to become the new main group and remove the control and old main groups.</li></ol><p>Furthermore, before traffic splitting we need to provide resources for our canary and control deployments. On the one hand, this ensures that an appropriate replica count exists to handle the traffic. On the other hand, traffic splitting can only happen from a third-party inside Kubernetes that can observe the replica count of the canary and control deployments.</p><p>In short, the above CD decisions are accomplished by sending updates for the canary and control deployments to the Kubernetes API server. A separate canary controller handles the rest.</p><h2 id=\"the-canary-controller\">The Canary Controller</h2><p>After sending the updates to Kubernetes the deployments of the canary and control groups, as well as the Ingress object, will be reconciled by a canary controller. The controller is responsible for the following actions:</p><ul><li><em><em>Scale the canary and control deployments</em></em>:<br>The number of replicas for the canary and control deployments is based on the traffic share</li></ul><pre><code>canaryReplicas = controlGroupReplicas =\n  ceil(appReplicas * canaryTrafficPercent / 100)</code></pre><ul><li><em><em>Enable the canary and control deployments:</em></em> This means to identify the Ingress object of the main deployment and add the service weights annotation for each deployment.</li><li><em><em>Disable the canary and control deployments:</em></em> In case of promotion/demotion of the canary release, the controller removes the service weights from the Ingress object.</li></ul><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-24.png\" class=\"kg-image\"></figure><h2 id=\"a-canary-release-from-kubernetes-perspective\">A Canary Release from Kubernetes Perspective</h2><p>If you are using Kubernetes, a simple deployment can contain multiple annotations to express use case specific information. Thus, our CD pipelines communicate each action by updating the annotations of the required deployment specifications. These annotations declare the requested state of our canary release, which in turn is reconciled by the canary controller.</p><p>Our canary release implementation requires the following annotations to express the state, as well as the Traefik service weight per deployment:</p><ul><li><code>holidaycheck.com/canary-active: bool</code>: Represents the current state of the canary release in each canary and control deployment.</li><li><code>holidaycheck.com/canary-percent: float</code>: Represents the service weight which should be applied for each the canary and control deployment.</li></ul><p>Let‚Äôs say we have a service <code>my-service</code> at version <code>v1.6</code>:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: my-service\n  namespace: my-namespace\nspec:\n  replicas: 10\n  template:\n      name: my-service\n    spec:\n      automountServiceAccountToken: false\n      containers:\n      - image: our-registry/my-service:v1.6\n        imagePullPolicy: IfNotPresent</code></pre><p>We want to evaluate a newer version <code>v1.7</code> of this service with a canary release, e.g.:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  annotations:\n    holidaycheck.com/canary-active: \"false\"\n    holidaycheck.com/canary-percent: \"20.0\"\n  name: my-service-canary\n  namespace: my-namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: my-service-canary\n    spec:\n      containers:\n      - image: our-registry/my-service:v1.7</code></pre><p>Accordingly, a control deployment will be an almost identical copy of the main deployment specification. The only addition here is the extra annotations, e.g.:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  annotations:\n    holidaycheck.com/canary-active: \"false\"\n    holidaycheck.com/canary-percent: \"20.0\"\n  name: my-service-control\n  namespace: my-namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: my-service-control\n    spec:\n      containers:\n      - image: our-registry/my-service:v1.6</code></pre><p>Next, the canary controller will reconcile the state of our three deployments to adhere to our replica count specification. Therefore splitting 20% of our traffic from a deployment with ten replicas results in canary and control deployments with two replicas each.</p><p>Finally, the controller will translate the canary annotation <code>canary-percent</code> for each deployment to the appropriate Traefik service weights annotation in the Ingress object. Also the <code>canary-active</code> will be set to <code>true</code> for the canary and control deployments:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-service: 60%\n      my-service-control: 20%\n      my-service-canary: 20%\n  name: my-service</code></pre><p><em><em>Note: To minimize toil creating the above specifications, our teams use a small CLI tool that generates and applies those for them to Kubernetes.</em></em></p><h2 id=\"challenges\">Challenges</h2><p>One challenge remains, namely how to separate Traefik backend metrics per endpoint. The current Traefik <code>v1.7</code>implementation does not provide a distinction of metrics per backend endpoint. However, you can circumvent this issue by relying on application level metrics, which can be separated by custom labels for the canary, control, and main group accordingly.</p><h2 id=\"conclusion\">Conclusion</h2><p>I hope this article has been helpful and will help you to tailor your canary release workflow for your platform based on Traefik‚Äôs excellent features.</p><p>In summary, we met our main goal to build a slim solution for canary releases with Traefik without introducing the complexity of a full service mesh.</p><p>The above implementation is based on:</p><ul><li>Traefik v1.7</li><li>Kubernetes v1.12</li></ul>","url":"https://containous.ghost.io/blog/canary-releases-with-traefik-on-gke-at-holidaycheck-d3c0928f1e02/","canonical_url":null,"uuid":"f2a7086b-dc30-4f82-8a20-d90968a1285f","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd6a3a8b6de2b00381d3fbf","reading_time":6}},{"node":{"id":"Ghost__Post__5dd6a17eb6de2b00381d3fa8","title":"With Great Community ‚Ä¶","slug":"with-great-community-2b9d97485eb8","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/great-community.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/e69a61d9ae605008e0470bd675753529/47498/great-community.jpg","srcSet":"/static/e69a61d9ae605008e0470bd675753529/9dc27/great-community.jpg 300w,\n/static/e69a61d9ae605008e0470bd675753529/4fe8c/great-community.jpg 600w,\n/static/e69a61d9ae605008e0470bd675753529/47498/great-community.jpg 1200w,\n/static/e69a61d9ae605008e0470bd675753529/52258/great-community.jpg 1800w,\n/static/e69a61d9ae605008e0470bd675753529/a41d1/great-community.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Recently, we were made aware that some users had misconfigured instances of Traefik, which could have exposed sensitive data...","custom_excerpt":"Recently, we were made aware that some users had misconfigured instances of Traefik, which could have exposed sensitive data...","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"June 5, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-21T14:38:54.000+00:00","published_at":"2019-06-05T14:38:00.000+00:00","updated_at":"2020-05-21T22:32:54.000+00:00","meta_title":"With Great Community... Comes Great Responsibility","meta_description":"Recently, we were made aware that some users had misconfigured instances of Traefik, which could have exposed sensitive data...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Community","slug":"community","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"‚Ä¶ Comes Great Responsibility\n\nThere is not a single day when we aren‚Äôt proud of our community and inspired by\nthe many people using Traefik. One of our greatest accomplishments with Traefik\nis its simplicity: making it possible for everyone to run microservices\narchitecture with ease.\n\nBut, with so many people using Traefik, we realized that it‚Äôs not only important\nto make sure that best practices are well documented, but that the time has come\nto think about ways to enforce best practices.\n\nRecently, we were made aware that some users had misconfigured instances of\nTraefik, which could have exposed sensitive data: Traefik embeds a dashboard\nthat lets administrators see the existing routes (and, their parameters). And,\nif this dashboard (and its APIs) was enabled and was made public (no protection,\nand accessible from the outside), then potential attackers would have been able\nto access sensitive configuration data.\n\nIn both cases, we released a fix as quickly as possible, and made a CVE (\nCVE-2019‚Äì12452 [https://www.cvedetails.com/cve/CVE-2019-12452/], CVE-2018‚Äì15598\n[https://www.cvedetails.com/cve/CVE-2018-15598/]) to disclose the information.\n\n> ‚ÄúEven though we don‚Äôt like stumbling onto security issues, running an\nopen-source project means being open and transparent about what‚Äôs happening.‚Äù\nAm I Impacted by This CVE?\nYou are impacted if you meet all the following criteria:\n\n * Running Traefik v1.7.11 or older,\n * And, the API is enabled (either with the directive [api] in traefik.toml,\n   with the command line flag --api, or with the deprecated directive [web] in \n   traefik.toml),\n * And, the API is not secured with authentication (but should be, see the \n   documentation [https://docs.traefik.io]),\n * And, the API is exposed on a non trusted network.\n\nIn this case, we recommend you to do the following:\n\n * Update to the latest stable version of Traefik (1.7.12\n   [https://github.com/containous/traefik/releases/tag/v1.7.12]),\n * Not expose the API/Dashboard (or, to disable it),\n * Configure the authentication [https://docs.traefik.io/operations/api/] if you\n   need the API/Dashboard to be accessible.\n\nCombining User Experience with Security\nHaving a user-friendly dashboard is one of the praised features of Traefik, but\nit‚Äôs our responsibility to make sure people can‚Äôt misconfigure it in a\npotentially harmful way.\n\nWe‚Äôve started a discussion here\n[https://github.com/containous/traefik/issues/4934] to find better ways to let\nour users enjoy a full-featured dashboard, but in a way that enforces security,\nand that doesn‚Äôt enable this feature unless using proper credentials.\n\nIn the meantime, once again, never ever expose your Traefik dashboard/API to the\noutside with no protection.\n\n\n--------------------------------------------------------------------------------\n\nWe also want to use this opportunity to tell our users enabling the access log\noption to remember to filter/redact sensitive data. Please, validate your\nconfiguration and make sure you don‚Äôt log sensible data.\n\n# example of how to keep / redact / drop data from the logs\n[accessLog.fields.headers]\n      defaultMode = \"keep\"\n      [accessLog.fields.headers.names]\n        \"User-Agent\" = \"redact\"\n        \"Authorization\" = \"drop\"\n        \"Content-Type\" = \"keep\"\n        # ...\n\n(Thanks goes to captn3m0 [https://github.com/captn3m0] for making sure we added\nthis reminder about logs.)\n\n\n--------------------------------------------------------------------------------\n\nReferences\n * CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12452\n * Traefik Release with the fix: \n   https://github.com/containous/traefik/releases/tag/v1.7.12\n * Traefik‚Äôs Documentation for Securing the API/Dashboard: \n   https://docs.traefik.io/operations/api/\n * Announcement on Traefik‚Äôs Security Mailing List: \n   https://groups.google.com/a/traefik.io/forum/#!topic/security/Hez9dsOFCA4\n * Discussion about the Dashboard/API features and security: \n   https://github.com/containous/traefik/issues/4934","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">‚Ä¶ Comes Great Responsibility</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-full\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-117.png\" class=\"kg-image\"></figure><p>There is not a single day when we aren‚Äôt proud of our community and inspired by the many people using Traefik. One of our greatest accomplishments with Traefik is its simplicity: making it possible for everyone to run microservices architecture with ease.</p><p>But, with so many people using Traefik, we realized that it‚Äôs not only important to make sure that best practices are well documented, but that the time has come to think about ways to <em><em>enforce</em></em> best practices.</p><p>Recently, we were made aware that some users had misconfigured instances of Traefik, which could have exposed sensitive data: Traefik embeds a dashboard that lets administrators see the existing routes (and, their parameters). And, if this dashboard (and its APIs) was enabled and was made public (no protection, and accessible from the outside), then potential attackers would have been able to access sensitive configuration data.</p><p>In both cases, we released a fix as quickly as possible, and made a CVE (<a href=\"https://www.cvedetails.com/cve/CVE-2019-12452/\" rel=\"noopener\">CVE-2019‚Äì12452</a>, <a href=\"https://www.cvedetails.com/cve/CVE-2018-15598/\" rel=\"noopener\">CVE-2018‚Äì15598</a>) to disclose the information.</p><blockquote>‚ÄúEven though we don‚Äôt like stumbling onto security issues, running an open-source project means being open and transparent about what‚Äôs happening.‚Äù</blockquote><h2 id=\"am-i-impacted-by-this-cve\">Am I Impacted by This CVE?</h2><p>You are impacted if you meet all the following criteria:</p><ul><li>Running Traefik v1.7.11 or older,</li><li><strong><strong>And,</strong></strong> the API is enabled (either with the directive <code>[api]</code> in <code>traefik.toml</code>, with the command line flag <code>--api</code>, or with the <em><em>deprecated</em></em> directive <code>[web]</code> in <code>traefik.toml</code>),</li><li><strong><strong>And,</strong></strong> the API is not secured with authentication (but should be, see the <a href=\"https://docs.traefik.io\">documentation</a>),</li><li><strong><strong>And,</strong></strong> the API is exposed on a non trusted network.</li></ul><p>In this case, we recommend you to do the following:</p><ul><li>Update to the latest stable version of Traefik (<a href=\"https://github.com/containous/traefik/releases/tag/v1.7.12\" rel=\"noopener\">1.7.12</a>),</li><li><em><em>Not</em></em> expose the API/Dashboard (or, to disable it),</li><li><a href=\"https://docs.traefik.io/operations/api/\">Configure the authentication</a> if you need the API/Dashboard to be accessible.</li></ul><h2 id=\"combining-user-experience-with-security\">Combining User Experience with Security</h2><p>Having a user-friendly dashboard is one of the praised features of Traefik, but it‚Äôs our responsibility to make sure people can‚Äôt misconfigure it in a potentially harmful way.</p><p>We‚Äôve <a href=\"https://github.com/containous/traefik/issues/4934\" rel=\"noopener\">started a discussion here</a> to find better ways to let our users enjoy a full-featured dashboard, but in a way that enforces security, and that doesn‚Äôt enable this feature unless using proper credentials.</p><p>In the meantime, once again, never <em><em>ever</em></em> expose your Traefik dashboard/API to the outside with no protection.</p><hr><p>We also want to use this opportunity to tell our users enabling the access log option to remember to <em><em>filter/redact </em></em>sensitive data. Please, validate your configuration and make sure you don‚Äôt log sensible data.</p><pre><code class=\"language-toml\"># example of how to keep / redact / drop data from the logs\n[accessLog.fields.headers]\n      defaultMode = \"keep\"\n      [accessLog.fields.headers.names]\n        \"User-Agent\" = \"redact\"\n        \"Authorization\" = \"drop\"\n        \"Content-Type\" = \"keep\"\n        # ...</code></pre><p><em><em>(Thanks goes to </em></em><a href=\"https://github.com/captn3m0\" rel=\"noopener\"><em><em>captn3m0</em></em></a><em><em> for making sure we added this reminder about logs.)</em></em></p><hr><h2 id=\"references\">References</h2><ul><li>CVE: <a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12452\" rel=\"noopener\">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12452</a></li><li>Traefik Release with the fix: <a href=\"https://github.com/containous/traefik/releases/tag/v1.7.12\" rel=\"noopener\">https://github.com/containous/traefik/releases/tag/v1.7.12</a></li><li>Traefik‚Äôs Documentation for Securing the API/Dashboard: <a href=\"https://docs.traefik.io/operations/api/\">https://docs.traefik.io/operations/api/</a></li><li>Announcement on Traefik‚Äôs Security Mailing List: <a href=\"https://groups.google.com/a/traefik.io/forum/#!topic/security/Hez9dsOFCA4\" rel=\"noopener\">https://groups.google.com/a/traefik.io/forum/#!topic/security/Hez9dsOFCA4</a></li><li>Discussion about the Dashboard/API features and security: <a href=\"https://github.com/containous/traefik/issues/4934\" rel=\"noopener\">https://github.com/containous/traefik/issues/4934</a></li></ul>","url":"https://containous.ghost.io/blog/with-great-community-2b9d97485eb8/","canonical_url":null,"uuid":"a7a301fd-9e09-4443-a554-60fca62c4be0","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd6a17eb6de2b00381d3fa8","reading_time":2}},{"node":{"id":"Ghost__Post__5dd69298b6de2b00381d3f96","title":"How to Pronounce Traefik?","slug":"how-to-pronounce-traefik-d06696a3f026","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/traefik-pron.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/0b7d4ac8468e89c4c03827ce915a85b4/47498/traefik-pron.jpg","srcSet":"/static/0b7d4ac8468e89c4c03827ce915a85b4/9dc27/traefik-pron.jpg 300w,\n/static/0b7d4ac8468e89c4c03827ce915a85b4/4fe8c/traefik-pron.jpg 600w,\n/static/0b7d4ac8468e89c4c03827ce915a85b4/47498/traefik-pron.jpg 1200w,\n/static/0b7d4ac8468e89c4c03827ce915a85b4/52258/traefik-pron.jpg 1800w,\n/static/0b7d4ac8468e89c4c03827ce915a85b4/a41d1/traefik-pron.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"How to Pronounce Traefik?\nThe Answer to the infamous question, ‚ÄúHow do you pronounce Traefik?‚Äù lies in the Question...","custom_excerpt":"How to Pronounce Traefik?\nThe Answer to the infamous question, ‚ÄúHow do you pronounce Traefik?‚Äù lies in the Question...","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"June 18, 2019","updated_at_pretty":"04 December, 2019","created_at":"2019-11-21T13:35:20.000+00:00","published_at":"2019-06-18T13:35:00.000+00:00","updated_at":"2019-12-04T00:21:35.000+00:00","meta_title":"How to Pronounce Traefik? The Answer Lies in the Question","meta_description":"How to Pronounce Traefik?\nThe Answer to the infamous question, ‚ÄúHow do you pronounce Traefik?‚Äù lies in the Question...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Company","slug":"company","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"The Answer Lies in the Question\n\nIf you‚Äôre here reading (at last!) the official answer to the infamous question,\n‚ÄúHow do you pronounce Traefik?‚Äù, then chances are you‚Äôre a Traefik user who has\nhad passionate debates with your colleagues around this weird looking character \n√¶ which shares the lines between an a and an e. (And chances are you already\nchose a distinct way to pronounce ‚ÄúTr√¶fik‚Äù that avoids confusion when talking\nabout how you handle traffic in Traefik ‚Ä¶ but that‚Äôs a different story.)\n\nDanish, Norwegian, Icelandic, or Faroese?\nOf course, if you speak Danish, Norwegian, Icelandic, or Faroese, then you‚Äôre\nfamiliar with the √¶sc grapheme. If so, you‚Äôre probably ready to bet a coffee on\nthe answer. On the other hand, the question still lingering in your mind has\ndrifted to, ‚ÄúWhy did they use the Danish character in Traefik? Are they Danish?‚Äù\n\nFrench?\nIf you‚Äôre French, you know for sure that this ligature looks like the e coul√© (a\npun for children to remember that the ‚Äúe is in the o‚Äù ‚Ä¶ o sounds like ‚Äúwater‚Äù in\nFrench ‚Ä¶ so ‚Äúe coul√©‚Äù literally translates to, ‚Äúsunken e‚Äù).\n\nBut even if you‚Äôve seen this syntax trick in words like ‚Äúc≈ìur‚Äù (heart), ‚Äú≈ìuf‚Äù (\neggs), ‚Äús≈ìur‚Äù (sister), or ‚Äú≈ìuvre‚Äù (work), you can‚Äôt find a single word with the\nsame ligature involving ana and an e (and even if you‚Äôd find one eventually, you\nwouldn‚Äôt put it in your curriculum vit√¶ anyways).\n\nEnglish?\nIf you‚Äôre a native English speaker, you know for sure that there are no such\nletter combinations in English (OK ‚Ä¶ apart from ph≈ìnix, but a gopher is not even\nclose to having wings ‚Ä¶ until you remember that there are other √¶therical\ncreatures ‚Ä¶ that there was a C√¶sar √¶ra ‚Ä¶ and that it won‚Äôt take you √¶ons before\nyou can find other examples ‚Ä¶ so the √¶ in Traefik might not be ‚Äújust an √¶sthetic\nchoice‚Äù).\n\nNon-native English speakers?\nTraefik, as an open-source project [https://github.com/containous/traefik], is\nthe result of many people working together. Containous [https://containo.us/],\nas a distributed company, has employees all over the world (and we‚Äôre hiring\n[https://containo.us/careers/]!). So the blunt answer could also be, ‚ÄúWe\npronounce Traefik the best we can.‚Äù\n\nSo many languages ‚Ä¶\nSo no, this ligature in Traefik has nothing to do with the etymology of the\nword. This ligature is the result of the very question, ‚ÄúHow do you pronounce\nTraefik?‚Äù\n\nTo answer this question, we‚Äôll use the International Phonetic Alphabet (IPA) and\nwill write:\n\n> You pronounce Traefik like the regular word Traffic\n[https://dictionary.cambridge.org/dictionary/english/traffic] (/Ààtr√¶f…™k/)\nWhile designing the logo, we‚Äôve just been sloppy and got rid of the stress Àà and\nsince French people are not able to make a proper …™ sound, we replaced it with\nan i.\n\nNow you know!\nEven though the official answer is out, we still hope to see many Traefik users\napproaching us and asking us the same question over and over again, ‚ÄúHow do you\npronounce Traefik?‚Äù simply because it‚Äôs the only thing they haven‚Äôt figured out\nfrom the documentation.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">The Answer Lies in the Question</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-full\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-116.png\" class=\"kg-image\"></figure><p>If you‚Äôre here reading (at last!) the official answer to the infamous question, ‚ÄúHow do you pronounce Traefik?‚Äù, then chances are you‚Äôre a Traefik user who has had passionate debates with your colleagues around this weird looking character <code>√¶</code> which shares the lines between an <code>a</code> and an <code>e</code>. (And chances are you already chose a distinct way to pronounce ‚ÄúTr√¶fik‚Äù that avoids confusion when talking about how you handle traffic in Traefik ‚Ä¶ but that‚Äôs a different story.)</p><h3 id=\"danish-norwegian-icelandic-or-faroese\">Danish, Norwegian, Icelandic, or Faroese?</h3><p>Of course, if you speak Danish, Norwegian, Icelandic, or Faroese, then you‚Äôre familiar with the <code>√¶sc</code> grapheme. If so, you‚Äôre probably ready to bet a coffee on the answer.<strong><strong> </strong></strong>On the other hand<strong><strong>, </strong></strong>the question still lingering in your mind has drifted to, ‚ÄúWhy did they use the Danish character in Traefik? Are they Danish?‚Äù</p><h3 id=\"french\">French?</h3><p>If you‚Äôre French, you know for sure that this ligature looks like the <code><em><em>e coul√©</em></em></code> (a pun for children to remember that the ‚Äú<em><em>e is in the o‚Äù</em></em> ‚Ä¶ <code>o</code> sounds like ‚Äúwater‚Äù in French ‚Ä¶ so ‚Äú<em><em>e coul√©‚Äù</em></em> literally translates to, ‚Äú<em><em>sunken e‚Äù</em></em>).</p><p>But even if you‚Äôve seen this syntax trick in words like ‚Äúc≈ìur‚Äù (<em><em>heart</em></em>), ‚Äú≈ìuf‚Äù (<em><em>eggs</em></em>), ‚Äús≈ìur‚Äù (<em><em>sister</em></em>), or ‚Äú≈ìuvre‚Äù (<em><em>work</em></em>), you can‚Äôt find a single word with the same ligature involving an<code>a</code> and an <code>e</code> (and even if you‚Äôd find one eventually, you wouldn‚Äôt put it in your <em><em>curriculum vit√¶</em></em> anyways).</p><h3 id=\"english\">English?</h3><p>If you‚Äôre a native English speaker, you know for sure that there are no such letter combinations in English (OK ‚Ä¶ apart from ph≈ìnix, but a gopher is not even close to having wings ‚Ä¶ until you remember that there are other √¶therical creatures ‚Ä¶ that there was a C√¶sar √¶ra ‚Ä¶ and that it won‚Äôt take you √¶ons before you can find other examples ‚Ä¶ so the <code>√¶</code> in Traefik might not be ‚Äújust an √¶sthetic choice‚Äù).</p><h3 id=\"non-native-english-speakers\">Non-native English speakers?</h3><p>Traefik, as an <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">open-source project</a>, is the result of many people working together. <a href=\"https://containo.us/\" rel=\"noopener\">Containous</a>, as a distributed company, has employees all over the world (and <a href=\"https://containo.us/careers/\" rel=\"noopener\">we‚Äôre hiring</a>!). So the blunt answer could also be, ‚ÄúWe pronounce Traefik the best we can.‚Äù</p><h3 id=\"so-many-languages-\">So many languages ‚Ä¶</h3><p>So no, this ligature in Traefik has nothing to do with the etymology of the word. This ligature is the result of the very question, ‚ÄúHow do you pronounce Traefik?‚Äù</p><p>To answer this question, we‚Äôll use the <em><em>International Phonetic Alphabet (IPA)</em></em> and will write:</p><blockquote><em><em>You pronounce Traefik like the regular word <a href=\"https://dictionary.cambridge.org/dictionary/english/traffic\" rel=\"noopener\">Traffic</a> (<strong><strong>/Ààtr√¶f…™k/</strong></strong>)</em></em></blockquote><p>While designing the logo, we‚Äôve just been sloppy and got rid of the stress <code>Àà</code> and since French people are not able to make a proper <code>…™</code><strong> </strong>sound, we replaced it with an <code>i</code>.</p><h3 id=\"now-you-know-\">Now you know!</h3><p>Even though the official answer is out, we still hope to see many Traefik users approaching us and asking us the same question over and over again, ‚ÄúHow do you pronounce Traefik?‚Äù simply because it‚Äôs the only thing they haven‚Äôt figured out from the documentation.</p>","url":"https://containous.ghost.io/blog/how-to-pronounce-traefik-d06696a3f026/","canonical_url":null,"uuid":"9add21c5-dcc3-4368-994c-039a86ea5f14","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd69298b6de2b00381d3f96","reading_time":2}},{"node":{"id":"Ghost__Post__5dd6923fb6de2b00381d3f86","title":"Announcing the Containous Community Forum!","slug":"announcing-the-containous-community-forum-d7828e220680","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/forum.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/216879e9c469a548f5fad1f416c23bff/f3583/forum.png","srcSet":"/static/216879e9c469a548f5fad1f416c23bff/630fb/forum.png 300w,\n/static/216879e9c469a548f5fad1f416c23bff/2a4de/forum.png 600w,\n/static/216879e9c469a548f5fad1f416c23bff/f3583/forum.png 1200w,\n/static/216879e9c469a548f5fad1f416c23bff/bbee5/forum.png 1800w,\n/static/216879e9c469a548f5fad1f416c23bff/ed396/forum.png 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"We‚Äôre thrilled to announce the launch of our community forum aimed at connecting and supporting our community.","custom_excerpt":"We‚Äôre thrilled to announce the launch of our community forum aimed at connecting and supporting our community.","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"June 25, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-21T13:33:51.000+00:00","published_at":"2019-06-25T13:33:00.000+00:00","updated_at":"2020-05-21T23:52:20.000+00:00","meta_title":"Announcing the Containous Community Forum!","meta_description":"We‚Äôre thrilled to announce the launch of our community forum aimed at connecting and supporting our community.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Marie Ponseel","slug":"marie","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/profile-picture.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Marie Ponseel","slug":"marie","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/profile-picture.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Community","slug":"community","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"We‚Äôre thrilled to announce the launch of our community forum\n[https://community.containo.us/] aimed at connecting and supporting our\ncommunity.\n\nWhy a Community Forum?\nTraefik [/traefik/] is a community of thousands of people around the world who\nare working with, and using Traefik on a daily basis. Until today, conversations\nhave been taking place on our Slack channel. But as the community grows, and\nusers of Traefik continue to engage, we‚Äôre seeing an increased set of commonly\nasked questions more and more frequently. In hopes of providing a more efficient\nway to help both new and experienced members, we are launching an open forum\nwhere anyone can post questions and search for any specific topic to find\nanswers from relevant past conversations.\n\nWith the forum, we also want to consolidate a dedicated base of knowledge for\neverything Traefik-related for our community. Whether you are a beginner or an\nadvanced user of Traefik, we hope the forum will serve as a valuable resource\nfor all your Traefik needs.\n\nWhat will I find in there?\nIf you are looking to get more involved and connected with our community, here‚Äôs\nwhat you‚Äôll find on community.containo.us [https://community.containo.us/]:\n\n * Connect with Traefik users from all around the world\n * Easily ask questions and get answers on any technical topics related to\n   Traefik\n * Share your experience and help other members\n * Connect with the core Traefik team, Traefik maintainers, and Traefik\n   contributors\n\nSign up and get started!\nThe forum is built using the popular Discourse platform. Creating an account is\nsuper easy ‚Äî just authenticate via email, or with your Github account.\n\nOnce you‚Äôre on the forum homepage, topics are classified by categories. The\ncategories are listed on the left side with the most recently asked topics on\nthe right side.\n\nYou‚Äôll be able to search for a topic, a post, or anything using the magnifying\nglass on the top right corner.\n\nAnd if you don‚Äôt find the answer you‚Äôre looking for, you can add a new post by\nclicking on the ‚ÄúNew Topic‚Äù button. From here, you only need to select a\ncategory, write a title, and your description. We encourage you to be as\nspecific as possible, and to give as much information as possible so that others\nmay have an easier time answering your question.\n\nWhile the community forum is brand new (and, therefore still pretty empty), you\nare officially invited to start using the forums for all support questions and\ndiscussions today!\n\nThe forum is moderated by Traefik contributors, but if you‚Äôd like to participate\nin answering questions, feel free to do so. This community forum is open and\nfree to everyone, so please join us [https://community.containo.us/]!\n\nWe‚Äôd love to hear your feedback!\nIf you have any suggestions or comments on how we could improve the forum, feel\nfree to contact us, we‚Äôd love to hear from you!\n\nWe look forward to seeing you in the forum [https://community.containo.us/]!","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-114.png\" class=\"kg-image\"></figure><p>We‚Äôre thrilled to announce the launch of <a href=\"https://community.containo.us/\" rel=\"noopener\">our community forum</a> aimed at connecting and supporting our community.</p><h2 id=\"why-a-community-forum\"><strong>Why a Community Forum?</strong></h2><p><a href=\"https://containous.ghost.io/traefik/\">Traefik</a> is a community of thousands of people around the world who are working with, and using Traefik on a daily basis. Until today, conversations have been taking place on our Slack channel. But as the community grows, and users of Traefik continue to engage, we‚Äôre seeing an increased set of commonly asked questions more and more frequently. In hopes of providing a more efficient way to help both new and experienced members, we are launching an open forum where anyone can post questions and search for any specific topic to find answers from relevant past conversations.</p><p>With the forum, we also want to consolidate a dedicated base of knowledge for everything Traefik-related for our community. Whether you are a beginner or an advanced user of Traefik, we hope the forum will serve as a valuable resource for all your Traefik needs.</p><h2 id=\"what-will-i-find-in-there\"><strong>What will I find in there?</strong></h2><p>If you are looking to get more involved and connected with our community, here‚Äôs what you‚Äôll find on <a href=\"https://community.containo.us/\" rel=\"noopener\"><strong><strong>community.containo.us</strong></strong></a>:</p><ul><li>Connect with Traefik users from all around the world</li><li>Easily ask questions and get answers on any technical topics related to Traefik</li><li>Share your experience and help other members</li><li>Connect with the core Traefik team, Traefik maintainers, and Traefik contributors</li></ul><h2 id=\"sign-up-and-get-started-\"><strong>Sign up and get started!</strong></h2><p>The forum is built using the popular Discourse platform. Creating an account is super easy ‚Äî just authenticate via email, or with your Github account.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-21.png\" class=\"kg-image\"></figure><p>Once you‚Äôre on the forum homepage, topics are classified by categories. The categories are listed on the left side with the most recently asked topics on the right side.</p><p>You‚Äôll be able to search for a topic, a post, or anything using the magnifying glass on the top right corner.</p><p>And if you don‚Äôt find the answer you‚Äôre looking for, you can add a new post by clicking on the ‚ÄúNew Topic‚Äù button. From here, you only need to select a category, write a title, and your description. We encourage you to be as specific as possible, and to give as much information as possible so that others may have an easier time answering your question.</p><p>While the community forum is brand new (and, therefore still pretty empty), you are officially invited to start using the forums for all support questions and discussions today!</p><p>The forum is moderated by Traefik contributors, but if you‚Äôd like to participate in answering questions, feel free to do so. This community forum is open and free to everyone, so please <a href=\"https://community.containo.us/\" rel=\"noopener\"><strong><strong>join us</strong></strong></a>!</p><h2 id=\"we-d-love-to-hear-your-feedback-\"><strong>We‚Äôd love to hear your feedback!</strong></h2><p>If you have any suggestions or comments on how we could improve the forum, feel free to contact us, we‚Äôd love to hear from you!</p><p>We look forward to seeing you <a href=\"https://community.containo.us/\" rel=\"noopener\">in the forum</a>!</p>","url":"https://containous.ghost.io/blog/announcing-the-containous-community-forum-d7828e220680/","canonical_url":null,"uuid":"03e9fed2-fe19-45c7-8bfd-69cad678dbad","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd6923fb6de2b00381d3f86","reading_time":2}},{"node":{"id":"Ghost__Post__5dd55473ec5ed300387889a5","title":"Announcing TraefikEE v1.1","slug":"announcing-traefikee-v1-1-1338e9b7cd79","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/traefikee-v1.1.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b0a42f21d3fb40cce89db9b6a9378543/f3583/traefikee-v1.1.png","srcSet":"/static/b0a42f21d3fb40cce89db9b6a9378543/630fb/traefikee-v1.1.png 300w,\n/static/b0a42f21d3fb40cce89db9b6a9378543/2a4de/traefikee-v1.1.png 600w,\n/static/b0a42f21d3fb40cce89db9b6a9378543/f3583/traefikee-v1.1.png 1200w,\n/static/b0a42f21d3fb40cce89db9b6a9378543/bbee5/traefikee-v1.1.png 1800w,\n/static/b0a42f21d3fb40cce89db9b6a9378543/ed396/traefikee-v1.1.png 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik Enterprise Edition is a platform built on top of Traefik. Version 1.1 offers Automatic Certificate Management, Distributed Features, and Enhanced...","custom_excerpt":"Traefik Enterprise Edition is a platform built on top of Traefik. Version 1.1 offers Automatic Certificate Management, Distributed Features, and Enhanced...","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"July 11, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T14:57:55.000+00:00","published_at":"2019-07-11T14:57:00.000+00:00","updated_at":"2020-05-21T23:53:47.000+00:00","meta_title":"Announcing TraefikEE v1.1","meta_description":"Traefik Enterprise 1.1 offers Automatic Certificate Management, Distributed Features, and support for Docker Enterprise","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Brendan LE GLAUNEC","slug":"brendan","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/NewAvatar.png","twitter":null,"facebook":null,"website":"https://github.com/Ullaakut"}],"primary_author":{"name":"Brendan LE GLAUNEC","slug":"brendan","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/NewAvatar.png","twitter":null,"facebook":null,"website":"https://github.com/Ullaakut"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Offers Automatic Certificate Management, Distributed Features, and Enhanced\nSupport for DockerEE\n\nIt‚Äôs been two months since the general availability\n[/blog/announcing-general-availability-of-traefik-enterprise-edition-9c9aad363ce/] \nof the 1.0 version of Traefik Enterprise Edition. Encouraged by its successful\nlaunch, and propelled by the immense feedback we received from customers, the\nteam started to work on 1.1 right away.\n\n> Traefik Enterprise Edition [/traefikee/] is a new platform built on top of \nTraefik [/traefik/], the popular open-source cloud-native edge router, designed\nfor business-critical deployments. It adds clustering features to satisfy the\nneeds of enterprise customers. See it in action in the video demonstration\n[https://info.containo.us/request-demo-traefikee]!\nSo, let‚Äôs see what‚Äôs new in this 1.1 for TraefikEE and traefikeectl, its control\ntool!\n\nACME Account & Certificate Management\nDesigned for users that already leverage Let‚Äôs Encrypt and its automatic\ncertificate management, TraefikEE 1.1 allows you to seamlessly import your\ncertificates right into the cluster.\n\ntraefikeectl acme-add-certificate \\\n\t--certfile=\"cert.pem\" \\\n\t--keyfile=\"key.pem\" \\\n\t--accountname=\"my account\"\n\nIn the process, it is now possible to manage ACME accounts within your TraefikEE\ncluster using the traefikee and traefikeectl binaries: ask TraefikEE to create\nACME accounts, or to import your existing accounts.\n\n# Adds your me@containo.us account to your TraefikEE cluster!\ntraefikeectl acme-add-account \\\n  --use \\\n  --caserver=\"https://caserver\" \\\n  --email=\"me@containo.us\" \\\n  --name=\"my account\" \n  --privatekey=\"key.pem\"\n  --uri=\"https://registration_uri.com‚Äù\n\nWant to learn more about these features, just check out the operating guide\n[https://docs.containo.us/operating/acme/] about TraefikEE 1.1.\n\nDistributed Rate Limiting\nTraefikEE makes autoscaling easy: deploy more data nodes as the number of\nincoming requests grows. Before 1.1, when you configured rate limiting for your\nunderlying services, each node had its own rate limiting. In 1.1, the control\nplane makes sure the rate limiting is distributed within the cluster.\n\nTraefikEE intercepts the rate limiting configuration and inject its own\ndistributed rate limiting middleware into Traefik.\n\nThe best part? The configuration remains exactly the same!\n\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: myservice\n  namespace: traefikee\n  labels:\n    app: myservice\n  annotations:\n    traefik.ingress.kubernetes.io/rate-limit: |\n      extractorfunc: client.ip\n      rateset:\n        bar:\n          period: 10s\n          average: 10000\n          burst: 10000\n\nThis service for example, has a cluster-wide rate limit set to 10,000 requests\nper client IP within 10 seconds.\n\nNetwork Automatic Discovery\nSome users were leveraging Docker Swarm [https://github.com/docker/swarm] \nnetwork capabilities to improve security on their cluster, making sure each\nservice used its own network.\n\nBefore 1.1, they had no choice but to attach another network to their services\nso that Traefik could reach them (and properly route the requests), or to attach\nthe new networks to TraefikEE itself. Since Traefik has always been about\ndynamic configuration, we weren‚Äôt satisfied with this situation.\n\nIn 1.1, TraefikEE (thanks to its redesigned architecture) is now able to\ndiscover the new networks and to reach them automatically.\n\nIt means that you are now able to add new applications from different Docker\nnetworks ‚Äî and TraefikEE will dynamically update the data plane to join those\nnetworks.\n\nYou can turn this feature on during installation time!\n\ntraefikeectl install \\\n  --swarm \\\n  --swarm.networkautodiscovery \\\n  --licensekey=\"$TRAEFIKEE_LICENSE_KEY\"\n\nDocker Enterprise Edition\nTraefikEE is Docker certified\n[/blog/traefikee-now-dockeree-certified-d926bf7255a4/]! It means that it has\nbeen tested and is supported by Docker Enterprise ‚Äî It complies with Docker best\npractices guidelines, has proven provenance, and has been scanned for security\nvulnerabilities.\n\nBefore 1.1, TraefikEE needed to install its control plane on the docker manager\nnodes, which could be a limitation.\n\nGood news, TraefikEE 1.1 can now be deployed on the worker nodes (and don‚Äôt even\nneed any manager node to fully operate).\n\nOn top of that, it now uses the UCP connector with enhanced security and proper\ncredentials.\n\nWhat‚Äôs Next?\nWith TraefikEE 1.1, we‚Äôre very proud to have helped our customers take full\nbenefit of Traefik and find ways to make sure every detail was taken care of.\n\nIn 1.2 (yes, there will be a 1.2 before the next big step!) we will keep\nimproving the user experience to make sure that managing a TraefikEE cluster is\nas simple as managing a single instance of Traefik, with extra benefits tailored\nfor the enterprise.\n\nTry it now!\nGet a free one month trial [/traefikee/] right now, and install TraefikEE on\nyour favorite environment by following the installation guides\n[https://docs.containo.us/].\n\nAnd if you want to learn more and see a live demo of TraefikEE 1.1, request a\ndemo [https://info.containo.us/request-demo-traefikee] today.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Offers Automatic Certificate Management, Distributed Features, and Enhanced Support for DockerEE</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-full\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-113.png\" class=\"kg-image\"></figure><p>It‚Äôs been two months since the <a href=\"https://containous.ghost.io/blog/announcing-general-availability-of-traefik-enterprise-edition-9c9aad363ce/\">general availability</a> of the 1.0 version of Traefik Enterprise Edition. Encouraged by its successful launch, and propelled by the immense feedback we received from customers, the team started to work on 1.1 right away.</p><blockquote><a href=\"https://containous.ghost.io/traefikee/\" rel=\"noopener\">Traefik Enterprise Edition</a> is a new platform built on top of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, the popular open-source cloud-native edge router, designed for business-critical deployments. It adds clustering features to satisfy the needs of enterprise customers. See it in action in the <a href=\"https://info.containo.us/request-demo-traefikee\">video demonstration</a>!</blockquote><p>So, let‚Äôs see what‚Äôs new in this 1.1 for TraefikEE <em><em>and</em></em> <code>traefikeectl</code>, its control tool!</p><h2 id=\"acme-account-certificate-management\">ACME Account &amp; Certificate Management</h2><p>Designed for users that already leverage Let‚Äôs Encrypt and its automatic certificate management, TraefikEE 1.1 allows you to seamlessly import your certificates right into the cluster.</p><pre><code class=\"language-shell\">traefikeectl acme-add-certificate \\\n\t--certfile=\"cert.pem\" \\\n\t--keyfile=\"key.pem\" \\\n\t--accountname=\"my account\"</code></pre><p>In the process, it is now possible to manage ACME accounts within your TraefikEE cluster using the <code>traefikee</code> and <code>traefikeectl</code> binaries: ask TraefikEE to create ACME accounts, or to import your existing accounts.</p><pre><code class=\"language-shell\"># Adds your me@containo.us account to your TraefikEE cluster!\ntraefikeectl acme-add-account \\\n  --use \\\n  --caserver=\"https://caserver\" \\\n  --email=\"me@containo.us\" \\\n  --name=\"my account\" \n  --privatekey=\"key.pem\"\n  --uri=\"https://registration_uri.com‚Äù</code></pre><p>Want to learn more about these features, just check out the <a href=\"https://docs.containo.us/operating/acme/\">operating guide</a> about TraefikEE 1.1.</p><h2 id=\"distributed-rate-limiting\">Distributed Rate Limiting</h2><p>TraefikEE makes autoscaling easy: deploy more data nodes as the number of incoming requests grows. Before 1.1, when you configured rate limiting for your underlying services, each node had its own rate limiting. In 1.1, the control plane makes sure the rate limiting is distributed within the cluster.</p><p>TraefikEE intercepts the rate limiting configuration and inject its own distributed rate limiting middleware into Traefik.</p><p>The best part? The configuration remains <strong><strong>exactly the same</strong></strong>!</p><pre><code class=\"language-yaml\">---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: myservice\n  namespace: traefikee\n  labels:\n    app: myservice\n  annotations:\n    traefik.ingress.kubernetes.io/rate-limit: |\n      extractorfunc: client.ip\n      rateset:\n        bar:\n          period: 10s\n          average: 10000\n          burst: 10000</code></pre><p>This service for example, has a cluster-wide rate limit set to 10,000 requests per client IP within 10 seconds.</p><h2 id=\"network-automatic-discovery\">Network Automatic Discovery</h2><p>Some users were leveraging <a href=\"https://github.com/docker/swarm\" rel=\"noopener\">Docker Swarm</a> network capabilities to improve security on their cluster, making sure each service used its own network.</p><p>Before 1.1, they had no choice but to attach another network to their services so that Traefik could reach them (and properly route the requests), or to attach the new networks to TraefikEE itself. Since Traefik has always been about dynamic configuration, we weren‚Äôt satisfied with this situation.</p><p>In 1.1, TraefikEE (thanks to its redesigned architecture) is now able to discover the new networks and to reach them automatically.</p><p>It means that you are now able to add new applications from different Docker networks ‚Äî and TraefikEE will dynamically update the data plane to join those networks.</p><p>You can turn this feature on during installation time!</p><pre><code class=\"language-shell\">traefikeectl install \\\n  --swarm \\\n  --swarm.networkautodiscovery \\\n  --licensekey=\"$TRAEFIKEE_LICENSE_KEY\"</code></pre><h2 id=\"docker-enterprise-edition\">Docker Enterprise Edition</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/proxy/1*YhmLMOeN6VJwGNqv-H_SiQ.jpeg\" class=\"kg-image\"></figure><p>TraefikEE is <a href=\"https://containous.ghost.io/blog/traefikee-now-dockeree-certified-d926bf7255a4/\">Docker certified</a>! It means that it has been tested and is supported by Docker Enterprise ‚Äî It complies with Docker best practices guidelines, has proven provenance, and has been scanned for security vulnerabilities.</p><p>Before 1.1, TraefikEE needed to install its control plane on the docker manager nodes, which could be a limitation.</p><p>Good news, TraefikEE 1.1 can now be deployed on the worker nodes (and don‚Äôt even need any manager node to fully operate).</p><p>On top of that, it now uses the UCP connector with enhanced security and proper credentials.</p><h2 id=\"what-s-next\">What‚Äôs Next?</h2><p>With TraefikEE 1.1, we‚Äôre very proud to have helped our customers take full benefit of Traefik and find ways to make sure every detail was taken care of.</p><p>In 1.2 (yes, there will be a 1.2 before the next big step!) we will keep improving the user experience to make sure that managing a TraefikEE cluster is as simple as managing a single instance of Traefik, with extra benefits tailored for the enterprise.</p><h2 id=\"try-it-now-\">Try it now!</h2><p>Get a <a href=\"https://containous.ghost.io/traefikee/\" rel=\"noopener\">free one month trial</a> right now, and install TraefikEE on your favorite environment by following the <a href=\"https://docs.containo.us/\">installation guides</a>.</p><p>And if you want to learn more and see a live demo of TraefikEE 1.1, <a href=\"https://info.containo.us/request-demo-traefikee\">request a demo</a> today.</p>","url":"https://containous.ghost.io/blog/announcing-traefikee-v1-1-1338e9b7cd79/","canonical_url":null,"uuid":"94d88173-729c-4f8d-9108-1443dbfbf758","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd55473ec5ed300387889a5","reading_time":3}},{"node":{"id":"Ghost__Post__5dd55551ec5ed300387889cc","title":"Can We Trust GitHub Stars?","slug":"can-we-trust-github-stars-e8aa8b6b0baa","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/1-Tswt2xxYYgoCa0kE-Wirfg.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/365a80dbb25a7f50aeb9b89c4e5d6b7e/f3583/1-Tswt2xxYYgoCa0kE-Wirfg.png","srcSet":"/static/365a80dbb25a7f50aeb9b89c4e5d6b7e/630fb/1-Tswt2xxYYgoCa0kE-Wirfg.png 300w,\n/static/365a80dbb25a7f50aeb9b89c4e5d6b7e/2a4de/1-Tswt2xxYYgoCa0kE-Wirfg.png 600w,\n/static/365a80dbb25a7f50aeb9b89c4e5d6b7e/f3583/1-Tswt2xxYYgoCa0kE-Wirfg.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"GitHub stars are an essential growth factor for many open source projects, but they can easily be from bot accounts. How can we trust GitHub stars again?","custom_excerpt":"GitHub stars are an essential growth factor for many open source projects, but they can easily be from bot accounts. How can we trust GitHub stars again?","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"July 16, 2019","updated_at_pretty":"04 December, 2019","created_at":"2019-11-20T15:01:37.000+00:00","published_at":"2019-07-16T15:01:00.000+00:00","updated_at":"2019-12-04T03:11:09.000+00:00","meta_title":"Can We Trust GitHub Stars?","meta_description":"GitHub stars are an essential growth factor for many open source projects, but they can easily be from bot accounts. ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Brendan LE GLAUNEC","slug":"brendan","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/NewAvatar.png","twitter":null,"facebook":null,"website":"https://github.com/Ullaakut"}],"primary_author":{"name":"Brendan LE GLAUNEC","slug":"brendan","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/NewAvatar.png","twitter":null,"facebook":null,"website":"https://github.com/Ullaakut"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Community","slug":"community","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"GitHub stars are an essential growth factor for many open source projects, but\nthey can easily be from bot accounts. How can we trust GitHub stars again?\n\nFor Open Source GitHub projects, stars are a primordial metric. Of course, there\nare ways to abuse this system, as you might have heard recently. As an open\nsource company, we want our community‚Äôs legitimacy to be transparent, and we\nwant to help the open source community do the same for other projects.\n\nIn the past, there have been many occurrences of people abusing the GitHub API:\n\n * Gaining followers quickly [https://github.com/andrewsyc/github-follow-bot] by\n   making their account follow thousands of other people, hoping for them to\n   follow back\n * Faking their GitHub contributions to make themselves look like outstanding\n   open source developers\n * Automatically creating bot accounts\n   [https://redmonk.com/jgovernor/2017/10/24/so-where-all-the-github-link-farms-at-astro-turfing-in-software-development/] \n   to star repositories and virtually increase their popularity (Examples: here\n   [https://github.com/ffujiawei/auto-stars/blob/master/auto_stars.py] and here\n   [https://www.zdnet.com/article/researchers-uncover-ring-of-github-accounts-promoting-300-backdoored-apps/] \n   among others)\n\nstarbot is an automated bot account creator which starred repositories (has been\ntaken down)GitHub has taken down several of the repositories responsible for\nsuch abuses, but not all of them. The main reason why it was so simple to write\nthose bots was that creating GitHub accounts did not used to require any kind of\nverification, not even a confirmation link via email.\n\nWhile GitHub recently changed that by including a verification system during\naccount creation, it turns out that the challenge can be switched to an audio\nchallenge, which is significantly weaker than the standard one. Also, many of\nthe bot accounts created for the last few years are still there, from before the\nintroduction of the verification procedures.\n\nThis means that some repositories might have used simple bot creation scripts in\nthe past, or might be currently using more advanced ones, able to bypass the\nverification system. This has serious implications, because of the impact of\nGitHub stars on today‚Äôs open source ecosystem.\n\nThe fastest growing repositories in terms of stars are put on the trending page\n[https://github.com/trending], sent in the GitHub daily mailing list\n[https://github.com/trending/go?since=daily] to thousands of users, are shown\nmore frequently in the Explore [https://github.com/explore] tab, and attract\nmore attention in general. It‚Äôs also a very well known phenomenon that many\nstartups tend to use technologies based on how many stars they have, as it‚Äôs\nusually a good indicator of the size of the community behind a project.\n\nThat‚Äôs why we decided to start a side-project, called Astronomer\n[https://github.com/Ullaakut/astronomer], as a reference to analyzing GitHub\nstars and fighting against astro-turfing\n[https://en.wikipedia.org/wiki/Astroturfing].\n\nIt‚Äôs an open source tool which leverages the GitHub API to scan GitHub\nstargazers and compute an overall trust level for the repository, based on\nmultiple statistics found within the stargazers. Using Astronomer can help the\nopen source community prove the authenticity of their communities, and stop\naccusing each other based on gut feelings.\n\nAstronomer, scanning itselfAstronomer can also give more detailed statistics for\nan in-depth look at a community. It computes many factors upon which it\ndetermines the trust level:\n\n * Weighted contributions (older contributions being worth more trust)\n * Private contributions (having the lowest weight when computing overall trust)\n * Independent factors for different types of public contributions (Issues\n   created, Pull Requests created, Code reviews, etc.) which helps mitigate the\n   impact potential bots which would have tons of fake code contributions.\n * Account age (older accounts being worth more trust)\n * Amount of owned repositories\n * Every 5th percentile of the weighted contribution score, from 5 to 95\n\nIt scans two sets of stargazers: the first 200 users to have starred the project\n(since they are the most likely to be bots), and random stargazers. It computes\ntwo trust reports and combines them into its final trust report.\n\nAstronomer then sends the trust reports that it generates to the Astrolab\n[https://github.com/Ullaakut/astrolab] server, which serves GitHub badges for\nthe repositories that were scanned by the community. If you want to generate a\nbadge for your repository, all you need is to docker run astronomer right now\nand it will generate it for you.\n\nAs expected, the results of scanning Traefik are very positive, since its\ncommunity tends to contribute to many open source repositories. At the bottom of\nan Astronomer report, the generated GitHub badge URL is displayed, ready to be\ninserted in the repository‚Äôs readme file.\n\nThe next step for Astronomer will be to provide a web application to view\ndetailed reports for all scanned repositories.\n\nWe sincerely hope that this tool will help the open source community overall,\nand that it will help in reducing the tension between competing open source\nprojects by removing the source of doubt in their communities and their\nlegitimacies.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">GitHub stars are an essential growth factor for many open source projects, but they can easily be from bot accounts. How can we trust GitHub stars again?</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-14.png\" class=\"kg-image\"></figure><p>For Open Source GitHub projects, stars are a primordial metric. Of course, there are ways to abuse this system, as you might have heard recently. As an open source company, we want our<strong><strong> community‚Äôs legitimacy</strong></strong> to be transparent, and we want to help the open source community do the same for other projects.</p><p>In the past, there have been many occurrences of people abusing the GitHub API:</p><ul><li><a href=\"https://github.com/andrewsyc/github-follow-bot\" rel=\"noopener\">Gaining followers quickly</a> by making their account follow thousands of other people, hoping for them to follow back</li><li>Faking their GitHub contributions to make themselves look like outstanding open source developers</li><li><a href=\"https://redmonk.com/jgovernor/2017/10/24/so-where-all-the-github-link-farms-at-astro-turfing-in-software-development/\" rel=\"noopener\">Automatically creating bot accounts</a> to star repositories and virtually increase their popularity (Examples: <a href=\"https://github.com/ffujiawei/auto-stars/blob/master/auto_stars.py\" rel=\"noopener\">here</a> and <a href=\"https://www.zdnet.com/article/researchers-uncover-ring-of-github-accounts-promoting-300-backdoored-apps/\" rel=\"noopener\">here</a> among others)</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-15.png\" class=\"kg-image\"><figcaption>starbot is an automated bot account creator which starred repositories (has been taken down)</figcaption></figure><p>GitHub has taken down several of the repositories responsible for such abuses, but not all of them. The main reason why it was so simple to write those bots was that creating GitHub accounts did not used to require any kind of verification, not even a confirmation link via email.</p><p>While GitHub recently changed that by including a <strong><strong>verification system</strong></strong> during account creation, it turns out that the challenge can be switched to an audio challenge, which is significantly weaker than the standard one. Also, many of the bot accounts created for the last few years are still there, from before the introduction of the verification procedures.</p><p>This means that some repositories might have used simple bot creation scripts in the past, or might be currently using more advanced ones, able to bypass the verification system. This has serious implications, because of the <strong><strong>impact of GitHub stars</strong></strong> on today‚Äôs open source ecosystem.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-16.png\" class=\"kg-image\"></figure><p>The fastest growing repositories in terms of stars are put on the <a href=\"https://github.com/trending\" rel=\"noopener\">trending page</a>, sent in the <a href=\"https://github.com/trending/go?since=daily\" rel=\"noopener\">GitHub daily mailing list</a> to thousands of users, are shown more frequently in the <a href=\"https://github.com/explore\" rel=\"noopener\">Explore</a> tab, and attract more attention in general. It‚Äôs also a very well known phenomenon that many startups tend to use technologies based on how many stars they have, as it‚Äôs usually a good indicator of the size of the community behind a project.</p><p>That‚Äôs why we decided to start a side-project, called <a href=\"https://github.com/Ullaakut/astronomer\" rel=\"noopener\">Astronomer</a>, as a reference to analyzing GitHub stars and fighting against <a href=\"https://en.wikipedia.org/wiki/Astroturfing\" rel=\"noopener\">astro-turfing</a>.</p><p>It‚Äôs an open source tool which leverages the GitHub API to <strong><strong>scan GitHub stargazers</strong></strong> and <strong><strong>compute an overall trust level</strong></strong> for the repository, based on multiple statistics found within the stargazers. Using Astronomer can help the open source community prove the authenticity of their communities, and stop accusing each other based on gut feelings.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/astronomer.gif\" class=\"kg-image\"><figcaption>Astronomer, scanning itself</figcaption></figure><p>Astronomer can also give more detailed statistics for an in-depth look at a community. It computes <strong><strong>many factors</strong></strong> upon which it determines the trust level:</p><ul><li>Weighted contributions (older contributions being worth more trust)</li><li>Private contributions (having the lowest weight when computing overall trust)</li><li>Independent factors for different types of public contributions (Issues created, Pull Requests created, Code reviews, etc.) which helps mitigate the impact potential bots which would have tons of fake code contributions.</li><li>Account age (older accounts being worth more trust)</li><li>Amount of owned repositories</li><li>Every 5th percentile of the weighted contribution score, from <code>5</code> to <code>95</code></li></ul><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-18.png\" class=\"kg-image\"></figure><p>It scans two sets of stargazers: the first 200 users to have starred the project (since they are the most likely to be bots), and random stargazers. It computes two trust reports and combines them into its final trust report.</p><p>Astronomer then sends the trust reports that it generates to the <a href=\"https://github.com/Ullaakut/astrolab\" rel=\"noopener\">Astrolab</a> server, which serves GitHub badges for the repositories that were scanned by the community. If you want to generate a badge for your repository, all you need is to <code>docker run</code> astronomer right now and it will generate it for you.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-19.png\" class=\"kg-image\"></figure><p>As expected, the results of scanning Traefik are very positive, since its community tends to contribute to many open source repositories. At the bottom of an Astronomer report, the generated GitHub badge URL is displayed, ready to be inserted in the repository‚Äôs readme file.</p><p>The next step for Astronomer will be to provide a web application to view detailed reports for all scanned repositories.</p><p>We sincerely hope that this tool will <strong><strong>help the open source community</strong></strong> overall, and that it will help in reducing the tension between competing open source projects by removing the source of doubt in their communities and their legitimacies.</p>","url":"https://containous.ghost.io/blog/can-we-trust-github-stars-e8aa8b6b0baa/","canonical_url":null,"uuid":"d3839868-063b-4b18-81c2-cb56a157e2f6","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd55551ec5ed300387889cc","reading_time":4}},{"node":{"id":"Ghost__Post__5dd5560dec5ed300387889f5","title":"Announcing Yaegi","slug":"announcing-yaegi-263a1e2d070a","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/yaegi.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/9c70aec44ba59d7e82b64c010a65a5f2/f3583/yaegi.png","srcSet":"/static/9c70aec44ba59d7e82b64c010a65a5f2/630fb/yaegi.png 300w,\n/static/9c70aec44ba59d7e82b64c010a65a5f2/2a4de/yaegi.png 600w,\n/static/9c70aec44ba59d7e82b64c010a65a5f2/f3583/yaegi.png 1200w,\n/static/9c70aec44ba59d7e82b64c010a65a5f2/bbee5/yaegi.png 1800w,\n/static/9c70aec44ba59d7e82b64c010a65a5f2/ed396/yaegi.png 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Yaegi, Yet Another Go Interpreter, is an open source project to bring executableGo scripts, embedded plugins on top of the Go runtime...","custom_excerpt":"Yaegi, Yet Another Go Interpreter, is an open source project to bring executableGo scripts, embedded plugins on top of the Go runtime...","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"July 24, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T15:04:45.000+00:00","published_at":"2019-07-24T15:04:00.000+00:00","updated_at":"2020-05-21T23:54:41.000+00:00","meta_title":"Announcing Yaegi, Yet Another Go Interpreter","meta_description":"Yaegi is an open source project developed to bring executable Go scripts, embedded plugins, interactive shells, and instant prototyping","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Marc Vertes","slug":"marc","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/mv2.png","twitter":"@MarcVertes","facebook":null,"website":null}],"primary_author":{"name":"Marc Vertes","slug":"marc","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/mv2.png","twitter":"@MarcVertes","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Yet Another Go Interpreter\n\nIn this post, we present Yaegi [https://github.com/containous/yaegi/], Yet\nAnother Go Interpreter, with the E standing for Elegant, Embedded, Easy, or\nwhatever you prefer.\n\nYaegi is an open source project developed by Containous, (the company behind \nTraefik [/traefik/] and TraefikEE [/traefikee/]), to bring executable Go\n[https://golang.org/] scripts, embedded plugins, interactive shells, and instant\nprototyping on top of the Go runtime. Yaegi project is hosted on GitHub\n[https://github.com/containous/yaegi].\n\nMotivation\nDespite being static and strongly typed, Go feels like a dynamic language. The\nstandard library even provides the Go parser used by the compiler and the\nreflection system to interact dynamically with the runtime. So why not just take\nthe last logical step and finally build a complete Go interpreter?\n\nProgramming languages for high level scripting and for low level implementation\nare usually different. This time, with Go, we have an opportunity to unify both.\nImagine all the C/C++/Java fast libraries for Python being written in Python\ninstead. That‚Äôs what Yaegi is for Go (or, the reverse). No burden due to syntax\nswitch, no need to rewrite or modify slow code to make it fast, and full access\nto goroutines, channels, type safety, etc. at script level.\n\nGoals and Priorities\n * Simplicity: New(), Eval() and Use() is the only API. No external dependencies\n   besides the standard Go library.\n * Standard: the interpreter supports 100% of the Go Specification\n   [https://golang.org/ref/spec].\n * Robustness: preserve type safety and runtime integrity: unsafe and syscall\n   packages are not used nor exposed by default. Security over performance.\n * Interoperability: scripts can ‚Äúimport‚Äù pre-compiled runtime packages, but\n   also compiled code can ‚Äúimport‚Äù script packages during execution. See usage\n   examples below for more details.\n\nUsing Yaegi\nAs a Command-Line Interpreter\nThe Yaegi executable can interpret Go files or run an interactive\nRead-Eval-Print-Loop:\n\n$ yaegi\n> 1 + 2\n3\n> import \"fmt\"\n> fmt.Println(\"Hello World\")\nHello World\n>\n\nYaegi works like go run (but faster). It also enables executable Go scripts\n(starting with #!). Yaegi provides a full Go environment with a complete\nstandard library in a single standalone executable.\n\nAs an Embedded Interpreter\nIn the following example, an interpreter is created with New() and then it\nevaluates Go code using Eval(). Nothing surprising here.\n\npackage main\n\nimport (\n    \"github.com/containous/yaegi/interp\"\n    \"github.com/containous/yaegi/stdlib\"\n)\n\nfunc main() {\n    i := interp.New(interp.Options{})\n    i.Use(stdlib.Symbols)\n    i.Eval(`import \"fmt\"`)\n    i.Eval(`fmt.Println(\"hello\")`)\n}\n\nThis example demonstrates the ability to use executable pre-compiled symbols in\nthe interpreter. Thanks to the statement i.Use(stdlib.Symbols), the interpreted \nimport \"fmt\"will load the fmt package from the executable itself (wrapped in \nreflect.Values) instead of trying to parse source files.\n\nYaegi also provides the goexports command to build the binary wrapper of any\npackage from its source. This is the command we used to generate all stdlib\nwrappers provided by default.\n\nAs a Dynamic Extension Framework\nThe program is compiled ahead of time, except for the function bar() that is\ninterpreted from a script. The import process involves the following steps:\n\n 1. use of i.Eval(src) to internally compile the script package in the context\n    of the interpreter\n 2. use of v,_ := i.Eval(\"foo.Bar\") to get the symbol that we want to use as a \n    reflect.Value (please forgive me for the missing error handling)\n 3. application of Interface()method and type assertion to convert the \n    reflect.Value into a usable Go typed function\n\npackage main\n\nimport \"github.com/containous/yaegi/interp\"\n\nconst src = `package foo\nfunc Bar(s string) string { return s + \"-Foo\" }`\n\nfunc main() {\n    i := interp.New(interp.Options{})\n    i.Eval(src)\n    v, _ := i.Eval(\"foo.Bar\")\n    bar := v.Interface().(func(string) string)\n    \n    r := bar(\"Kung\")\n    println(r)\n    // Output:\n    // Kung-Foo\n}\n\nWhat about Performance?\nInterpreters are quite common in domains like gaming or science. But could Yaegi\nalso be usable as a plugin engine in the context of distributed systems?\n\nTo answer that, we have benchmarked the use of gziphandler\n[https://github.com/nytimes/gziphandler], a middleware for compressing HTTP\nresponses. Gziphandler provides interface methods implementing compression for\nthe HTTP server in the standard library. This demonstrates an interpreted\ndynamic processing inserted into a statically compiled server program, with a\ndirect impact on latency and throughput.\n\nIn one case, gziphandler is compiled and used directly as a callback passed to \nhttp.Handle(). In the other, the interpreted version of gziphandler is used.\n\nBenchmark      old ns/op   new ns/op    delta\nCompress-8     769088      817632       +6.31%\n\nWe measured less than 10% of overhead for the interpreted version of gziphandler\ncompared to the compiled version, which is to us an acceptable cost for to the\nbenefits of dynamically extending foour server.\n\nOne important factor is that the gzip compression itself is provided by the\nstandard lib, already compiled, and exposed to the interpreter by Use().\n\nInterpreters work best at providing the glue language and offloading CPU\nintensive computations to optimized compiled libraries. With Go and Yaegi, this\ncan be achieved simply and almost transparently.\n\nConclusion\nWe are announcing Yaegi, a Go interpreter. It‚Äôs a young project and as such, far\nfrom perfect. Yaegi is open source and needs your feedback and contributions. We\nhope to make it as useful as possible for the Go community and beyond. This is\nonly the beginning. At Containous, we are focused on solving practical problems\nthrough innovative solutions. Stay tuned for upcoming announcements about both\nYaegi and Containous.\n\nJoin us at github.com/containous/yaegi [https://github.com/containous/yaegi].\n\nI want to thank Containous [/], Emile Vauge [https://twitter.com/emilevauge], \nLudovic Fernandez [https://twitter.com/ludnadez], Mathieu Lonjaret\n[https://twitter.com/lejatorn] who coined the name, Peka\n[https://www.linkedin.com/in/pierre-keersbulik-198107117] for the awesome logo,\nand many other colleagues for their support.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Yet Another Go Interpreter</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-112.png\" class=\"kg-image\"></figure><p>In this post, we present <a href=\"https://github.com/containous/yaegi/\" rel=\"noopener\">Yaegi</a>, Yet Another Go Interpreter, with the E standing for Elegant, Embedded, Easy, or whatever you prefer.</p><p>Yaegi is an open source project developed by Containous, (the company behind <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> and <a href=\"https://containous.ghost.io/traefikee/\" rel=\"noopener\">TraefikEE</a>), to bring executable <a href=\"https://golang.org/\" rel=\"noopener\">Go</a> scripts, embedded plugins, interactive shells, and instant prototyping on top of the Go runtime. Yaegi project is hosted on <a href=\"https://github.com/containous/yaegi\" rel=\"noopener\">GitHub</a>.</p><h2 id=\"motivation\">Motivation</h2><p>Despite being static and strongly typed, Go feels like a dynamic language. The standard library even provides the Go parser used by the compiler and the reflection system to interact dynamically with the runtime. So why not just take the last logical step and finally build a complete Go interpreter?</p><p>Programming languages for high level scripting and for low level implementation are usually different. This time, with Go, we have an opportunity to unify both. Imagine all the C/C++/Java fast libraries for Python being written in Python instead. That‚Äôs what Yaegi is for Go (or, the reverse). No burden due to syntax switch, no need to rewrite or modify slow code to make it fast, and full access to goroutines, channels, type safety, etc. at script level.</p><h2 id=\"goals-and-priorities\">Goals and Priorities</h2><ul><li>Simplicity: <code>New()</code>, <code>Eval()</code> and <code>Use()</code> is the only API. No external dependencies besides the standard Go library.</li><li>Standard: the interpreter supports 100% of the <a href=\"https://golang.org/ref/spec\" rel=\"noopener\">Go Specification</a>.</li><li>Robustness: preserve type safety and runtime integrity: <code>unsafe</code> and <code>syscall</code>packages are not used nor exposed by default. Security over performance.</li><li>Interoperability: scripts can ‚Äúimport‚Äù pre-compiled runtime packages, but also compiled code can ‚Äúimport‚Äù script packages during execution. See usage examples below for more details.</li></ul><h2 id=\"using-yaegi\">Using Yaegi</h2><h3 id=\"as-a-command-line-interpreter\">As a Command-Line Interpreter</h3><p>The Yaegi executable can interpret Go files or run an interactive Read-Eval-Print-Loop:</p><pre><code class=\"language-shell\">$ yaegi\n&gt; 1 + 2\n3\n&gt; import \"fmt\"\n&gt; fmt.Println(\"Hello World\")\nHello World\n&gt;</code></pre><p>Yaegi works like <code>go run</code> (but faster). It also enables executable Go scripts (starting with <code>#!</code>). Yaegi provides a full Go environment with a complete standard library in a single standalone executable.</p><h3 id=\"as-an-embedded-interpreter\">As an Embedded Interpreter</h3><p>In the following example, an interpreter is created with <code>New()</code> and then it evaluates Go code using <code>Eval()</code>. Nothing surprising here.</p><pre><code class=\"language-go\">package main\n\nimport (\n    \"github.com/containous/yaegi/interp\"\n    \"github.com/containous/yaegi/stdlib\"\n)\n\nfunc main() {\n    i := interp.New(interp.Options{})\n    i.Use(stdlib.Symbols)\n    i.Eval(`import \"fmt\"`)\n    i.Eval(`fmt.Println(\"hello\")`)\n}</code></pre><p>This example demonstrates the ability to use executable pre-compiled symbols in the interpreter. Thanks to the statement <code>i.Use(stdlib.Symbols)</code>, the interpreted <code>import \"fmt\"</code>will load the <code>fmt</code> package from the executable itself (wrapped in <code>reflect.Values</code>) instead of trying to parse source files.</p><p>Yaegi also provides the <code>goexports</code> command to build the binary wrapper of any package from its source. This is the command we used to generate all stdlib wrappers provided by default.</p><h3 id=\"as-a-dynamic-extension-framework\">As a Dynamic Extension Framework</h3><p>The program is compiled ahead of time, except for the function <code>bar()</code> that is interpreted from a script. The import process involves the following steps:</p><ol><li>use of <code>i.Eval(src)</code> to internally compile the script package in the context of the interpreter</li><li>use of <code>v,_ := i.Eval(\"<em><em>foo.Bar</em></em>\")</code> to get the symbol that we want to use as a <code>reflect.Value </code>(please forgive me for the missing error handling)</li><li>application of <code>Interface()</code>method and type assertion to convert the <code>reflect.Value</code> into a usable Go typed function</li></ol><pre><code class=\"language-go\">package main\n\nimport \"github.com/containous/yaegi/interp\"\n\nconst src = `package foo\nfunc Bar(s string) string { return s + \"-Foo\" }`\n\nfunc main() {\n    i := interp.New(interp.Options{})\n    i.Eval(src)\n    v, _ := i.Eval(\"foo.Bar\")\n    bar := v.Interface().(func(string) string)\n    \n    r := bar(\"Kung\")\n    println(r)\n    // Output:\n    // Kung-Foo\n}</code></pre><h2 id=\"what-about-performance\">What about Performance?</h2><p>Interpreters are quite common in domains like gaming or science. But could Yaegi also be usable as a plugin engine in the context of distributed systems?</p><p>To answer that, we have benchmarked the use of <a href=\"https://github.com/nytimes/gziphandler\" rel=\"noopener\">gziphandler</a>, a middleware for compressing HTTP responses. Gziphandler provides interface methods implementing compression for the HTTP server in the standard library. This demonstrates an interpreted dynamic processing inserted into a statically compiled server program, with a direct impact on latency and throughput.</p><p>In one case, gziphandler is compiled and used directly as a callback passed to <code>http.Handle()</code>. In the other, the interpreted version of gziphandler is used.</p><pre><code class=\"language-text\">Benchmark      old ns/op   new ns/op    delta\nCompress-8     769088      817632       +6.31%</code></pre><p>We measured less than 10% of overhead for the interpreted version of gziphandler compared to the compiled version, which is to us an acceptable cost for to the benefits of dynamically extending foour server.</p><p>One important factor is that the gzip compression itself is provided by the standard lib, already compiled, and exposed to the interpreter by <code>Use()</code>.</p><p>Interpreters work best at providing the glue language and offloading CPU intensive computations to optimized compiled libraries. With Go and Yaegi, this can be achieved simply and almost transparently.</p><h2 id=\"conclusion\">Conclusion</h2><p>We are announcing Yaegi, a Go interpreter. It‚Äôs a young project and as such, far from perfect. Yaegi is open source and needs your feedback and contributions. We hope to make it as useful as possible for the Go community and beyond. This is only the beginning. At Containous, we are focused on solving practical problems through innovative solutions. Stay tuned for upcoming announcements about both Yaegi and Containous.</p><p>Join us at <a href=\"https://github.com/containous/yaegi\" rel=\"noopener\">github.com/containous/yaegi</a>.</p><p>I want to thank <a href=\"https://containous.ghost.io/\" rel=\"noopener\">Containous</a>, <a href=\"https://twitter.com/emilevauge\" rel=\"noopener\">Emile Vauge</a>, <a href=\"https://twitter.com/ludnadez\" rel=\"noopener\">Ludovic Fernandez</a>, <a href=\"https://twitter.com/lejatorn\" rel=\"noopener\">Mathieu Lonjaret</a> who coined the name, <a href=\"https://www.linkedin.com/in/pierre-keersbulik-198107117\" rel=\"noopener\">Peka</a> for the awesome logo, and many other colleagues for their support.</p>","url":"https://containous.ghost.io/blog/announcing-yaegi-263a1e2d070a/","canonical_url":null,"uuid":"35426a19-ead7-403f-b5c3-69421eb25799","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd5560dec5ed300387889f5","reading_time":4}},{"node":{"id":"Ghost__Post__5dd553eaec5ed30038788992","title":"From Zero to Hero in Minutes with Konvoy‚Äôs Built-In Traefik for Kubernetes","slug":"from-zero-to-hero-in-minutes-with-konvoys-built-in-traefik-for-kubernetes-11577fdeeb14","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/d2iq.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/57b06de950e215169b9335c2c7d6fe56/47498/d2iq.jpg","srcSet":"/static/57b06de950e215169b9335c2c7d6fe56/9dc27/d2iq.jpg 300w,\n/static/57b06de950e215169b9335c2c7d6fe56/4fe8c/d2iq.jpg 600w,\n/static/57b06de950e215169b9335c2c7d6fe56/47498/d2iq.jpg 1200w,\n/static/57b06de950e215169b9335c2c7d6fe56/52258/d2iq.jpg 1800w,\n/static/57b06de950e215169b9335c2c7d6fe56/53d6a/d2iq.jpg 1950w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Konvoy, from D2iQ, provides a complete out-of-the-box experience of production-ready Kubernetes.\nIt is a tool for provisioning pure Kubernetes clusters...","custom_excerpt":"Konvoy, from D2iQ, provides a complete out-of-the-box experience of production-ready Kubernetes.\nIt is a tool for provisioning pure Kubernetes clusters...","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"August 8, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-20T14:55:38.000+00:00","published_at":"2019-08-08T14:55:00.000+00:00","updated_at":"2020-05-22T00:15:26.000+00:00","meta_title":"From Zero to Hero with Konvoy‚Äôs Built-In Traefik for Kubernetes","meta_description":"Konvoy provides a complete out-of-the-box experience of production-ready Kubernetes. It is a tool for provisioning pure Kubernetes clusters","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Partners","slug":"partners","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Konvoy [https://d2iq.com/solutions/ksphere/konvoy], from D2iQ, provides a\ncomplete out-of-the-box experience of production-ready Kubernetes.\n\nIt is a tool for provisioning pure Kubernetes clusters, based on a set of Cloud\nNative Computing Foundation (CNCF) and community-contributed components. This\nKubernetes distribution provides a set of pre-installed components to get you\nstarted immediately.\n\nWe‚Äôre delighted to announce that Traefik [/traefik/], the popular open source\ncloud native edge router, integrates with Konvoy.\n\nClick to continue reading‚Ä¶\n[https://d2iq.com/blog/from-zero-to-hero-in-minutes-with-konvoy-s-built-in-traefik-for-kubernetes]\n\nWelcome To Konvoy Ops Dashboard: Traefik is already there!","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-111.png\" class=\"kg-image\"></figure><p><a href=\"https://d2iq.com/solutions/ksphere/konvoy\" rel=\"noopener\">Konvoy</a>, from D2iQ, provides a complete out-of-the-box experience of production-ready Kubernetes.</p><p>It is a tool for provisioning pure Kubernetes clusters, based on a set of Cloud Native Computing Foundation (CNCF) and community-contributed components. This Kubernetes distribution provides a set of pre-installed components to get you started immediately.</p><p>We‚Äôre delighted to announce that <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, the popular open source cloud native edge router, integrates with Konvoy.</p><p><a href=\"https://d2iq.com/blog/from-zero-to-hero-in-minutes-with-konvoy-s-built-in-traefik-for-kubernetes\" rel=\"noopener\">Click to continue reading‚Ä¶</a></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-13.png\" class=\"kg-image\"><figcaption>Welcome To Konvoy Ops Dashboard: Traefik is already there!</figcaption></figure>","url":"https://containous.ghost.io/blog/from-zero-to-hero-in-minutes-with-konvoys-built-in-traefik-for-kubernetes-11577fdeeb14/","canonical_url":null,"uuid":"168418c1-96a7-4a33-a812-57808b935115","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd553eaec5ed30038788992","reading_time":1}},{"node":{"id":"Ghost__Post__5dd54eefec5ed30038788910","title":"Announcing Maesh, a Lightweight and Simpler Service Mesh Made by the Traefik Team","slug":"announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/maesh.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/14e5db97752eac82720eec1f0b64d421/f3583/maesh.png","srcSet":"/static/14e5db97752eac82720eec1f0b64d421/630fb/maesh.png 300w,\n/static/14e5db97752eac82720eec1f0b64d421/2a4de/maesh.png 600w,\n/static/14e5db97752eac82720eec1f0b64d421/f3583/maesh.png 1200w,\n/static/14e5db97752eac82720eec1f0b64d421/bbee5/maesh.png 1800w,\n/static/14e5db97752eac82720eec1f0b64d421/0ef64/maesh.png 2400w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"We are proud to introduce Maesh, Containous‚Äô new service mesh designed from the ground up to be straightforward, easy to install and easy to use...","custom_excerpt":"We are proud to introduce Maesh, Containous‚Äô new service mesh designed from the ground up to be straightforward, easy to install and easy to use...","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"September 4, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T14:34:23.000+00:00","published_at":"2019-09-04T14:36:00.000+00:00","updated_at":"2020-05-21T23:51:21.000+00:00","meta_title":"Announcing Maesh, a Lightweight and Simpler Service Mesh","meta_description":"We are proud to introduce Maesh, Containous‚Äô new service mesh designed from the ground up to be straightforward, easy to install and easy to use...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"We are proud to introduce Maesh [/maesh/], Containous‚Äô new service mesh designed\nfrom the ground up to be straightforward, easy to install and easy to use. Maesh\nallows for visibility and management of the traffic that flows inside your\nKubernetes cluster, which is just as important as the ingress and egress\ntraffic.\n\nBuilt on top of Traefik, Maesh is a simple, yet full-featured service mesh. It\nis container-native and fits as your de-facto service mesh in your Kubernetes\ncluster. It supports the latest Service Mesh Interface specification (SMI\n[https://smi-spec.io/]) that facilitates integration with pre-existing\nsolutions. Moreover, Maesh is opt-in by default, which means that your existing\nservices are unaffected until you decide to add them to the mesh.\n\nNon-Invasive Service Mesh\nMaesh does not use any sidecar container but handles routing through proxy\nendpoints running on each node. The mesh controller runs in a dedicated pod and\nhandles all the configuration parsing and deployment to the proxy nodes. Maesh\nsupports multiple configuration options: annotations on user service objects,\nand SMI objects. Not using sidecars means that Maesh does not modify your\nKubernetes objects, and does not modify your traffic without your knowledge.\nUsing the Maesh endpoints is all that is required.\n\nMaesh ArchitectureRelies on Kubernetes DNS\nMaesh leverages the CoreDNS platform installed by default in Kubernetes. It\nallows users to use the Maesh endpoints (instead of the standard Kubernetes\nservice endpoints) to benefit from its feature set ‚Äî no sidecars! Maesh\nendpoints run side-by-side with user services: you choose whether you use them\nor not (opt-in). This gives more confidence, since users know that they are able\nto test, and revert back to the user services: they should be happy with the\nresult.\n\nAlso, the updates to CoreDNS made during the installation of Maesh is minimal\nand non-invasive, and is easily removable.\n\nMultiple Network Layers\nMaesh can run in both TCP and HTTP mode\n\n * In HTTP mode, Maesh leverages Traefik‚Äôs feature set to enable rich routing on\n   virtual-host, path, headers, cookies.\n * Using TCP mode allows a seamless and easy integration with SNI routing\n   support.\n\nUse both modes at the same time within the same cluster, and is configurable via\nannotations on services.\n\nBuilt on Top of Traefik\nMaesh builds on top of Traefik [/traefik/], the leading reverse proxy for\nrouting, and provides every feature users would expect: OpenTracing, load\nbalancing for HTTP, gRPC, WebSocket, TCP, rich routing rules, retries and\nfail-overs, not to mention access controls, rate limits, and circuit breakers.\n\nEasy to Install; Easy to Use\nInstalling Maesh to your cluster is easy: install the Helm chart, as there are\nno helper applications, no CRDs to install, and no new vocabulary for users to\nlearn. If users understand how pods and services work, then Maesh will be easy\nto understand and use.\n\nLet‚Äôs get started by installing Maesh using the following commands:\n\nhelm repo add maesh https://containous.github.io/maesh/charts\nhelm repo update\nhelm install --name=maesh --namespace=maesh maesh/maesh\n\nMaesh is now ready to use in your cluster, and you‚Äôre one annotation away from\nusing it on any running application:\n\nkubectl annotate service \\\n    web-application maesh.containo.us/traffic-type=http\n\nIs your application using a TCP communication protocol (which is not HTTP)? It\nis also supported:\n\nkubectl annotate service mongo-database \\\n    maesh.containo.us/traffic-type=tcp\n\nThat‚Äôs how easy it is to install and use Maesh!\n\nWhat‚Äôs Next\nBecause Maesh is open source, we would love the community‚Äôs input as to which\nfeatures are important to you, so that we can prioritise the top requests.\n\nWe welcome community contributions and love when they are faster than us to\nprovide additional features! Pull requests are the best way to support the\nproduct and make it your own.\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-110.png\" class=\"kg-image\"></figure><p>We are proud to introduce <a href=\"https://containous.ghost.io/maesh/\">Maesh</a>, Containous‚Äô new service mesh designed from the ground up to be straightforward, easy to install and easy to use. Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic.</p><p>Built on top of Traefik, Maesh is a simple, yet full-featured service mesh. It is container-native and fits as your de-facto service mesh in your Kubernetes cluster. It supports the latest Service Mesh Interface specification (<a href=\"https://smi-spec.io/\" rel=\"noopener\">SMI</a>) that facilitates integration with pre-existing solutions. Moreover, Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.</p><h2 id=\"non-invasive-service-mesh\">Non-Invasive Service Mesh</h2><p>Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Maesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Maesh does not modify your Kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-10.png\" class=\"kg-image\"><figcaption>Maesh Architecture</figcaption></figure><h2 id=\"relies-on-kubernetes-dns\">Relies on Kubernetes DNS</h2><p>Maesh leverages the CoreDNS platform installed by default in Kubernetes. It allows users to use the Maesh endpoints (instead of the standard Kubernetes service endpoints) to benefit from its feature set ‚Äî no sidecars! Maesh endpoints run side-by-side with user services: you choose whether you use them or not (opt-in). This gives more confidence, since users know that they are able to test, and revert back to the user services: they should be happy with the result.</p><p>Also, the updates to CoreDNS made during the installation of Maesh is minimal and non-invasive, and is easily removable.</p><h2 id=\"multiple-network-layers\">Multiple Network Layers</h2><p>Maesh can run in both TCP and HTTP mode</p><ul><li>In HTTP mode, Maesh leverages Traefik‚Äôs feature set to enable rich routing on virtual-host, path, headers, cookies.</li><li>Using TCP mode allows a seamless and easy integration with SNI routing support.</li></ul><p>Use both modes at the same time within the same cluster, and is configurable via annotations on services.</p><h2 id=\"built-on-top-of-traefik\">Built on Top of Traefik</h2><p>Maesh builds on top of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, the leading reverse proxy for routing, and provides every feature users would expect: OpenTracing, load balancing for HTTP, gRPC, WebSocket, TCP, rich routing rules, retries and fail-overs, not to mention access controls, rate limits, and circuit breakers.</p><h2 id=\"easy-to-install-easy-to-use\">Easy to Install; Easy to Use</h2><p>Installing Maesh to your cluster is easy: install the Helm chart, as there are no helper applications, no CRDs to install, and no new vocabulary for users to learn. If users understand how pods and services work, then Maesh will be easy to understand and use.</p><p>Let‚Äôs get started by installing Maesh using the following commands:</p><pre><code class=\"language-shell\">helm repo add maesh https://containous.github.io/maesh/charts\nhelm repo update\nhelm install --name=maesh --namespace=maesh maesh/maesh</code></pre><p>Maesh is now ready to use in your cluster, and you‚Äôre one annotation away from using it on any running application:</p><pre><code class=\"language-shell\">kubectl annotate service \\\n    web-application maesh.containo.us/traffic-type=http</code></pre><p>Is your application using a TCP communication protocol (which is not HTTP)? It is also supported:</p><pre><code class=\"language-shell\">kubectl annotate service mongo-database \\\n    maesh.containo.us/traffic-type=tcp</code></pre><p>That‚Äôs how easy it is to install and use Maesh!</p><h2 id=\"what-s-next\">What‚Äôs Next</h2><p>Because Maesh is open source, we would love the community‚Äôs input as to which features are important to you, so that we can prioritise the top requests.</p><p>We welcome community contributions and love when they are faster than us to provide additional features! Pull requests are the best way to support the product and make it your own.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\" rel=\"noopener\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\" rel=\"noopener\">Community Forum</a></li></ul>","url":"https://containous.ghost.io/blog/announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29/","canonical_url":null,"uuid":"3100e2c8-491b-40da-a686-6e372e6d1979","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd54eefec5ed30038788910","reading_time":3}},{"node":{"id":"Ghost__Post__5dd54affec5ed3003878888c","title":"Traefik 2.0","slug":"traefik-2-0-6531ec5196c2","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/Traefik2.0-Blog.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/d296ee0938e591fca4472b2324a12286/f3583/Traefik2.0-Blog.png","srcSet":"/static/d296ee0938e591fca4472b2324a12286/630fb/Traefik2.0-Blog.png 300w,\n/static/d296ee0938e591fca4472b2324a12286/2a4de/Traefik2.0-Blog.png 600w,\n/static/d296ee0938e591fca4472b2324a12286/f3583/Traefik2.0-Blog.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"When we started our journey toward 2.0, we had high expectations (since you had high expectations), and huddled around the whiteboard...","custom_excerpt":"When we started our journey toward 2.0, we had high expectations (since you had high expectations), and huddled around the whiteboard...","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"September 17, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-20T14:17:35.000+00:00","published_at":"2019-09-17T14:28:00.000+00:00","updated_at":"2020-05-22T00:42:01.000+00:00","meta_title":"Traefik 2.0 - The Wait is Over!","meta_description":"When we started our journey toward 2.0, we had high expectations (since you had high expectations), and huddled around the whiteboard...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"The Wait Is Over!\n\nWhen we started our journey toward 2.0, we had high expectations (since you had\nhigh expectations), and huddled around the whiteboard.\n\nWe designed Version 2 as if there were no constraints: we forgot our codebase,\nput aside technical challenges, and developed a new configuration structure that\nwould welcome everything we had ever dreamed of for Traefik.\n\n> We forgot what was impossible so we could build it!\nA year later, we proudly present to you Traefik 2.0. Make sure you grab your cup\nof coffee/cup of tea before going further because this is probably the biggest\nnew features list we‚Äôve ever had to write!\n\n\n--------------------------------------------------------------------------------\n\nTCP Support with SNI Routing & Multi-Protocol Ports\nWe talked about this flagship feature in the 2.0 alpha announcement\n[/blog/back-to-traefik-2-0-2f9aa17be305/], but since it was feature request #10\n[https://github.com/containous/traefik/issues/10], we thought we would dedicate\nsome time to discussing this key element in a world of new possibilities.\n\nLet‚Äôs see a sample configuration ‚Äî using the newly supported YAML format ‚Äî that\nroutes requests to a database:\n\ntcp:\n  routers:\n    to-database:\n      entrypoints:\n      - database-entrypoint\n      rule: HostSNI(`*`)\n      service: database-service\n  services:     \n    database-service:\n      loadBalancer:\n        servers:\n        - address: xx.xx.xx.xx:xx\n\nIn the example above, every request ending on database-entrypoint will be routed\nto our database-service.\n\n> Over TLS, Traefik routes TCP \nrequests based on the SNI\nIn the following example, Traefik [/traefik/] routes requests to two databases\nbased on the SNI (Server Name Indication):\n\ntcp:\n  routers:\n    to-db-1:\n      entrypoints:\n      - web-secure\n      rule: \"HostSNI(`db1.domain`)\"\n      service: \"db1\"\n      tls: {} \n    to-db-2:\n      entrypoints:\n      - web-secure\n      rule: \"HostSNI(`db2.domain`)\"\n      service: \"db2\"\n      tls: {}\n\n> HTTP & TCP on the same port?\nYes, there is Traefik for that!\nIf you ever want to have the same entrypoint get both HTTP and TCP requests,\nknow that Traefik will handle it perfectly!\n\ntcp:\n  routers:\n    to-db-1:\n      entrypoints:\n      - web-secure\n      rule: \"HostSNI(`db1.domain`)\"\n      service: \"db-1\"\n      tls: {}\nhttp:\n  routers:\n    to-db1-dashboard:\n      entrypoints:\n      - web-secure\n      rule: \"Host(`dashboard.db1.domain`)\"\n      service: \"db1-dashboard\"\n      tls: {}\n\nIn the above example, HTTP requests on dashboard.db1.domain will be routed to\nthe database dashboard service, and TCP requests on db1.domain will be routed to\nthe database.\n\nFully Customize Your Routes with Middleware\nTraefik 2.0 introduces middleware\n[https://docs.traefik.io/middlewares/overview/]: a common banner for features\nthat tweak requests before/after routing them to their destinations.\n\n> You can declare Middleware and reuse them on as \nmany routers as you like.\nWant to see how to configure them? Let‚Äôs declare a BasicAuth middleware\n[https://docs.traefik.io/middlewares/basicauth/] to control access to our\nservice! (this time using TOML)\n\n# Declaring a basicauth middleware with two users\n[http.middlewares.test-auth.basicAuth]\n  users = [\"user1:hashed\", \"user2:hashed\"]\n\n# Applying the middleware to our router\n[http.routers.my-router.to-service]\n  rule = \"host(`my-protected.domain`)\"\n  middlewares = [\"test-auth\"]\n  service = \"service1\"\n\n> A Chain to Bind Them All\nIf you have a classic combination you often use together, you can declare chains\n[https://docs.traefik.io/middlewares/chain/], and reuse them over and over.\nWhat‚Äôs even better for our Kubernetes users, you can use Traefik‚Äôs new CRD\n(Custom Resource Definition) for a crystal clear configuration that doesn‚Äôt\ninvolve intricate annotations. (You can find more information on the \nIngressRoute object\n[https://docs.traefik.io/providers/kubernetes-crd/#traefik-ingressroute-definition] \nin our documentation.)\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test\n  namespace: default\nspec:\n  entryPoints:\n    - web\n  routes:\n    - match: Host(`mydomain`)\n      kind: Rule\n      services:\n        - name: whoami\n          port: 80\n      middlewares:\n        - name: secured\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: secured\nspec:\n  chain:\n    middlewares:\n    - name: https-only\n    - name: known-ips\n    - name: auth-users\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: auth-users\nspec:\n  basicAuth:\n    secret: secretUsers #yes! Compatible with K8S secrets\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: https-only\nspec:\n  redirectScheme:\n    scheme: https\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: known-ips\nspec:\n  ipWhiteList:\n    sourceRange:\n    - 192.168.1.7\n    - 127.0.0.1/32\n\nAt release, Traefik comes with many pieces of middleware\n[https://docs.traefik.io/middlewares/overview/]: path manipulation\n[https://docs.traefik.io/middlewares/replacepath/], several authentication\nmechanisms [https://docs.traefik.io/middlewares/forwardauth/], buffering\n[https://docs.traefik.io/middlewares/buffering/], circuit breaker\n[https://docs.traefik.io/middlewares/circuitbreaker/], retry\n[https://docs.traefik.io/middlewares/retry/], compression\n[https://docs.traefik.io/middlewares/compress/], error handling\n[https://docs.traefik.io/middlewares/errorpages/], headers\n[https://docs.traefik.io/middlewares/headers/], IP whitelisting\n[https://docs.traefik.io/middlewares/ipwhitelist/], rate limiting\n[https://docs.traefik.io/middlewares/ratelimit/], redirections\n[https://docs.traefik.io/middlewares/redirectscheme/], and more.\n\nAlso, we‚Äôve re-architectured the code to make it easier for contributors to\nprovide additional pieces of middleware, and I‚Äôm sure we‚Äôll find a way to do \neven better [https://github.com/containous/yaegi].\n\nA New Dashboard & WebUI\nOur goal with the new WebUI was to show users what was happening on their\ncluster at a glance. We also wanted to display what features they can enable.\n\nSince the flow has changed, we wanted to display every path that leads to\nservices, with every configuration option.\n\nCanary Deployments with Service Load Balancers\nAnother long-awaited feature [https://github.com/containous/traefik/issues/1164] \n‚Äî canary deployments, A/B testing ‚Äî makes its way into Traefik 2.0 in the form\nof Service Load Balancers.\n\nService Load Balancers can be seen as virtual services that are responsible for\nforwarding the request to the actual services.\n\nLet‚Äôs take a classic scenario where you have an existing route to an API:\n\nhttp:\n  routers:\n    my-route:\n      rule: \"Host(`my.domain`)\"\n      service: my-api-v1\n  services:\n    my-api-v1:\n      loadBalancer:\n        servers:\n        - url: \"http://private-ip-server-1/\"\n\nNow you want to deploy a new version of this service, but would like to deploy\nit progressively, let‚Äôs say approximately a third of the requests. What you‚Äôll\ndo is deploy the new service, with its own ID (here it‚Äôsmy-api-v2).\n\nhttp:\n  services:\n    my-api-v2:\n      loadBalancer:\n        servers:\n        - url: \"http://private-ip-server-2/\"\n\nThen, instead of pointing directly to this new version, you‚Äôll first define a\nService Load Balancer (in the example canary-api) and define the proportion for\neach version (with the weight option).\n\nhttp:\n  services:\n    canary-api:\n      weighted:\n        services:\n        - name: my-api-v1\n          weight: 3\n        - name: my-api-v2\n          weight: 1\n\nFinally, point to this canary-api service from your router.\n\nhttp:\n  routers:\n    my-route:\n      rule: \"Host(`my.domain`)\"\n      service: canary-api\n\nLater, you‚Äôll be able to update the weight without having to redeploy your \nactual services. You‚Äôll also be able to scale them without any impact on the\ncanary deployment itself.\n\nMirroring with Service Load Balancers\nCanary deployments aren‚Äôt the only tricks available in the service family.\nTraefik 2.0 introduces Mirroring Services ‚Äî a way to duplicate the incoming\nrequest [https://github.com/containous/traefik/issues/2989] and send it to\ndifferent services at the same time. The mirror will get a given percentage of\nrequests, and its answers will be ignored.\n\n[http.services.mirrored-api]\n    [http.services.mirrored-api.mirroring]\n      service = \"api\"\n    [[http.services.mirrored-api.mirroring.mirrors]]\n      name = \"api-v2\"\n      percent = 10\n\n[http.services.api]\n    [http.services.api.loadBalancer]\n      [[http.services.api.loadBalancer.servers]]\n        url = \"http://private-ip-server-1/\"\n\n[http.services.api-v2]\n    [http.services.api-v2.loadBalancer]\n      [[http.services.api-v2.loadBalancer.servers]]\n        url = \"http://private-ip-server-2/\"\n\nIn the above example, we‚Äôre sending 10% of the requests to the mirror.\n\nAnd Much, Much More!\nTraefik 2.0 introduces a syntax (@provider) to allow users to declare elements\n(middleware, services, routers) in a provider and to reference them from an\nother one. It provides an easier way to configure CORS headers\n[https://docs.traefik.io/middlewares/headers/#cors-headers], embeds a redesigned \nconstraint management\n[https://docs.traefik.io/providers/overview/#restrict-the-scope-of-service-discovery] \nto better control services you want to expose, and improves the default rule\ngeneration for a quick and easy way to define routes for containers.\n\nOn top of many enhancements [https://docs.traefik.io/operations/api/], the API\nnow embeds status information for your middleware, services, routers, and\nreports errors to help you identify and fix problems.\n\nThe polished configuration options ensure that configuring Traefik is always\nachieved the same way whether expressed with TOML, YAML, labels, or keys, and\nthe revamped documentation [https://docs.traefik.io/] includes examples for\nevery syntax.\n\nYou can define TLS termination separately on each router, configure TLS\npassthrough, use the new CertResolver to benefit from different challenges for\ncertificate generation (yes, it‚Äôs now multiple-DNS-providers-proof!), and\ndynamically generate wildcard certificates.\n\nRouter rules now use a go-like syntax with operators and parenthesis\n[https://docs.traefik.io/routing/routers/#rule] for powerful and readable\ncombinations.\n\nThe list goes on and on with bug fixes and other significant tweaks!\n\n\n--------------------------------------------------------------------------------\n\nMigrating From 1.x\nWith so many new features, bug fixes, and enhancements, Traefik 2.0 might ask\nyou to re-think the way you used to route your requests. In order to facilitate\nthe transition and help you leverage the power of these new options, we\ninitiated a migration guide [https://docs.traefik.io/migration/v1-to-v2/] that\ngoes through every change we made.\n\nFor our Kubernetes [https://kubernetes.io/] user-base, we‚Äôve also written a \nmigration tool [https://github.com/containous/traefik-migration-tool] to help\nyou convert your Ingress objects to the new IngressRoute format. (This migration\ntool will also help all users convert their acme.json file.)\n\nAll this is designed for the thousands of people already using Traefik.\n\n\n--------------------------------------------------------------------------------\n\nBehind the Curtain\nTraefik 2.0 is not the only thing that has improved! By the time we released\n2.0, we launched TraefikEE [/traefikee/], Yaegi\n[https://github.com/containous/yaegi], Maesh [/maesh/], and you can bet we‚Äôll\nkeep going further. We also constantly monitor our processes and tools. We‚Äôve\nlaunched a Community Forum [https://community.containo.us/] to foster better\ncommunication amongst users, introduced a monthly journal, and scheduled \nTraefik\nOnline Meetups [/events/] to promote the community talent.\n\n\n--------------------------------------------------------------------------------\n\nNext Steps\nMore than anything, this release shows the importance of the community. Every\n[https://github.com/containous/traefik/issues/10] feature\n[https://github.com/containous/traefik/issues/2999] that\n[https://github.com/containous/traefik/issues/7] has\n[https://github.com/containous/traefik/issues/727] been\n[https://github.com/containous/traefik/issues/895] discussed\n[https://github.com/containous/traefik/issues/1164] today\n[https://github.com/containous/traefik/issues/160] was born\n[https://github.com/containous/traefik/issues/2989] from\n[https://github.com/containous/traefik/issues/914] a\n[https://github.com/containous/traefik/issues/2653] user\n[https://github.com/containous/traefik/issues/966] asking for a new feature\n[https://github.com/containous/traefik/issues/3378], reporting a bug\n[https://github.com/containous/traefik/issues/4069], or just asking\n[https://github.com/containous/traefik/issues/3868] for ‚Äúbetter.‚Äù\n[https://github.com/containous/traefik/issues/2773]\n\nTraefik 1.X has been downloaded more than a billion times, and we hope to double\nthat number with Traefik 2.X.\n\n> ‚ù§Ô∏è Thank you for your support!‚ù§Ô∏è\n‚Ä¶ and keep raising your voice for the (many) version(s) to come!\n\nP.S. ‚Äî Stay tuned! There is so much to show you with this new version that our\ndeveloper team is preparing an Online Meetup for you. :-)\n\n\n--------------------------------------------------------------------------------\n\nUseful Links\n * Traefik documentation [https://docs.traefik.io/], website [/traefik/] & \n   Github page [https://github.com/containous/traefik]\n * Containous website [/]\n * Community forum [https://community.containo.us/]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">The Wait Is Over!</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-108.png\" class=\"kg-image\"></figure><p>When we started our journey toward 2.0, we had high expectations (since <em><em>you</em></em> had high expectations), and huddled around the whiteboard.</p><p>We designed Version 2 as if there were no constraints: we forgot our codebase, put aside technical challenges, and developed a new configuration structure that would welcome everything we had ever dreamed of for Traefik.</p><blockquote>We forgot what was impossible so we could build it!</blockquote><p>A year later, we proudly present to you Traefik 2.0. Make sure you grab your cup of coffee/cup of tea before going further because this is probably the biggest new features list we‚Äôve ever had to write!</p><hr><h2 id=\"tcp-support-with-sni-routing-multi-protocol-ports\">TCP Support with SNI Routing &amp; Multi-Protocol Ports</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-4.png\" class=\"kg-image\"></figure><p>We talked about this flagship feature in the <a href=\"https://containous.ghost.io/blog/back-to-traefik-2-0-2f9aa17be305/\">2.0 alpha announcement</a>, but since it was <a href=\"https://github.com/containous/traefik/issues/10\" rel=\"noopener\">feature request #10</a>, we thought we would dedicate some time to discussing this key element in a world of new possibilities.</p><p>Let‚Äôs see a sample configuration ‚Äî using the <em><em>newly supported </em></em><strong><strong><em><em>YAML</em></em></strong></strong><em><em> format</em></em> ‚Äî that routes requests to a database:</p><pre><code class=\"language-yaml\">tcp:\n  routers:\n    to-database:\n      entrypoints:\n      - database-entrypoint\n      rule: HostSNI(`*`)\n      service: database-service\n  services:     \n    database-service:\n      loadBalancer:\n        servers:\n        - address: xx.xx.xx.xx:xx</code></pre><p>In the example above, every request ending on <code>database-entrypoint</code> will be routed to our <code>database-service</code>.</p><blockquote>Over TLS, Traefik routes TCP <br>requests based on the SNI</blockquote><p>In the following example, <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> routes requests to two databases based on the SNI (<em><em>Server Name Indication</em></em>):</p><pre><code class=\"language-yaml\">tcp:\n  routers:\n    to-db-1:\n      entrypoints:\n      - web-secure\n      rule: \"HostSNI(`db1.domain`)\"\n      service: \"db1\"\n      tls: {} \n    to-db-2:\n      entrypoints:\n      - web-secure\n      rule: \"HostSNI(`db2.domain`)\"\n      service: \"db2\"\n      tls: {}</code></pre><blockquote>HTTP &amp; TCP on the same port?<br>Yes, there is Traefik for that!</blockquote><p>If you ever want to have the same <em><em>entrypoint</em></em> get both HTTP and TCP requests, know that Traefik will handle it perfectly!</p><pre><code class=\"language-yaml\">tcp:\n  routers:\n    to-db-1:\n      entrypoints:\n      - web-secure\n      rule: \"HostSNI(`db1.domain`)\"\n      service: \"db-1\"\n      tls: {}\nhttp:\n  routers:\n    to-db1-dashboard:\n      entrypoints:\n      - web-secure\n      rule: \"Host(`dashboard.db1.domain`)\"\n      service: \"db1-dashboard\"\n      tls: {}</code></pre><p>In the above example, HTTP requests on <code>dashboard.db1.domain</code> will be routed to the database dashboard service, and TCP requests on <code>db1.domain</code> will be routed to the database.</p><h2 id=\"fully-customize-your-routes-with-middleware\">Fully Customize Your Routes with Middleware</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-5.png\" class=\"kg-image\"></figure><p>Traefik 2.0 introduces <a href=\"https://docs.traefik.io/middlewares/overview/\">middleware</a>: a common banner for features that tweak requests before/after routing them to their destinations.</p><blockquote>You can declare Middleware and reuse them on as <br>many routers as you like.</blockquote><p>Want to see how to configure them? Let‚Äôs declare a <a href=\"https://docs.traefik.io/middlewares/basicauth/\">BasicAuth middleware</a> to control access to our service! (this time using TOML)</p><pre><code class=\"language-toml\"># Declaring a basicauth middleware with two users\n[http.middlewares.test-auth.basicAuth]\n  users = [\"user1:hashed\", \"user2:hashed\"]\n\n# Applying the middleware to our router\n[http.routers.my-router.to-service]\n  rule = \"host(`my-protected.domain`)\"\n  middlewares = [\"test-auth\"]\n  service = \"service1\"</code></pre><blockquote>A Chain to Bind Them All</blockquote><p>If you have a classic combination you often use together, you can declare <a href=\"https://docs.traefik.io/middlewares/chain/\">chains</a>, and reuse them over and over. What‚Äôs even better for our Kubernetes users, you can use Traefik‚Äôs new CRD (Custom Resource Definition) for a crystal clear configuration that doesn‚Äôt involve intricate annotations. (You can find more information on the <a href=\"https://docs.traefik.io/providers/kubernetes-crd/#traefik-ingressroute-definition\">IngressRoute object</a> in our documentation.)</p><pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test\n  namespace: default\nspec:\n  entryPoints:\n    - web\n  routes:\n    - match: Host(`mydomain`)\n      kind: Rule\n      services:\n        - name: whoami\n          port: 80\n      middlewares:\n        - name: secured\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: secured\nspec:\n  chain:\n    middlewares:\n    - name: https-only\n    - name: known-ips\n    - name: auth-users\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: auth-users\nspec:\n  basicAuth:\n    secret: secretUsers #yes! Compatible with K8S secrets\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: https-only\nspec:\n  redirectScheme:\n    scheme: https\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: known-ips\nspec:\n  ipWhiteList:\n    sourceRange:\n    - 192.168.1.7\n    - 127.0.0.1/32</code></pre><p>At release, Traefik comes with many <a href=\"https://docs.traefik.io/middlewares/overview/\">pieces of middleware</a>: <a href=\"https://docs.traefik.io/middlewares/replacepath/\">path manipulation</a>, <a href=\"https://docs.traefik.io/middlewares/forwardauth/\">several authentication mechanisms</a>, <a href=\"https://docs.traefik.io/middlewares/buffering/\">buffering</a>, <a href=\"https://docs.traefik.io/middlewares/circuitbreaker/\">circuit breaker</a>, <a href=\"https://docs.traefik.io/middlewares/retry/\">retry</a>, <a href=\"https://docs.traefik.io/middlewares/compress/\">compression</a>, <a href=\"https://docs.traefik.io/middlewares/errorpages/\">error handling</a>, <a href=\"https://docs.traefik.io/middlewares/headers/\">headers</a>, <a href=\"https://docs.traefik.io/middlewares/ipwhitelist/\">IP whitelisting</a>, <a href=\"https://docs.traefik.io/middlewares/ratelimit/\">rate limiting</a>, <a href=\"https://docs.traefik.io/middlewares/redirectscheme/\">redirections</a>, and more.</p><p>Also, we‚Äôve re-architectured the code to make it easier for contributors to provide additional pieces of middleware, and I‚Äôm sure we‚Äôll find a way to do <a href=\"https://github.com/containous/yaegi\" rel=\"noopener\">even better</a>.</p><h2 id=\"a-new-dashboard-webui\">A New Dashboard &amp; WebUI</h2><p>Our goal with the new WebUI was to show users what was happening on their cluster at a glance. We also wanted to display what features they can enable.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-6.png\" class=\"kg-image\"></figure><p>Since the flow has changed, we wanted to display every path that leads to services, with every configuration option.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-7.png\" class=\"kg-image\"></figure><h2 id=\"canary-deployments-with-service-load-balancers\">Canary Deployments with Service Load Balancers</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-8.png\" class=\"kg-image\"></figure><p>Another <a href=\"https://github.com/containous/traefik/issues/1164\" rel=\"noopener\">long-awaited feature</a> ‚Äî canary deployments, A/B testing ‚Äî makes its way into Traefik 2.0 in the form of Service Load Balancers.</p><p>Service Load Balancers can be seen as virtual services that are responsible for forwarding the request to the actual services.</p><p>Let‚Äôs take a classic scenario where you have an existing route to an API:</p><pre><code class=\"language-yaml\">http:\n  routers:\n    my-route:\n      rule: \"Host(`my.domain`)\"\n      service: my-api-v1\n  services:\n    my-api-v1:\n      loadBalancer:\n        servers:\n        - url: \"http://private-ip-server-1/\"</code></pre><p>Now you want to deploy a new version of this service, but would like to deploy it progressively, let‚Äôs say approximately a third of the requests. What you‚Äôll do is deploy the new service, with its own ID (here it‚Äôs<code>my-api-v2</code>).</p><pre><code class=\"language-yaml\">http:\n  services:\n    my-api-v2:\n      loadBalancer:\n        servers:\n        - url: \"http://private-ip-server-2/\"</code></pre><p>Then, instead of pointing directly to this new version, you‚Äôll first define a Service Load Balancer (in the example <code>canary-api</code>) and define the proportion for each version (with the <code>weight</code> option).</p><pre><code class=\"language-yaml\">http:\n  services:\n    canary-api:\n      weighted:\n        services:\n        - name: my-api-v1\n          weight: 3\n        - name: my-api-v2\n          weight: 1</code></pre><p>Finally, point to this <code>canary-api</code> service from your router.</p><pre><code class=\"language-yaml\">http:\n  routers:\n    my-route:\n      rule: \"Host(`my.domain`)\"\n      service: canary-api</code></pre><p>Later, you‚Äôll be able to update the weight without having to redeploy your <em><em>actual</em></em> services. You‚Äôll also be able to scale them without any impact on the canary deployment itself.</p><h2 id=\"mirroring-with-service-load-balancers\">Mirroring with Service Load Balancers</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-9.png\" class=\"kg-image\"></figure><p>Canary deployments aren‚Äôt the only tricks available in the service family. Traefik 2.0 introduces Mirroring Services ‚Äî a way to <a href=\"https://github.com/containous/traefik/issues/2989\" rel=\"noopener\">duplicate the incoming request</a> and send it to different services at the same time. The mirror will get a given percentage of requests, and its answers will be ignored.</p><pre><code class=\"language-toml\">[http.services.mirrored-api]\n    [http.services.mirrored-api.mirroring]\n      service = \"api\"\n    [[http.services.mirrored-api.mirroring.mirrors]]\n      name = \"api-v2\"\n      percent = 10\n\n[http.services.api]\n    [http.services.api.loadBalancer]\n      [[http.services.api.loadBalancer.servers]]\n        url = \"http://private-ip-server-1/\"\n\n[http.services.api-v2]\n    [http.services.api-v2.loadBalancer]\n      [[http.services.api-v2.loadBalancer.servers]]\n        url = \"http://private-ip-server-2/\"</code></pre><p>In the above example, we‚Äôre sending 10% of the requests to the mirror.</p><h2 id=\"and-much-much-more-\">And Much, Much More!</h2><p>Traefik 2.0 introduces a syntax (<code>@provider</code>) to allow users to declare elements (middleware, services, routers) in a provider and to reference them from an other one. It provides an easier way to configure <a href=\"https://docs.traefik.io/middlewares/headers/#cors-headers\">CORS headers</a>, embeds a redesigned <a href=\"https://docs.traefik.io/providers/overview/#restrict-the-scope-of-service-discovery\">constraint management</a> to better control services you want to expose, and improves the default rule generation for a quick and easy way to define routes for containers.</p><p>On top of <a href=\"https://docs.traefik.io/operations/api/\">many enhancements</a>, the API now embeds status information for your middleware, services, routers, and reports errors to help you identify and fix problems.</p><p>The polished configuration options ensure that configuring Traefik is always achieved the same way whether expressed with TOML, YAML, labels, or keys, and the <a href=\"https://docs.traefik.io/\">revamped documentation</a> includes examples for every syntax.</p><p>You can define TLS termination separately on each router, configure TLS passthrough, use the new <code>CertResolver</code> to benefit from different challenges for certificate generation (yes, it‚Äôs now multiple-DNS-providers-proof!), and dynamically generate wildcard certificates.</p><p>Router rules now use a go-like syntax with <a href=\"https://docs.traefik.io/routing/routers/#rule\">operators and parenthesis</a> for powerful and readable combinations.</p><p>The list goes on and on with bug fixes and other significant tweaks!</p><hr><h2 id=\"migrating-from-1-x\">Migrating From 1.x</h2><p>With so many new features, bug fixes, and enhancements, Traefik 2.0 might ask you to re-think the way you used to route your requests. In order to facilitate the transition and help you leverage the power of these new options, we initiated a <a href=\"https://docs.traefik.io/migration/v1-to-v2/\" rel=\"noopener\">migration guide</a> that goes through every change we made.</p><p>For our <a href=\"https://kubernetes.io/\" rel=\"noopener\">Kubernetes</a> user-base, we‚Äôve also written a <a href=\"https://github.com/containous/traefik-migration-tool\" rel=\"noopener\">migration tool</a> to help you convert your Ingress objects to the new IngressRoute format. (This migration tool will also help all users convert their <code>acme.json</code> file.)</p><p>All this is designed for the thousands of people already using Traefik.</p><hr><h2 id=\"behind-the-curtain\">Behind the Curtain</h2><p>Traefik 2.0 is not the only thing that has improved! By the time we released 2.0, we launched <a href=\"https://containous.ghost.io/traefikee/\" rel=\"noopener\">TraefikEE</a>, <a href=\"https://github.com/containous/yaegi\" rel=\"noopener\">Yaegi</a>, <a href=\"https://containous.ghost.io/maesh/\">Maesh</a>, and you can bet we‚Äôll keep going further. We also constantly monitor our processes and tools. We‚Äôve launched a <a href=\"https://community.containo.us/\" rel=\"noopener\">Community Forum</a> to foster better communication amongst users, introduced a monthly journal, and scheduled <a href=\"https://containous.ghost.io/events/\">Traefik Online Meetups</a> to promote the community talent.</p><hr><h2 id=\"next-steps\">Next Steps</h2><p>More than anything, this release shows the importance of the community. <a href=\"https://github.com/containous/traefik/issues/10\" rel=\"noopener\">Every</a> <a href=\"https://github.com/containous/traefik/issues/2999\" rel=\"noopener\">feature</a> <a href=\"https://github.com/containous/traefik/issues/7\" rel=\"noopener\">that</a> <a href=\"https://github.com/containous/traefik/issues/727\" rel=\"noopener\">has</a> <a href=\"https://github.com/containous/traefik/issues/895\" rel=\"noopener\">been</a> <a href=\"https://github.com/containous/traefik/issues/1164\" rel=\"noopener\">discussed</a> <a href=\"https://github.com/containous/traefik/issues/160\" rel=\"noopener\">today</a> <a href=\"https://github.com/containous/traefik/issues/2989\" rel=\"noopener\">was born</a> <a href=\"https://github.com/containous/traefik/issues/914\" rel=\"noopener\">from</a> <a href=\"https://github.com/containous/traefik/issues/2653\" rel=\"noopener\">a</a> <a href=\"https://github.com/containous/traefik/issues/966\" rel=\"noopener\">user</a> <a href=\"https://github.com/containous/traefik/issues/3378\" rel=\"noopener\">asking for a new feature</a>, <a href=\"https://github.com/containous/traefik/issues/4069\" rel=\"noopener\">reporting a bug</a>, <a href=\"https://github.com/containous/traefik/issues/3868\" rel=\"noopener\">or just asking</a> <a href=\"https://github.com/containous/traefik/issues/2773\" rel=\"noopener\">for ‚Äúbetter.‚Äù</a></p><p>Traefik 1.X has been downloaded more than a <strong><strong>billion</strong></strong> times, and we hope to double that number with Traefik 2.X.</p><blockquote>‚ù§Ô∏è Thank you for your support!‚ù§Ô∏è</blockquote><p>‚Ä¶ and keep raising your voice for the (many) version(s) to come!</p><p>P.S. ‚Äî Stay tuned! There is so much to show you with this new version that our developer team is preparing an Online Meetup for you. :-)</p><hr><h2 id=\"useful-links\">Useful Links</h2><ul><li>Traefik <a href=\"https://docs.traefik.io/\">documentation</a>, <a href=\"https://containous.ghost.io/traefik/\">website</a> &amp; <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">Github page</a></li><li>Containous <a href=\"https://containous.ghost.io/\" rel=\"noopener\">website</a></li><li><a href=\"https://community.containo.us/\" rel=\"noopener\">Community forum</a></li></ul>","url":"https://containous.ghost.io/blog/traefik-2-0-6531ec5196c2/","canonical_url":null,"uuid":"541963bd-f2ae-4fcf-b184-0e9c60d790be","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd54affec5ed3003878888c","reading_time":7}},{"node":{"id":"Ghost__Post__5dd54a8eec5ed3003878887c","title":"Easy Ingress Management on the Edge with K3s lightweight Kubernetes and Traefik","slug":"easy-ingress-management-on-the-edge-with-k3s-lightweight-kubernetes-and-traefik-9d51c4ecacce","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/k3s-banner.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/12db4454582e4712a4b73b647841402c/ee604/k3s-banner.png","srcSet":"/static/12db4454582e4712a4b73b647841402c/630fb/k3s-banner.png 300w,\n/static/12db4454582e4712a4b73b647841402c/2a4de/k3s-banner.png 600w,\n/static/12db4454582e4712a4b73b647841402c/ee604/k3s-banner.png 800w","sizes":"(max-width: 800px) 100vw, 800px"}}},"excerpt":"K3s, by Rancher, is the best way to have a lightweight, fully CNCF conformant Kubernetes cluster. Traefik is a cloud-native dynamic reverse proxy. Its purpose...","custom_excerpt":"K3s, by Rancher, is the best way to have a lightweight, fully CNCF conformant Kubernetes cluster. Traefik is a cloud-native dynamic reverse proxy. Its purpose...","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"September 18, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-20T14:15:42.000+00:00","published_at":"2019-09-18T14:16:00.000+00:00","updated_at":"2020-05-22T00:14:40.000+00:00","meta_title":"Easy Ingress Management on the Edge with K3s and Traefik","meta_description":"K3s, by Rancher, is the best way to have a lightweight, fully CNCF conformant Kubernetes cluster. Traefik is a cloud-native dynamic reverse proxy. ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Partners","slug":"partners","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"K3s and Traefik are partnering to speed up cloud native applications deployment.\n\nK3s [http://k3s.io/], by Rancher, is the best way to have a lightweight, fully\nCNCF conformant Kubernetes cluster running on diverse infrastructures, including\npossible IoT appliances such as Raspberry Pis.\n\nK3s starts in seconds thanks to its light weight nature. As it adds some\ncomponents to the cluster automatically, k3s is very easy to use and therefore\nvery accessible for new users. One of these components is Traefik, which is\ndeployed in a k3s cluster as the default Ingress Controller.\n\nTraefik [/traefik/] is a cloud-native dynamic reverse proxy. Its purpose is to\nroute incoming requests to all your services deployed on your platform. Traefik\nis able to observe different container technologies such as Docker or Kubernetes\nto auto-configure itself.\n\nClick to continue reading‚Ä¶\n[https://rancher.com/blog/2019/ingress-on-the-edge-with-k3s-and-traefik]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">K3s and Traefik are partnering to speed up cloud native applications deployment.</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-107.png\" class=\"kg-image\"></figure><p><a href=\"http://k3s.io/\" rel=\"noopener\">K3s</a>, by Rancher, is the best way to have a lightweight, fully CNCF conformant Kubernetes cluster running on diverse infrastructures, including possible IoT appliances such as Raspberry Pis.</p><p>K3s starts in seconds thanks to its light weight nature. As it adds some components to the cluster automatically, k3s is very easy to use and therefore very accessible for new users. One of these components is Traefik, which is deployed in a k3s cluster as the default Ingress Controller.</p><p><a href=\"https://containous.ghost.io/traefik/\">Traefik</a> is a cloud-native dynamic reverse proxy. Its purpose is to route incoming requests to all your services deployed on your platform. Traefik is able to observe different container technologies such as Docker or Kubernetes to auto-configure itself.</p><p><a href=\"https://rancher.com/blog/2019/ingress-on-the-edge-with-k3s-and-traefik\" rel=\"noopener\">Click to continue reading‚Ä¶</a></p>","url":"https://containous.ghost.io/blog/easy-ingress-management-on-the-edge-with-k3s-lightweight-kubernetes-and-traefik-9d51c4ecacce/","canonical_url":null,"uuid":"a59a0479-afca-405e-abbd-c49b0d4db869","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd54a8eec5ed3003878887c","reading_time":1}},{"node":{"id":"Ghost__Post__5dd550aeec5ed3003878892e","title":"Traefik 2.0 & Docker 101","slug":"traefik-2-0-docker-101-fc2893944b9d","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/traefik-2-101-docker.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/19e113d66274fb69bbfde43d3e491cc0/f3583/traefik-2-101-docker.png","srcSet":"/static/19e113d66274fb69bbfde43d3e491cc0/630fb/traefik-2-101-docker.png 300w,\n/static/19e113d66274fb69bbfde43d3e491cc0/2a4de/traefik-2-101-docker.png 600w,\n/static/19e113d66274fb69bbfde43d3e491cc0/f3583/traefik-2-101-docker.png 1200w,\n/static/19e113d66274fb69bbfde43d3e491cc0/bbee5/traefik-2-101-docker.png 1800w,\n/static/19e113d66274fb69bbfde43d3e491cc0/0ef64/traefik-2-101-docker.png 2400w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Docker friends ‚Äî Welcome!\nToday we decided to dedicate some time to walk you through the 2.0 changes using practical & common scenarios.","custom_excerpt":"Docker friends ‚Äî Welcome!\nToday we decided to dedicate some time to walk you through the 2.0 changes using practical & common scenarios.","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"October 1, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T14:41:50.000+00:00","published_at":"2019-10-01T14:37:00.000+00:00","updated_at":"2020-05-21T22:02:15.000+00:00","meta_title":"Traefik 2.0 & Docker 101","meta_description":"Docker friends ‚Äî Welcome!\nToday we decided to dedicate some time to walk you through the 2.0 changes using practical & common scenarios.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},{"name":"Ludovic Fernandez","slug":"ldez","bio":null,"profile_image":"//www.gravatar.com/avatar/9185f906b875328134ba0d4a6bb6085a?s=250&d=mm&r=x","twitter":"@ludnadez","facebook":null,"website":"https://ldez.github.io"}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Docker","slug":"docker","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Tips & Tricks the Documentation Doesn‚Äôt Tell You\n\nDocker friends ‚Äî Welcome!\n\nToday we decided to dedicate some time to walk you through the 2.0 changes using\npractical & common scenarios. Hopefully, after having read this article, you‚Äôll\nunderstand every concept there is to know, and you‚Äôll keep learning by yourself,\ndiscovering tips & tricks to share with the community.\n\nBefore we go further, I‚Äôll assume for this article that you already have a\ndocker setup using Traefik 2.0. Since I like to use docker-compose files for\nbasic demonstrations, I‚Äôll use the following base compose file:\n\nversion: \"3.3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker=true\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n  \n  my-app:\n    image: containous/whoami:v1.3.0\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-01.yml]\nNothing fancy, we declare an entrypoint\n[https://docs.traefik.io/v2.0/routing/entrypoints/] (web for port 80), enable\nthe docker provider [https://docs.traefik.io/v2.0/providers/overview/], attach\nour traefik container to the needed ports and make sure we can listen to Docker\nthought the socket. We also have an application my-app we‚Äôll expose later.\n\nSide Note: You can get the examples from our repository if you want to play with\nthem. (Yes, we know how dangerous it can be to copy/paste some YAML :-))\n\nNow that we‚Äôre all set, let‚Äôs start!\n\n\n--------------------------------------------------------------------------------\n\nLet‚Äôs Enable the Dashboard!\nBecause we all enjoy seeing what we‚Äôre doing, we‚Äôll first enable Traefik‚Äôs\nDashboard in development mode, and all we need to do is add one argument to the\nTraefik command itself.\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker\n      - --api.insecure # Don't do that in production\n#   ...\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-02.yml]\nThere we are! By adding --api.insecure we‚Äôve enabled the API along with the\ndashboard. But beware, in this first step, we‚Äôve enabled the insecure\ndevelopment mode ‚Äî Don‚Äôt do that in production!\n\nOf course, we‚Äôll see at the end of the article how to enable a secured\ndashboard, but for now, you can enjoy and see it on localhost:8080/dashboard/\n\n\n--------------------------------------------------------------------------------\n\nMy Application Handles Requests on \"example.com\"\nIf you only need to route requests to my-app based on the host, then attach one \nlabel to your container ‚Äî That‚Äôs it!\n\nservices:\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-03.yml]\nQuick Explanation\nIn English, this label means, ‚ÄúHey Traefik! (traefik.) This HTTP router (\nhttp.routers.) I call my-app (my-app.) must catch requests to example.com (\nrule=Host(`example.com`)).‚Äù\n\nMore Details (Optional Read)\nTraefik 2.0 introduces the notion of Routers\n[https://docs.traefik.io/v2.0/routing/routers/]. Routers define the routes that\nconnect your services to the requests, and you use rules\n[https://docs.traefik.io/v2.0/routing/routers/#rule] to define what makes the\nconnection. This is the reason why you see routers in the label, as well as rule\n.\n\nTraefik 2.0 also introduces TCP support (in addition to the existing HTTP\nsupport). Since Traefik supports both protocols, it wants to know what kind of\nprotocol you‚Äôre interested in, which explains the http keyword in the label.\n\n\n--------------------------------------------------------------------------------\n\nMy Application Listens on a Specific Port\nWhat happens if your application listens on a different port than the default \n:80? Let‚Äôs say it listens on :8082. We‚Äôll build on the previous example and add\n(again) one label.\n\nservices:\n  my-service:\n    image: containous/whoami:v1.3.0\n    command:\n      - --port=8082 # Our service listens on 8082\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.services.my-app.loadbalancer.server.port=8082\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-04.yml]\nQuick Explanation\nIn English, this label means, ‚ÄúHey Traefik! (traefik.) This HTTP service (\nhttp.services.) I call my-app (my-app.) will load balance incoming requests\nbetween servers (.server) that listen on port 8082 (.port=8082).‚Äù\n\nMore Details (Optional Read)\nTraefik 2.0 introduces the notion of Services\n[https://docs.traefik.io/v2.0/routing/services/]. Services are the targets for\nthe routes. They usually define how to reach your programs in your cluster.\nServices can have different types. The most common one is the LoadBalancer\n[https://docs.traefik.io/v2.0/routing/services/#servers-load-balancer] type. The\nLoadBalancer type is a round robin between all the available instances (called \nserver). By default, Traefik considers that your program is available on the\nport exposed by the Dockerfile of your program, but you can change that by\nexplicitly defining the port.\n\nSince we specify only one service in the example, there is no need to define the\ntarget of the previously defined router explicitly.\n\nSide Note: The‚Äî-port=8082 command is specific to our whoami application and has\nnothing to do with Traefik. It tells whoami to start listening on 8082, so we\ncan simulate our use case.\n\n\n--------------------------------------------------------------------------------\n\nI Need BasicAuth (Or Any Piece of Middleware)\nOnce Traefik has found a match for the request, it can process it before\nforwarding it to the service. In the following example, we‚Äôll add a BasicAuth\nmechanism for our route. This is done with two additional labels.\n\nservices:\n  my-svc:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.routers.my-app.middlewares=auth\n      - traefik.http.middlewares.auth.basicauth.users=test:xxx\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-05.yml]\nQuick Explanation\nIn English, the first label means, ‚ÄúHey Traefik! (traefik.) My HTTP router I\ncalled my-app, remember? (http.routers.my-app.) I‚Äôd like to attach to it a piece\nof middleware named auth (.middlewares=auth).‚Äù\n\nOf course, since we haven‚Äôt yet declared the auth middleware, we need to be a\nbit more explicit, so the second label means, ‚ÄúHey Traefik! (traefik.) Let‚Äôs\ntalk about an HTTP middleware (http.middlewares.) I call auth (auth.). It‚Äôs a\nBasicAuth middleware (basicauth.). Since you probably need users to know who can\ndo what, here is the users list (.users=test:xxx).‚Äù\n\nMore Details (Optional Read)\nTraefik 2.0 introduces the notion of Middleware\n[https://docs.traefik.io/v2.0/middlewares/overview/]. Middleware is a way to\ndefine behaviors and tweak the incoming request before forwarding it to the\nservice. Since they act before the request is forwarded, they are attached to\nRouters. You can define middleware and reuse them as many times as you like\n(this is why you need to name them, in the example auth). There are many kinds\nof middleware, and BasicAuth\n[https://docs.traefik.io/v2.0/middlewares/basicauth/] is one of them. Each\nmiddleware has a different set of parameters to define their behaviors (in the\nexample, we define the users list).\n\n\n--------------------------------------------------------------------------------\n\nI Need HTTPS\nWith Traefik, enabling automatic certificate generation is a matter of 4 lines\nof configuration, and enabling HTTPS on your routes is a matter of 2 lines of\nconfiguration.\n\n1 ‚Äî Enabling Automatic Certificate Generation\n\nWe‚Äôll introduce a little tip here ‚Äî Since Traefik is launched as a container,\nwe‚Äôll attach labels to it for common configuration options. (What is specific to\nother containers will, of course, stay on other containers, we‚Äôre not messy\npeople!)\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.websecure.address=:443\n      # ...\n      - --certificatesresolvers.le.acme.email=my@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n      # ...\n    ports:\n      # ...\n      - \"443:443\"\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml]\nQuick Explanation\nWe‚Äôve seen already the first command line given to Traefik. In English, it\nmeans, ‚ÄúI have an entrypoint (entrypoints.) I call websecure (websecure.) that\nuses port 443 (.address=:443).‚Äù And since Traefik now listens to 443, we need to\ntell Docker that it should bind external port 443 to our service‚Äôs port 443 (\n\"443:443\").\n\nNow, the others are a bit trickier, but nothing crazy if you‚Äôve had time to\ndrink your coffee/tea. The first says, ‚ÄúI‚Äôd like a mechanism to generate\ncertificates for me (certificatesresolvers.) that I‚Äôll call le (le.). It‚Äôs an\nacme resolver (acme.), my account there is my@email.com (email=my@email.com).‚Äù\n(Disclaimer: not my real email address, don‚Äôt try it.)\n\nThe second says, ‚ÄúThis mechanism named le I told you about, the acme stuff (\ncertificatesresolvers.le.acme.), it will save the certificates in the file \n/acme.json (storage=/acme.json).‚Äù\n\nAnd the third is our inner geek speaking, ‚ÄúSince this le mechanism I defined\nbefore (certificatesresolvers.le.acme.) supports different challenges for\ncertificate generation, I‚Äôll choose ‚Ä¶ the TLS challenge (tlschallenge=true).‚Äù\n\nThat was a bit more text than usual, but here we are: we have a fully functional\nmechanism to generate/renew certificates for us!\n\nMore Details (Optional Read)\nTraefik 2.0 introduces the notion of CertificatesResolvers\n[https://docs.traefik.io/v2.0/https/acme/]. Certificates resolvers are a system\nthat handles certificate generation/renewal/disposal for you. They detect the\nhosts you‚Äôve defined for your routers and get the matching certificates.\n\nCurrently, certificates resolvers leverage Let‚Äôs Encrypt\n[https://letsencrypt.org/] to get certificates, and expect you to configure your\naccount (which is basically your email address). In order to prove Let‚Äôs Encrypt\nthat you‚Äôre the owner of the domains you‚Äôll request certificates for, LE will\ngive Traefik a challenge. There are multiple possible challenges, and we chose\nin the example the TLSChallenge. In the documentation, you‚Äôll find a description\nfor each other challenges\n[https://docs.traefik.io/v2.0/https/acme/#the-different-acme-challenges] (\ndnsChallenge [https://docs.traefik.io/v2.0/https/acme/#dnschallenge] and \nhttpChallenge [https://docs.traefik.io/v2.0/https/acme/#httpchallenge]).\n\nKnow that advanced users can define multiple CertificatesResolvers using\ndifferent challenges, and that they can use them to generate wildcards ‚Ä¶ but\nthat‚Äôs a story we‚Äôll talk about later :-)\n\n2 ‚Äî Enabling Automatic Certificate Generation\n\nNow that we have a mechanism to generate certificates for us, let‚Äôs leverage it\nto enable HTTPS on our route. We‚Äôll only need two labels!\n\nmy-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.routers.my-app.middlewares=auth\n      - traefik.http.routers.my-app.tls.certresolver=le\n      - traefik.http.routers.my-app.entrypoints=websecure\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml]\nQuick Explanation\nIn English, the first label means, ‚ÄúHey Traefik! (traefik.) My HTTP router (\nhttp.routers.) I call my-app (my-app.) uses TLS and the CertificateResolver\nnamed le (certresolver=le).‚Äù\n\nAnd the second says, ‚ÄúTraefik! (traefik.) this router, you know? (\nhttp.routers.my-app) It will only listen to the entrypoint I call websecure (\nentrypoints=websecure).‚Äù\n\nMore Details (Optional Read)\nTraefik 2.0 allows you to define TLS termination directly on your routers\n[https://docs.traefik.io/v2.0/routing/routers/#tls]!\n\nAlso, by default, routers listen to every known entrypoints. In our example, we\nwanted Traefik to limit the use of https on port 443, which is the reason why we\ntold the router to listen only to websecure (defined to port 443 with \nentrypoints.websecure.address=:443)\n\n\n--------------------------------------------------------------------------------\n\nI Want HTTPS Redirection!\nNow that we have HTTPS routes, let‚Äôs redirect every non-https requests to their\nhttps equivalent. For that, we‚Äôll reuse the previous trick and add just 4 labels \nto declare a redirect middleware and a catch-all router for unsecured routes.\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    # ...\n    labels:\n      # ...\n      \n      # middleware redirect\n      - \"traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https\"\n      \n      # global redirect to https\n      - \"traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\"\n      - \"traefik.http.routers.redirs.entrypoints=web\"\n      - \"traefik.http.routers.redirs.middlewares=redirect-to-https\"\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-07.yml]\nQuick Explanation\nIn English, the first label means, ‚ÄúHey Traefik! (traefik.) let‚Äôs declare an\nHTTP middleware (http.middlewares.) we‚Äôll call redirect-to-https (\nredirect-to-https.). It‚Äôs a RedirectScheme\n[https://docs.traefik.io/v2.0/middlewares/redirectscheme/] middleware (\nredirectscheme.) that will force the scheme to https (scheme=https).‚Äù\n\nThen, let‚Äôs see the router part, ‚ÄúHey Traefik! (you know the drill) (traefik.) I\nhave an HTTP router (http.routers.) I‚Äôll call redirs (redirs.) that will match\nrequests on any host (rule=hostregexp(`{host:.+}`)) Yes sir! I‚Äôm insane and will\ncatch everything, that‚Äôs how greedy I am.‚Äù\n\nThen, we add, ‚ÄúHey Traefik! (traefik.) I was kidding ‚Ä¶ the redirs HTTP router (\nhttp.routers.redirs.) won‚Äôt catch everything but just requests on port 80 (\nentrypoints=web).‚Äù\n\nFinally, we‚Äôll add the redirect middleware to the router. ‚ÄúTraefik? (traefik.)\nOn the redirs HTTP router (http.routers.redirs.) we‚Äôll add the redirect-to-https \nmiddleware (middlewares=redirect-to-https).‚Äù\n\nMore Details (Optional Read)\nBy now, we‚Äôve seen everything there is to know, so no additional details to\nlearn about :-)\n\n\n--------------------------------------------------------------------------------\n\nCompiling Everything for a Secured Dashboard!\nNow that we‚Äôve manipulated every important notion (Entrypoints, Routers,\nMiddleware, Services, CertificatesResolvers & TLS), we can combine them to\nobtain a secured Dashboard!\n\nversion: \"3.3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --entrypoints.websecure.address=:443\n      - --providers.docker\n      - --api\n      - --certificatesresolvers.le.acme.email=your@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n      - \"./acme.json:/acme.json\"\n    labels:\n      # Dashboard\n      - \"traefik.http.routers.traefik.rule=Host(`api.example.com`)\"\n      - \"traefik.http.routers.traefik.service=api@internal\"\n      - \"traefik.http.routers.traefik.middlewares=admin\"\n      - \"traefik.http.routers.traefik.tls.certresolver=le\"\n      - \"traefik.http.routers.traefik.entrypoints=websecure\"\n      - \"traefik.http.middlewares.admin.basicauth.users=admin:xxx\"\n\n      # ...\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-09.yml]\nQuick Explanation\nFirst, we remove the insecure api (specifying --api instead of --api.insecure).\n\nThen, we tell Traefik (traefik.) to add an HTTP router called traefik (\nhttp.routers.traefik.) catching requests on api.example.com (\nrule=Host(`api.example.com`)).\n\nThis router (traefik.http.routers.traefik.) will forward requests to a service\ncalled api@internal (service=api@internal), uses a middleware named admin (\nmiddlewares=admin), and uses tls (tls=true) with a certresolver called le (\ntls.certresolver=le).\n\nFinally, we declare the admin middleware (\ntraefik.http.middlewares.admin.basicauth.users=admin:xxx).\n\nMore Details (Optional Read)\nThe only subtle thing to know is that when you enable the api (in default mode,\nit creates an internal service called api@internal (It‚Äôs then up to you to\nproperly secure it).\n\n\n--------------------------------------------------------------------------------\n\nQuestions? Where to Go Next?\nHopefully, we‚Äôve gone through important questions you‚Äôll have when dealing with\nTraefik 2.0 in a Docker setup, and we hope this article brings many answers.\n\nIf you want to keep the conversation going, let us know on the community forum\n[https://community.containo.us/c/traefik/traefik-v2]!\n\nIn the meantime ‚Äî Happy Traefik!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Tips & Tricks the Documentation Doesn‚Äôt Tell You</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-109.png\" class=\"kg-image\"></figure><p>Docker friends ‚Äî Welcome!</p><p>Today we decided to dedicate some time to walk you through the 2.0 changes using practical &amp; common scenarios. Hopefully, after having read this article, you‚Äôll understand every concept there is to know, and you‚Äôll keep learning by yourself, discovering tips &amp; tricks to share with the community.</p><p>Before we go further, I‚Äôll assume for this article that you already have a docker setup using Traefik 2.0. Since I like to use docker-compose files for basic demonstrations, I‚Äôll use the following base compose file:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">version: \"3.3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker=true\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n  \n  my-app:\n    image: containous/whoami:v1.3.0</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-01.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><p><em><em>Nothing fancy, we declare an </em></em><a href=\"https://docs.traefik.io/v2.0/routing/entrypoints/\" rel=\"noopener\"><em><em>entrypoint</em></em></a><em><em> (</em></em><code><em><em>web</em></em></code><em><em> for port </em></em><code><em><em>80</em></em></code><em><em>), enable the docker </em></em><a href=\"https://docs.traefik.io/v2.0/providers/overview/\" rel=\"noopener\"><em><em>provider</em></em></a><em><em>, attach our traefik container to the needed ports and make sure we can listen to Docker thought the socket. We also have an application </em></em><code><em><em>my-app</em></em></code><em><em> we‚Äôll expose later.</em></em></p><p><strong><strong>Side Note</strong></strong>: You can get the examples from our repository if you want to play with them. (Yes, we know how dangerous it can be to copy/paste some YAML :-))</p><p>Now that we‚Äôre all set, let‚Äôs start!</p><hr><h2 id=\"let-s-enable-the-dashboard-\">Let‚Äôs Enable the Dashboard!</h2><p>Because we all enjoy seeing what we‚Äôre doing, we‚Äôll first enable Traefik‚Äôs Dashboard in <em><em>development</em></em> mode, and all we need to do is add <em><em>one</em></em> argument to the Traefik command itself.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker\n      - --api.insecure # Don't do that in production\n#   ...</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-02.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><p>There we are! By adding <code>--api.insecure</code> we‚Äôve enabled the API along with the dashboard. But beware, in this first step, we‚Äôve enabled the insecure development mode ‚Äî Don‚Äôt do that in production!</p><p>Of course, we‚Äôll see at the end of the article how to enable a secured dashboard, but for now, you can enjoy and see it on localhost:8080/dashboard/</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-11.png\" class=\"kg-image\"></figure><hr><h2 id=\"my-application-handles-requests-on-example-com\">My Application Handles Requests on \"example.com\"</h2><p>If you only need to route requests to <code>my-app</code> based on the host, then attach <em><em>one</em></em> label to your container ‚Äî That‚Äôs it!</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-03.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation\">Quick Explanation</h3><p>In English, this label means, ‚ÄúHey Traefik! (<code>traefik.</code>) This HTTP router (<code>http.routers.</code>) I call my-app (<code>my-app.</code>) must catch requests to example.com (<code>rule=Host(`example.com`)</code>).‚Äù</p><h3 id=\"more-details-optional-read-\">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href=\"https://docs.traefik.io/v2.0/routing/routers/\" rel=\"noopener\">Routers</a>. Routers define the routes that connect your services to the requests, and you use <a href=\"https://docs.traefik.io/v2.0/routing/routers/#rule\" rel=\"noopener\">rules</a> to define <em><em>what</em></em> makes the connection. This is the reason why you see <code>routers</code> in the label, as well as <code>rule</code>.</p><p>Traefik 2.0 also introduces TCP support (in addition to the existing HTTP support). Since Traefik supports both protocols, it wants to know what kind of protocol you‚Äôre interested in, which explains the <code>http</code> keyword in the label.</p><hr><h2 id=\"my-application-listens-on-a-specific-port\">My Application Listens on a Specific Port</h2><p>What happens if your application listens on a different port than the default <code>:80</code>? Let‚Äôs say it listens on <code>:8082</code>. We‚Äôll build on the previous example and add (again) <em><em>one</em></em> label.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  my-service:\n    image: containous/whoami:v1.3.0\n    command:\n      - --port=8082 # Our service listens on 8082\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.services.my-app.loadbalancer.server.port=8082</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-04.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-1\">Quick Explanation</h3><p>In English, this label means, ‚ÄúHey Traefik! (<code>traefik.</code>) This HTTP service (<code>http.services.</code>) I call my-app (<code>my-app.</code>) will load balance incoming requests between servers (<code>.server</code>) that listen on port 8082 (<code>.port=8082</code>).‚Äù</p><h3 id=\"more-details-optional-read--1\">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href=\"https://docs.traefik.io/v2.0/routing/services/\" rel=\"noopener\">Services</a>. Services are the <em><em>targets</em></em> for the routes. They usually define how to reach your programs in your cluster. Services can have different types. The most common one is the <a href=\"https://docs.traefik.io/v2.0/routing/services/#servers-load-balancer\" rel=\"noopener\">LoadBalancer</a> type. The LoadBalancer type is a round robin between all the available instances (called <code>server</code>). By default, Traefik considers that your program is available on the port exposed by the Dockerfile of your program, but you can change that by explicitly defining the port.</p><p>Since we specify only one service in the example, there is no need to define the target of the previously defined router explicitly.</p><p>Side Note: The<code>‚Äî-port=8082</code> command is specific to our <code>whoami</code> application and has nothing to do with Traefik. It tells <code>whoami</code> to start listening on 8082, so we can simulate our use case.</p><hr><h2 id=\"i-need-basicauth-or-any-piece-of-middleware-\">I Need BasicAuth (Or Any Piece of Middleware)</h2><p>Once Traefik has found a match for the request, it can process it before forwarding it to the service. In the following example, we‚Äôll add a BasicAuth mechanism for our route. This is done with <em><em>two</em></em> additional labels.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  my-svc:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.routers.my-app.middlewares=auth\n      - traefik.http.middlewares.auth.basicauth.users=test:xxx</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-05.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-2\">Quick Explanation</h3><p>In English, the first label means, ‚ÄúHey Traefik! (<code>traefik.</code>) My HTTP router I called my-app, remember? (<code>http.routers.my-app.</code>) I‚Äôd like to attach to it a piece of middleware named auth (<code>.middlewares=auth</code>).‚Äù</p><p>Of course, since we haven‚Äôt yet declared the <code>auth</code> middleware, we need to be a bit more explicit, so the second label means, ‚ÄúHey Traefik! (<code>traefik.</code>) Let‚Äôs talk about an HTTP middleware (<code>http.middlewares.</code>) I call auth (<code>auth.</code>). It‚Äôs a BasicAuth middleware (<code>basicauth.</code>). Since you probably need users to know who can do what, here is the users list (<code>.users=test:xxx</code>).‚Äù</p><h3 id=\"more-details-optional-read--2\">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href=\"https://docs.traefik.io/v2.0/middlewares/overview/\" rel=\"noopener\">Middleware</a>. Middleware is a way to define behaviors and tweak the incoming request before forwarding it to the service. Since they act before the request is forwarded, they are attached to Routers. You can define middleware and reuse them as many times as you like (this is why you need to name them, in the example <code>auth</code>). There are many kinds of middleware, and <a href=\"https://docs.traefik.io/v2.0/middlewares/basicauth/\" rel=\"noopener\">BasicAuth</a> is one of them. Each middleware has a different set of parameters to define their behaviors (in the example, we define the users list).</p><hr><h2 id=\"i-need-https\">I Need HTTPS</h2><p>With Traefik, enabling automatic certificate generation is a matter of <em><em>4 lines of configuration, </em></em>and enabling HTTPS on your routes is a matter of<em><em> 2 lines of configuration</em></em>.</p><p><strong><strong>1 ‚Äî Enabling Automatic Certificate Generation</strong></strong></p><p>We‚Äôll introduce a little tip here ‚Äî Since Traefik is launched as a container, we‚Äôll attach labels to it for common configuration options. (What is specific to other containers will, of course, stay on other containers, we‚Äôre not messy people!)</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.websecure.address=:443\n      # ...\n      - --certificatesresolvers.le.acme.email=my@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n      # ...\n    ports:\n      # ...\n      - \"443:443\"</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-3\">Quick Explanation</h3><p>We‚Äôve seen already the first command line given to Traefik. In English, it means, ‚ÄúI have an entrypoint (<code>entrypoints.</code>) I call websecure (<code>websecure.</code>) that uses port 443 (<code>.address=:443</code>).‚Äù And since Traefik now listens to 443, we need to tell Docker that it should bind external port 443 to our service‚Äôs port 443 (<code>\"443:443\"</code>).</p><p>Now, the others are a bit trickier, but nothing crazy if you‚Äôve had time to drink your coffee/tea. The first says, ‚ÄúI‚Äôd like a mechanism to generate certificates for me (<code>certificatesresolvers.</code>) that I‚Äôll call le (<code>le.</code>). It‚Äôs an acme resolver (<code>acme.</code>), my account there is <code>my@email.com</code> (<code>email=my@email.com</code>).‚Äù (Disclaimer: not my real email address, don‚Äôt try it.)</p><p>The second says, ‚ÄúThis mechanism named <code>le</code> I told you about, the acme stuff (<code>certificatesresolvers.le.acme.</code>), it will save the certificates in the file <code>/acme.json </code>(<code>storage=/acme.json</code>).‚Äù</p><p>And the third is our inner geek speaking, ‚ÄúSince this <code>le</code> mechanism I defined before (<code>certificatesresolvers.le.acme.</code>) supports different challenges for certificate generation, I‚Äôll choose ‚Ä¶ the TLS challenge (<code>tlschallenge=true</code>).‚Äù</p><p>That was a bit more text than usual, but here we are: we have a fully functional mechanism to generate/renew certificates for us!</p><h3 id=\"more-details-optional-read--3\">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href=\"https://docs.traefik.io/v2.0/https/acme/\" rel=\"noopener\">CertificatesResolvers</a>. Certificates resolvers are a system that handles certificate generation/renewal/disposal for you. They detect the hosts you‚Äôve defined for your routers and get the matching certificates.</p><p>Currently, certificates resolvers leverage <a href=\"https://letsencrypt.org/\" rel=\"noopener\">Let‚Äôs Encrypt</a> to get certificates, and expect you to configure your account (which is basically your email address). In order to prove Let‚Äôs Encrypt that you‚Äôre the owner of the domains you‚Äôll request certificates for, LE will give Traefik a challenge. There are multiple possible challenges, and we chose in the example the TLSChallenge. In the documentation, you‚Äôll find a description for each <a href=\"https://docs.traefik.io/v2.0/https/acme/#the-different-acme-challenges\" rel=\"noopener\">other challenges</a> (<a href=\"https://docs.traefik.io/v2.0/https/acme/#dnschallenge\" rel=\"noopener\">dnsChallenge</a> and <a href=\"https://docs.traefik.io/v2.0/https/acme/#httpchallenge\" rel=\"noopener\">httpChallenge</a>).</p><p>Know that advanced users can define multiple CertificatesResolvers using different challenges, and that they can use them to generate wildcards ‚Ä¶ but that‚Äôs a story we‚Äôll talk about later :-)</p><p><strong><strong>2 ‚Äî Enabling Automatic Certificate Generation</strong></strong></p><p>Now that we have a mechanism to generate certificates for us, let‚Äôs leverage it to enable HTTPS on our route. We‚Äôll only need <em><em>two</em></em> labels!</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.routers.my-app.middlewares=auth\n      - traefik.http.routers.my-app.tls.certresolver=le\n      - traefik.http.routers.my-app.entrypoints=websecure</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-4\">Quick Explanation</h3><p>In English, the first label means, ‚ÄúHey Traefik! (<code>traefik.</code>) My HTTP router (<code>http.routers.</code>) I call <em><em>my-app</em></em> (<code>my-app.</code>) uses TLS and the CertificateResolver named le (<code>certresolver=le</code>).‚Äù</p><p>And the second says, ‚ÄúTraefik! (<code>traefik.</code>) this router, you know? (<code>http.routers.my-app</code>) It will only listen to the <em><em>entrypoint</em></em> I call <em><em>websecure </em></em>(<code>entrypoints=websecure</code>).‚Äù</p><h3 id=\"more-details-optional-read--4\">More Details (Optional Read)</h3><p>Traefik 2.0 allows you to define TLS termination <a href=\"https://docs.traefik.io/v2.0/routing/routers/#tls\" rel=\"noopener\">directly on your routers</a>!</p><p>Also, by default, routers listen to every known <em><em>entrypoints</em></em>. In our example, we wanted Traefik to limit the use of https on port <code>443</code>, which is the reason why we told the router to listen only to <em><em>websecure</em></em> (defined to port 443 with <code>entrypoints.websecure.address=:443</code>)</p><hr><h2 id=\"i-want-https-redirection-\">I Want HTTPS Redirection!</h2><p>Now that we have HTTPS routes, let‚Äôs redirect every non-https requests to their https equivalent. For that, we‚Äôll reuse the previous trick and add just <em><em>4 labels</em></em> to declare a redirect middleware and a catch-all router for unsecured routes.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    # ...\n    labels:\n      # ...\n      \n      # middleware redirect\n      - \"traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https\"\n      \n      # global redirect to https\n      - \"traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\"\n      - \"traefik.http.routers.redirs.entrypoints=web\"\n      - \"traefik.http.routers.redirs.middlewares=redirect-to-https\"</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-07.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-5\">Quick Explanation</h3><p>In English, the first label means, ‚ÄúHey Traefik! (<code>traefik.</code>) let‚Äôs declare an HTTP middleware (<code>http.middlewares.</code>) we‚Äôll call redirect-to-https (<code>redirect-to-https.</code>). It‚Äôs a <a href=\"https://docs.traefik.io/v2.0/middlewares/redirectscheme/\" rel=\"noopener\">RedirectScheme</a> middleware (<code>redirectscheme.</code>) that will force the scheme to https (<code>scheme=https</code>).‚Äù</p><p>Then, let‚Äôs see the router part, ‚ÄúHey Traefik! (you know the drill) (<code>traefik.</code>) I have an HTTP router (<code>http.routers.</code>) I‚Äôll call redirs (<code>redirs.</code>) that will match requests on any host (<code>rule=hostregexp(`{host:.+}`)</code>) Yes sir! I‚Äôm insane and will catch everything, that‚Äôs how greedy I am.‚Äù</p><p>Then, we add, ‚ÄúHey Traefik! (<code>traefik.</code>) I was kidding ‚Ä¶ the <em><em>redirs</em></em> HTTP router (<code>http.routers.redirs.</code>) won‚Äôt catch everything but just requests on port 80 (<code>entrypoints=web</code>).‚Äù</p><p>Finally, we‚Äôll add the redirect middleware to the router. ‚ÄúTraefik? (<code>traefik.</code>) On the <em><em>redirs</em></em> HTTP router (<code>http.routers.redirs.</code>) we‚Äôll add the <em><em>redirect-to-https</em></em> middleware (<code>middlewares=redirect-to-https</code>).‚Äù</p><h3 id=\"more-details-optional-read--5\">More Details (Optional Read)</h3><p>By now, we‚Äôve seen everything there is to know, so no additional details to learn about :-)</p><hr><h2 id=\"compiling-everything-for-a-secured-dashboard-\">Compiling Everything for a Secured Dashboard!</h2><p>Now that we‚Äôve manipulated every important notion (Entrypoints, Routers, Middleware, Services, CertificatesResolvers &amp; TLS), we can combine them to obtain a secured Dashboard!</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">version: \"3.3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --entrypoints.websecure.address=:443\n      - --providers.docker\n      - --api\n      - --certificatesresolvers.le.acme.email=your@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n      - \"./acme.json:/acme.json\"\n    labels:\n      # Dashboard\n      - \"traefik.http.routers.traefik.rule=Host(`api.example.com`)\"\n      - \"traefik.http.routers.traefik.service=api@internal\"\n      - \"traefik.http.routers.traefik.middlewares=admin\"\n      - \"traefik.http.routers.traefik.tls.certresolver=le\"\n      - \"traefik.http.routers.traefik.entrypoints=websecure\"\n      - \"traefik.http.middlewares.admin.basicauth.users=admin:xxx\"\n\n      # ...</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-09.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-6\">Quick Explanation</h3><p>First, we remove the insecure api (specifying <code>--api</code> instead of <code>--api.insecure</code>).</p><p>Then, we tell Traefik (<code>traefik.</code>) to add an HTTP router called traefik (<code>http.routers.traefik.</code>) catching requests on <em><em>api.example.com</em></em> (<code>rule=Host(`api.example.com`)</code>).</p><p>This router (<code>traefik.http.routers.traefik.</code>) will forward requests to a service called api@internal (<code>service=api@internal</code>), uses a middleware named admin (<code>middlewares=admin</code>), and uses tls (<code>tls=true</code>) with a certresolver called <em><em>le</em></em> (<code>tls.certresolver=le</code>).</p><p>Finally, we declare the admin middleware (<code>traefik.http.middlewares.admin.basicauth.users=admin:xxx</code>).</p><h3 id=\"more-details-optional-read--6\">More Details (Optional Read)</h3><p>The only subtle thing to know is that when you enable the api (in default mode, it creates an internal service called <code>api@internal</code> (It‚Äôs then up to you to properly secure it).</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-12.png\" class=\"kg-image\"></figure><hr><h2 id=\"questions-where-to-go-next\">Questions? Where to Go Next?</h2><p>Hopefully, we‚Äôve gone through important questions you‚Äôll have when dealing with Traefik 2.0 in a Docker setup, and we hope this article brings many answers.</p><p>If you want to keep the conversation going, let us know on the <a href=\"https://community.containo.us/c/traefik/traefik-v2\" rel=\"noopener\">community forum</a>!</p><p>In the meantime ‚Äî Happy Traefik!</p>","url":"https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/","canonical_url":null,"uuid":"56123f92-a17f-4afe-a461-a255ae2f2e1e","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd550aeec5ed3003878892e","reading_time":9}},{"node":{"id":"Ghost__Post__5dd548aeec5ed3003878884c","title":"13 Key Considerations When Selecting an Ingress Controller for Kubernetes","slug":"13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/13-keys-considerations-ingress.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/c55e2e1f948717dedf6b7ee99f99d704/f3583/13-keys-considerations-ingress.png","srcSet":"/static/c55e2e1f948717dedf6b7ee99f99d704/630fb/13-keys-considerations-ingress.png 300w,\n/static/c55e2e1f948717dedf6b7ee99f99d704/2a4de/13-keys-considerations-ingress.png 600w,\n/static/c55e2e1f948717dedf6b7ee99f99d704/f3583/13-keys-considerations-ingress.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ","custom_excerpt":"Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"October 8, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T14:07:42.000+00:00","published_at":"2019-10-08T14:11:00.000+00:00","updated_at":"2020-05-21T22:06:35.000+00:00","meta_title":"Considerations When Picking an Ingress Controller for Kubernetes","meta_description":"Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#kubernetes-ingress-related-resource","slug":"hash-kubernetes-ingress-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Evaluating Ingress Controllers\nIngresses are critical to any successful Kubernetes (k8s) deployment. Ingresses\nallow you to define how external (and/or internal) traffic is routed to services\nwithin your cluster. The Kubernetes documentation\n[https://kubernetes.io/docs/concepts/services-networking/ingress/] states that:\n\n> ‚ÄúAn Ingress can be configured to give Services externally-reachable URLs, load\nbalance traffic, terminate SSL / TLS, and offer name based virtual hosting.‚Äù\nHowever, Ingresses themselves don‚Äôt do anything ‚Äî they‚Äôre just metadata. The\nheavy lifting is performed by Ingress Controllers. An Ingress without an Ingress\nController won‚Äôt do anything. There‚Äôs one more catch: while there are a number\nof system controllers (like ReplicaSet Controller, Endpoints Controller,\nNamespace Controller and others) that are managed by the Kubernetes control\nplane, Ingress Controllers are not automatically started with a cluster ‚Äî you\nhave to install, configure and manage your own Ingress Controllers.\n\nIt‚Äôs also possible to have multiple Ingress Controllers in the same cluster. You\ncan divide the ‚Äúrouting space‚Äù by using Ingress class annotations, so that each\nIngress knows which Ingress Controller should be handling it. You could end up\nusing a combination of Ingress Controllers for different scenarios within the\nsame cluster. For example, you may have one Ingress Controller for handling\nexternal traffic coming in to the cluster including bindings to SSL\ncertificates, and have another internal Ingress Controller with no SSL binding\nthat handles in-cluster traffic.\n\nThere are scores of Ingress Controllers to choose from. The Kubernetes\ndocumentation has a list of popular Ingress Controllers here\n[https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers]\n.\n\nThese controllers have varied feature sets and varying levels of community or\ncommercial support. Some are ‚Äúpure‚Äù edge routers, while others have features\nmore akin to service meshes.\n\nSelecting the Right Ingress Controller\nSo how do you choose the right Ingress Controller? There are several criteria\nthat are important to consider when doing so. In this post we‚Äôre not going to do\na feature comparison between specific Ingress Controllers, since there are many\nhead-to-head comparisons on the internet already, and because there are so many\nIngress Controllers. Rather, we‚Äôre going to discuss what features you should be\nweighing when selecting an Ingress Controller.\n\n1/ Traffic Protocol\nAre you just routing HTTP(S), HTTP/2 or websockets? Do you want to route TCP/UDP\nor gRPC? Not all Ingress Controllers support all these protocols, so you‚Äôll have\nto check which protocols an Ingress Controller supports.\n\n2/ Dynamic Configuration Updates\nDo you require zero-downtime configuration changes ‚Äî often called ‚Äúhitless\nreloads‚Äù? Some Ingress Controllers require downtime in order to update\nconfiguration, while others update dynamically without downtime.\n\n3/ Resiliency\nDo you need rate limiting, retries or circuit breakers at the edge, or have you\nbuilt this functionality into your services yourself? Some Ingress Controllers\nsupport these features, which means you won‚Äôt have to code them yourself.\n\n4/ External Load Balancer Integration\nAre you integrating with an external, managed cloud-based load balancer? Make\nsure the Ingress Controller you select integrates well with your external load\nbalancer in order to reduce work and management for your networking team.\n\n5/ Service Mesh\nIngress Controllers can be configured to handle external traffic (traffic\noriginating outside the cluster) or internal traffic or both. If you need to\nobserve or trace internal traffic, you may need a special breed of Ingress\nController ‚Äî a Service Mesh. Kubernetes provides standards for Service Meshes\nthrough the SMI Specification for interoperability. If you do require a Service\nMesh, make sure you pick the right tool for the right job. Ingress Controllers\nand Service Meshes are not mutually exclusive.\n\n6/ API Gateway\nDo you need an Ingress Controller or an API gateway, or something that does\nboth? Typically API gateways integrate business logic, while edge routers are\ntypically business agnostic. For example, API Gateways let you monitor traffic\nper customer, or measure transactions for billing purposes. If you require\nbusiness logic at the edge, you should probably look at an API gateway instead\nof an Ingress Controller. Just as with Service Meshes, Ingress Controller and\nAPI gateways are not mutually exclusive.\n\n7/ High Availability\nCan you afford downtime when a server restarts for either planned or unplanned\nmaintenance? If so, you need high availability for your Ingress Controller. Not\nall Ingress Controllers support high availability.\n\n8/ Load Balancing Algorithms\nWhat sort of algorithm-based routing do you need? Most Ingress Controllers\nsupport Round Robin, but if you want Least Connection so that the load on your\nservices is taken into account, you‚Äôll need an Ingress Controller that supports\nmore advanced load balancing algorithms.\n\n9/ Advanced Traffic Shifting\nDo you need to perform canary testing (shifting a percentage of traffic to\ndifferent services for progressive exposure)? Load balancing lets you spread the\nload of a service, but not all load balancers can split traffic using more\nsophisticated rules. If you‚Äôre testing in production using techniques like\ncanary testing, make sure the Ingress Controller you select supports traffic\nshifting.\n\n10/ Resources Constraints\nAre you cost sensitive as far as resources in your cluster are concerned?\nIngress Controllers can be resource intensive, so if you are cost sensitive,\nyou‚Äôre going to be better off with a light-weight Ingress Controller. Some\nIngress Controllers support scaling up and down, while others do not.\n\n11/ Monitoring\nDo you need to integrate with existing metrics and log collection systems? Some\nIngress Controllers offer limited monitoring and logging and may not support\nyour specific monitoring and logging tooling.\n\n12/ Support\nDo you need enterprise support? Open source Ingress Controllers are easy on the\ncheck book, but what happens when you need support in the middle of the night?\nRemember, some open source Ingress Controllers offer enterprise support plans.\n\n13/ Ecosystem\nMake sure the Ingress Controller you are considering has support in the\nKubernetes partner ecosystem.\n\nConclusion\nAs you can see, there are many factors that require thought before you can\nselect the right Ingress Controller for your clusters. Don‚Äôt just select a\nhype-driven, popular option ‚Äî be deliberate about your requirements and then\nevaluate Ingress Controllers according to the criteria we‚Äôve listed. If you do,\nyou‚Äôll have made an informed decision about a very important part of your\ninfrastructure!\n\n [https://info.containo.us/request-white-paper-routing-in-the-cloud]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-106.png\" class=\"kg-image\"></figure><h2 id=\"evaluating-ingress-controllers\">Evaluating Ingress Controllers</h2><p>Ingresses are critical to any successful Kubernetes (k8s) deployment. Ingresses allow you to define how external (and/or internal) traffic is routed to services within your cluster. The Kubernetes <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress/\" rel=\"noopener\">documentation</a> states that:</p><blockquote><em><em>‚ÄúAn Ingress can be configured to give Services externally-reachable URLs, load balance traffic, terminate SSL / TLS, and offer name based virtual hosting.‚Äù</em></em></blockquote><p>However, Ingresses themselves don‚Äôt do anything ‚Äî they‚Äôre just <em><em>metadata</em></em>. The heavy lifting is performed by <em><em>Ingress Controllers</em></em>. An Ingress without an Ingress Controller won‚Äôt do anything. There‚Äôs one more catch: while there are a number of system controllers (like ReplicaSet Controller, Endpoints Controller, Namespace Controller and others) that are managed by the Kubernetes control plane, Ingress Controllers are not automatically started with a cluster ‚Äî you have to install, configure and manage your own Ingress Controllers.</p><p>It‚Äôs also possible to have multiple Ingress Controllers in the same cluster. You can divide the ‚Äúrouting space‚Äù by using Ingress class annotations, so that each Ingress knows which Ingress Controller should be handling it. You could end up using a combination of Ingress Controllers for different scenarios within the same cluster. For example, you may have one Ingress Controller for handling external traffic coming in to the cluster including bindings to SSL certificates, and have another internal Ingress Controller with no SSL binding that handles in-cluster traffic.</p><p>There are scores of Ingress Controllers to choose from. The Kubernetes documentation has a list of popular Ingress Controllers <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers\" rel=\"noopener\">here</a>.</p><p>These controllers have varied feature sets and varying levels of community or commercial support. Some are ‚Äúpure‚Äù edge routers, while others have features more akin to service meshes.</p><h2 id=\"selecting-the-right-ingress-controller\">Selecting the Right Ingress Controller</h2><p>So how do you choose the right Ingress Controller? There are several criteria that are important to consider when doing so. In this post we‚Äôre not going to do a feature comparison between specific Ingress Controllers, since there are many head-to-head comparisons on the internet already, and because there are so many Ingress Controllers. Rather, we‚Äôre going to discuss what features you should be weighing when selecting an Ingress Controller.</p><h3 id=\"1-traffic-protocol\">1/ Traffic Protocol</h3><p>Are you just routing HTTP(S), HTTP/2 or websockets? Do you want to route TCP/UDP or gRPC? Not all Ingress Controllers support all these protocols, so you‚Äôll have to check which protocols an Ingress Controller supports.</p><h3 id=\"2-dynamic-configuration-updates\">2/ Dynamic Configuration Updates</h3><p>Do you require zero-downtime configuration changes ‚Äî often called ‚Äúhitless reloads‚Äù? Some Ingress Controllers require downtime in order to update configuration, while others update dynamically without downtime.</p><h3 id=\"3-resiliency\">3/ Resiliency</h3><p>Do you need rate limiting, retries or circuit breakers at the edge, or have you built this functionality into your services yourself? Some Ingress Controllers support these features, which means you won‚Äôt have to code them yourself.</p><h3 id=\"4-external-load-balancer-integration\">4/ External Load Balancer Integration</h3><p>Are you integrating with an external, managed cloud-based load balancer? Make sure the Ingress Controller you select integrates well with your external load balancer in order to reduce work and management for your networking team.</p><h3 id=\"5-service-mesh\">5/ Service Mesh</h3><p>Ingress Controllers can be configured to handle external traffic (traffic originating outside the cluster) or internal traffic or both. If you need to observe or trace internal traffic, you may need a special breed of Ingress Controller ‚Äî a Service Mesh. Kubernetes provides standards for Service Meshes through the SMI Specification for interoperability. If you do require a Service Mesh, make sure you pick the right tool for the right job. Ingress Controllers and Service Meshes are not mutually exclusive.</p><h3 id=\"6-api-gateway\">6/ API Gateway</h3><p>Do you need an Ingress Controller or an API gateway, or something that does both? Typically API gateways integrate business logic, while edge routers are typically business agnostic. For example, API Gateways let you monitor traffic per customer, or measure transactions for billing purposes. If you require business logic at the edge, you should probably look at an API gateway instead of an Ingress Controller. Just as with Service Meshes, Ingress Controller and API gateways are not mutually exclusive.</p><h3 id=\"7-high-availability\">7/ High Availability</h3><p>Can you afford downtime when a server restarts for either planned or unplanned maintenance? If so, you need high availability for your Ingress Controller. Not all Ingress Controllers support high availability.</p><h3 id=\"8-load-balancing-algorithms\">8/ Load Balancing Algorithms</h3><p>What sort of algorithm-based routing do you need? Most Ingress Controllers support Round Robin, but if you want Least Connection so that the load on your services is taken into account, you‚Äôll need an Ingress Controller that supports more advanced load balancing algorithms.</p><h3 id=\"9-advanced-traffic-shifting\">9/ Advanced Traffic Shifting</h3><p>Do you need to perform canary testing (shifting a percentage of traffic to different services for progressive exposure)? Load balancing lets you spread the load of a service, but not all load balancers can split traffic using more sophisticated rules. If you‚Äôre testing in production using techniques like canary testing, make sure the Ingress Controller you select supports traffic shifting.</p><h3 id=\"10-resources-constraints\">10/ Resources Constraints</h3><p>Are you cost sensitive as far as resources in your cluster are concerned? Ingress Controllers can be resource intensive, so if you are cost sensitive, you‚Äôre going to be better off with a light-weight Ingress Controller. Some Ingress Controllers support scaling up and down, while others do not.</p><h3 id=\"11-monitoring\">11/ Monitoring</h3><p>Do you need to integrate with existing metrics and log collection systems? Some Ingress Controllers offer limited monitoring and logging and may not support your specific monitoring and logging tooling.</p><h3 id=\"12-support\">12/ Support</h3><p>Do you need enterprise support? Open source Ingress Controllers are easy on the check book, but what happens when you need support in the middle of the night? Remember, some open source Ingress Controllers offer enterprise support plans.</p><h3 id=\"13-ecosystem\">13/ Ecosystem</h3><p>Make sure the Ingress Controller you are considering has support in the Kubernetes partner ecosystem.</p><h2 id=\"conclusion\">Conclusion</h2><p>As you can see, there are many factors that require thought before you can select the right Ingress Controller for your clusters. Don‚Äôt just select a hype-driven, popular option ‚Äî be deliberate about your requirements and then evaluate Ingress Controllers according to the criteria we‚Äôve listed. If you do, you‚Äôll have made an informed decision about a very important part of your infrastructure!</p><!--kg-card-begin: markdown--><p><a href=\"https://info.containo.us/request-white-paper-routing-in-the-cloud\"><img src=\"https://containous.ghost.io/content/images/2019/12/request-white-paper-routing-in-the-cloud.png\" alt=\"request-white-paper-routing-in-the-cloud\"></a></p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/","canonical_url":null,"uuid":"2c5e7ed6-3b40-4690-b39b-772ba9a0f24c","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd548aeec5ed3003878884c","reading_time":4}},{"node":{"id":"Ghost__Post__5dcc44711127150038885824","title":"Traefik Enterprise Edition 1.2 is out!","slug":"traefik-enterprise-edition-1-2-is-out-2ba37e22983c","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/traefikee-v1.2.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/cc689a5812614192721fe6084b77347f/f3583/traefikee-v1.2.png","srcSet":"/static/cc689a5812614192721fe6084b77347f/630fb/traefikee-v1.2.png 300w,\n/static/cc689a5812614192721fe6084b77347f/2a4de/traefikee-v1.2.png 600w,\n/static/cc689a5812614192721fe6084b77347f/f3583/traefikee-v1.2.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Today, we‚Äôre happy to announce the availability of TraefikEE 1.2. This minor version was driven by customers feedback, and keeps improving...","custom_excerpt":"Today, we‚Äôre happy to announce the availability of TraefikEE 1.2. This minor version was driven by customers feedback, and keeps improving...","visibility":"public","created_at_pretty":"12 November, 2019","published_at_pretty":"October 15, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-12T20:56:37.000+00:00","published_at":"2019-10-15T20:57:00.000+00:00","updated_at":"2020-05-21T21:40:25.000+00:00","meta_title":"Traefik Enterprise Edition 1.2 is out!","meta_description":"Today, we‚Äôre happy to announce the availability of TraefikEE 1.2. This minor version was driven by customers feedback, and keeps improving...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Brendan LE GLAUNEC","slug":"brendan","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/NewAvatar.png","twitter":null,"facebook":null,"website":"https://github.com/Ullaakut"}],"primary_author":{"name":"Brendan LE GLAUNEC","slug":"brendan","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/NewAvatar.png","twitter":null,"facebook":null,"website":"https://github.com/Ullaakut"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"With OpenShift compatibility, more distributed features, improved operations,\nand more.\n\nToday, we‚Äôre happy to announce the availability of TraefikEE 1.2. This minor\nversion was driven by customers feedback, and keeps improving clustering\nfeatures while adding support for more platforms.\n\n> Traefik Enterprise Edition is a platform built on top of Traefik, designed for\nbusiness-critical deployments. It adds clustering features to satisfy the needs\nof enterprise customers.\nOpenShift Compatibility\nBecause Traefik has always been about compatibility with every platform,\nTraefikEE follows the same path and is now OpenShift\n[https://www.openshift.com/learn/what-is-openshift] ready! We‚Äôre also actively\nworking with RedHat on the certification process.\n\nWith this new step, we keep giving our customers more choices for their\ninfrastructure.\n\nDistributed features\nThanks to its clustered architecture, TraefikEE allowed us to provide\ndistributed rate limiting, and 1.2 introduces distributed connection limiting.\n\nThe goal of these distributed features is to keep the configuration simple, yet\nscalable. Whatever the number of data planes you‚Äôve deployed, the configuration\nstays the same ‚Äî even with hundreds of Traefik instances on your cluster, your\nbackend will only receive the given number of simultaneous requests.\n\nOperations\nACME\nA small tweak that makes administrators‚Äô day easier, the traefikee and \ntraefikeectl CLIs now allow users to list the certificates within their\nclusters, and they‚Äôre also able to add ACME accounts directly from TraefikEE\nbackup files.\n\nInstallation on DockerEE\nThe whole installation of TraefikEE can now be done using the traefikeectl tool,\nas opposed to having to manually deploy compose files\n[https://docs.containo.us/installing/advanced/swarm-compose/n-cn/] in the\nversion 1.1. This makes it much more convenient as well as much faster to\ninstall. Take a look at the documentation for more information on DockerEE\ninstalls [https://docs.containo.us/integrating/dockeree/].\n\nWhat‚Äôs next?\nThe next logical step will be to integrate Traefik 2.0 into TraefikEE and bring\nwith it every feature‚Ä¶ and hopefully much more!\n\nTry it now!\nGet a free one month trial\n[https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days] right\nnow, and install TraefikEE on your favorite environment by following the \ninstallation guides [https://docs.containo.us/v1.2/].","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">With OpenShift compatibility, more distributed features, improved operations, and more.</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-105.png\" class=\"kg-image\"></figure><p>Today, we‚Äôre happy to announce the availability of TraefikEE 1.2. This minor version was driven by customers feedback, and keeps improving clustering features while adding support for more platforms.</p><blockquote>Traefik Enterprise Edition is a platform built on top of Traefik, designed for business-critical deployments. It adds clustering features to satisfy the needs of enterprise customers.</blockquote><h2 id=\"openshift-compatibility\">OpenShift Compatibility</h2><p>Because Traefik has always been about compatibility with every platform, TraefikEE follows the same path and is now <a href=\"https://www.openshift.com/learn/what-is-openshift\" rel=\"noopener nofollow\">OpenShift</a> ready! We‚Äôre also actively working with RedHat on the certification process.</p><p>With this new step, we keep giving our customers more choices for their infrastructure.</p><h2 id=\"distributed-features\">Distributed features</h2><p>Thanks to its clustered architecture, TraefikEE allowed us to provide distributed rate limiting, and 1.2 introduces distributed connection limiting.</p><p>The goal of these distributed features is to keep the configuration simple, yet scalable. Whatever the number of data planes you‚Äôve deployed, the configuration stays the same ‚Äî even with hundreds of Traefik instances on your cluster, your backend will only receive the given number of simultaneous requests.</p><h2 id=\"operations\">Operations</h2><h3 id=\"acme\">ACME</h3><p>A small tweak that makes administrators‚Äô day easier, the <code>traefikee</code> and <code>traefikeectl</code> CLIs now allow users to list the certificates within their clusters, and they‚Äôre also able to add ACME accounts directly from TraefikEE backup files.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-1.png\" class=\"kg-image\"></figure><h3 id=\"installation-on-dockeree\">Installation on DockerEE</h3><p>The whole installation of TraefikEE can now be done using the <code>traefikeectl</code> tool, as opposed to having to <a href=\"https://docs.containo.us/installing/advanced/swarm-compose/n-cn/\" rel=\"noopener nofollow\">manually deploy compose files</a> in the version 1.1. This makes it much more convenient as well as much faster to install. Take a look at the documentation for <a href=\"https://docs.containo.us/integrating/dockeree/\" rel=\"noopener nofollow\">more information on DockerEE installs</a>.</p><h2 id=\"what-s-next\">What‚Äôs next?</h2><p>The next logical step will be to integrate Traefik 2.0 into TraefikEE and bring with it every feature‚Ä¶ and hopefully much more!</p><h2 id=\"try-it-now-\">Try it now!</h2><p>Get a <a href=\"https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days\" rel=\"noopener nofollow\">free one month trial</a> right now, and install TraefikEE on your favorite environment by following the <a href=\"https://docs.containo.us/v1.2/\" rel=\"noopener nofollow\">installation guides</a>.</p>","url":"https://containous.ghost.io/blog/traefik-enterprise-edition-1-2-is-out-2ba37e22983c/","canonical_url":null,"uuid":"7e8545e4-254a-4a3d-8dea-98ff4f8dc5dc","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dcb1c8569991550c004b6d3","reading_time":2}},{"node":{"id":"Ghost__Post__5dce00062345360038abe2aa","title":"Traefik and Docker: A Discussion with Docker Captain, Bret Fisher","slug":"traefik-and-docker-a-discussion-with-docker-captain-bret-fisher-7f0b9a54ff88","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/Traefik-and-Bret-Fisher-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/047a148bb8af5c21fbc2377a71881001/47498/Traefik-and-Bret-Fisher-1.jpg","srcSet":"/static/047a148bb8af5c21fbc2377a71881001/9dc27/Traefik-and-Bret-Fisher-1.jpg 300w,\n/static/047a148bb8af5c21fbc2377a71881001/4fe8c/Traefik-and-Bret-Fisher-1.jpg 600w,\n/static/047a148bb8af5c21fbc2377a71881001/47498/Traefik-and-Bret-Fisher-1.jpg 1200w,\n/static/047a148bb8af5c21fbc2377a71881001/52258/Traefik-and-Bret-Fisher-1.jpg 1800w,\n/static/047a148bb8af5c21fbc2377a71881001/a41d1/Traefik-and-Bret-Fisher-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"During the past summer, we had an interesting discussion about Traefik andDocker with Bret Fisher, the creator of ‚ÄúDocker Mastery‚Äù and part of theDocker Captain program.","custom_excerpt":"During the past summer, we had an interesting discussion about Traefik andDocker with Bret Fisher, the creator of ‚ÄúDocker Mastery‚Äù and part of theDocker Captain program.","visibility":"public","created_at_pretty":"15 November, 2019","published_at_pretty":"October 22, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-15T01:31:50.000+00:00","published_at":"2019-10-22T08:31:00.000+00:00","updated_at":"2020-05-22T00:45:04.000+00:00","meta_title":"Traefik and Docker: A Discussion with Docker Captain, Bret Fisher","meta_description":"An interesting discussion about Traefik and Docker with Bret Fisher. Read on to learn more about Bret, and his experience using Traefik and Docker.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Community","slug":"community","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Bret Fisher is the creator of ‚ÄúDocker Mastery‚Äù and part of the Docker Captain\nprogram.\n\nDuring the past summer, we had an interesting discussion about Traefik\n[/traefik/] and Docker\n[https://events.docker.com/events/details/docker-san-francisco-presents-traefik-v20-in-docker-containerd-updates/] \nwith Bret Fisher, the creator of ‚ÄúDocker Mastery\n[https://www.bretfisher.com/courses/]‚Äù and part of the Docker Captain\n[https://www.docker.com/community/captains] program.\n\nWe‚Äôd like to share our discussion with you. Read on to learn more about Bret,\nand his experience using Traefik and Docker.\n\n\n--------------------------------------------------------------------------------\n\nContainous: Hi Bret, could you introduce yourself to our community?\n\nBret: Hi, I‚Äôm Bret Fisher [https://twitter.com/BretFisher], a freelance DevOps\nand Docker consultant, focused on containers. I‚Äôm also a Docker Captain. My time\nis split between teaching, helping students, answering questions.\n\n> I‚Äôm driven by having fun while helping people.\nContainous: Could you explain what is a ‚ÄúDocker Captain‚Äù?\n\nBret: The ‚ÄúDocker Captain‚Äù program is from Docker Inc.. A Docker Captain is like\na Microsoft MVP. You cannot work for Docker Inc., should be an expert on docker\ntools and share your love for containers often. It also gives you access to\npre-release Docker software.\n\nContainous: How did you get into Traefik?\n\nBret: Because of Docker Swarm mode. Even though Kubernetes has become the most\npopular orchestrator, Docker Swarm still solves a lot of problems for many team.\nI was searching for an easy ‚ÄúIngress‚Äù for Docker Swarm and Traefik was\nrecommended by a fellow Docker Captain.\n\n> I liked Traefik because of the Let‚Äôs Encrypt support out-of-the box and because\n‚ÄúIt just works‚Äù.\nContainous: Where do you use Traefik?\n\nBret: I‚Äôm using it on my own website at https://www.bretfisher.com/\n[https://www.bretfisher.com/]. This website runs on Docker Swarm with Traefik. I\nalso recommended Traefik to my customers, and in my talks and workshops. A lot\nof my 120,000 students have ended up using Traefik.\n\nContainous: Let‚Äôs talk a bit about container security. Are you running Traefik\nas the user ‚Äúroot‚Äù?\n\nBret: Is it the default ? (Laugh). I‚Äôm using the official Docker image so I\nguess ‚Äúyes,‚Äù if it is the default user in that container Image.\n\nContainous: Do you see any compensation measure for this?\n\nBret: First of all, I have a list of general container security activities\n[https://github.com/BretFisher/ama/issues/17] that I follow and recommend others\ncheck out. It follows an order of ‚Äúeasiest steps with biggest benefits first‚Äù so\nyou don‚Äôt spend time on hard security changes that have little overall\nimprovement in your security posture. In addition, consider running Traefik‚Äôs\ncontainer in ‚Äúread-only‚Äù mode\n[https://docs.docker.com/engine/reference/commandline/run/#mount-volume--v---read-only]\n. This mode forbids any writing on the filesystem (unless you explicitly define\na volume on an explicit path.). This first step avoids some (but not all!)\ncommon tasks as installing packages or downloading scripts in case of a bad\nactor gaining file system control in the container. Also, you could enable the\nfeature ‚Äúuser namespaces‚Äù in the Docker Engine config, to map the root user of\ncontainers to an unprivileged user of the host machines, which I‚Äôm a big fan of.\n\nRunning a Traefik container as a non privileged user to avoid being ‚Äúroot‚Äù might\ncreate two challenges:\n\n * Listening on ports below 1024: the range of ports [0‚Äì1024] are privileged and\n   thus require special capabilities. Either you can bind to port > 1024, or\n   ensure you are able to grant the Linux Capability CAP_NET_BIND_SERVICE to\n   Traefik.\n * Docker socket membership: the socket file in /var/run/docker.sock is owned by\n   the root user, and a group named docker. The unprivileged user of Traefik\n   must be part of the group docker to allow access to the Docker API.\n\nContainous: Speaking about the Docker socket, do you run Traefik on Swarm\nManager Nodes?\n\nBret: It‚Äôs not mandatory. The point is ‚Äî you can always forward the Docker\nsocket through TCP instead of using a bind-mount of /var/run/docker.sock. If you\nforward the socket in TCP inside and encrypted Docker network, then it removes\nthe ‚Äúrun on manager‚Äù constraint for Traefik.\n\nPlease note that overlay networks optional encryption is not performed by Docker\nSwarm itself, but rather the Linux kernel (IPSec), ensuring low-level security.\n\nAlso, it‚Äôs worthwhile to add an intermediate proxy to control requests through\nthe TCP-forwarded Docker socket, allowing read-only requests to the API.\n\nI have an example Swarm stack YAML of this setup here\n[https://github.com/BretFisher/dogvscat/blob/master/stack-proxy-global.yml].\n\nWith all of these, running Traefik on the host network of worker nodes, with an\noverlay network for backends is totally doable.\n\nContainous: Are you using the Traefik dashboard? If yes, what is your point of\nview on the security of this feature?\n\nTraefik v2 DashboardBret: Yes. I‚Äôm using the Traefik dashboard. I tend to configure the dashboard\nwith an IP whitelist, and not exposed on a public network or on the default\nport.\n\nPublicly exposing an admin dashboard keeps happening: just look at situations\nsuch as the Kubernetes dashboard hack at Tesla\n[https://redlock.io/blog/cryptojacking-tesla].\n\nI‚Äôm a huge fan of ‚Äúsecure by default‚Äù tools, and I wished more tools were like\nDocker and Swarm in this way. Over my 25 years in tech helping many companies\nwith infrastructure, I‚Äôve learned that if authentication and encryption are\noptional, many won‚Äôt do it.\n\nContainous: Do you have a recommendation about using the ‚Äúdefault‚Äù Docker image\nfor Traefik based on ‚Äúscratch‚Äù versus the ‚ÄúLinux Alpine‚Äù image? Why?\n\nBret: As a rule of thumb, I would avoid ‚Äúscratch‚Äù (or distroless\n[https://github.com/GoogleContainerTools/distroless]) images until everyone in\nthe pipeline is able to know how to operate it. Size is not important unless\nyou‚Äôre operating an IoT business. Compared to the pain and suffering of ‚Äúno\ntools,‚Äù using ‚Äúscratch‚Äù doesn‚Äôt feel a good trade-off unless you have\nspecialists on board. The image ‚Äúscratch‚Äù feels like a ‚ÄúGolang developers‚Äù\nhabit, but when it comes to the Ops team it‚Äôs another topic: What about not\nbeing able to docker exec or kubectl cp?\n\nHopefully, the Kubernetes ephemeral containers\n[https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/] \nfeature will help make this possible for more people.\n\nAs a rule of thumb, for container newcomers, they need to learn by doing. In\nthis case, I wouldn‚Äôt use ‚Äúscratch‚Äù here to keep the learning curve smooth.\n\nI also share this opinion about the host OS. Too many people try to use a\n‚ÄúContainer OS‚Äù too early in their organisational learning. It tends to add lots\nof risk without a big productivity boost. Stick with your traditional Linux\ndistribution until you‚Äôve had significant production Docker usage.\n\nContainous: What is your recommendation for the load balancer part outside\nSwarm? To create an external load balancer pointing to nodes, using DNS, or\nsomething else? And, why?\n\nBret: The expected answer is ‚ÄúIt‚Äôs complicated‚Äù or ‚ÄùIt depends‚Äù (laugh).\n\nMost companies already have their own solution for load balancing, including\ncloud load balancers and datacenter hardware load balancers. Then they point\ntheir load balancer to the Docker Swarm nodes and rely on Traefik for providing\nthe application layer load balancing inside the cluster. Pro Tip: Don‚Äôt point\nLB‚Äôs to all your Swarm nodes. Pick 2‚Äì3 worker nodes and make those the ingress\npoints, which will make troubleshooting and load easier to manage.\n\nHowever, about the ‚ÄúDNS round robin‚Äù solution, I refer to it as the ‚Äúpoor\nperson‚Äôs LB‚Äù, because of the small amount of time required to make it work. It‚Äôs\nsimple when the client is a web browser, but as you cannot control the ‚Äúclient‚Äù,\nthat‚Äôs where the limit is drawn (DNS caching, no retry patterns, etc.). Another\nlimit: as soon as showing HTTP 503 errors is an issue, there is no ‚Äúretry\npattern‚Äù expected from web browsers (even though Traefik could do that). It‚Äôs\nthe recommended solution in my course ‚ÄúSolo DevOps‚Äù where the context is ‚Äúonly\none person in charge of the DevOps tasks, with so many tools involved‚Äù. Once you\nhave an external load balancer solution, it‚Äôs likely best to stick with that in\nall but the smallest projects.\n\nAs a general rule, ask yourselves: ‚ÄúDuring the time it goes down, do you lose\nmoney? If yes, then go for load balancing with health checks.‚Äù\n\n> Try both solutions for education purposes. It‚Äôs really valuable.\nContainous: Have you tried the new Traefik v2.0\n[/blog/traefik-2-0-6531ec5196c2/]?\n\nBret: Not yet, but it made quite some noise in the Docker Captain channel. It\nmight be the fact that they are ‚ÄúGolang people,‚Äù but it looks neat.\n\nContainous: Is there something you would like to tell the Traefik community?\n\nBret: Traefik is a really nice tool because everything is configurable from the\ncommand line when starting in a container (using CMD). TOML files are fine, but\nit‚Äôs great to have the option to skip that and configure it dynamically at\nruntime.\n\nAlso, everything is streamlined for the container world, with a linear learning\ncurve: configuration management is not mandatory even for rich features such as\nLet‚Äôs Encrypt.\n\nContainous: Thanks a lot for these insights Bret! Happy to have this exchange.\nLet‚Äôs meet again for a live session next time!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Bret Fisher is the creator of ‚ÄúDocker Mastery‚Äù and part of the Docker Captain program.</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/Traefik-and-Bret-Fisher-1-1.jpg\" class=\"kg-image\"></figure><p>During the past summer, we had an interesting discussion about<a href=\"https://containous.ghost.io/traefik/\"> Traefik</a> and <a href=\"https://events.docker.com/events/details/docker-san-francisco-presents-traefik-v20-in-docker-containerd-updates/\" rel=\"noopener nofollow\">Docker</a> with Bret Fisher, the creator of ‚Äú<a href=\"https://www.bretfisher.com/courses/\" rel=\"noopener nofollow\">Docker Mastery</a>‚Äù and part of the <a href=\"https://www.docker.com/community/captains\" rel=\"noopener nofollow\">Docker Captain</a> program.</p><p>We‚Äôd like to share our discussion with you. Read on to learn more about Bret, and his experience using Traefik and Docker.</p><hr><p><strong><strong>Containous: Hi Bret, could you introduce yourself to our community?</strong></strong></p><p><em><em>Bret: </em></em>Hi, I‚Äôm<a href=\"https://twitter.com/BretFisher\" rel=\"noopener nofollow\"> Bret Fisher</a>, a freelance DevOps and Docker consultant, focused on containers. I‚Äôm also a Docker Captain. My time is split between teaching, helping students, answering questions.</p><blockquote><em>I‚Äôm driven by having fun while helping people.</em></blockquote><p><strong><strong>Containous: Could you explain what is a ‚ÄúDocker Captain‚Äù?</strong></strong></p><p><em><em>Bret: </em></em>The ‚ÄúDocker Captain‚Äù program is from Docker Inc.. A Docker Captain is like a Microsoft MVP. You cannot work for Docker Inc., should be an expert on docker tools and <strong><strong>share</strong></strong> your love for containers often. It also gives you access to pre-release Docker software.</p><p><strong><strong>Containous: How did you get into Traefik?</strong></strong></p><p><em><em>Bret: </em></em>Because of Docker Swarm mode. Even though Kubernetes has become the most popular orchestrator, Docker Swarm still solves a lot of problems for many team. I was searching for an easy ‚ÄúIngress‚Äù for Docker Swarm and Traefik was recommended by a fellow Docker Captain.</p><blockquote><em>I liked Traefik because of the Let‚Äôs Encrypt support out-of-the box and because ‚ÄúIt just works‚Äù.</em></blockquote><p><strong><strong>Containous: Where do you use Traefik?</strong></strong></p><p><em><em>Bret: </em></em>I‚Äôm using it on my own website at<a href=\"https://www.bretfisher.com/\" rel=\"noopener nofollow\"> https://www.bretfisher.com/</a>. This website runs on Docker Swarm with Traefik. I also recommended Traefik to my customers, and in my talks and workshops. A lot of my 120,000 students have ended up using Traefik.</p><p><strong><strong>Containous: Let‚Äôs talk a bit about container security. Are you running Traefik as the user ‚Äúroot‚Äù?</strong></strong></p><p><em><em>Bret: </em></em>Is it the default ? (Laugh). I‚Äôm using the official Docker image so I guess ‚Äúyes,‚Äù if it is the default user in that container Image.</p><p><strong><strong>Containous: Do you see any compensation measure for this?</strong></strong></p><p><em><em>Bret: </em></em>First of all, I have a <a href=\"https://github.com/BretFisher/ama/issues/17\" rel=\"noopener nofollow\">list of general container security activities</a> that I follow and recommend others check out. It follows an order of ‚Äúeasiest steps with biggest benefits first‚Äù so you don‚Äôt spend time on hard security changes that have little overall improvement in your security posture. In addition, consider running Traefik‚Äôs container in<a href=\"https://docs.docker.com/engine/reference/commandline/run/#mount-volume--v---read-only\" rel=\"noopener nofollow\"> ‚Äúread-only‚Äù mode</a>. This mode forbids any writing on the filesystem (unless you explicitly define a volume on an explicit path.). This first step avoids some (but not all!) common tasks as installing packages or downloading scripts in case of a bad actor gaining file system control in the container. Also, you could enable the feature ‚Äúuser namespaces‚Äù in the Docker Engine config, to map the root user of containers to an unprivileged user of the host machines, which I‚Äôm a big fan of.</p><p>Running a Traefik container as a non privileged user to avoid being ‚Äúroot‚Äù might create two challenges:</p><ul><li>Listening on ports below 1024: the range of ports [0‚Äì1024] are privileged and thus require special capabilities. Either you can bind to port &gt; 1024, or ensure you are able to grant the Linux Capability <code>CAP_NET_BIND_SERVICE </code>to Traefik.</li><li>Docker socket membership: the socket file in /var/run/docker.sock is owned by the root user, and a group named docker. The unprivileged user of Traefik must be part of the group docker to allow access to the Docker API.</li></ul><p><strong><strong>Containous: Speaking about the Docker socket, do you run Traefik on Swarm Manager Nodes?</strong></strong></p><p><em><em>Bret: </em></em>It‚Äôs not mandatory. The point is ‚Äî you can always forward the Docker socket through TCP instead of using a bind-mount of <code>/var/run/docker.sock</code>. If you forward the socket in TCP inside and encrypted Docker network, then it removes the ‚Äúrun on manager‚Äù constraint for Traefik.</p><p>Please note that overlay networks optional encryption is not performed by Docker Swarm itself, but rather the Linux kernel (IPSec), ensuring low-level security.</p><p>Also, it‚Äôs worthwhile to add an intermediate proxy to control requests through the TCP-forwarded Docker socket, allowing read-only requests to the API.</p><p>I have an <a href=\"https://github.com/BretFisher/dogvscat/blob/master/stack-proxy-global.yml\" rel=\"noopener nofollow\">example Swarm stack YAML of this setup here</a>.</p><p>With all of these, running Traefik on the host network of worker nodes, with an overlay network for backends is totally doable.</p><p><strong><strong>Containous: Are you using the Traefik dashboard? If yes, what is your point of view on the security of this feature?</strong></strong></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/0-kb8q6VKOvrvofb36.png\" class=\"kg-image\" alt=\"Traefik v2 Dashboard\"><figcaption><strong><strong>Traefik v2 Dashboard</strong></strong></figcaption></figure><p><em><em>Bret: </em></em>Yes. I‚Äôm using the Traefik dashboard. I tend to configure the dashboard with an IP whitelist, and not exposed on a public network or on the default port.</p><p>Publicly exposing an admin dashboard keeps happening: just look at situations such as the<a href=\"https://redlock.io/blog/cryptojacking-tesla\" rel=\"noopener nofollow\"> Kubernetes dashboard hack at Tesla</a>.</p><p>I‚Äôm a huge fan of ‚Äúsecure by default‚Äù tools, and I wished more tools were like Docker and Swarm in this way. Over my 25 years in tech helping many companies with infrastructure, I‚Äôve learned that if authentication and encryption are optional, many won‚Äôt do it.</p><p><strong><strong>Containous: Do you have a recommendation about using the ‚Äúdefault‚Äù Docker image for Traefik based on ‚Äúscratch‚Äù versus the ‚ÄúLinux Alpine‚Äù image? Why?</strong></strong></p><p><em><em>Bret: </em></em>As a rule of thumb, I would avoid ‚Äúscratch‚Äù (or <a href=\"https://github.com/GoogleContainerTools/distroless\" rel=\"noopener nofollow\">distroless</a>) images until everyone in the pipeline is able to know how to operate it. Size is not important unless you‚Äôre operating an IoT business. Compared to the pain and suffering of ‚Äúno tools,‚Äù using ‚Äúscratch‚Äù doesn‚Äôt feel a good trade-off unless you have specialists on board. The image ‚Äúscratch‚Äù feels like a ‚ÄúGolang developers‚Äù habit, but when it comes to the Ops team it‚Äôs another topic: What about not being able to <code>docker exec</code> or <code>kubectl cp</code>?</p><p>Hopefully, the <a href=\"https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/\" rel=\"noopener nofollow\">Kubernetes ephemeral containers</a> feature will help make this possible for more people.</p><p>As a rule of thumb, for container newcomers, they need to learn by doing. In this case, I wouldn‚Äôt use ‚Äúscratch‚Äù here to keep the learning curve smooth.</p><p>I also share this opinion about the host OS. Too many people try to use a ‚ÄúContainer OS‚Äù too early in their organisational learning. It tends to add lots of risk without a big productivity boost. Stick with your traditional Linux distribution until you‚Äôve had significant production Docker usage.</p><p><strong><strong>Containous: What is your recommendation for the load balancer part outside Swarm? To create an external load balancer pointing to nodes, using DNS, or something else? And, why?</strong></strong></p><p><em><em>Bret: </em></em>The expected answer is ‚ÄúIt‚Äôs complicated‚Äù or ‚ÄùIt depends‚Äù (laugh).</p><p>Most companies already have their own solution for load balancing, including cloud load balancers and datacenter hardware load balancers. Then they point their load balancer to the Docker Swarm nodes and rely on Traefik for providing the application layer load balancing inside the cluster. Pro Tip: Don‚Äôt point LB‚Äôs to all your Swarm nodes. Pick 2‚Äì3 worker nodes and make those the ingress points, which will make troubleshooting and load easier to manage.</p><p>However, about the ‚ÄúDNS round robin‚Äù solution, I refer to it as the ‚Äúpoor person‚Äôs LB‚Äù, because of the small amount of time required to make it work. It‚Äôs simple when the client is a web browser, but as you cannot control the ‚Äúclient‚Äù, that‚Äôs where the limit is drawn (DNS caching, no retry patterns, etc.). Another limit: as soon as showing HTTP 503 errors is an issue, there is no ‚Äúretry pattern‚Äù expected from web browsers (even though Traefik could do that). It‚Äôs the recommended solution in my course ‚ÄúSolo DevOps‚Äù where the context is ‚Äúonly one person in charge of the DevOps tasks, with so many tools involved‚Äù. Once you have an external load balancer solution, it‚Äôs likely best to stick with that in all but the smallest projects.</p><p>As a general rule, ask yourselves: ‚ÄúDuring the time it goes down, do you lose money? If yes, then go for load balancing with health checks.‚Äù</p><blockquote><em>Try both solutions for education purposes. It‚Äôs really valuable.</em></blockquote><p><strong><strong>Containous: Have you tried the new<a href=\"https://containous.ghost.io/blog/traefik-2-0-6531ec5196c2/\"> Traefik v2.0</a>?</strong></strong></p><p><em><em>Bret: </em></em>Not yet, but it made quite some noise in the Docker Captain channel. It might be the fact that they are ‚ÄúGolang people,‚Äù but it looks neat.</p><p><strong><strong>Containous: Is there something you would like to tell the Traefik community?</strong></strong></p><p><em><em>Bret: </em></em>Traefik is a really nice tool because everything is configurable from the command line when starting in a container (using CMD). TOML files are fine, but it‚Äôs great to have the option to skip that and configure it dynamically at runtime.</p><p>Also, everything is streamlined for the container world, with a linear learning curve: configuration management is not mandatory even for rich features such as Let‚Äôs Encrypt.</p><p><strong><strong>Containous: Thanks a lot for these insights Bret! Happy to have this exchange. Let‚Äôs meet again for a live session next time!</strong></strong></p>","url":"https://containous.ghost.io/blog/traefik-and-docker-a-discussion-with-docker-captain-bret-fisher-7f0b9a54ff88/","canonical_url":null,"uuid":"aa3d6be3-2d32-46bf-961c-0c347dfb8bbc","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dce00062345360038abe2aa","reading_time":6}},{"node":{"id":"Ghost__Post__5dcdfe132345360038abe28c","title":"eBay Classifieds Group chooses Traefik to achieve load balancing at scale","slug":"ebay-classifieds-group-chooses-traefik-to-achieve-load-balancing-at-scale-f1332fcc9fbb","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/Blog-Post_eBay-Study@2x-1.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/7e53eb7a624b40c11d05d6df456fa2dd/f3583/Blog-Post_eBay-Study%402x-1.png","srcSet":"/static/7e53eb7a624b40c11d05d6df456fa2dd/630fb/Blog-Post_eBay-Study%402x-1.png 300w,\n/static/7e53eb7a624b40c11d05d6df456fa2dd/2a4de/Blog-Post_eBay-Study%402x-1.png 600w,\n/static/7e53eb7a624b40c11d05d6df456fa2dd/f3583/Blog-Post_eBay-Study%402x-1.png 1200w,\n/static/7e53eb7a624b40c11d05d6df456fa2dd/bbee5/Blog-Post_eBay-Study%402x-1.png 1800w,\n/static/7e53eb7a624b40c11d05d6df456fa2dd/0ef64/Blog-Post_eBay-Study%402x-1.png 2400w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"eBay Classifieds Group is a global collection of local brands that aim to create connected commerce, enabled by people, supported by technology and open for everyone. ","custom_excerpt":"eBay Classifieds Group is a global collection of local brands that aim to create connected commerce, enabled by people, supported by technology and open for everyone. ","visibility":"public","created_at_pretty":"15 November, 2019","published_at_pretty":"November 13, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-15T01:23:31.000+00:00","published_at":"2019-11-13T08:23:00.000+00:00","updated_at":"2020-05-21T22:18:49.000+00:00","meta_title":"eBay chooses Traefik to achieve load balancing at scale","meta_description":"eBay Classified Group needed a solution that could easily handle routing external and internal traffic flow with no bottlenecks or scalability issues.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Marie Ponseel","slug":"marie","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/profile-picture.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Marie Ponseel","slug":"marie","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/profile-picture.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Case Studies","slug":"case-studies","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":"Learn from our users and customers why they choose Traefik and TraefikEE as a modern load balancer to manage network traffic.","meta_title":"Case studies | Containous","visibility":"public"},{"name":"#traefik-related-resource","slug":"hash-traefik-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"About eBay Classifieds Group\neBay Classifieds Group is a global collection of local brands that aim to create\nconnected commerce, enabled by people, supported by technology and open for\neveryone. Our sites in 14 countries help people find whatever they‚Äôre looking\nfor in their local communities ‚Äî whether it‚Äôs a job, an apartment, a sofa, a\ncar, a concert ticket, financial services or new friends. Every connection made\nor item found makes a difference by creating a world where people share more and\nwaste less. People who want to trade visit our sites because they‚Äôre fun, easy\nto use and built on trust.\n\nOverview\nWim Fournier, Site Reliability Engineer at eBay Classifieds Group (eCG), is part\nof a team who manages the infrastructure platform for the classifieds platforms.\neCG Benelux‚Äôs platform supports over 12 million unique monthly users, and 15\nmillion live listings, with unique requirements to handle peak traffic daily.\nThere is no ‚Äúoff-peak‚Äù day for eBay Classifieds Group‚Äôs Benelux platforms ‚Äî 100%\nuptime is a must. On a weekly basis hundreds of improvements are released to\nconstantly make trading on the platform easier, effortless and most of all fun.\n\nWim‚Äôs team‚Äôs mission is to help development teams become self sufficient and\nmake their jobs easier. They create tools to simplify infrastructure\nprovisioning, deploy applications seamlessly, and manage configurations easily.\nUltimately, they are in charge of building and maintaining all internal\ninfrastructure platforms in order to offer end-users a good and consistent\nexperience.\n\nChallenge\nThe challenge is to provide excellent online service accessible by anyone from\nanywhere, with the best trading experience for each and every customer. Wim‚Äôs\nteam specifically is chartered to deliver a platform that is capable of handling\ntraffic peaks and scale according to demand, ensuring that the marketplace is\nalways available when anybody wants to buy or sell anything.\n\nThe platform is a containerized set of microservices, deployed to the cloud, to\ntake advantage of the scalability and availability offered by cloud resources.\nThis platform is quite large, hosting and managing hundreds of microservices.\n\nRouting and load balancing in a dynamic and complex environment was a real\nchallenge for Wim‚Äôs team. Their original approach consisted of Fabio as a\ntraditional load balancer, in conjunction with a hardware load balancer, and\nNomad as their orchestrator. This setup did not scale anymore to meet the\nrouting and configuration flexibility they needed, leading them to explore other\nedge routing solutions.\n\nWim‚Äôs team needed a solution that could easily handle routing external and\ninternal traffic flow with no bottlenecks or scalability issues, while enabling\nthem to easily configure multiple advanced routes per service.\n\n> ‚ÄúWe needed an advanced load balancer and an API Gateway for advanced routing to\ncontrol traffic flow with flexible configuration and automation capabilities.\nThis complexity makes it difficult to find a good load balancer. A load balancer\nper domain was not enough for us.‚Äù\nSolution\nWim‚Äôs teams platform strategy is to make things as simple as possible and to\nhave as few components as possible.\n\nThe team researched and conducted an extensive evaluation across a wide range of\ncompetitive software-based products in the market. Traditional solutions for\nrouting and load balancing are very configuration based, and lacked the ability\nto handle the complexity of a dynamic and advanced configuration system.\nMeanwhile, many of the new, modern alternative products are either great at load\nbalancing (TLS management, Websocket, HTTP2‚Ä¶), or as an API gateway (Advanced\nHTTP routing, canary, observability‚Ä¶), but rarely do both effectively.\n\neCG found Traefik was very well suited to natively support its requirements.\nTraefik offers an all-in-one product that is easy to use, configure and scales\nperfectly for the volume of traffic eCG Benelux sees on a daily basis. Traefik\nalso integrates with core technologies eCG is using across the company, such as\nDocker for containers, Nomad for orchestration, and Consul for service\nconfiguration management.\n\n> ‚ÄúWe were looking for both a load balancer and an API Gateway that is easy to\nconfigure, scale, and secure.‚Äù\neCG uses Traefik for load balancing and as an API Gateway to route external and\ninternal traffic. Traefik is today deployed across various platforms.\n\nWim‚Äôs team has hundreds of services running behind the API Gateway. Since\ndeploying Traefik nearly a year ago, they have achieved zero downtime while\nhandling traffic peak of 22k requests per second. In terms of configuration,\nTraefik‚Äôs ability to react to their dynamic environment by automatically\nconfiguring itself accelerates and simplifies deployments without having\nmanually touch or configure anything.\n\neCG favors open source software for its infrastructure because it gives them the\nability to change the product if needed. The fact that they are not locked-in\nwith any vendor and can contribute to open source software is very important for\nWim‚Äôs team. Traefik open source software gives eCG full access to the source\ncode and the opportunity to implement changes if needed.\n\n> ‚ÄúTraefik gives us flexibility and avoid any vendor lock-in.‚Äù\nBottom Line\nWim‚Äôs team has been able to improve development velocity and operational\nefficiency with Traefik by saving their team hours of work on configuration\ntasks, while achieving 24x7 availability across the entire Benelux.\n\nWhat‚Äôs Next?\n * Get started with Traefik [/traefik/] today\n * Ready for production deployments? Discover TraefikEE [/traefikee/], and \n   request your demo [https://info.containo.us/request-demo-traefikee]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-104.png\" class=\"kg-image\"></figure><h2 id=\"about-ebay-classifieds-group\">About eBay Classifieds Group</h2><p>eBay Classifieds Group is a global collection of local brands that aim to create connected commerce, enabled by people, supported by technology and open for everyone. Our sites in 14 countries help people find whatever they‚Äôre looking for in their local communities ‚Äî whether it‚Äôs a job, an apartment, a sofa, a car, a concert ticket, financial services or new friends. Every connection made or item found makes a difference by creating a world where people share more and waste less. People who want to trade visit our sites because they‚Äôre fun, easy to use and built on trust.</p><h2 id=\"overview\">Overview</h2><p>Wim Fournier, Site Reliability Engineer at eBay Classifieds Group (eCG), is part of a team who manages the infrastructure platform for the classifieds platforms. eCG Benelux‚Äôs platform supports over 12 million unique monthly users, and 15 million live listings, with unique requirements to handle peak traffic daily. There is no ‚Äúoff-peak‚Äù day for eBay Classifieds Group‚Äôs Benelux platforms ‚Äî 100% uptime is a must. On a weekly basis hundreds of improvements are released to constantly make trading on the platform easier, effortless and most of all fun.</p><p>Wim‚Äôs team‚Äôs mission is to help development teams become self sufficient and make their jobs easier. They create tools to simplify infrastructure provisioning, deploy applications seamlessly, and manage configurations easily. Ultimately, they are in charge of building and maintaining all internal infrastructure platforms in order to offer end-users a good and consistent experience.</p><h2 id=\"challenge\">Challenge</h2><p>The challenge is to provide excellent online service accessible by anyone from anywhere, with the best trading experience for each and every customer. Wim‚Äôs team specifically is chartered to deliver a platform that is capable of handling traffic peaks and scale according to demand, ensuring that the marketplace is always available when anybody wants to buy or sell anything.</p><p>The platform is a containerized set of microservices, deployed to the cloud, to take advantage of the scalability and availability offered by cloud resources. This platform is quite large, hosting and managing hundreds of microservices.</p><p>Routing and load balancing in a dynamic and complex environment was a real challenge for Wim‚Äôs team. Their original approach consisted of Fabio as a traditional load balancer, in conjunction with a hardware load balancer, and Nomad as their orchestrator. This setup did not scale anymore to meet the routing and configuration flexibility they needed, leading them to explore other edge routing solutions.</p><p>Wim‚Äôs team needed a solution that could easily handle routing external and internal traffic flow with no bottlenecks or scalability issues, while enabling them to easily configure multiple advanced routes per service.</p><blockquote><em><em>‚ÄúWe needed an advanced load balancer and an API Gateway for advanced routing to control traffic flow with flexible configuration and automation capabilities. This complexity makes it difficult to find a good load balancer. A load balancer per domain was not enough for us.‚Äù</em></em></blockquote><h2 id=\"solution\">Solution</h2><p>Wim‚Äôs teams platform strategy is to make things as simple as possible and to have as few components as possible.</p><p>The team researched and conducted an extensive evaluation across a wide range of competitive software-based products in the market. Traditional solutions for routing and load balancing are very configuration based, and lacked the ability to handle the complexity of a dynamic and advanced configuration system. Meanwhile, many of the new, modern alternative products are either great at load balancing (TLS management, Websocket, HTTP2‚Ä¶), or as an API gateway (Advanced HTTP routing, canary, observability‚Ä¶), but rarely do both effectively.</p><p>eCG found Traefik was very well suited to natively support its requirements. Traefik offers an all-in-one product that is easy to use, configure and scales perfectly for the volume of traffic eCG Benelux sees on a daily basis. Traefik also integrates with core technologies eCG is using across the company, such as Docker for containers, Nomad for orchestration, and Consul for service configuration management.</p><blockquote><em><em>‚ÄúWe were looking for both a load balancer and an API Gateway that is easy to configure, scale, and secure.‚Äù</em></em></blockquote><p>eCG uses Traefik for load balancing and as an API Gateway to route external and internal traffic. Traefik is today deployed across various platforms.</p><p>Wim‚Äôs team has hundreds of services running behind the API Gateway. Since deploying Traefik nearly a year ago, they have achieved zero downtime while handling traffic peak of 22k requests per second. In terms of configuration, Traefik‚Äôs ability to react to their dynamic environment by automatically configuring itself accelerates and simplifies deployments without having manually touch or configure anything.</p><p>eCG favors open source software for its infrastructure because it gives them the ability to change the product if needed. The fact that they are not locked-in with any vendor and can contribute to open source software is very important for Wim‚Äôs team. Traefik open source software gives eCG full access to the source code and the opportunity to implement changes if needed.</p><blockquote><em><em>‚ÄúTraefik gives us flexibility and avoid any vendor lock-in.‚Äù</em></em></blockquote><h2 id=\"bottom-line\">Bottom Line</h2><p>Wim‚Äôs team has been able to improve development velocity and operational efficiency with Traefik by saving their team hours of work on configuration tasks, while achieving 24x7 availability across the entire Benelux.</p><h2 id=\"what-s-next\">What‚Äôs Next?</h2><ul><li>Get started with <a href=\"https://containous.ghost.io/traefik/\" rel=\"noopener nofollow\">Traefik</a> today</li><li>Ready for production deployments? <a href=\"https://containous.ghost.io/traefikee/\" rel=\"noopener nofollow\">Discover TraefikEE</a>, and <a href=\"https://info.containo.us/request-demo-traefikee\" rel=\"noopener nofollow\">request your demo</a></li></ul>","url":"https://containous.ghost.io/blog/ebay-classifieds-group-chooses-traefik-to-achieve-load-balancing-at-scale-f1332fcc9fbb/","canonical_url":null,"uuid":"58103d5b-40a5-4e1e-a204-07281e83ea90","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dcdfe132345360038abe28c","reading_time":4}},{"node":{"id":"Ghost__Post__5dcdfa6f2345360038abe218","title":"Traefik 2 & TLS 101","slug":"traefik-2-tls-101-23b4fbee81f1","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/Traefik-2---TLS-101-x-Docker---Blog-Post-@2x-2.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/cc3e270abe4acb548943583a98f72cfb/f3583/Traefik-2---TLS-101-x-Docker---Blog-Post-%402x-2.png","srcSet":"/static/cc3e270abe4acb548943583a98f72cfb/630fb/Traefik-2---TLS-101-x-Docker---Blog-Post-%402x-2.png 300w,\n/static/cc3e270abe4acb548943583a98f72cfb/2a4de/Traefik-2---TLS-101-x-Docker---Blog-Post-%402x-2.png 600w,\n/static/cc3e270abe4acb548943583a98f72cfb/f3583/Traefik-2---TLS-101-x-Docker---Blog-Post-%402x-2.png 1200w,\n/static/cc3e270abe4acb548943583a98f72cfb/bbee5/Traefik-2---TLS-101-x-Docker---Blog-Post-%402x-2.png 1800w,\n/static/cc3e270abe4acb548943583a98f72cfb/ed396/Traefik-2---TLS-101-x-Docker---Blog-Post-%402x-2.png 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"You have an HTTP service exposed through Traefik, and you want Traefik to deal with the HTTPS burden (TLS termination)...","custom_excerpt":"You have an HTTP service exposed through Traefik, and you want Traefik to deal with the HTTPS burden (TLS termination)...","visibility":"public","created_at_pretty":"15 November, 2019","published_at_pretty":"November 14, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-15T01:07:59.000+00:00","published_at":"2019-11-14T08:07:00.000+00:00","updated_at":"2020-05-22T00:43:50.000+00:00","meta_title":"How to configure Traefik 2 with TLS - Traefik 2 & TLS 101","meta_description":"You have an HTTP service exposed through Traefik, and you want Traefik to deal with the HTTPS burden (TLS termination)...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#community-related-resource","slug":"hash-community-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"},{"name":"#traefik-related-resource","slug":"hash-traefik-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"HTTPS (& TCP over TLS) for everyone!\n\nThere are hundreds of reasons why I love being a developer (besides memories of\nsleepless nights trying to fix a video game that nobody except myself would ever\nplay).\n\nBeing a developer gives you superpowers ‚Äî you can solve any kind of problems.\nYes, especially if they don‚Äôt involve real-life practical situations.\n\nBut these superpowers are sometimes hindered by tedious configuration work that\nexpects you to master yet another arcane language assembled with heaps of words\nyou‚Äôve never seen before. Such a barrier can be encountered when dealing with\nHTTPS and its certificates.\n\nLuckily for us, Traefik tends to lower this kind of hurdle and makes sure that\nthere are easy ways of securely connecting your developments to the outside\nworld.\n\nThe Goal for Today\nThe challenge we‚Äôll accept is the following ‚Äî You have an HTTP service exposed\nthrough Traefik, and you want Traefik to deal with the HTTPS burden (TLS\ntermination), leaving your pristine service unspoiled by mundane technical\ndetails.\n\nWe‚Äôll assume you have a basic understanding of Traefik on Docker and that you‚Äôre\nfamiliar with its configuration (if not, it‚Äôs time to read Traefik 2 & Docker\n101 [/blog/traefik-2-0-docker-101-fc2893944b9d/]).\n\nDuring this article, we‚Äôll use my pet demo docker-compose file: it enables the\ndocker provider and launches a my-app application that allows us to test any\nrequest.\n\nversion: \"3\"\nservices:\n  traefik:\n    image: \"traefik:v2.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker=true\n    ports:\n      - \"80:80\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n  \n  my-app:\n    image: containous/whoami:v1.3.0\n\nGetting Things Ready\nFirst things first, let‚Äôs make sure our setup can handle HTTPS traffic on the\ndefault port (:443), and that Traefik listens to this port thanks to an \nentrypoint [https://docs.traefik.io/routing/entrypoints/] we‚Äôll name web-secure.\n\nversion: \"3\"\nservices:\n  traefik:\n    image: \"traefik:v2.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --entrypoints.web-secure.address=:443 #Declares the web-secure entrypoint in Traefik\n      - --providers.docker=true\n    ports:\n      - \"80:80\"\n      - \"443:443\" #Docker sends requests on port 443 to Traefik on port 443\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n  \n  my-app:\n    image: containous/whoami:v1.3.0\n\nTo avoid confusion, let‚Äôs state the obvious ‚Äî We haven‚Äôt yet configured anything\nbut enabled requests on 443 to be handled by Traffic. So, no certificate\nmanagement yet!\n\nGeneral Concepts\nUltimately, in Traefik, you configure HTTPS on the router\n[https://docs.traefik.io/routing/routers/] level. While defining routes, you\ndecide whether they are HTTP routes or HTTPS routes (by default, they are HTTP\nroutes).\n\nFirst, let‚Äôs expose our my-app service on HTTP so that it handles requests on\ndomain example.com.\n\nversion: \"3\"\n\nservices:\n  # ...\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - \"traefik.http.routers.my-app.rule=Host(`example.com`)\"\n\nAnd now, see what it takes to make this route HTTPS only!\n\nversion: \"3\"\n\nservices:\n  # ...\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - \"traefik.http.routers.my-app.rule=Host(`example.com`)\"\n      - \"traefik.http.routers.my-app.tls=true\"\n\nThere, by adding the tls option to the route, we‚Äôve made it HTTPS.\n\nThe only unanswered question left is, ‚ÄúWhere does Traefik get its certificates\nfrom?‚Äù And the answer is, ‚ÄúEither from a collection of certificates you own and\nhave configured or from a fully automatic mechanism that gets them for you.‚Äù\n\nLet‚Äôs see these solutions in action!\n\n\n--------------------------------------------------------------------------------\n\nOption 1 ‚Äî Certificates You Own\nThe least magical of the two options involves creating a configuration file.\n\nSay you already own a certificate for a domain (or a collection of certificates\nfor different domains) and that you are then the proud holder of files to claim\nyour ownership of the said domain.\n\nTo have Traefik make a claim on your behalf, you‚Äôll have to give it access to\nthe certificate files. Let‚Äôs do this.\n\nAdd a Configuration File for Certificates\n\nversion: \"3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --entrypoints.web-secure.address=:443\n      - --providers.docker=true\n      - --providers.file.directory=/configuration/\n      - --providers.file.watch=true\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n      - \"/home/username/traefik/configuration/:/configuration/\"\n\nTraefik runs with many providers beyond Docker (i.e., Kubernetes\n[https://docs.traefik.io/providers/kubernetes-crd/], Rancher\n[https://docs.traefik.io/providers/rancher/], Marathon\n[https://docs.traefik.io/providers/marathon/]), and here we chose to add plain\nold configuration files (--providers.file) in the configuration/ directory (and\nwe‚Äôll automatically reload changes with --providers.file.watch=true). We‚Äôll use\na configuration file to declare our certificates.\n\nAdd the Certificates to the Configuration File\n# in files/certificates.toml\n\n[[tls.certificates]] #first certificate\n   certFile = ‚Äú/path/to/example-com.cert‚Äù \n   keyFile = ‚Äú/path/to/example-com.key‚Äù\n\n[[tls.certificates]] #second certificate\n   certFile = ‚Äú/path/to/other.cert‚Äù \n   keyFile = ‚Äú/path/to/other.key‚Äù\n   \n# and so on\n\nNow that we have our TOML configuration file available (thanks to the enabled\nfile provider), we can fill in certificates in the [[tls.certificates]]section.\n\nEnjoy!\nThis is all there is to do. When dealing with an HTTPS route, Traefik goes\nthrough your default certificate store to find a matching certificate.\n\nSpecifying a Default Certificate?\nIf no valid certificate is found, Traefik serves a default auto-signed\ncertificate. But if needed, you can customize the default certificate like so:\n\n[tls.stores]\n  [tls.stores.default]\n   [tls.stores.default.defaultCertificate] \n     certFile = ‚Äúpath/to/cert.crt‚Äù \n     keyFile = ‚Äúpath/to/cert.key‚Äù\n\nAdditional Thoughts\nEven though the configuration is straightforward, it is your responsibility, as\nthe administrator, to configure / renew your certificates when they expire. If\nyou don‚Äôt like such constraints, keep reading!\n\n\n--------------------------------------------------------------------------------\n\nOption 2 ‚Äî Dynamic / Automatic Certificates\nHaving to manage (buy/install/renew) your certificates is a process you might \nnot enjoy (I don‚Äôt). If so, you‚Äôll be interested in the automatic certificate\ngeneration embedded in Traefik (thanks to Let‚Äôs Encrypt).\n\nLong story short, you can start Traefik with no other configuration than your\nLet‚Äôs Encrypt account, and Traefik automatically negotiates\n(get/renew/configure) certificates for you ‚Äî No extra step.\n\nCertificate Resolvers\nWe saw that you can configure a router to use TLS\n(--traefik.http.routers.router-name.tls=true). \nAs a consequence, we saw that Traefik would go through your certificate list to\nfind a suitable match for the domain at hand (and if not would use a default\ncertificate).\n\nFor automatic certificate generation, you can add a certificate resolver to your\nTLS options. A certificate resolver is responsible for retrieving certificates.\n\nHere, let‚Äôs define a certificate resolver that works with your Let‚Äôs Encrypt\naccount!\n\nservices:\n  traefik:\n    image: \"traefik:v2.0\"\n    command:\n      - --entrypoints.websecure.address=:443\n      # ...\n      - --certificatesresolvers.le.acme.email=my@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n      # ...\n\nAs you can read, we defined a certificate resolver named le of type acme. Then,\nwe provided an email (your Let‚Äôs Encrypt account), the storage file (for\ncertificates it retrieves), and the challenge for certificate negotiation\n[https://docs.traefik.io/https/acme/#the-different-acme-challenges](here \ntlschallenge, just because it‚Äôs the most concise configuration option for the\nsake of the example).\n\nFrom now on, Traefik is fully equipped to generate certificates for you!\n\nUsing the Certificate Resolver\nIf you remember correctly (I‚Äôm sure you do!), we enabled TLS on our router like\nso:\n\nversion: \"3\"\n\nservices:\n  # ...\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - \"traefik.http.routers.my-app.rule=Host(`example.com`)\"\n      - \"traefik.http.routers.my-app.tls=true\"\n\nNow, to enable our certificate resolver and have it automatically generate\ncertificates (when needed), we‚Äôll add it to the TLS configuration, like so:\n\nversion: \"3\"\n\nservices:\n  # ...\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - \"traefik.http.routers.my-app.rule=Host(`example.com`)\"\n      - \"traefik.http.routers.my-app.tls=true\"\n      - \"traefik.http.routers.my-app.tls.certresolver=le\"\n\nNow, if your certificate store doesn‚Äôt yet have a valid certificate for \nexample.com, the le certificate resolver will transparently negotiate one for\nyou ‚Äî it‚Äôs that simple.\n\nMultiple Certificate Resolvers?\nWith certificate resolvers, you can configure different challenges.\n\nBelow is an example that shows how to configure two CertResolvers that leverage\nLet‚Äôs Encrypt, one using the dnsChallenge\n[https://docs.traefik.io/https/acme/#dnschallenge], the other using the \ntlsChallenge [https://docs.traefik.io/https/acme/#tlschallenge].\n\n[certificatesResolvers.resolver-digital-ocean.acme]\n  # ... \n  [certificatesResolvers.resolver-digital-ocean.acme.dnsChallenge]\n    provider = \"digitalocean\"\n    delayBeforeCheck = 0\n\n[certificatesResolvers.tls-challenge-resolver.acme]\n  # ...\n  [certificatesResolvers.tls-challenge-resolver.acme.tlsChallenge]\n\nLater on, you‚Äôll be able to use one or the other on your routers.\n\n# in routers.toml\n\n[http.routers]\n  [http.routers.https-route]\n    rule = \"Host(`my.domain`)\"\n    [http.routers.https-route.tls]\n      certResolver = \"resolver-digital-ocean\"\n\n[http.routers.https-route-2]\n    rule = \"Host(`other.domain`)\"\n    [http.routers.https-route-2.tls]\n      certResolver = \"tls-challenge-resolver\"\n\nIn the above example (that uses the file provider), we‚Äôve asked Traefik to\ngenerate certificates for my.domain using the dnsChallenge (with digital ocean)\nand to generate certificates for other.domain using the TLSChallenge.\n\nAnd you‚Äôve guessed it already ‚Äî Traefik supports DNS challenge for different DNS\nproviders, at the same time!\n\n\n\n--------------------------------------------------------------------------------\n\nWildcard and Let‚Äôs Encrypt?\nInstead of generating a certificate for each subdomain, you can choose to\ngenerate wildcard certificates!\n\n[http.routers]\n  [http.routers.router-example]\n    rule = \"Host(`something.my.domain`)\"\n    [http.routers.router-example.tls]\n      certResolver = \"my-resolver\"\n      [[http.routers.router-example.tls.domains]]\n        main = \"my.domain\"\n        sans = \"*.my.domain\"\n\nIn the above example, we‚Äôve configured Traefik to generate a wildcard\ncertificate for *.my.domain.\n\nIf we had omitted the .tls.domains section, Traefik would have used the host\n(here something.my.domain) defined in the Host rule to generate a certificate.\n\n\n--------------------------------------------------------------------------------\n\nWhat About TCP & TLS?\nIf you want to configure TLS with TCP, then good news: nothing changes, you‚Äôll\nconfigure the same tls option, but this time on your tcp router.\n\nversion: \"3\"\n\nservices:\n  # ...\n  my-tcp-app:\n    image: containous/whoamitcp:v1.0.0\n    labels:\n      - \"traefik.tcp.routers.my-tcp-app.rule=HostSNI(`tcp-example.com`)\"\n      - \"traefik.tcp.routers.my-tcp-app.tls=true\"\n\n\n--------------------------------------------------------------------------------\n\nWhat About Pass-Through?\nSometimes your services handle TLS by themselves. In such cases, Traefik mustn‚Äôt\nterminate the TLS connection but forward the request ‚Äúas is‚Äù to these services.\nTo configure this passthrough, you‚Äôll need to configure a TCP router (even if\nyour service handles HTTPS).\n\nversion: \"3\"\n\nservices:\n  # ...\n  my-tcp-app:\n    image: containous/whoamitcp:v1.0.0\n    labels:\n      - \"traefik.tcp.routers.my-tcp-app.rule=HostSNI(`tcp-example.com`)\"\n      - \"traefik.tcp.routers.my-tcp-app.tls.passthrough=true\"\n\n\n--------------------------------------------------------------------------------\n\nQuestions? Where to Go Next?\nHopefully, this article sheds light on how to configure Traefik 2 with TLS.\n\nIf there are missing use cases or still unanswered questions, let me know in the\ncomments or on the community forum\n[https://community.containo.us/c/traefik/traefik-v2]!\n\nIn the meantime ‚Äî Happy Traefik!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">HTTPS (& TCP over TLS) for everyone!</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-103.png\" class=\"kg-image\"></figure><p>There are hundreds of reasons why I love being a developer (besides memories of sleepless nights trying to fix a video game that nobody except myself would ever play).</p><p>Being a developer gives you superpowers ‚Äî you can solve any kind of problems. Yes, especially if they don‚Äôt involve real-life practical situations.</p><p>But these superpowers are sometimes hindered by tedious configuration work that expects you to master <em><em>yet another</em></em> arcane language assembled with heaps of words you‚Äôve never seen before. Such a barrier can be encountered when dealing with HTTPS and its certificates.</p><p>Luckily for us, Traefik tends to lower this kind of hurdle and makes sure that there are easy ways of securely connecting your developments to the outside world.</p><h2 id=\"the-goal-for-today\">The Goal for Today</h2><p>The challenge we‚Äôll accept is the following ‚Äî You have an HTTP service exposed through Traefik, and you want Traefik to deal with the HTTPS burden (TLS termination), leaving your pristine service unspoiled by mundane technical details.</p><p>We‚Äôll assume you have a basic understanding of Traefik on Docker and that you‚Äôre familiar with its configuration (if not, it‚Äôs time to read <a href=\"https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/\">Traefik 2 &amp; Docker 101</a>).</p><p>During this article, we‚Äôll use my pet demo docker-compose file: it enables the docker provider and launches a <code>my-app</code> application that allows us to test any request.</p><pre><code class=\"language-yaml\">version: \"3\"\nservices:\n  traefik:\n    image: \"traefik:v2.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker=true\n    ports:\n      - \"80:80\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n  \n  my-app:\n    image: containous/whoami:v1.3.0</code></pre><h2 id=\"getting-things-ready\">Getting Things Ready</h2><p>First things first, let‚Äôs make sure our setup can handle HTTPS traffic on the default port (<code>:443</code>), and that Traefik listens to this port thanks to an <a href=\"https://docs.traefik.io/routing/entrypoints/\" rel=\"noopener nofollow\">entrypoint</a> we‚Äôll name <code>web-secure</code>.</p><pre><code class=\"language-yaml\">version: \"3\"\nservices:\n  traefik:\n    image: \"traefik:v2.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --entrypoints.web-secure.address=:443 #Declares the web-secure entrypoint in Traefik\n      - --providers.docker=true\n    ports:\n      - \"80:80\"\n      - \"443:443\" #Docker sends requests on port 443 to Traefik on port 443\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n  \n  my-app:\n    image: containous/whoami:v1.3.0</code></pre><p>To avoid confusion, let‚Äôs state the obvious ‚Äî We haven‚Äôt yet configured anything but enabled requests on 443 to be handled by Traffic. So, no certificate management yet!</p><h2 id=\"general-concepts\">General Concepts</h2><p>Ultimately, in Traefik, you configure HTTPS on the <a href=\"https://docs.traefik.io/routing/routers/\" rel=\"noopener nofollow\">router</a> level. While defining routes, you decide whether they are HTTP routes or HTTPS routes (by default, they are HTTP routes).</p><p>First, let‚Äôs expose our <code>my-app</code> service on HTTP so that it handles requests on domain <code>example.com</code>.</p><pre><code class=\"language-yaml\">version: \"3\"\n\nservices:\n  # ...\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - \"traefik.http.routers.my-app.rule=Host(`example.com`)\"</code></pre><p>And now, see what it takes to make this route HTTPS only!</p><pre><code class=\"language-yaml\">version: \"3\"\n\nservices:\n  # ...\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - \"traefik.http.routers.my-app.rule=Host(`example.com`)\"\n      - \"traefik.http.routers.my-app.tls=true\"</code></pre><p>There, by adding the <code>tls</code> option to the route, we‚Äôve made it HTTPS.</p><p>The only unanswered question left is, ‚ÄúWhere does Traefik get its certificates from?‚Äù And the answer is, ‚ÄúEither from a collection of certificates you own and have configured or from a fully automatic mechanism that gets them for you.‚Äù</p><p>Let‚Äôs see these solutions in action!</p><hr><h2 id=\"option-1-certificates-you-own\">Option 1 ‚Äî Certificates You Own</h2><p>The least magical of the two options involves creating a configuration file.</p><p>Say you already own a certificate for a domain (or a collection of certificates for different domains) and that you are then the proud holder of files to claim your ownership of the said domain.</p><p>To have Traefik make a claim on your behalf, you‚Äôll have to give it access to the certificate files. Let‚Äôs do this.</p><h3 id=\"add-a-configuration-file-for-certificates\">Add a Configuration File for Certificates<br></h3><pre><code class=\"language-yaml\">version: \"3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --entrypoints.web-secure.address=:443\n      - --providers.docker=true\n      - --providers.file.directory=/configuration/\n      - --providers.file.watch=true\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n      - \"/home/username/traefik/configuration/:/configuration/\"</code></pre><p>Traefik runs with many providers beyond Docker (i.e., <a href=\"https://docs.traefik.io/providers/kubernetes-crd/\" rel=\"noopener nofollow\">Kubernetes</a>, <a href=\"https://docs.traefik.io/providers/rancher/\" rel=\"noopener nofollow\">Rancher</a>, <a href=\"https://docs.traefik.io/providers/marathon/\" rel=\"noopener nofollow\">Marathon</a>), and here we chose to add plain old configuration files (<code>--providers.file</code>) in the <code>configuration/</code> directory (and we‚Äôll automatically reload changes with <code>--providers.file.watch=true</code>). We‚Äôll use a configuration file to declare our certificates.</p><h3 id=\"add-the-certificates-to-the-configuration-file\">Add the Certificates to the Configuration File</h3><pre><code class=\"language-toml\"># in files/certificates.toml\n\n[[tls.certificates]] #first certificate\n   certFile = ‚Äú/path/to/example-com.cert‚Äù \n   keyFile = ‚Äú/path/to/example-com.key‚Äù\n\n[[tls.certificates]] #second certificate\n   certFile = ‚Äú/path/to/other.cert‚Äù \n   keyFile = ‚Äú/path/to/other.key‚Äù\n   \n# and so on</code></pre><p>Now that we have our TOML configuration file available (thanks to the enabled file provider), we can fill in certificates in the <code>[[tls.certificates]]</code>section.</p><h3 id=\"enjoy-\">Enjoy!</h3><p>This is all there is to do. When dealing with an HTTPS route, Traefik goes through your default certificate store to find a matching certificate.</p><h3 id=\"specifying-a-default-certificate\">Specifying a Default Certificate?</h3><p>If no valid certificate is found, Traefik serves a default auto-signed certificate. But if needed, you can customize the default certificate like so:</p><pre><code class=\"language-toml\">[tls.stores]\n  [tls.stores.default]\n   [tls.stores.default.defaultCertificate] \n     certFile = ‚Äúpath/to/cert.crt‚Äù \n     keyFile = ‚Äúpath/to/cert.key‚Äù</code></pre><h3 id=\"additional-thoughts\">Additional Thoughts</h3><p>Even though the configuration is straightforward, it is your responsibility, as the administrator, to configure / renew your certificates when they expire. If you don‚Äôt like such constraints, keep reading!</p><hr><h2 id=\"option-2-dynamic-automatic-certificates\">Option 2 ‚Äî Dynamic / Automatic Certificates</h2><p>Having to manage (buy/install/renew) your certificates is a process you might <em><em>not</em></em> enjoy (I don‚Äôt). If so, you‚Äôll be interested in the automatic certificate generation embedded in Traefik (thanks to Let‚Äôs Encrypt).</p><p>Long story short, you can start Traefik with no other configuration than your Let‚Äôs Encrypt account, and Traefik automatically negotiates (get/renew/configure) certificates for you ‚Äî No extra step.</p><h3 id=\"certificate-resolvers\">Certificate Resolvers</h3><p>We saw that you can configure a router to use TLS<br>(<code>--traefik.http.routers.router-name.tls=true</code>). <br>As a consequence, we saw that Traefik would go through your certificate list to find a suitable match for the domain at hand (and if not would use a default certificate).</p><p>For automatic certificate generation, you can add a <em><em>certificate resolver</em></em> to your TLS options. A certificate resolver is responsible for retrieving certificates.</p><p>Here, let‚Äôs define a certificate resolver that works with your Let‚Äôs Encrypt account!</p><pre><code class=\"language-yaml\">services:\n  traefik:\n    image: \"traefik:v2.0\"\n    command:\n      - --entrypoints.websecure.address=:443\n      # ...\n      - --certificatesresolvers.le.acme.email=my@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n      # ...</code></pre><p>As you can read, we defined a certificate resolver named <code>le</code> of type <code>acme</code>. Then, we provided an email (your Let‚Äôs Encrypt account), the storage file (for certificates it retrieves), and <a href=\"https://docs.traefik.io/https/acme/#the-different-acme-challenges\" rel=\"noopener nofollow\">the challenge for certificate negotiation</a>(here <code>tlschallenge</code>, just because it‚Äôs the most concise configuration option for the sake of the example).</p><p>From now on, Traefik is fully equipped to generate certificates for you!</p><h3 id=\"using-the-certificate-resolver\">Using the Certificate Resolver</h3><p>If you remember correctly (I‚Äôm sure you do!), we enabled TLS on our router like so:</p><pre><code class=\"language-yaml\">version: \"3\"\n\nservices:\n  # ...\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - \"traefik.http.routers.my-app.rule=Host(`example.com`)\"\n      - \"traefik.http.routers.my-app.tls=true\"</code></pre><p>Now, to enable our certificate resolver and have it automatically generate certificates (when needed), we‚Äôll add it to the TLS configuration, like so:</p><pre><code class=\"language-yaml\">version: \"3\"\n\nservices:\n  # ...\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - \"traefik.http.routers.my-app.rule=Host(`example.com`)\"\n      - \"traefik.http.routers.my-app.tls=true\"\n      - \"traefik.http.routers.my-app.tls.certresolver=le\"</code></pre><p>Now, if your certificate store doesn‚Äôt yet have a valid certificate for <code>example.com</code>, the <code>le</code> certificate resolver will transparently negotiate one for you ‚Äî it‚Äôs that simple.</p><h3 id=\"multiple-certificate-resolvers\">Multiple Certificate Resolvers?</h3><p>With certificate resolvers, you can configure different challenges.</p><p>Below is an example that shows how to configure two CertResolvers that leverage Let‚Äôs Encrypt, one using the <a href=\"https://docs.traefik.io/https/acme/#dnschallenge\" rel=\"noopener nofollow\">dnsChallenge</a>, the other using the <a href=\"https://docs.traefik.io/https/acme/#tlschallenge\" rel=\"noopener nofollow\">tlsChallenge</a>.</p><pre><code class=\"language-toml\">[certificatesResolvers.resolver-digital-ocean.acme]\n  # ... \n  [certificatesResolvers.resolver-digital-ocean.acme.dnsChallenge]\n    provider = \"digitalocean\"\n    delayBeforeCheck = 0\n\n[certificatesResolvers.tls-challenge-resolver.acme]\n  # ...\n  [certificatesResolvers.tls-challenge-resolver.acme.tlsChallenge]</code></pre><p>Later on, you‚Äôll be able to use one or the other on your routers.</p><pre><code class=\"language-toml\"># in routers.toml\n\n[http.routers]\n  [http.routers.https-route]\n    rule = \"Host(`my.domain`)\"\n    [http.routers.https-route.tls]\n      certResolver = \"resolver-digital-ocean\"\n\n[http.routers.https-route-2]\n    rule = \"Host(`other.domain`)\"\n    [http.routers.https-route-2.tls]\n      certResolver = \"tls-challenge-resolver\"</code></pre><p>In the above example (that uses the file provider), we‚Äôve asked Traefik to generate certificates for <code>my.domain</code> using the dnsChallenge (with digital ocean) and to generate certificates for <code>other.domain</code> using the TLSChallenge.</p><p>And you‚Äôve guessed it already ‚Äî Traefik supports DNS challenge for different DNS providers, <em><em>at the same time</em></em>!<br></p><hr><h2 id=\"wildcard-and-let-s-encrypt\">Wildcard and Let‚Äôs Encrypt?</h2><p>Instead of generating a certificate for each subdomain, you can choose to generate wildcard certificates!</p><pre><code class=\"language-toml\">[http.routers]\n  [http.routers.router-example]\n    rule = \"Host(`something.my.domain`)\"\n    [http.routers.router-example.tls]\n      certResolver = \"my-resolver\"\n      [[http.routers.router-example.tls.domains]]\n        main = \"my.domain\"\n        sans = \"*.my.domain\"</code></pre><p>In the above example, we‚Äôve configured Traefik to generate a wildcard certificate for <code>*.my.domain</code>.</p><p>If we had omitted the <code>.tls.domains</code> section, Traefik would have used the host (here <code>something.my.domain</code>) defined in the <code>Host</code> rule to generate a certificate.</p><hr><h2 id=\"what-about-tcp-tls\">What About TCP &amp; TLS?</h2><p>If you want to configure TLS with TCP, then good news: nothing changes, you‚Äôll configure the same <code>tls</code> option, but this time on your <code>tcp</code> router.</p><pre><code class=\"language-yaml\">version: \"3\"\n\nservices:\n  # ...\n  my-tcp-app:\n    image: containous/whoamitcp:v1.0.0\n    labels:\n      - \"traefik.tcp.routers.my-tcp-app.rule=HostSNI(`tcp-example.com`)\"\n      - \"traefik.tcp.routers.my-tcp-app.tls=true\"</code></pre><hr><h2 id=\"what-about-pass-through\">What About Pass-Through?</h2><p>Sometimes your services handle TLS by themselves. In such cases, Traefik mustn‚Äôt terminate the TLS connection but forward the request ‚Äúas is‚Äù to these services. To configure this passthrough, you‚Äôll need to configure a TCP router (even if your service handles HTTPS).</p><pre><code class=\"language-yaml\">version: \"3\"\n\nservices:\n  # ...\n  my-tcp-app:\n    image: containous/whoamitcp:v1.0.0\n    labels:\n      - \"traefik.tcp.routers.my-tcp-app.rule=HostSNI(`tcp-example.com`)\"\n      - \"traefik.tcp.routers.my-tcp-app.tls.passthrough=true\"</code></pre><hr><h2 id=\"questions-where-to-go-next\">Questions? Where to Go Next?</h2><p>Hopefully, this article sheds light on how to configure Traefik 2 with TLS.</p><p>If there are missing use cases or still unanswered questions, let me know in the comments or on the <a href=\"https://community.containo.us/c/traefik/traefik-v2\" rel=\"noopener nofollow\">community forum</a>!</p><p>In the meantime ‚Äî Happy Traefik!</p>","url":"https://containous.ghost.io/blog/traefik-2-tls-101-23b4fbee81f1/","canonical_url":null,"uuid":"63ca7b89-9af1-4516-ba7c-c4f4747cf300","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dcdfa6f2345360038abe218","reading_time":7}},{"node":{"id":"Ghost__Post__5dd68f68b6de2b00381d3f6b","title":"Maesh 1.0","slug":"maesh-1-0-802f4be9a9a7","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/maesh-1.0.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b00e1a35700706f1ce67f13a71d0d148/f3583/maesh-1.0.png","srcSet":"/static/b00e1a35700706f1ce67f13a71d0d148/630fb/maesh-1.0.png 300w,\n/static/b00e1a35700706f1ce67f13a71d0d148/2a4de/maesh-1.0.png 600w,\n/static/b00e1a35700706f1ce67f13a71d0d148/f3583/maesh-1.0.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic.","custom_excerpt":"Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic.","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"November 21, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-21T13:21:44.000+00:00","published_at":"2019-11-21T13:21:00.000+00:00","updated_at":"2020-05-22T00:21:18.000+00:00","meta_title":"Maesh 1.0","meta_description":"Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Simpler Service Mesh, Now Production Ready\n\nThree months ago (in September 2019) we were proud to unleash Maesh\n[/blog/announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29/]\n, the simpler service mesh. With so many tools already available on the market,\nwe couldn‚Äôt wait to see how the community would react to our vision of the\nconcept.\n\nThe answer is ‚Äî incredibly well. In less than a month, Maesh had gathered a\ncommunity of people that adopted it right from the start on their development\ncluster. These brave early adopters provided us with invaluable insights about\nvarious cluster configurations and shed light on possible improvements. We\nlistened the best we could, helped them contribute to the project, fixed what\nhad to be fixed, and we‚Äôre now contemplating the result of this common effort ‚Äî \nMaesh 1.0\n\nWhat is Maesh?\nMaesh allows for visibility and management of the traffic that flows inside your\nKubernetes cluster, which is just as important as the ingress and egress\ntraffic. Maesh is designed from the ground up to be straightforward, easy to\ninstall, and easy to use.\n\nBuilt on top of Traefik, Maesh is a simple, yet full-featured service mesh. It\nfits as your de-facto service mesh in your Kubernetes cluster and supports the\nlatest Service Mesh Interface specification (SMI [https://smi-spec.io/]) that\nfacilitates integration with pre-existing solutions. Maesh is opt-in by default,\nwhich means that your existing services are unaffected until you decide to add\nthem to the mesh.\n\nMaesh does not use any sidecar container but handles routing through proxy\nendpoints running on each node. Not using sidecars means that Maesh does not\nmodify your Kubernetes objects, and does not modify your traffic without your\nknowledge. Using the Maesh endpoints is all that is required.\n\nWhat‚Äôs New since the Alpha?\nPerformance Improvements\nBased on feedback, we started to rework the inner architecture of Maesh to\nimprove performance and stability. In particular, we made the Maesh controller\nstateless (again) and refactored the internal architecture used to refresh the\nconfiguration. As a result Maesh reacts faster and is more resilient to changes.\nTo make it easier to customize, plenty of options\n[https://github.com/containous/maesh/blob/master/helm/chart/maesh/values.yaml] \nare now configurable (namespaces, the cluster domain, ‚Ä¶).\n\nGKE Support\nMany of our early adopters tried to install Maesh (alpha) on GKE with no\nsuccess. The reason was that Maesh relied on CoreDNS to opt-in into the usage of\nthe internal mesh and that GKE doesn‚Äôt embed it.\n\nAs a result and to support GKE and distributions that do not ship with CoreDNS,\nwe‚Äôve added support for kube-dns.\n\nFor Maesh 1.0, we‚Äôve tested many distributions but couldn‚Äôt test every one of\nthem. If your favorite appears to be unsupported, please raise your voice and\nhelp us fixing that!\n\nSupport for the SMI TCPRoute\nMaesh supported the SMI HTTP part from the beginning, and now supports the TCP\nportion as well. (Bellow is an example of an SMI TCPRoute.)\n\nkind: TrafficTarget\napiVersion: access.smi-spec.io/v1alpha1\nmetadata:\n  name: api-service-target\n  namespace: default\ndestination:\n  kind: ServiceAccount\n  name: api-service\n  namespace: default\nspecs:\n- kind: TCPRoute\n  name: my-tcp-route\nsources:\n- kind: ServiceAccount\n  name: my-other-service\n  namespace: default\n---\napiVersion: specs.smi-spec.io/v1alpha1\nkind: TCPRoute\nmetadata:\n  name: my-tcp-route\n\nkind: TrafficTarget\napiVersion: access.smi-spec.io/v1alpha1\nmetadata:\n  name: api-service-target\n  namespace: default\ndestination:\n  kind: ServiceAccount\n  name: api-service\n  namespace: default\nspecs:\n- kind: TCPRoute\n  name: my-tcp-route\nsources:\n- kind: ServiceAccount\n  name: my-other-service\n  namespace: default\n---\napiVersion: specs.smi-spec.io/v1alpha1\nkind: TCPRoute\nmetadata:\n  name: my-tcp-route\n\n\n\n--------------------------------------------------------------------------------\n\nWhat‚Äôs Next\nOnce again, we are thankful for the multitude of contributors that went straight\nahead and added Maesh to their development clusters. You provided us with\ninvaluable and early feedback and made this release possible.\n\nBut it‚Äôs just the beginning! Keep telling us what you like, giving us thoughts\nand ideas, and keep (or start) contributing! Pull requests and Issues are the\nbest way to support the product and make it your own.\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Simpler Service Mesh, Now Production Ready</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/1_iap46n1HJlw_lNotg3MtzA.png\" class=\"kg-image\"></figure><p>Three months ago (in September 2019) we were <a href=\"https://containous.ghost.io/blog/announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29/\">proud to unleash Maesh</a>, the simpler service mesh. With so many tools already available on the market, we couldn‚Äôt wait to see how the community would react to our vision of the concept.</p><p>The answer is ‚Äî incredibly well. In less than a month, Maesh had gathered a community of people that adopted it right from the start on their development cluster. These brave early adopters provided us with invaluable insights about various cluster configurations and shed light on possible improvements. We listened the best we could, helped them contribute to the project, fixed what had to be fixed, and we‚Äôre now contemplating the result of this common effort ‚Äî <strong><strong>Maesh 1.0</strong></strong></p><h2 id=\"what-is-maesh\">What is Maesh?</h2><p>Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic. Maesh is designed from the ground up to be straightforward, easy to install, and easy to use.</p><p>Built on top of Traefik, Maesh is a simple, yet full-featured service mesh. It fits as your de-facto service mesh in your Kubernetes cluster and supports the latest Service Mesh Interface specification (<a href=\"https://smi-spec.io/\" rel=\"noopener\">SMI</a>) that facilitates integration with pre-existing solutions. Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.</p><p>Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. Not using sidecars means that Maesh does not modify your Kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-20.png\" class=\"kg-image\"></figure><h2 id=\"what-s-new-since-the-alpha\">What‚Äôs New since the Alpha?</h2><h3 id=\"performance-improvements\">Performance Improvements</h3><p>Based on feedback, we started to rework the inner architecture of Maesh to improve performance and stability. In particular, we made the Maesh controller stateless (again) and refactored the internal architecture used to refresh the configuration. As a result Maesh reacts faster and is more resilient to changes. To make it easier to customize, <a href=\"https://github.com/containous/maesh/blob/master/helm/chart/maesh/values.yaml\" rel=\"noopener\">plenty of options</a> are now configurable (namespaces, the cluster domain, ‚Ä¶).</p><h3 id=\"gke-support\">GKE Support</h3><p>Many of our early adopters tried to install Maesh (alpha) on GKE with no success. The reason was that Maesh relied on CoreDNS to opt-in into the usage of the internal mesh and that GKE doesn‚Äôt embed it.</p><p>As a result and to support GKE and distributions that do not ship with CoreDNS, we‚Äôve added support for kube-dns.</p><p>For Maesh 1.0, we‚Äôve tested many distributions but couldn‚Äôt test every one of them. If your favorite appears to be unsupported, please raise your voice and help us fixing that!</p><h3 id=\"support-for-the-smi-tcproute\">Support for the SMI TCPRoute</h3><p>Maesh supported the SMI HTTP part from the beginning, and now supports the TCP portion as well. (Bellow is an example of an SMI TCPRoute.)</p><pre><code class=\"language-yaml\">kind: TrafficTarget\napiVersion: access.smi-spec.io/v1alpha1\nmetadata:\n  name: api-service-target\n  namespace: default\ndestination:\n  kind: ServiceAccount\n  name: api-service\n  namespace: default\nspecs:\n- kind: TCPRoute\n  name: my-tcp-route\nsources:\n- kind: ServiceAccount\n  name: my-other-service\n  namespace: default\n---\napiVersion: specs.smi-spec.io/v1alpha1\nkind: TCPRoute\nmetadata:\n  name: my-tcp-route</code></pre><!--kg-card-begin: markdown--><pre><code>kind: TrafficTarget\napiVersion: access.smi-spec.io/v1alpha1\nmetadata:\n  name: api-service-target\n  namespace: default\ndestination:\n  kind: ServiceAccount\n  name: api-service\n  namespace: default\nspecs:\n- kind: TCPRoute\n  name: my-tcp-route\nsources:\n- kind: ServiceAccount\n  name: my-other-service\n  namespace: default\n---\napiVersion: specs.smi-spec.io/v1alpha1\nkind: TCPRoute\nmetadata:\n  name: my-tcp-route\n</code></pre>\n<!--kg-card-end: markdown--><hr><h2 id=\"what-s-next\">What‚Äôs Next</h2><p>Once again, we are thankful for the multitude of contributors that went straight ahead and added Maesh to their development clusters. You provided us with invaluable and early feedback and made this release possible.</p><p>But it‚Äôs just the beginning! Keep telling us what you like, giving us thoughts and ideas, and keep (or start) contributing! Pull requests and Issues are the best way to support the product and make it your own.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\" rel=\"noopener\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\" rel=\"noopener\">Community Forum</a></li></ul>","url":"https://containous.ghost.io/blog/maesh-1-0-802f4be9a9a7/","canonical_url":null,"uuid":"c50521f7-f849-4c76-a75f-3cb3067a6de6","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd68f68b6de2b00381d3f6b","reading_time":3}},{"node":{"id":"Ghost__Post__5def57371efbbd0038ef55ec","title":"Traefik 2.1","slug":"traefik-2-1-in-the-wild","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/Traefik2.1-Blog.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/9064b05f744a66955ef4f6af07b520d9/f3583/Traefik2.1-Blog.png","srcSet":"/static/9064b05f744a66955ef4f6af07b520d9/630fb/Traefik2.1-Blog.png 300w,\n/static/9064b05f744a66955ef4f6af07b520d9/2a4de/Traefik2.1-Blog.png 600w,\n/static/9064b05f744a66955ef4f6af07b520d9/f3583/Traefik2.1-Blog.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Releases keep coming, but this one feels unique to us because this is our very first release since Traefik 2.0, and we've learned a lot! ","custom_excerpt":"Releases keep coming, but this one feels unique to us because this is our very first release since Traefik 2.0, and we've learned a lot! ","visibility":"public","created_at_pretty":"10 December, 2019","published_at_pretty":"December 12, 2019","updated_at_pretty":"09 April, 2020","created_at":"2019-12-10T08:28:39.000+00:00","published_at":"2019-12-12T13:03:00.000+00:00","updated_at":"2020-04-09T18:36:28.000+00:00","meta_title":"Traefik 2.1 - 2.X in the Wild","meta_description":"This release feels unique to us because this is our very first release since Traefik 2.0! Let's talk about changes introduced in 2.1.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"2.X in the Wild\n\nReleases keep coming, but this one feels unique to us because this is our very\nfirst release since Traefik 2.0, and we've learned a lot! \n\nWe all know it, you all know it: Traefik 2.0 consisted in a fest of new\nfeatures: TCP, middleware, rule syntax, YAML support, CRDs, WebUI, canary,\nmirroring, provider namespaces, new documentation, and many other inconspicuous\nchanges that will help us building the product we love towards greater heights.\n\nAll this was accompanied by tools to help the community seamlessly make the\ntransition: We developed a migration tool\n[https://github.com/containous/traefik-migration-tool], ¬†launched a community\nforum [https://community.containo.us/] to foster good communication and support,\nwrote new tutorials to help people have a fresh start with Traefik\n[/blog/traefik-2-0-docker-101-fc2893944b9d/] (including details about new TLS\noptions [/blog/traefik-2-tls-101-23b4fbee81f1/]), and of course we added a \nmigration guide in our documentation\n[https://docs.traefik.io/migration/v1-to-v2/]. \n\nThanks to the (immense) feedback we got from the community, we know we can do \neven better, and we were given some pointers in the right direction.\n\nBut before we talk about what we've learned and how we'll leverage this\nknowledge, let's talk about the changes introduced in 2.1. \n\nConsul Catalog Is Back!\nGreat news for Consul Catalog fans, Traefik 2.1 brings it back in the list of \nsupported providers\n[https://docs.traefik.io/v2.1/providers/overview/#supported-providers]! (But\nstay on hold because I know for sure that others will follow suit\n[https://github.com/containous/traefik/pull/5899].)\n\nImproving the CRD\nStickiness\nThe stickiness option is the ability for a load balancer to keep using the same\ntarget for a client once it has been sent to one. This option is now available\nfor our CRD users!\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: myName\n  namespace: myNamespace\nspec:\n  entryPoints:\n  - web\n  routes:\n  - kind: Rule\n    match: Host(`some-domain`)\n    services:\n    - kind: Service\n      name: myService\n      namespace: myNamespace\n      port: 80\n      sticky:\n        cookie: {} # Once a pod is selected for a client, it will stay the same for future calls\n\nService Load Balancing & Mirroring\nIntroduced in 2.0, service load balancing and mirroring were previously\nexclusively configurable using the file provider\n[https://docs.traefik.io/v2.0/providers/file/]. With 2.1 and the introduction of\nthe TraefikService object, we leveraged Traefik's CRD to enable such\nconfiguration in Kubernetes, and here is a first example with mirroring:\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: my-route-to-mirroring\n  namespace: default\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`some-domain`) && PathPrefix(`/some/path`)\n    kind: Rule\n    services:\n    - name: mirroring-example #targets the mirroring-example service\n      namespace: default\n      kind: TraefikService # we want to target the TraefikService we've declared (and not a K8S service named mirroring-example)\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: TraefikService\nmetadata:\n  name: mirroring-example\n  namespace: default\nspec:\n  mirroring:\n    name: v1 #sends 100% of the requests to the K8S service \"v1\" ...\n    mirrors:\n      - name: v2 # ... and sends a copy of 10% of the requests to v2\n        percent: 10\n        port: 80\n\nFor our second example, let's see how we could use service load balancing to do\ncanary deployments:\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: my-route-to-canary\n  namespace: default\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`some-domain`) && PathPrefix(`/some/path`)\n    kind: Rule\n    services:\n    - name: mirror1\n      namespace: default\n      kind: TraefikService\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: TraefikService\nmetadata:\n  name: canary-example\n  namespace: default\n\nspec:\n  weighted:\n    services:\n      - name: v1\n        weight: 80\n        port: 80\n      - name: v2\n        weight: 20\n        port: 80\n\nWe can now change the weight for each service (v1 and v2) at will!\n\nMixing Regular (Kubernetes) Services with TraefikServices\nWhen you define a target (with the name attribute) for your IngressRoute, by\ndefault, it targets a regular Service. If you want to target the new \nTraefikService objects, you just specify the kind attribute. What's great with\nthis system is that you can chain and combine them at will, creating intricate\npatterns depending on your needs.\n\nBelow is an example that leverages both services and TraefikServices, and that\nuses mirroring and service load balancing at the same time!\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: route-to-mirroring\n  namespace: default\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`some-domain`) && PathPrefix(`/some/path`)\n    kind: Rule\n    services:\n    - name: mirroring-example\n      namespace: default\n      kind: TraefikService\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: TraefikService\nmetadata:\n  name: mirroring-example\n  namespace: default\nspec:\n  mirroring:\n    name: canary-example\n    kind: TraefikService\n    mirrors:\n      - name: service-mirror\n        percent: 20\n        port: 80\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: TraefikService\nmetadata:\n  name: canary-example\n  namespace: default\nspec:\n  weighted:\n    services:\n      - name: v1\n        port: 80\n        weight: 80\n      - name: v2\n        weight: 20\n        port: 80\n\nNote on Updating the CRD for 2.1\nWhile updating an installation to v2.1, it is required to apply the new CRD and\nto enhance the existing ClusterRoledefinition. You will find out how in the \nfollowing guide [https://docs.traefik.io/migration/v2/].\n\nMore Control On Internal Routing\nIn 2.0, we've made changes to make sure people would be able to properly secure\nsome critical services offered by Traefik, like the API and the Dashboard (you\ncan see an example in our Traefik & Docker 101 article\n[/blog/traefik-2-0-docker-101-fc2893944b9d/]).\n\nPursuing the ability to configure internal services further while always giving\nusers more control, the 2.1 dashboard now shows the internal routers and\nservices involved.\n\nShows the internal services for the API and the DashboardShows the internal\nrouters leading to the internal API and Dashboard services (when users don't\nexplicitly configure them)We also jumped on the opportunity to add other\nconfigurable services to the list, namely rest@internal, ping@internal, and \nprometheus@internal. \n\n\n--------------------------------------------------------------------------------\n\nMigrating to 2.X Made Easy\nWith so many new options to customize Traefik to your every need, we understand\nthat some people can be a bit lost when migrating to 2.x, especially since\nTraefik is the kind of software that you run and forget (because it works nights\nand days without any other intervention from its users).\n\n> We have been working really hard to make this migration a matter of minutes.\nSo, if you're thinking about migrating but haven't jumped on the task yet, we\nwant to point you in the right direction:\n\n * This guide [/blog/traefik-2-0-docker-101-fc2893944b9d/] helps you truly\n   understand how Traefik 2 works on a Docker setup and will show you that 5\n   minutes are enough to have a good grasp of what you can do with it.\n * If you're looking for information about how to configure HTTPS / TLS, we\n   have\n   you covered with this guide [/blog/traefik-2-tls-101-23b4fbee81f1/]!\n * If you don't want to lose time converting your Ingress objects in Kubernetes\n   (who would want that?), we've developed a migration tool\n   [https://github.com/containous/traefik-migration-tool] that will handle it\n   for you.\n * Same goes with your traefik.toml file: the migration tool\n   [https://github.com/containous/traefik-migration-tool] can convert it for\n   you.\n * Oh, and the migration tool\n   [https://github.com/containous/traefik-migration-tool] can also convert your \n   acme.json certificate file.\n * And always feel free to engage conversation in our community forum\n   [https://community.containo.us], we read everything and do our best to\n   provide answers when we can.\n\n\n--------------------------------------------------------------------------------\n\nSupporting the 1.X Branch for Two Years!\nOur community matters, and we don't want our users to feel rushed to migrate to\nversion 2. We prefer seeing people slowly falling in love with the new tools\nTraefik has to offer and migrate. For this reason, we've decided to extend the\nsupport of the 1.X version until the end of 2021. \n\nThat's right: you have two years ahead of you before you need to make the leap!\n(And we believe you'll find benefits in migrating to 2.X way before that.)\n\n\n--------------------------------------------------------------------------------\n\nNext? Focusing on the User Experience\nIn the introduction, we've stated that we received (and are still receiving) a\nlot of feedback about 2.0. And let me tell you:\n\n> We listen\nApart from bringing extra features in the next release (like UDP, HTTP/3,\nKey-Value Stores, and the list goes on ...), we want to focus this release on\nthe user experience.\n\nNow that we've seen people massively use Traefik 2, we decided it's time to work\non making powerful features simpler to configure, or at least ... less verbose. \n\nSo, let's work together on making it happen! Come and raise your voice in the \nissue tracker [https://github.com/containous/traefik/issues], on the community\nforum [https://community.containo.us], or better‚Äîpull request\n[https://github.com/containous/traefik/pulls] your way into making Traefik a\nbetter tool for everyone.\n\nSee you around, and happy Traefik!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">2.X in the Wild</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/12/traefik-cantal-flat.png\" class=\"kg-image\"></figure><p>Releases keep coming, but this one feels unique to us because this is our very first release since Traefik 2.0, and we've learned a lot! </p><p>We all know it, <em>you</em> all know it: Traefik 2.0 consisted in a fest of new features: TCP, middleware, rule syntax, YAML support, CRDs, WebUI, canary, mirroring, provider namespaces, new documentation, and many other inconspicuous changes that will help us building the product we love towards greater heights.</p><p>All this was accompanied by tools to help the community seamlessly make the transition: We developed a <a href=\"https://github.com/containous/traefik-migration-tool\">migration tool</a>, ¬†launched a <a href=\"https://community.containo.us/\">community forum</a> to foster good communication and support, wrote new tutorials to help people have a <a href=\"https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/\">fresh start with Traefik</a> (including <a href=\"https://containous.ghost.io/blog/traefik-2-tls-101-23b4fbee81f1/\">details about new TLS options</a>), and of course we added a <a href=\"https://docs.traefik.io/migration/v1-to-v2/\">migration guide in our documentation</a>. </p><p>Thanks to the (immense) feedback we got from the community, we know we can do <em>even</em> better, and we were given some pointers in the right direction.</p><p>But before we talk about what we've learned and how we'll leverage this knowledge, let's talk about the changes introduced in 2.1. </p><h2 id=\"consul-catalog-is-back-\">Consul Catalog Is Back!</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/consul-catalog.png\" class=\"kg-image\"></figure><p>Great news for Consul Catalog fans, Traefik 2.1 brings it back in the list of <a href=\"https://docs.traefik.io/v2.1/providers/overview/#supported-providers\">supported providers</a>! (But stay on hold because I know for sure that <a href=\"https://github.com/containous/traefik/pull/5899\">others will follow suit</a>.)</p><h2 id=\"improving-the-crd\">Improving the CRD</h2><h3 id=\"stickiness\">Stickiness</h3><p>The stickiness option is the ability for a load balancer to keep using the same target for a client once it has been sent to one. This option is now available for our CRD users!</p><pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: myName\n  namespace: myNamespace\nspec:\n  entryPoints:\n  - web\n  routes:\n  - kind: Rule\n    match: Host(`some-domain`)\n    services:\n    - kind: Service\n      name: myService\n      namespace: myNamespace\n      port: 80\n      sticky:\n        cookie: {} # Once a pod is selected for a client, it will stay the same for future calls</code></pre><h3 id=\"service-load-balancing-mirroring\">Service Load Balancing &amp; Mirroring</h3><p>Introduced in 2.0, service load balancing and mirroring were previously exclusively configurable using the <a href=\"https://docs.traefik.io/v2.0/providers/file/\">file provider</a>. With 2.1 and the introduction of the <code>TraefikService</code> object, we leveraged Traefik's CRD to enable such configuration in Kubernetes, and here is a first example with mirroring:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-18.png\" class=\"kg-image\"></figure><pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: my-route-to-mirroring\n  namespace: default\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`some-domain`) &amp;&amp; PathPrefix(`/some/path`)\n    kind: Rule\n    services:\n    - name: mirroring-example #targets the mirroring-example service\n      namespace: default\n      kind: TraefikService # we want to target the TraefikService we've declared (and not a K8S service named mirroring-example)\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: TraefikService\nmetadata:\n  name: mirroring-example\n  namespace: default\nspec:\n  mirroring:\n    name: v1 #sends 100% of the requests to the K8S service \"v1\" ...\n    mirrors:\n      - name: v2 # ... and sends a copy of 10% of the requests to v2\n        percent: 10\n        port: 80</code></pre><p>For our second example, let's see how we could use service load balancing to do canary deployments:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-19.png\" class=\"kg-image\"></figure><pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: my-route-to-canary\n  namespace: default\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`some-domain`) &amp;&amp; PathPrefix(`/some/path`)\n    kind: Rule\n    services:\n    - name: mirror1\n      namespace: default\n      kind: TraefikService\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: TraefikService\nmetadata:\n  name: canary-example\n  namespace: default\n\nspec:\n  weighted:\n    services:\n      - name: v1\n        weight: 80\n        port: 80\n      - name: v2\n        weight: 20\n        port: 80</code></pre><p>We can now change the weight for each service (v1 and v2) at will!</p><h3 id=\"mixing-regular-kubernetes-services-with-traefikservices\">Mixing Regular (Kubernetes) Services with TraefikServices</h3><p>When you define a target (with the <code>name</code> attribute) for your <code>IngressRoute</code>, by default, it targets a regular <code>Service</code>. If you want to target the new <code>TraefikService</code> objects, you just specify the <code>kind</code> attribute. What's great with this system is that you can chain and combine them at will, creating intricate patterns depending on your needs.</p><p>Below is an example that leverages both services and <code>TraefikServices</code>, and that uses mirroring and service load balancing at the same time!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/canary-and-mirroring.png\" class=\"kg-image\"></figure><pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: route-to-mirroring\n  namespace: default\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`some-domain`) &amp;&amp; PathPrefix(`/some/path`)\n    kind: Rule\n    services:\n    - name: mirroring-example\n      namespace: default\n      kind: TraefikService\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: TraefikService\nmetadata:\n  name: mirroring-example\n  namespace: default\nspec:\n  mirroring:\n    name: canary-example\n    kind: TraefikService\n    mirrors:\n      - name: service-mirror\n        percent: 20\n        port: 80\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: TraefikService\nmetadata:\n  name: canary-example\n  namespace: default\nspec:\n  weighted:\n    services:\n      - name: v1\n        port: 80\n        weight: 80\n      - name: v2\n        weight: 20\n        port: 80</code></pre><h3 id=\"note-on-updating-the-crd-for-2-1\">Note on Updating the CRD for 2.1</h3><p>While updating an installation to v2.1, it is required to apply the new CRD and to enhance the existing <code>ClusterRole</code>definition. You will find out how in the <a href=\"https://docs.traefik.io/migration/v2/\">following guide</a>.</p><h2 id=\"more-control-on-internal-routing\">More Control On Internal Routing</h2><p>In 2.0, we've made changes to make sure people would be able to properly secure some critical services offered by Traefik, like the API and the Dashboard (you can see an example in our <a href=\"https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/\">Traefik &amp; Docker 101 article</a>).</p><p>Pursuing the ability to configure internal services further while always giving users more control, the 2.1 dashboard now shows the internal routers and services involved.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/12/Screenshot_2019-12-10-Traefik.png\" class=\"kg-image\"><figcaption>Shows the internal services for the API and the Dashboard</figcaption></figure><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/12/Screenshot_2019-12-10-Traefik-1-.png\" class=\"kg-image\"><figcaption>Shows the internal routers leading to the internal API and Dashboard services (when users don't explicitly configure them)</figcaption></figure><p>We also jumped on the opportunity to add other configurable services to the list, namely <code>rest@internal</code>, <code>ping@internal</code>, and <code>prometheus@internal</code>. </p><hr><h2 id=\"migrating-to-2-x-made-easy\">Migrating to 2.X Made Easy</h2><p>With so many new options to customize Traefik to your every need, we understand that some people can be a bit lost when migrating to 2.x, especially since Traefik is the kind of software that you run and forget (because it works nights and days without any other intervention from its users).</p><blockquote>We have been working really hard to make this migration a matter of minutes.</blockquote><p>So, if you're thinking about migrating but haven't jumped on the task yet, we want to point you in the right direction:</p><ul><li><a href=\"https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/\">This guide</a> helps you truly understand how Traefik 2 works on a Docker setup and will show you that 5 minutes are enough to have a good grasp of what you can do with it.</li><li>If you're looking for information about how to configure HTTPS / TLS, <a href=\"https://containous.ghost.io/blog/traefik-2-tls-101-23b4fbee81f1/\">we have you covered with this guide</a>!</li><li>If you don't want to lose time converting your Ingress objects in Kubernetes (who would want that?), we've developed a <a href=\"https://github.com/containous/traefik-migration-tool\">migration tool</a> that will handle it for you.</li><li>Same goes with your <code>traefik.toml</code> file: the <a href=\"https://github.com/containous/traefik-migration-tool\">migration tool</a> can convert it for you.</li><li>Oh, and the <a href=\"https://github.com/containous/traefik-migration-tool\">migration tool</a> can also convert your <code>acme.json</code> certificate file.</li><li>And always feel free to engage conversation in our <a href=\"https://community.containo.us\">community forum</a>, we read <em>everything</em> and do our best to provide answers when we can.</li></ul><hr><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/2-year-warranty.jpg\" class=\"kg-image\"></figure><h2 id=\"supporting-the-1-x-branch-for-two-years-\">Supporting the 1.X Branch for Two Years!</h2><p>Our community matters, and we don't want our users to feel rushed to migrate to version 2. We prefer seeing people slowly falling in love with the new tools Traefik has to offer and migrate. For this reason, we've decided to extend the support of the 1.X version until the end of 2021. </p><p>That's right: you have <strong>two years</strong> ahead of you before you need to make the leap! (And we believe you'll find benefits in migrating to 2.X <em>way</em> <em>before</em> that.)</p><hr><h2 id=\"next-focusing-on-the-user-experience\">Next? Focusing on the User Experience</h2><p>In the introduction, we've stated that we received (and are still receiving) a lot of feedback about 2.0. And let me tell you:</p><blockquote>We listen</blockquote><p>Apart from bringing extra features in the next release (like UDP, HTTP/3, Key-Value Stores, and the list goes on ...), we want to focus this release on the user experience.</p><p>Now that we've seen people massively use Traefik 2, we decided it's time to work on making powerful features simpler to configure, or at least ... less verbose. </p><p>So, let's work together on making it happen! Come and raise your voice in the <a href=\"https://github.com/containous/traefik/issues\">issue tracker</a>, on the <a href=\"https://community.containo.us\">community forum</a>, or better‚Äî<a href=\"https://github.com/containous/traefik/pulls\">pull request</a> your way into making Traefik a better tool for everyone.</p><p>See you around, and happy Traefik!</p>","url":"https://containous.ghost.io/blog/traefik-2-1-in-the-wild/","canonical_url":null,"uuid":"d345bdcc-6cf7-4811-a78d-505391119b8a","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5def57371efbbd0038ef55ec","reading_time":6}},{"node":{"id":"Ghost__Post__5e3999aecf5e3c00386bad49","title":"Traefik Enterprise Edition 2","slug":"traefik-enterprise-edition-2","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/TraefikEE2.0-Blog.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/f6c6cb29efa60da530b5d5d7b9b90913/f3583/TraefikEE2.0-Blog.png","srcSet":"/static/f6c6cb29efa60da530b5d5d7b9b90913/630fb/TraefikEE2.0-Blog.png 300w,\n/static/f6c6cb29efa60da530b5d5d7b9b90913/2a4de/TraefikEE2.0-Blog.png 600w,\n/static/f6c6cb29efa60da530b5d5d7b9b90913/f3583/TraefikEE2.0-Blog.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Four months after we launched Traefik V2.0, we're happy to announce that the Enterprise Edition is now available and brings its load of dedicated features!","custom_excerpt":"Four months after we launched Traefik V2.0, we're happy to announce that the Enterprise Edition is now available and brings its load of dedicated features!","visibility":"public","created_at_pretty":"04 February, 2020","published_at_pretty":"February 5, 2020","updated_at_pretty":"21 May, 2020","created_at":"2020-02-04T16:19:58.000+00:00","published_at":"2020-02-05T18:24:20.000+00:00","updated_at":"2020-05-21T18:45:02.000+00:00","meta_title":"Traefik Enterprise Edition 2","meta_description":"Twice The High Availability, Scalability, and Security. We're happy to announce that Traefik Enterprise 2 is now available.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Nicolas Mengin","slug":"nicolas","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/02/wam.jpeg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Nicolas Mengin","slug":"nicolas","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/02/wam.jpeg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Twice The High Availability, Scalability, and Security\n\nFour months after we launched Traefik v2.0 [/blog/traefik-2-0-6531ec5196c2/],\nwe're happy to announce that the Enterprise Edition is now available\n[https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days], and\nit is loaded with Enterprise specific features!\n\nOn top of enabling our users to leverage the 2.1 feature set\n[/blog/traefik-2-1-in-the-wild/] (TCP routing, middleware, canary, mirroring,\nenhanced rule syntax, etc.), the Enterprise Edition keeps helping our customers\nto set up highly available, scalable, and distributed systems.\n\nWhat's in TraefikEE 2.0?\nImproved High Availability\nOne of the core values behind Traefik Enterprise Edition is to secure our\ncustomers' infrastructure with a highly available solution. Behind the scenes,\nthis is achieved through the Raft consensus algorithm that allows recovery from\ncomponent failure.\n\nBut we know from experience, that in some extreme scenarios which combine heavy\nnetwork latency, multiple failures, and scheduled operations, the quorum of\nnormal state can be lost.\n\nFor this very reason, with TraefikEE 2.0 we've improved the resilience to a\ntemporary quorum loss, and we've introduced a mechanism to enable the cluster to\nrecover ‚Äì without any downtime ‚Äì from a single working instance of the\ncontrollers, and all it takes is a single command line\n[https://docs.containo.us/operating/disaster-recovery/].\n\nLDAP Authentication\nDeploying APIs on your cluster often comes with the necessity to manage\ncredentials, either for your business partners or for your teams. And the more\nAPIs you deploy, the more you engage in microservice architectures, the more API\nmanagement becomes part of your workflow.\n\nWith TraefikEE, we've introduced a way to simplify and centralize authentication\nwith the ability to connect with an LDAP server\n[https://docs.containo.us/middlewares/ldap/].\n\nDeclare users, groups, and credentials in your directory, then have TraefikEE\ndeal with authorization on your behalf.\n\nIn the following example, we're connecting TraefikEE to our LDAP server. Then we\nattach a rule to our service so that only users from the authorized group (with\nthe group id 500) can use our API.\n\n# Static Configuration\nauthSources:\n  mySource:\n    ldap:\n      url: ldap://ldap.server.addr:389\n\n\nversion: '3.4'\nservices:\n  whoami:\n    image: containous/whoami\n    deploy:\n      labels:\n        # Dynamic Configuration\n        - \"traefik.http.routers.whoami.rule=Path(`/whoami`)\"\n        - \"traefik.http.routers.whoami.service=whoami\"\n        - \"traefik.http.services.whoami.loadbalancer.server.port=80\"\n        - \"traefik.http.routers.whoami.middlewares=mymiddleware\"\n        - \"traefik.http.middlewares.mymiddleware.plugin.ldapauth.source=mySource\"\n        - \"traefik.http.middlewares.mymiddleware.plugin.ldapauth.baseDN=dc=example,dc=org\"\n        - \"traefik.http.middlewares.mymiddleware.plugin.ldapAuth.searchFilter=(&(objectClass=inetOrgPerson)(gidNumber=500)(uid=%s))\"\n\n\nCustomization Made Easy\nThe premise with TraefikEE is that you can setup a cluster of Traefik in one\nsingle command line, saving you hours of configuration decisions. But since no\ninfrastructure is the same, some users needed a way to customize many aspects of\ntheir architecture during installation.\n\nTraefikEE 2.0 still comes with a default setup command and it's now possible to\ngenerate a pre-configured manifest before the actual installation. With this\nmanifest, users are able to see every available configuration option and tweak\nevery parameter.\n\nOf course, each manifest is specific to the orchestrator, whether you use Swarm\n[https://docs.containo.us/installing/swarm/] or Kubernetes\n[https://docs.containo.us/installing/kubernetes/].\n\nDynamic TLS Certificates Management\nTraefikEE has always been fully integrated with Let‚Äôs Encrypt\n[https://docs.containo.us/operating/acme/], which has enabled many users to\nautomate certificate generation throughout their cluster.\n\nBut operating a cluster with many applications also means you have to deal with\nother certificates, whether in-house or bought separately. For such situations,\nTraefikEE comes with a command line to deploy them dynamically\n[https://docs.containo.us/operating/tls/].\n\nIn the following example, we‚Äôre adding a whoami.example.com certificate to the\ncluster.\n\n$ teectl create tls-cert --cert=mycrt.pem --key=mykey.prem\n$ teectl get tls-cert\nID     CN                  SANs  NOT AFTER             STORE    DEFAULT\nu7vxw  whoami.example.com        2022-01-22T15:27:25Z  default  false\n\n\nCLI 2.0\nOperating a Traefik cluster means being able to operate, configure,\nre-configure, stop and start proxies at will, wherever they are hosted in your\ninfrastructure -- and TraefikEE embeds a CLI (teectl\n[https://docs.containo.us/references/cli/teectl/]) for this purpose.\n\nWe saw the command line growing to become the main user interface for\nadministrators, and decided it was time to tweak its grammar for more\nconsistency.\n\nNow (like in Kubernetes), you‚Äôll create, get or delete resources to and from\nyour TraefikEE cluster, like in the previous TLS example.\n\nRedesigned Web UI\nInspired by Traefik, the Web UI allows users to have an overview of their\ncluster's health with just a glance.\n\nThe welcome page contains all the main information. It's the starting point from\nwhich you‚Äôll access all the cluster details.\n\nWhat's Next?\nAs you can see, TraefikEE not only adds a clustering system on top of Traefik,\nbut it contains additional features designed for enterprise and a CLI to operate\nthe cluster.\n\nThere are many benefits you can get from switching to TraefikEE, and the best is\nthat you can test it for yourself and request a free trial license on our\nwebsite\n[https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days] (and\nto make it simple, the TraefikEE configuration is fully compatible with your\nexisting Traefik configuration).\n\nAnd if you still have questions or need help finding a tailored option for your\ninfrastructure, we‚Äôll be happy to discuss it with you, and to help you find the\nbest solution for your use case\n[https://info.containo.us/request-demo-traefikee].\n\nTry it today\n[https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days], and\nbe sure that we'll continue to pack TraefikEE with new features driven by\ncompanies' needs... to make networking boring!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Twice The High Availability, Scalability, and Security</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/02/Containous-TraefikEE-2-0-1.png\" class=\"kg-image\"></figure><p>Four months after we launched <a href=\"https://containous.ghost.io/blog/traefik-2-0-6531ec5196c2/\">Traefik v2.0</a>, we're happy to announce that the <a href=\"https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days\">Enterprise Edition is now available</a>, and it is loaded with Enterprise specific features!</p><p>On top of enabling our users to leverage the <a href=\"https://containous.ghost.io/blog/traefik-2-1-in-the-wild/\">2.1 feature set</a> (TCP routing, middleware, canary, mirroring, enhanced rule syntax, etc.), the Enterprise Edition keeps helping our customers to set up highly available, scalable, and distributed systems.</p><h2 id=\"what-s-in-traefikee-2-0\"><strong>What's in TraefikEE 2.0?</strong></h2><h3 id=\"improved-high-availability\">Improved High Availability</h3><p>One of the core values behind Traefik Enterprise Edition is to secure our customers' infrastructure with a highly available solution. Behind the scenes, this is achieved through the Raft consensus algorithm that allows recovery from component failure.</p><p>But we know from experience, that in some extreme scenarios which combine heavy network latency, multiple failures, and scheduled operations, the quorum of normal state can be lost.</p><p>For this very reason, with TraefikEE 2.0 we've improved the resilience to a temporary quorum loss, and we've introduced a mechanism to enable the cluster to recover ‚Äì without any downtime ‚Äì from a single working instance of the controllers, and all it takes is <a href=\"https://docs.containo.us/operating/disaster-recovery/\">a single command line</a>.</p><h3 id=\"ldap-authentication\"><strong>LDAP Authentication</strong></h3><p>Deploying APIs on your cluster often comes with the necessity to manage credentials, either for your business partners or for your teams. And the more APIs you deploy, the more you engage in microservice architectures, the more API management becomes part of your workflow.</p><p>With TraefikEE, we've introduced a way to simplify and centralize authentication with the ability <a href=\"https://docs.containo.us/middlewares/ldap/\">to connect with an LDAP server</a>.</p><p>Declare users, groups, and credentials in your directory, then have TraefikEE deal with authorization on your behalf.</p><p>In the following example, we're connecting TraefikEE to our LDAP server. Then we attach a rule to our service so that only users from the authorized group (with the group id <strong>500</strong>) can use our API.</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\"># Static Configuration\nauthSources:\n  mySource:\n    ldap:\n      url: ldap://ldap.server.addr:389\n</code></pre>\n<pre><code class=\"language-yaml\">version: '3.4'\nservices:\n  whoami:\n    image: containous/whoami\n    deploy:\n      labels:\n        # Dynamic Configuration\n        - &quot;traefik.http.routers.whoami.rule=Path(`/whoami`)&quot;\n        - &quot;traefik.http.routers.whoami.service=whoami&quot;\n        - &quot;traefik.http.services.whoami.loadbalancer.server.port=80&quot;\n        - &quot;traefik.http.routers.whoami.middlewares=mymiddleware&quot;\n        - &quot;traefik.http.middlewares.mymiddleware.plugin.ldapauth.source=mySource&quot;\n        - &quot;traefik.http.middlewares.mymiddleware.plugin.ldapauth.baseDN=dc=example,dc=org&quot;\n        - &quot;traefik.http.middlewares.mymiddleware.plugin.ldapAuth.searchFilter=(&amp;(objectClass=inetOrgPerson)(gidNumber=500)(uid=%s))&quot;\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"customization-made-easy\">Customization Made Easy</h2><p>The premise with TraefikEE is that you can setup a cluster of Traefik in one single command line, saving you hours of configuration decisions. But since no infrastructure is the same, some users needed a way to customize many aspects of their architecture during installation.</p><p>TraefikEE 2.0 still comes with a default setup command and it's now possible to generate a pre-configured manifest before the actual installation. With this manifest, users are able to see every available configuration option and tweak every parameter.</p><p>Of course, each manifest is specific to the orchestrator, whether you use <a href=\"https://docs.containo.us/installing/swarm/\">Swarm</a> or <a href=\"https://docs.containo.us/installing/kubernetes/\">Kubernetes</a>.</p><h2 id=\"dynamic-tls-certificates-management\">Dynamic TLS Certificates Management</h2><p>TraefikEE has always been fully <a href=\"https://docs.containo.us/operating/acme/\">integrated with Let‚Äôs Encrypt</a>, which has enabled many users to automate certificate generation throughout their cluster.</p><p>But operating a cluster with many applications also means you have to deal with other certificates, whether in-house or bought separately. For such situations, TraefikEE comes with <a href=\"https://docs.containo.us/operating/tls/\">a command line to deploy them dynamically</a>.</p><p>In the following example, we‚Äôre adding a <em>whoami.example.com</em> certificate to the cluster.</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ teectl create tls-cert --cert=mycrt.pem --key=mykey.prem\n$ teectl get tls-cert\nID     CN                  SANs  NOT AFTER             STORE    DEFAULT\nu7vxw  whoami.example.com        2022-01-22T15:27:25Z  default  false\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"cli-2-0\"><strong>CLI 2.0</strong></h3><p>Operating a Traefik cluster means being able to operate, configure, re-configure, stop and start proxies at will, wherever they are hosted in your infrastructure -- and TraefikEE embeds a CLI (<a href=\"https://docs.containo.us/references/cli/teectl/\">teectl</a>) for this purpose.</p><p>We saw the command line growing to become the main user interface for administrators, and decided it was time to tweak its grammar for more consistency.</p><p>Now (like in Kubernetes), you‚Äôll create, get or delete resources to and from your TraefikEE cluster, like in the previous TLS example.</p><h3 id=\"redesigned-web-ui\"><strong>Redesigned Web UI</strong></h3><p>Inspired by Traefik, the Web UI allows users to have an overview of their cluster's health with just a glance.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh5.googleusercontent.com/ZlLHtYOEgYPOVH-y6BNyG71wYM482AD2RgJRDFnjru0g7MhiXk-Kni8J9LnfagtRmpBzWtsQw8ZERXI2RGAmw8X9_Jo3ElU1KazcPXKvBJBaomqJqIsps-EAFfhl9DTkG1xBzaSh\" class=\"kg-image\" alt=\"TraefikEE Dashboard Overview Page\"></figure><p>The welcome page contains all the main information. It's the starting point from which you‚Äôll access all the cluster details.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh5.googleusercontent.com/i_uFx15lA7CuEE9mL4JF0tekprysRoqYjh8sdDIyMg7tgg8qhmXgmVe7ovv90cC3f1G-vcZQ62rESuou6W8LNNuPnJ1WbqiRt857KdDJZGIEppBgON7bliBtrXXgHmRrmoKaJ3nj\" class=\"kg-image\" alt=\"TraefikEE Dashboard HTTP Routers Page\"></figure><h2 id=\"what-s-next\"><strong>What's Next?</strong></h2><p>As you can see, TraefikEE not only adds a clustering system on top of Traefik, but it contains additional features designed for enterprise and a CLI to operate the cluster.</p><p>There are many benefits you can get from switching to TraefikEE, and the best is that you can test it for yourself and <a href=\"https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days\">request a free trial license on our website</a> (and to make it simple, the TraefikEE configuration is fully compatible with your existing Traefik configuration).</p><p>And if you still have questions or need help finding a tailored option for your infrastructure, we‚Äôll be happy to discuss it with you, and to <a href=\"https://info.containo.us/request-demo-traefikee\">help you find the best solution for your use case</a>.</p><p><a href=\"https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days\">Try it today</a>, and be sure that we'll continue to pack TraefikEE with new features driven by companies' needs... to make networking boring!</p>","url":"https://containous.ghost.io/blog/traefik-enterprise-edition-2/","canonical_url":null,"uuid":"a85161ca-fc5a-4734-9739-c0fe0d6a0ded","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e3999aecf5e3c00386bad49","reading_time":4}},{"node":{"id":"Ghost__Post__5e5e2d1c3727400038a2fa13","title":"Announcing Maesh 1.1","slug":"traefik-maesh-1-1","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/Maesh1.1-Blog.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/0e11bb0798830e4ec3b9493c39196ca2/f3583/Maesh1.1-Blog.png","srcSet":"/static/0e11bb0798830e4ec3b9493c39196ca2/630fb/Maesh1.1-Blog.png 300w,\n/static/0e11bb0798830e4ec3b9493c39196ca2/2a4de/Maesh1.1-Blog.png 600w,\n/static/0e11bb0798830e4ec3b9493c39196ca2/f3583/Maesh1.1-Blog.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"A few months have passed since the release of Maesh General Availability. During that time we‚Äôve received feedback from you, the community, about use cases you‚Äôd like to adopt Maesh for, and we‚Äôve addressed them with this release.","custom_excerpt":"A few months have passed since the release of Maesh General Availability. During that time we‚Äôve received feedback from you, the community, about use cases you‚Äôd like to adopt Maesh for, and we‚Äôve addressed them with this release.","visibility":"public","created_at_pretty":"03 March, 2020","published_at_pretty":"March 9, 2020","updated_at_pretty":"22 May, 2020","created_at":"2020-03-03T10:10:36.000+00:00","published_at":"2020-03-09T18:42:45.000+00:00","updated_at":"2020-05-22T00:47:35.000+00:00","meta_title":"Announcing Maesh 1.1. With Helm Version 3 support and more!","meta_description":"Announcing Maesh 1.1. With Helm Version 3 support and more!","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"With Helm Version 3 support and more!\n\nDuring KubeCon North America 2019 in San Diego, we proudly announced the General\nAvailability for Maesh. Since then, roughly three months have passed. During\nthat time we‚Äôve received feedback from you, the community, about use cases you‚Äôd\nlike to adopt Maesh for, and we‚Äôve addressed them with this release.\n\nHelm Version 3 Support\nAs of November 2019, Helm 3 has been released to the public. Maesh's Helm chart\nis now Helm v3 compatible, to benefit from all the changes in the internal\narchitecture of Helm v3. As the internal architecture of Helm 3 changed\nenormously, sadly the change causes breaks, so the current chart is not\ndeployable anymore with Helm 2.\n\nFor more information about Helm 3, please check that link\n[https://helm.sh/blog/helm-3-released/].\n\nApplication Namespace Support\nOne request we received was to install Maesh along with your other services in\nthe same namespace, instead of having Maesh need to run in its own namespace.\nWith that new release, we're now supporting that scenario. You can now easily\ninstall Maesh in the same namespace as your applications which allows for\ngreater flexibility and easier management, especially in multi-tenant Kubernetes\nclusters. However, of course it's also still supported to install it in a\nseparate namespace and share it between all your applications.\n\nPerformance Improvement\nAs our Maesh controllers job is to configure the underlying Traefik pods, it\nneeds to make use of the Kubernetes API to get the current state and create a\nproper configuration. With that release, we reworked the internal architecture\nof the controller to make use of listers instead of plain API queries. As\nlisters are making use of a local cache, this is a huge performance improvement.\nLookups are now made to that cache in milliseconds compared to live HTTP calls,\nthus reducing the load on your Kubernetes API as well.\n\nImproved metrics support\nVersion 1.1 brings support for two new metric backends. Starting now, InfluxDB\n[https://www.influxdata.com/] and StatsD [https://github.com/statsd/statsd] can\nbe configured to receive metrics from Maesh. The possible configuration options\nare best visible in the Helm chart. \nhttps://github.com/containous/maesh/blob/v1.1/helm/chart/maesh/values.yaml\n[https://github.com/dtomcej/maesh/blob/v1.1/helm/chart/maesh/values.yaml]\n\nTraefik Upgrade to 2.1\nLast but not least we also upgraded the underlying Traefik that Maesh uses to\ncreate the service mesh to the current version of 2.1 to stay up to date and\nbenefits from the improvements that is bringing on its own. The full changelog\nfor Traefik 2.1 can be read here \nhttps://containo.us/blog/traefik-2-1-in-the-wild/\n[/blog/traefik-2-1-in-the-wild/]\n\nWhat‚Äôs Next\nOnce again, we are thankful for the multitude of contributors that went straight\nahead and added Maesh to their development clusters. You provided us with\ninvaluable and early feedback and made this release possible.\n\nBut, it‚Äôs just the beginning! Keep telling us what you like, giving us thoughts\nand ideas, and keep (or start) contributing! Pull requests and Issues are the\nbest way to support the product and make it your own.\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">With Helm Version 3 support and more!</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/03/Blog-Post-1.png\" class=\"kg-image\"></figure><p>During KubeCon North America 2019 in San Diego, we proudly announced the General Availability for Maesh. Since then, roughly three months have passed. During that time we‚Äôve received feedback from you, the community, about use cases you‚Äôd like to adopt Maesh for, and we‚Äôve addressed them with this release.</p><h2 id=\"helm-version-3-support\">Helm Version 3 Support</h2><p>As of November 2019, Helm 3 has been released to the public. Maesh's Helm chart is now Helm v3 compatible, to benefit from all the changes in the internal architecture of Helm v3. As the internal architecture of Helm 3 changed enormously, sadly the change causes breaks, so the current chart is not deployable anymore with Helm 2.</p><p>For more information about Helm 3, <a href=\"https://helm.sh/blog/helm-3-released/\">please check that link</a>.</p><h2 id=\"application-namespace-support\">Application Namespace Support</h2><p>One request we received was to install Maesh along with your other services in the same namespace, instead of having Maesh need to run in its own namespace. With that new release, we're now supporting that scenario. You can now easily install Maesh in the same namespace as your applications which allows for greater flexibility and easier management, especially in multi-tenant Kubernetes clusters. However, of course it's also still supported to install it in a separate namespace and share it between all your applications.</p><h2 id=\"performance-improvement\">Performance Improvement</h2><p>As our Maesh controllers job is to configure the underlying Traefik pods, it needs to make use of the Kubernetes API to get the current state and create a proper configuration. With that release, we reworked the internal architecture of the controller to make use of listers instead of plain API queries. As listers are making use of a local cache, this is a huge performance improvement. Lookups are now made to that cache in milliseconds compared to live HTTP calls, thus reducing the load on your Kubernetes API as well.</p><h2 id=\"improved-metrics-support\">Improved metrics support</h2><p>Version 1.1 brings support for two new metric backends. Starting now,<a href=\"https://www.influxdata.com/\"> InfluxDB</a> and<a href=\"https://github.com/statsd/statsd\"> StatsD</a> can be configured to receive metrics from Maesh. The possible configuration options are best visible in the Helm chart.<a href=\"https://github.com/dtomcej/maesh/blob/v1.1/helm/chart/maesh/values.yaml\"> https://github.com/containous/maesh/blob/v1.1/helm/chart/maesh/values.yaml</a></p><h2 id=\"traefik-upgrade-to-2-1\">Traefik Upgrade to 2.1</h2><p>Last but not least we also upgraded the underlying Traefik that Maesh uses to create the service mesh to the current version of 2.1 to stay up to date and benefits from the improvements that is bringing on its own. The full changelog for Traefik 2.1 can be read here<a href=\"https://containous.ghost.io/blog/traefik-2-1-in-the-wild/\"> https://containo.us/blog/traefik-2-1-in-the-wild/</a></p><h2 id=\"what-s-next\">What‚Äôs Next</h2><p>Once again, we are thankful for the multitude of contributors that went straight ahead and added Maesh to their development clusters. You provided us with invaluable and early feedback and made this release possible.</p><p>But, it‚Äôs just the beginning! Keep telling us what you like, giving us thoughts and ideas, and keep (or start) contributing! Pull requests and Issues are the best way to support the product and make it your own.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\">Community Forum</a></li></ul>","url":"https://containous.ghost.io/blog/traefik-maesh-1-1/","canonical_url":null,"uuid":"89f93dd3-b298-4e9b-8d8b-0a855eac69bb","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e5e2d1c3727400038a2fa13","reading_time":2}},{"node":{"id":"Ghost__Post__5e70260319908e0038512ce1","title":"Leading travel platform simplifies network management by deploying Traefik as preferred reverse proxy","slug":"leading-travel-platform-simplifies-network-management-by-deploying-traefik-as-preferred-reverse-proxy","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/LeadingTravelPlatformCaseStudy-Blog.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/64ef30f3fcc8e53d0d327951d52c5241/f3583/LeadingTravelPlatformCaseStudy-Blog.png","srcSet":"/static/64ef30f3fcc8e53d0d327951d52c5241/630fb/LeadingTravelPlatformCaseStudy-Blog.png 300w,\n/static/64ef30f3fcc8e53d0d327951d52c5241/2a4de/LeadingTravelPlatformCaseStudy-Blog.png 600w,\n/static/64ef30f3fcc8e53d0d327951d52c5241/f3583/LeadingTravelPlatformCaseStudy-Blog.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Covering all aspects of traveling, hotels, flights, car rental, and vacation homes, this world leading travel company‚Äôs platform is managed by an infrastructure team that counts over one thousand engineers. ","custom_excerpt":"Covering all aspects of traveling, hotels, flights, car rental, and vacation homes, this world leading travel company‚Äôs platform is managed by an infrastructure team that counts over one thousand engineers. ","visibility":"public","created_at_pretty":"17 March, 2020","published_at_pretty":"March 18, 2020","updated_at_pretty":"27 July, 2020","created_at":"2020-03-17T01:21:07.000+00:00","published_at":"2020-03-18T14:49:14.000+00:00","updated_at":"2020-07-27T23:42:19.000+00:00","meta_title":"Leading travel platform eases network management with Traefik","meta_description":"The team needed a single reverse proxy solution to standardize and consolidate the existing disparate solutions and simplify new deployments.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/03/Twitter-Leading-travel-platform-simplifies-network-management-by-deploying-Traefik-as-preferred-reverse-proxy.png","twitter_title":null,"authors":[{"name":"Marie Ponseel","slug":"marie","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/profile-picture.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Marie Ponseel","slug":"marie","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/profile-picture.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Case Studies","slug":"case-studies","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":"Learn from our users and customers why they choose Traefik and TraefikEE as a modern load balancer to manage network traffic.","meta_title":"Case studies | Containous","visibility":"public"}],"plaintext":"Overview\nCovering all aspects of traveling, hotels, flights, car rental, and vacation\nhomes, this world leading travel company‚Äôs platform is managed by an\ninfrastructure team that counts over one thousand engineers. This infrastructure\nengineering team supports an expansive brand portfolio, ensuring transactions\nare always up and running smoothly, a monumental task given the sheer scale of\ntheir business. Given the diversity of applications across their brands, the\ngroup delicately supports a wide range of networking solutions and programming\nlanguages throughout the organization.\n\nChallenge \nLike many other large companies, this leading travel company‚Äôs broad range of\napplications had requirements for specific tools and platforms, such as various\ncontainerization solutions. As a result, the team managed a multitude of\ncontainer platforms, each having a unique networking configuration and runtime\nto operate. This made management of these environments very difficult and time\nconsuming because each network change needed to be applied one-by-one for each\nand every environment (i.e. Amazon ECS and Kubernetes, Mesos and Marathon, etc). \n\n\nThe team set out to find a proxy solution flexible enough to work across\nmultiple platforms such as Consul, Mesos, and Kubernetes, while integrating\nnatively with each platform‚Äôs unique discovery mechanisms and information\nmodels. What they needed was a single reverse proxy solution to standardize and\nconsolidate the existing disparate solutions to reduce operational overhead, s\nimplify new deployments, and minimize human errors during configuration changes.\nGiven the company‚Äôs size, the ‚Äúperfect‚Äù solution would need to meet specific\nrequirements around massive scalability, ease and speed of deployment, and\nfunction efficiently in highly-dynamic containerized environments.\n\n\nSolution\nThe leading travel company‚Äôs infrastructure team stumbled onto Traefik while\nevaluating and testing different solutions in the networking landscape of the\ncontainerized world. \n\n\nTraefik offers the ability for engineering teams to plug in multiple data\nsources, such as Mesos, Marathon, Consul, etc, all with the use of a single\ntool. Traefik‚Äôs wide array of pluggable providers connects to any compatible\ndata source, presenting a unified and consistent platform for traffic routing.\nThis feature appealed greatly to the engineering team and encouraged a closer\nlook.\n\n\nTraefik is a lean implementation, written in Go, and a single binary which makes\nit easy to deploy. Traefik offers extensive configuration options, suitable for\nany application scenario and scale. With advanced routing capabilities, Traefik\nwas one of the only solutions capable of easily configuring multiple advanced\nroutes per service and running custom configuration templates. Ultimately, the\nengineering team chose Traefik for its simplicity and ease of maintenance and\nconfiguration.\n\n\nBy standardizing on Traefik as their reverse proxy of choice across all\nenvironments, the engineering team saved countless hours by simplifying network\noperation management.\n\n\nThe company is also committed to the values of open source, supporting and\nencouraging open source throughout the organization. As an open source project,\nTraefik bolsters their commitment to consume and contribute to open source\nsoftware as part of the greater community. They found engagement with the\nTraefik developer community to be responsive, receptive and collaborative,\nsomething important to them as well.\n\n\nBottom Line\nThis leading travel company‚Äôs selection of Traefik as their preferred reverse\nproxy solution, enables them to achieve increased delivery speed at scale, even\nin the rapidly and ever-evolving container ecosystem.\n\n\nIn spite of their vigorous requirements tested throughout the evaluation\nprocess, Traefik easily passed with flying colors, proving its ability to handle\nthe most demanding workloads in high traffic environments. The team is\nexperiencing greater simplicity managing large scale containerized\ninfrastructure while enhancing ease of maintenance by delivering features\ncritical to this unique environment.\n\n\nThe engineering team happily recommends Traefik to other organizations facing\nthe same challenges.\n\n\n> ‚ÄúTraefik pretty much supports itself. There isn‚Äôt much support that we require\nfrom outside. Things just work. I absolutely recommend Traefik.‚Äù\n\nWhat‚Äôs Next?\n * Get started with Traefik [/traefik/] today\n * Ready for production deployments? Discover Traefik Enterprise Edition\n   [/traefikee/], and request your demo\n   [https://info.containo.us/request-demo-traefikee]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/03/Leading-Travel-Platform-Simplifies-Network-Management-by-Deploying-Traefik-as-Preferred-Reverse-Proxy.png\" class=\"kg-image\"></figure><h2 id=\"overview\">Overview</h2><p>Covering all aspects of traveling, hotels, flights, car rental, and vacation homes, this world leading travel company‚Äôs platform is managed by an infrastructure team that counts over one thousand engineers. This infrastructure engineering team supports an expansive brand portfolio, ensuring transactions are always up and running smoothly, a monumental task given the sheer scale of their business. Given the diversity of applications across their brands, the group delicately supports a wide range of networking solutions and programming languages throughout the organization.</p><h2 id=\"challenge\">Challenge </h2><p>Like many other large companies, this leading travel company‚Äôs broad range of applications had requirements for specific tools and platforms, such as various containerization solutions. As a result, the team managed a multitude of container platforms, each having a unique networking configuration and runtime to operate. This made management of these environments very difficult and time consuming because each network change needed to be applied one-by-one for each and every environment (i.e. Amazon ECS and Kubernetes, Mesos and Marathon, etc). <br></p><p>The team set out to find a proxy solution flexible enough to work across multiple platforms such as Consul, Mesos, and Kubernetes, while integrating natively with each platform‚Äôs unique discovery mechanisms and information models. What they needed was a single reverse proxy solution to standardize and consolidate the existing disparate solutions to reduce operational overhead<em>, s</em>implify new deployments, and minimize human errors during configuration changes. Given the company‚Äôs size, the ‚Äúperfect‚Äù solution would need to meet specific requirements around massive scalability, ease and speed of deployment, and function efficiently in highly-dynamic containerized environments.<br></p><h2 id=\"solution\">Solution</h2><p>The leading travel company‚Äôs infrastructure team stumbled onto Traefik while evaluating and testing different solutions in the networking landscape of the containerized world. <br></p><p>Traefik offers the ability for engineering teams to plug in multiple data sources, such as Mesos, Marathon, Consul, etc, all with the use of a single tool. Traefik‚Äôs wide array of pluggable providers connects to any compatible data source, presenting a unified and consistent platform for traffic routing. This feature appealed greatly to the engineering team and encouraged a closer look.<br></p><p>Traefik is a lean implementation, written in Go, and a single binary which makes it easy to deploy. Traefik offers extensive configuration options, suitable for any application scenario and scale. With advanced routing capabilities, Traefik was one of the only solutions capable of easily configuring multiple advanced routes per service and running custom configuration templates. Ultimately, the engineering team chose Traefik for its simplicity and ease of maintenance and configuration.<br></p><p>By standardizing on Traefik as their reverse proxy of choice across all environments, the engineering team saved countless hours by simplifying network operation management.<br></p><p>The company is also committed to the values of open source, supporting and encouraging open source throughout the organization. As an open source project, Traefik bolsters their commitment to consume and contribute to open source software as part of the greater community. They found engagement with the Traefik developer community to be responsive, receptive and collaborative, something important to them as well.<br></p><h2 id=\"bottom-line\">Bottom Line</h2><p>This leading travel company‚Äôs selection of Traefik as their preferred reverse proxy solution, enables them to achieve increased delivery speed at scale, even in the rapidly and ever-evolving container ecosystem.<br></p><p>In spite of their vigorous requirements tested throughout the evaluation process, Traefik easily passed with flying colors, proving its ability to handle the most demanding workloads in high traffic environments. The team is experiencing greater simplicity managing large scale containerized infrastructure while enhancing ease of maintenance by delivering features critical to this unique environment.<br></p><p>The engineering team happily recommends Traefik to other organizations facing the same challenges.<br></p><blockquote><em>‚ÄúTraefik pretty much supports itself. There isn‚Äôt much support that we require from outside. Things just work. I absolutely recommend Traefik.‚Äù</em></blockquote><h2 id=\"what-s-next\"><br>What‚Äôs Next?</h2><ul><li>Get started with <a href=\"https://containous.ghost.io/traefik/\" rel=\"noopener nofollow\">Traefik</a> today</li><li>Ready for production deployments? <a href=\"https://containous.ghost.io/traefikee/\">Discover Traefik Enterprise Edition</a>, and <a href=\"https://info.containo.us/request-demo-traefikee\" rel=\"noopener nofollow\">request your demo</a></li></ul>","url":"https://containous.ghost.io/blog/leading-travel-platform-simplifies-network-management-by-deploying-traefik-as-preferred-reverse-proxy/","canonical_url":null,"uuid":"45763dd7-bd70-4ddd-88cb-c7e371776dd1","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e70260319908e0038512ce1","reading_time":3}},{"node":{"id":"Ghost__Post__5e5cd2ba3727400038a2f958","title":"Announcing Traefik 2.2","slug":"traefik-2-2-ingress","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/Traefik2.2Blog.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/45b5b2113a5d238563769f59eb3b6ce2/f3583/Traefik2.2Blog.png","srcSet":"/static/45b5b2113a5d238563769f59eb3b6ce2/630fb/Traefik2.2Blog.png 300w,\n/static/45b5b2113a5d238563769f59eb3b6ce2/2a4de/Traefik2.2Blog.png 600w,\n/static/45b5b2113a5d238563769f59eb3b6ce2/f3583/Traefik2.2Blog.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik 2.1 adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik since the beginning and is utterly important for us, but also for you, our users. ","custom_excerpt":"Traefik 2.1 adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik since the beginning and is utterly important for us, but also for you, our users. ","visibility":"public","created_at_pretty":"02 March, 2020","published_at_pretty":"March 26, 2020","updated_at_pretty":"28 April, 2020","created_at":"2020-03-02T09:32:42.000+00:00","published_at":"2020-03-26T12:58:01.000+00:00","updated_at":"2020-04-28T13:02:41.000+00:00","meta_title":"Announcing Traefik 2.2 - With Enhanced Ingress support and more!","meta_description":"Traefik 2.1 adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/03/Traefik2.2-Twitter.png","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#community-related-resource","slug":"hash-community-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"},{"name":"#traefik-related-resource","slug":"hash-traefik-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"With Enhanced Ingress support and more!\n\nAfter releasing 2.1 in December, we are excited to announce a new release. This\none adds couple of long awaited features, but also brings simplicity in certain\nareas. Simplicity has always been a key feature of Traefik since the beginning\nand is utterly important for us, but also for you, our users. Our goal is to\nkeep constantly improving the user experience by making the handling of Traefik\neven more easy, that you can focus on your real issues. \n\nEnhanced Ingress Support\nAs announced with the 2.1 release, this release is focusing on user experience.\nFor that reason, we brought back extended Ingress Support. Prior to Traefik\nv2.2, plain Kubernetes Ingress Objects were only supported without annotations.\nAs our community told us, they have a valuable use-case where they want to run\nTraefik as a simple Ingress Controller, and don't want to fully commit to the\nIngressRoute in order to stay better included with the Kubernetes ecosystem. For\nthat reason, we‚Äôre supporting Ingress Objects with a sub-set of annotations\nagain.\n\nkind: Ingress\napiVersion: networking.k8s.io/v1beta1\nmetadata:\n  name: foo\n  namespace: bar\n  annotations:\n    traefik.ingress.kubernetes.io/router.entrypoints: web, websecure\n    traefik.ingress.kubernetes.io/router.middlewares: redirect-http@kuberntes-crd\n    external-dns.alpha.kubernetes.io/hostname: *.mycompany.org\nspec:\n  rules:\n  - host: foo.com\n    http:\n      paths:\n      - path: /bar\n        backend:\n          serviceName: service1\n          servicePort: 80\n\nAdditionally, not all the behavior we want to be configurable for our users fit\ninto the idea of an Ingress, therefore we're also supporting a subset of\nannotations on Service Objects to fill the gap.\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: service1\n  namespace: bar\n  annotations: traefik.ingress.kubernetes.io/service.sticky: \"true\"\nspec:\n  type: ClusterIP\n  ports:\n  - port: 80\n    name: http\n\nA list of all annotations (Ingress and Service) can be found here \nhttps://docs.traefik.io/master/routing/providers/kubernetes-ingress/\n\nEntrypoint Redirection And Default Router Configuration\nTraefik 2.x is really powerful, given the reworked architecture allowing us to\noperate from Layer 4 and above. Additionally, the new concept of routers,\nmiddlewares and services allows for more flexibility. As a result, you told us\nthat the configuration ended up being a bit too verbose, and that you're missing\nsome sort of redirects on Entrypoints, as we had something similar with Traefik\n1.x.\n\nFor that reason, we introduced the concepts of Entrypoint redirects, and default\nrouter configuration.\n\nWith that release, it's possible to configure redirects bound to an Entrypoint\nthrough the static configuration. Additionally, you can also set defaults for\nthe other areas a router can handle.\n\nhttp:\n    redirections:\n        entryPoint:\n          to: foobar\n          scheme: foobar\n    middlewares:\n      - foobar\n      - foobar\n    tls:\n      options: foobar\n      certResolver: foobar\n      domains:\n        - main: foobar\n          sans:\n          - foobar\n          - foobar\n        - main: foobar\n          sans:\n          - foobar\n          - foobar\n\nTraefik will then create a default router, which will handle the configured\nredirects for you. For everything starting with middlewares, the default values\nwill be copied automatically to all the routers you create.\n\nKey Value Stores\nAnother long awaited feature have been the addition of Key Value Stores as a\ndynamic configuration provider in Traefik v2.Not only have former stores are\nre-added again (such as e.g. etcd or Consul), but new ones such as Redis have\nbeen added providing more supported platforms.\n\nUDP\nSupport for TCP is one of the major changes from Traefik Version to Version 2.\nNow, with the new release we're also adding support for UDP! The only\nrequirement is enabling an Entrypoint to be UDP based and that‚Äôs it.\n\n[entryPoints]\n  [entryPoints.udp]\n    address = \":8093/udp\"\n  [entryPoints.http]\n    address = \":8093\" # same as \":8093/tcp\"\n\nFor now, we don't have any routing rules, as TLS is not supported currently (so\nthere is no HostSNI), and there is no PathPrefix notion since there are no\nrequests at the transport layer level. However, that‚Äôs not preventing you from\nload balancing your UDP services. That only means that you need to have one\ndedicated Entrypoint per UDP service you want to load balance.\n\nElastic APM Tracer\nElastic APM is a well known solution in the ecosystem. It's the APM solution\nprovided by Elastic [https://www.elastic.co/de/apm]. Starting now, it's a\nsupported Tracing backend for Traefik as well thanks to a community\ncontribution. Just configure it, and you'll have your traces transferred to that\nsystem. \n\nWeb UI Enhancement\nLast but not least, there have been a couple of modifications to the Web UI. Now\nnot only will you be able to see your UDP services, but we‚Äôve had a great\ncommunity contribution to add a dark theme also!\n\nWhat's next?\nAs we said with the previous release, focusing on improving the user experience\nis our goal. Implementing advanced Ingress support on Kubernetes and providing a\nway to configure defaults on an Entrypoint was one of our first steps. However,\nthere are still things to be done which will be part of the upcoming release(s).\nNot only on improving the user experience but also on providing additional\nfeatures. For that please keep raising your voice in the issue tracker\n[https://github.com/containous/traefik/issues], on the community forum\n[https://community.containo.us/], or better‚Äîpull request\n[https://github.com/containous/traefik/pulls] your way into making Traefik a\nbetter tool for everyone.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">With Enhanced Ingress support and more!</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/03/Traefik2.2-blog.png\" class=\"kg-image\"></figure><p>After releasing 2.1 in December, we are excited to announce a new release. This one adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik since the beginning and is utterly important for us, but also for you, our users. Our goal is to keep constantly improving the user experience by making the handling of Traefik even more easy, that you can focus on your real issues. </p><h3 id=\"enhanced-ingress-support\">Enhanced Ingress Support</h3><p>As announced with the 2.1 release, this release is focusing on user experience. For that reason, we brought back extended Ingress Support. Prior to Traefik v2.2, plain Kubernetes Ingress Objects were only supported without annotations. As our community told us, they have a valuable use-case where they want to run Traefik as a simple Ingress Controller, and don't want to fully commit to the IngressRoute in order to stay better included with the Kubernetes ecosystem. For that reason, we‚Äôre supporting Ingress Objects with a sub-set of annotations again.</p><pre><code class=\"language-yaml\">kind: Ingress\napiVersion: networking.k8s.io/v1beta1\nmetadata:\n  name: foo\n  namespace: bar\n  annotations:\n    traefik.ingress.kubernetes.io/router.entrypoints: web, websecure\n    traefik.ingress.kubernetes.io/router.middlewares: redirect-http@kuberntes-crd\n    external-dns.alpha.kubernetes.io/hostname: *.mycompany.org\nspec:\n  rules:\n  - host: foo.com\n    http:\n      paths:\n      - path: /bar\n        backend:\n          serviceName: service1\n          servicePort: 80</code></pre><p>Additionally, not all the behavior we want to be configurable for our users fit into the idea of an Ingress, therefore we're also supporting a subset of annotations on Service Objects to fill the gap.</p><pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: service1\n  namespace: bar\n  annotations: traefik.ingress.kubernetes.io/service.sticky: \"true\"\nspec:\n  type: ClusterIP\n  ports:\n  - port: 80\n    name: http</code></pre><p>A list of all annotations (Ingress and Service) can be found here <a href=\"https://docs.traefik.io/master/routing/providers/kubernetes-ingress/\">https://docs.traefik.io/master/routing/providers/kubernetes-ingress/</a></p><h2 id=\"entrypoint-redirection-and-default-router-configuration\">Entrypoint Redirection And Default Router Configuration</h2><p>Traefik 2.x is really powerful, given the reworked architecture allowing us to operate from Layer 4 and above. Additionally, the new concept of routers, middlewares and services allows for more flexibility. As a result, you told us that the configuration ended up being a bit too verbose, and that you're missing some sort of redirects on Entrypoints, as we had something similar with Traefik 1.x.</p><p>For that reason, we introduced the concepts of Entrypoint redirects, and default router configuration.</p><p>With that release, it's possible to configure redirects bound to an Entrypoint through the static configuration. Additionally, you can also set defaults for the other areas a router can handle.</p><pre><code class=\"language-yaml\">http:\n    redirections:\n        entryPoint:\n          to: foobar\n          scheme: foobar\n    middlewares:\n      - foobar\n      - foobar\n    tls:\n      options: foobar\n      certResolver: foobar\n      domains:\n        - main: foobar\n          sans:\n          - foobar\n          - foobar\n        - main: foobar\n          sans:\n          - foobar\n          - foobar</code></pre><p>Traefik will then create a default router, which will handle the configured redirects for you. For everything starting with <strong>middlewares</strong>, the default values will be copied automatically to all the routers you create.</p><h2 id=\"key-value-stores\">Key Value Stores</h2><p>Another long awaited feature have been the addition of Key Value Stores as a dynamic configuration provider in Traefik v2.Not only have former stores are re-added again (such as e.g. etcd or Consul), but new ones such as Redis have been added providing more supported platforms.</p><h2 id=\"udp\">UDP</h2><p>Support for TCP is one of the major changes from Traefik Version to Version 2. Now, with the new release we're also adding support for UDP! The only requirement is enabling an Entrypoint to be UDP based and that‚Äôs it.</p><pre><code class=\"language-yaml\">[entryPoints]\n  [entryPoints.udp]\n    address = \":8093/udp\"\n  [entryPoints.http]\n    address = \":8093\" # same as \":8093/tcp\"</code></pre><p>For now, we don't have any routing rules, as TLS is not supported currently (so there is no HostSNI), and there is no PathPrefix notion since there are no requests at the transport layer level. However, that‚Äôs not preventing you from load balancing your UDP services. That only means that you need to have one dedicated Entrypoint per UDP service you want to load balance.</p><h2 id=\"elastic-apm-tracer\">Elastic APM Tracer</h2><p>Elastic APM is a well known solution in the ecosystem. It's the <a href=\"https://www.elastic.co/de/apm\">APM solution provided by Elastic</a>. Starting now, it's a supported Tracing backend for Traefik as well thanks to a community contribution. Just configure it, and you'll have your traces transferred to that system. </p><h2 id=\"web-ui-enhancement\">Web UI Enhancement</h2><p>Last but not least, there have been a couple of modifications to the Web UI. Now not only will you be able to see your UDP services, but we‚Äôve had a great community contribution to add a dark theme also!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/03/image.png\" class=\"kg-image\"></figure><h2 id=\"what-s-next\">What's next?</h2><p>As we said with the previous release, focusing on improving the user experience is our goal. Implementing advanced Ingress support on Kubernetes and providing a way to configure defaults on an Entrypoint was one of our first steps. However, there are still things to be done which will be part of the upcoming release(s). Not only on improving the user experience but also on providing additional features. For that please keep raising your voice in the <a href=\"https://github.com/containous/traefik/issues\">issue tracker</a>, on the <a href=\"https://community.containo.us/\">community forum</a>, or better‚Äî<a href=\"https://github.com/containous/traefik/pulls\">pull request</a> your way into making Traefik a better tool for everyone.</p>","url":"https://containous.ghost.io/blog/traefik-2-2-ingress/","canonical_url":null,"uuid":"d7ee17a1-2b6a-4486-8694-3db02c494b5e","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e5cd2ba3727400038a2f958","reading_time":4}},{"node":{"id":"Ghost__Post__5e950d861afff4004456e057","title":"Traefik Enterprise Edition 2.1 Now Available","slug":"traefik-enterprise-edition-2-1-now-available","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/TraefikEE2.1-Blog.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/f4934efe26cd689a1362814ac4ff60b9/f3583/TraefikEE2.1-Blog.png","srcSet":"/static/f4934efe26cd689a1362814ac4ff60b9/630fb/TraefikEE2.1-Blog.png 300w,\n/static/f4934efe26cd689a1362814ac4ff60b9/2a4de/TraefikEE2.1-Blog.png 600w,\n/static/f4934efe26cd689a1362814ac4ff60b9/f3583/TraefikEE2.1-Blog.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"This release adds crucial new capabilities designed to tame the complexity of managing internal connections, especially with enhanced security options.","custom_excerpt":"This release adds crucial new capabilities designed to tame the complexity of managing internal connections, especially with enhanced security options.","visibility":"public","created_at_pretty":"14 April, 2020","published_at_pretty":"April 14, 2020","updated_at_pretty":"21 May, 2020","created_at":"2020-04-14T01:10:30.000+00:00","published_at":"2020-04-14T16:09:23.000+00:00","updated_at":"2020-05-21T18:47:59.000+00:00","meta_title":"Traefik Enterprise 2.1 - New authentication for API gateways","meta_description":"This release adds crucial new capabilities designed to tame the complexity of managing internal connections, especially with enhanced security options.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/04/TraefikEE2.1-Twitter.png","twitter_title":null,"authors":[{"name":"Nicolas Mengin","slug":"nicolas","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/02/wam.jpeg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Nicolas Mengin","slug":"nicolas","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/02/wam.jpeg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"New authentication features for API gateways and more\n\nAfter one year of existence, TraefikEE has grown up to add much more value on\ntop of Traefik open source.\n\nWhile Traefik open source is laser-focused on being a world-class reverse proxy\noptimized to manage external incoming connections, this release adds crucial new\ncapabilities designed to tame the complexity of managing internal connections,\nespecially with enhanced security options.\n\nTraefikEE 2.1 now provides support for three new authentication protocols: JWT,\nHMAC, and OAuth2 Token Introspection, that can be used to easily secure both\nexternal and internal traffic.\n\nAlso included in this release: enhanced cluster management, Traefik 2.2 support,\nand RedHat OpenShift certification.\n\nThree flavors of Authentication\nDeploying a microservice architecture requires managing an infrastructure with\nmany APIs. These APIs are reached by both external and internal systems, and the\nnecessity to secure access to all your APIs takes on fundamental importance.\n\nTraefikEE has acknowledged this need, firstly by adding the LDAP Middleware, and\nnow by adding JWT, HMAC and oAuth2 Token Introspection.\n\nNo matter what your security needs are, TraefikEE has a middleware that can\nhelp!\n\nFirst flavor: JWT\nJWT is a very popular technology to quickly secure your infrastructure, and\nTraefikEE now embeds a dedicated middleware\n[https://docs.containo.us/middlewares/jwt/] to complement your microservice\narchitecture. All it takes is one extra line of configuration!\n\n  services:\n    whoami:\n      image: containous/whoami\n      labels:\n        # ‚Ä¶ routing labels...\n        - \"traefik.http.middlewares.test-jwtAuth.plugin.jwtAuth.source=my-jwt-src\" # Authentication Source declared in another place.\n\n\nAnd for the icing on the cake, the JWT middleware behavior can be extended to\nallow operations such as authorization (using claims), and header forwarding.\n\n  services:\n    whoami:\n      image: containous/whoami\n      labels:\n        # ‚Ä¶ routing labels...\n        - \"traefik.http.middlewares.test-jwtAuth.plugin.jwtAuth.source=my-jwt-src\" # Authentication Source declared in another place.\n        - \"traefik.http.middlewares.test-jwtAuth.plugin.jwtAuth.claims=Equals(`team`, `admin`) || Equals(`team`, `dev`)\" # Only users from admin and dev teams can reach your services.\n\n\nSecond flavor: OAuth2 Token Introspection\nNow, if you've already deployed an OAuth2 server with a token introspection\nendpoint, you probably want to leverage it to secure your services.\n\nGood news then, TraefikEE can connect to it\n[https://docs.containo.us/middlewares/oauth-intro/`]and add an authorization\nlayer directly in your routing configuration. Securing a service has never been\nso easy!\n\n# Static Configuration\n  authSources:\n    oait-src:\n      oAuthIntrospection:\n        url: http://myoauth2server # OAuth2 server endpoint\n        authorizationHeader: Basic XXxxxx # Type of authentication\n\n\nversion: '3.4'\n  services:\n    whoami:\n      image: containous/whoami\n      deploy:\n        labels:\n          # Dynamic Configuration\n          # ‚Ä¶ routing labels...\n          - \"traefik.http.middlewares.test-oauth-intro.plugin.oAuthIntrospection.source=oait-src‚Äù\n          - \"traefik.http.middlewares.test-oauth-intro.plugin.oAuthIntrospection.claims= Equals(`team`, `admin`) || Equals(`team`, `dev`)\" # Only users from admin and dev teams can reach your services.\n\n\nThird flavor: HMAC\nWant to prevent your system from attacks such as man-in-middle, XSS injection,\netc.?\n\nYou can enforce your infrastructure security by checking both the integrity and\nthe sender's identity of the incoming requests with the new HMAC middleware\n[https://docs.containo.us/middlewares/hmac/].\n\n# Static Configuration\nauthSources:\n  my-hmac-src:\n    hmac:\n      inline: # Declare here the authorized id/keys\n        - id: \"secret-key\"\n          key: \"traefikee-approved\"\n\n\nversion: '3.4'\n  services:\n    whoami:\n      image: containous/whoami\n      deploy:\n        labels:\n          # Dynamic Configuration\n          # ‚Ä¶ routing labels...\n          - \"traefik.http.middlewares.test-hmac-auth.plugin.hmacauth.source=my-hmac-src\"\n\n\nRoot-LESS Image, Secured-MORE Infrastructure\nTraefikEE has always been focused on infrastructure security.\n\nWe‚Äôve used a gRPC MTLS communication between the nodes and we‚Äôve split the\nresponsibilities between controllers and proxies to secure both internal and\noutgoing cluster connections.\n\nIn TraefikEE v2.1, we‚Äôve added a rootless image to secure your infrastructure\nagainst potential vulnerabilities in the Docker daemon, and the container\nruntime.\n\nTake advantage of this feature by following the comprehensive guide in the\ndocumentation [https://docs.containo.us/operating/rootless-image/].\n\nEnhanced Cluster Management\nMany users reported to us that they‚Äôve had to maintain TraefiKEE clusters\ninstalled on both their Q&A and Production infrastructures, and they‚Äôd like to\navoid specifying the cluster name on each command they launched.\n\nIn order to help them, and to improve the user experience, we‚Äôve introduced a\nfew commands into the CLI (teectl) to help manage multiple clusters\n[https://docs.containo.us/operating/teectl-cluster-mgt/], and especially, to\ncustomize the active cluster. Thus, users can set a cluster as the active one\nand not provide its name in each command.\n\nRed Hat OpenShift Operator Certified\nLike Traefik, TraefikEE eases your Ingress Controller integration regardless of\nyour infrastructure, including Red Hat OpenShift clusters!\n\nStarting with TraefikEE v2.0, we introduced a Kubernetes Operator to install\nTraefikEE into OpenShift v4 clusters.\n\nToday, we are proud to announce that TraefikEE v2.1 is Red Hat OpenShift\nOperator certified. With this certification, TraefikEE joins the Red Hat\nsoftware certified partner ecosystem and is readily available through the Red\nHat OpenShift Container Platform\n[https://www.openshift.com/products/container-platform].\n\nThe TraefikEE Operator is now available in the Red Hat Container Catalog\n[https://catalog.redhat.com/software/containers/explore]. Via OperatorHub\n[https://operatorhub.io/operator/traefikee-operator], you can install and update\nTraefikEE quickly and seamlessly into any OpenShift cluster.\n\nWhat's Next?\nTraefikEE continues to bring more enterprise specific features. High\nAvailability, distributed services, and enterprise authentication protocols are\njust a few of the benefits you can get from switching to TraefikEE.\n\nTake a look at all these features in our 5-minute video\n[https://info.containo.us/request-demo-traefikee] to learn more about them.\n\nAs always, we are happy to answer your questions, and help you find the best\nsolution for your projects [https://info.containo.us/request-demo-traefikee].\n\nIf you want to test drive our new features, give Traefik Enterprise Edition 2.1\na try today\n[https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days].","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">New authentication features for API gateways and more</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/04/TraefikEE2.1-Blog-1.png\" class=\"kg-image\"></figure><p>After one year of existence, TraefikEE has grown up to add much more value on top of Traefik open source.</p><p>While Traefik open source is laser-focused on being a world-class reverse proxy optimized to manage external incoming connections, this release adds crucial new capabilities designed to tame the complexity of managing internal connections, especially with enhanced security options.</p><p>TraefikEE 2.1 now provides support for three new authentication protocols: JWT, HMAC, and OAuth2 Token Introspection, that can be used to easily secure both external and internal traffic.</p><p>Also included in this release: enhanced cluster management, Traefik 2.2 support, and RedHat OpenShift certification.</p><h2 id=\"three-flavors-of-authentication\">Three flavors of Authentication</h2><p>Deploying a microservice architecture requires managing an infrastructure with many APIs. These APIs are reached by both external and internal systems, and the necessity to secure access to all your APIs takes on fundamental importance.</p><p>TraefikEE has acknowledged this need, firstly by adding the LDAP Middleware, and now by adding JWT, HMAC and oAuth2 Token Introspection.</p><p>No matter what your security needs are, TraefikEE has a middleware that can help!</p><h4 id=\"first-flavor-jwt\">First flavor: JWT</h4><p>JWT is a very popular technology to quickly secure your infrastructure, and TraefikEE now embeds <a href=\"https://docs.containo.us/middlewares/jwt/\">a dedicated middleware</a> to complement your microservice architecture. All it takes is one extra line of configuration!</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">  services:\n    whoami:\n      image: containous/whoami\n      labels:\n        # ‚Ä¶ routing labels...\n        - &quot;traefik.http.middlewares.test-jwtAuth.plugin.jwtAuth.source=my-jwt-src&quot; # Authentication Source declared in another place.\n</code></pre>\n<!--kg-card-end: markdown--><p>And for the icing on the cake, the JWT middleware behavior can be extended to allow operations such as authorization (using claims), and header forwarding.</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">  services:\n    whoami:\n      image: containous/whoami\n      labels:\n        # ‚Ä¶ routing labels...\n        - &quot;traefik.http.middlewares.test-jwtAuth.plugin.jwtAuth.source=my-jwt-src&quot; # Authentication Source declared in another place.\n        - &quot;traefik.http.middlewares.test-jwtAuth.plugin.jwtAuth.claims=Equals(`team`, `admin`) || Equals(`team`, `dev`)&quot; # Only users from admin and dev teams can reach your services.\n</code></pre>\n<!--kg-card-end: markdown--><h4 id=\"second-flavor-oauth2-token-introspection\">Second flavor: OAuth2 Token Introspection</h4><p>Now, if you've already deployed an OAuth2 server with a token introspection endpoint, you probably want to leverage it to secure your services.</p><p>Good news then,<a href=\"https://docs.containo.us/middlewares/oauth-intro/`\"> TraefikEE can connect to it </a>and add an authorization layer directly in your routing configuration. Securing a service has never been so easy!</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\"># Static Configuration\n  authSources:\n    oait-src:\n      oAuthIntrospection:\n        url: http://myoauth2server # OAuth2 server endpoint\n        authorizationHeader: Basic XXxxxx # Type of authentication\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">version: '3.4'\n  services:\n    whoami:\n      image: containous/whoami\n      deploy:\n        labels:\n          # Dynamic Configuration\n          # ‚Ä¶ routing labels...\n          - &quot;traefik.http.middlewares.test-oauth-intro.plugin.oAuthIntrospection.source=oait-src‚Äù\n          - &quot;traefik.http.middlewares.test-oauth-intro.plugin.oAuthIntrospection.claims= Equals(`team`, `admin`) || Equals(`team`, `dev`)&quot; # Only users from admin and dev teams can reach your services.\n</code></pre>\n<!--kg-card-end: markdown--><h4 id=\"third-flavor-hmac\">Third flavor: HMAC</h4><p>Want to prevent your system from attacks such as man-in-middle, XSS injection, etc.?</p><p>You can enforce your infrastructure security by checking both the integrity and the sender's identity of the incoming requests with the new <a href=\"https://docs.containo.us/middlewares/hmac/\">HMAC middleware</a>.</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\"># Static Configuration\nauthSources:\n  my-hmac-src:\n    hmac:\n      inline: # Declare here the authorized id/keys\n        - id: &quot;secret-key&quot;\n          key: &quot;traefikee-approved&quot;\n</code></pre>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">version: '3.4'\n  services:\n    whoami:\n      image: containous/whoami\n      deploy:\n        labels:\n          # Dynamic Configuration\n          # ‚Ä¶ routing labels...\n          - &quot;traefik.http.middlewares.test-hmac-auth.plugin.hmacauth.source=my-hmac-src&quot;\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"root-less-image-secured-more-infrastructure\">Root-LESS Image, Secured-MORE Infrastructure</h2><p>TraefikEE has always been focused on infrastructure security.</p><p>We‚Äôve used a gRPC MTLS communication between the nodes and we‚Äôve split the responsibilities between controllers and proxies to secure both internal and outgoing cluster connections.</p><p>In TraefikEE v2.1, we‚Äôve added a rootless image to secure your infrastructure against potential vulnerabilities in the Docker daemon, and the container runtime.</p><p>Take advantage of this feature by following <a href=\"https://docs.containo.us/operating/rootless-image/\">the comprehensive guide in the documentation</a>.</p><h2 id=\"enhanced-cluster-management\">Enhanced Cluster Management</h2><p>Many users reported to us that they‚Äôve had to maintain TraefiKEE clusters installed on both their Q&amp;A and Production infrastructures, and they‚Äôd like to avoid specifying the cluster name on each command they launched.</p><p>In order to help them, and to improve the user experience, we‚Äôve introduced a few commands into the CLI (teectl) to help <a href=\"https://docs.containo.us/operating/teectl-cluster-mgt/\">manage multiple clusters</a>, and especially, to customize the active cluster. Thus, users can set a cluster as the active one and not provide its name in each command.</p><h2 id=\"red-hat-openshift-operator-certified\">Red Hat OpenShift Operator Certified</h2><p>Like Traefik, TraefikEE eases your Ingress Controller integration regardless of your infrastructure, including Red Hat OpenShift clusters!</p><p>Starting with TraefikEE v2.0, we introduced a Kubernetes Operator to install TraefikEE into OpenShift v4 clusters.</p><p>Today, we are proud to announce that TraefikEE v2.1 is Red Hat OpenShift Operator certified. With this certification, TraefikEE joins the Red Hat software certified partner ecosystem and is readily available through the <a href=\"https://www.openshift.com/products/container-platform\">Red Hat OpenShift Container Platform</a>.</p><p>The TraefikEE Operator is now available in the <a href=\"https://catalog.redhat.com/software/containers/explore\">Red Hat Container Catalog</a>. Via <a href=\"https://operatorhub.io/operator/traefikee-operator\">OperatorHub</a>, you can install and update TraefikEE quickly and seamlessly into any OpenShift cluster.</p><h2 id=\"what-s-next\">What's Next?</h2><p>TraefikEE continues to bring more enterprise specific features. High Availability, distributed services, and enterprise authentication protocols are just a few of the benefits you can get from switching to TraefikEE.</p><p>Take a look at all these features in <a href=\"https://info.containo.us/request-demo-traefikee\">our 5-minute video</a> to learn more about them.</p><p>As always, we are happy to answer your questions, <a href=\"https://info.containo.us/request-demo-traefikee\">and help you find the best solution for your projects</a>.</p><p>If you want to test drive our new features, <a href=\"https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days\">give Traefik Enterprise Edition 2.1 a try today</a>.</p>","url":"https://containous.ghost.io/blog/traefik-enterprise-edition-2-1-now-available/","canonical_url":null,"uuid":"94cc784c-228d-43c6-9944-7be3a0834e62","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e950d861afff4004456e057","reading_time":4}},{"node":{"id":"Ghost__Post__5e9890445df7fe004475aa62","title":"Connecting Users to Applications with Kubernetes Ingress Controllers","slug":"connecting-users-to-applications-with-kubernetes-ingress-controllers","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/1caf24ae2a6677b201631dedaab14f3e/47498/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg","srcSet":"/static/1caf24ae2a6677b201631dedaab14f3e/9dc27/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg 300w,\n/static/1caf24ae2a6677b201631dedaab14f3e/4fe8c/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg 600w,\n/static/1caf24ae2a6677b201631dedaab14f3e/47498/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Kubernetes is the de facto standard for teams developing cloud-native applications. In this article, we‚Äôll review one of the most critical aspects of Kubernetes networking: The Ingress Controller.","custom_excerpt":"Kubernetes is the de facto standard for teams developing cloud-native applications. In this article, we‚Äôll review one of the most critical aspects of Kubernetes networking: The Ingress Controller.","visibility":"public","created_at_pretty":"16 April, 2020","published_at_pretty":"April 21, 2020","updated_at_pretty":"12 October, 2020","created_at":"2020-04-16T17:05:08.000+00:00","published_at":"2020-04-21T13:30:00.000+00:00","updated_at":"2020-10-12T17:54:08.000+00:00","meta_title":"Connecting Users to Apps with Kubernetes Ingress Controllers","meta_description":"In this article, we‚Äôll briefly review one of the most critical but perhaps confusing aspects of Kubernetes networking: The Ingress Controller.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Containerization technologies such as Docker [https://www.docker.com/] have been\nrapidly adopted by software teams, and the ensuing ability to easily package\napplication components into reusable parts has given rise to the widespread use\nof microservices. However, these benefits have come with a price tag as\ndevelopers are faced with challenges around orchestrating and managing\nconnectivity to the underlying containers in a datacenter. Kubernetes\n[https://kubernetes.io/] (k8s) is the de facto standard for teams developing\ncloud-native applications and directly addresses these issues. In this article,\nwe‚Äôll briefly review one of the most critical but perhaps confusing aspects of\nKubernetes networking: The Ingress Controller.\n\nFrom Pods to Production\nLet‚Äôs start with a typical scenario: A development team is tasked with writing a\nbackend API service for external applications/users. In the early phases of\ndevelopment, an engineer may instantiate a local instance of the containerized\nimplementation on development machines using direct docker invocations or even\ndocker-compose. At some point, though, they‚Äôll want to deploy a version of the\nservice to a shared development or staging cluster in the same manner as the\nfinal production configuration. Pods, the fundamental deployable units defined\nby k8s, and higher-level abstractions such as Deployment resources can help\nautomate lifecycle management of containers during this step, but they don‚Äôt\naddress how applications are accessed over the network. Kubernetes provides a\ndedicated resource abstraction for this purpose.\n\nExposing applications as k8s services\nWhen deployed within Pods, containers are assigned IP addresses that may change\nover time due to a variety of lifecycle operations. This immediately poses\nchallenges when other components need to find and establish network connections\nwith them. The Service resource defined as part of Kubernetes networking manages\nthese aspects automatically. Users can define Services that get associated with\nunderlying Pods through selectors and allows them to be accessed through a\nuser-specified service name. Where connections can be established from and how\nthey‚Äôre implemented depends upon the Service type configured. The most commonly\nused service types offered by k8s are:\n\n * ClusterIP\n * NodePort\n * LoadBalancer\n\nClusterIP service type\nThe ClusterIP is enabled by default if no type is defined in the Service\nresource definition. When invoked, k8s creates a virtual cluster IP address that\ncan be used to connect to the underlying Pods. The caveat, though, is that this\nIP address is routable only within the cluster itself. ClusterIP services are\noften used for exposing internal-only application endpoints to each other.\n\nNodePort service type\nThe NodePort type provides the simplest mechanism for external access to\nservices. Specifically, it opens a specific port (within a k8s configured port\nrange) on every node in the cluster. Underneath, a ClusterIP service is created,\nand clients that attempt to connect to an exposed NodePort are routed through.\nWhile the NodePort service type extends a method to access services from outside\nof the cluster, it has some drawbacks including:\n\n * Services can only be exposed on ports from a range (30000-32767 by default)\n * One port can only be mapped to a single service\n * Clients connect through a node and if the corresponding IP of the underlying\n   host / VM changes, they need to be updated accordingly\n\nLoadBalancer service type\nThe LoadBalancer type is often used in cloud environments in order to automate\nthe provisioning of external load balancers outside of the underlying k8s\ncluster. While this enables external network access and avoids the problem of IP\naddresses shifting out from underneath clients, the use of LoadBalancer Service\ntypes can quickly lead to high costs from the underlying cloud (e.g. GCE or\nAWS).\n\nWhile the three Service types above are viable alternatives for some use cases,\nwhen application developers want to expose their services externally without the\nlimitations of NodePort and LoadBalancer types, there‚Äôs a better alternative\nextended by Kubernetes networking.\n\nK8s networking and the Ingress resource abstraction\nKubernetes defines a native Ingress resource abstraction that exposes HTTP and\nHTTPS endpoints and routes traffic based upon rules defined by the user. The\nIngress resource is a natural fit when developers and devops engineers want to\nexpose multiple underlying services through a single external endpoint and/or\nload balancer. The Ingress resource definition allows them to route traffic to\ndefined Service resources based upon, for example, host and/or prefix rules.\nTherefore, it complements the Service resource capabilities to provide a\nflexible method for enabling external access. However, defining an Ingress\nresource on its own doesn‚Äôt actually expose services outside Kubernetes since it\nsimply conveys a request for networking configuration.\n\nThe wizard behind the curtain: Ingress Controllers\nOur discussion thus far has helped highlight the need for ingress resources, but\nit leaves open the question of how corresponding requests are acted upon. The\nanswer comes in the form of Ingress Controllers which are responsible for\nconsuming inbound requests and creating the corresponding routing specifications\nin a technology-specific manner. Typically, the specific controller installed in\na k8s cluster is selected and deployed by operators. There are many potential\noptions available, but a few illustrative examples include:\n\n * AWS ALB - An instance of an Ingress Controller tied to a specific public\n   cloud, it satisfies inbound Ingress resource requests using AWS Application\n   Load Balancers\n   [https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html]\n * NGINX - Implements Ingress resources using the NGINX open source software\n * Traefik - A leading open source Kubernetes Ingress Controller [/traefik/] \n   that makes setting up routes between Kubernetes services and the outside\n   world simple and reliable\n\nThere need not be a strict either / or decision when it comes to choosing\nIngress Controllers\n[/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/]\n, and k8s operators can elect to deploy multiple controllers if desired. The\nselection process should take into consideration the benefits specific\ncontrollers like Traefik [/traefik/] may provide such as:\n\n * Lets Encrypt support for automated certificate management\n * Traffic splitting based upon custom weight definitions\n * Flexibly route definitions including support for name and path based routing\n   as well as route prioritization\n * Custom resource definitions that provide additional controller-specific\n   enhancements\n\nBy integrating controllers that align with their use cases, development teams\ncan enjoy a variety of capabilities provided by Kubernetes for external access\nwithout having to become networking experts.\n\nWant to learn more about Kubernetes Ingress? Check out this video\n[https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes] \nthat describes the different patterns for deploying external load balancers in\nKubernetes.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg\" class=\"kg-image\" alt=\"Connecting Users to Applications with Kubernetes Ingress Controllers\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 1000w, https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Containerization technologies such as <a href=\"https://www.docker.com/\">Docker</a> have been rapidly adopted by software teams, and the ensuing ability to easily package application components into reusable parts has given rise to the widespread use of microservices. However, these benefits have come with a price tag as developers are faced with challenges around orchestrating and managing connectivity to the underlying containers in a datacenter. <a href=\"https://kubernetes.io/\">Kubernetes</a> (k8s) is the de facto standard for teams developing cloud-native applications and directly addresses these issues. In this article, we‚Äôll briefly review one of the most critical but perhaps confusing aspects of Kubernetes networking: The Ingress Controller.</p><h2 id=\"from-pods-to-production\">From Pods to Production</h2><p>Let‚Äôs start with a typical scenario: A development team is tasked with writing a backend API service for external applications/users. In the early phases of development, an engineer may instantiate a local instance of the containerized implementation on development machines using direct docker invocations or even docker-compose. At some point, though, they‚Äôll want to deploy a version of the service to a shared development or staging cluster in the same manner as the final production configuration. Pods, the fundamental deployable units defined by k8s, and higher-level abstractions such as Deployment resources can help automate lifecycle management of containers during this step, but they don‚Äôt address how applications are accessed over the network. Kubernetes provides a dedicated resource abstraction for this purpose.</p><h2 id=\"exposing-applications-as-k8s-services\">Exposing applications as k8s services</h2><p>When deployed within Pods, containers are assigned IP addresses that may change over time due to a variety of lifecycle operations. This immediately poses challenges when other components need to find and establish network connections with them. The Service resource defined as part of Kubernetes networking manages these aspects automatically. Users can define Services that get associated with underlying Pods through selectors and allows them to be accessed through a user-specified service name. Where connections can be established from and how they‚Äôre implemented depends upon the Service type configured. The most commonly used service types offered by k8s are:</p><ul><li>ClusterIP</li><li>NodePort</li><li>LoadBalancer</li></ul><h3 id=\"clusterip-service-type\">ClusterIP service type</h3><p>The ClusterIP is enabled by default if no type is defined in the Service resource definition. When invoked, k8s creates a virtual cluster IP address that can be used to connect to the underlying Pods. The caveat, though, is that this IP address is routable only within the cluster itself. ClusterIP services are often used for exposing internal-only application endpoints to each other.</p><h3 id=\"nodeport-service-type\">NodePort service type</h3><p>The NodePort type provides the simplest mechanism for external access to services. Specifically, it opens a specific port (within a k8s configured port range) on every node in the cluster. Underneath, a ClusterIP service is created, and clients that attempt to connect to an exposed NodePort are routed through. While the NodePort service type extends a method to access services from outside of the cluster, it has some drawbacks including:</p><ul><li>Services can only be exposed on ports from a range (30000-32767 by default)</li><li>One port can only be mapped to a single service</li><li>Clients connect through a node and if the corresponding IP of the underlying host / VM changes, they need to be updated accordingly</li></ul><h3 id=\"loadbalancer-service-type\">LoadBalancer service type</h3><p>The LoadBalancer type is often used in cloud environments in order to automate the provisioning of external load balancers outside of the underlying k8s cluster. While this enables external network access and avoids the problem of IP addresses shifting out from underneath clients, the use of LoadBalancer Service types can quickly lead to high costs from the underlying cloud (e.g. GCE or AWS).</p><p>While the three Service types above are viable alternatives for some use cases, when application developers want to expose their services externally without the limitations of NodePort and LoadBalancer types, there‚Äôs a better alternative extended by Kubernetes networking.</p><h2 id=\"k8s-networking-and-the-ingress-resource-abstraction\">K8s networking and the Ingress resource abstraction</h2><p>Kubernetes defines a native Ingress resource abstraction that exposes HTTP and HTTPS endpoints and routes traffic based upon rules defined by the user. The Ingress resource is a natural fit when developers and devops engineers want to expose multiple underlying services through a single external endpoint and/or load balancer. The Ingress resource definition allows them to route traffic to defined Service resources based upon, for example, host and/or prefix rules. Therefore, it complements the Service resource capabilities to provide a flexible method for enabling external access. However, defining an Ingress resource on its own doesn‚Äôt actually expose services outside Kubernetes since it simply conveys a request for networking configuration.</p><h2 id=\"the-wizard-behind-the-curtain-ingress-controllers\">The wizard behind the curtain: Ingress Controllers</h2><p>Our discussion thus far has helped highlight the need for ingress resources, but it leaves open the question of how corresponding requests are acted upon. The answer comes in the form of Ingress Controllers which are responsible for consuming inbound requests and creating the corresponding routing specifications in a technology-specific manner. Typically, the specific controller installed in a k8s cluster is selected and deployed by operators. There are many potential options available, but a few illustrative examples include:</p><ul><li>AWS ALB - An instance of an Ingress Controller tied to a specific public cloud, it satisfies inbound Ingress resource requests using <a href=\"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html\">AWS Application Load Balancers</a></li><li>NGINX - Implements Ingress resources using the NGINX open source software</li><li>Traefik - A leading open source <a href=\"https://containous.ghost.io/traefik/\">Kubernetes Ingress Controller</a> that makes setting up routes between Kubernetes services and the outside world simple and reliable</li></ul><p>There need not be a strict either / or decision when it comes to <a href=\"https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/\">choosing Ingress Controllers</a>, and k8s operators can elect to deploy multiple controllers if desired. The selection process should take into consideration the benefits specific controllers like <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> may provide such as:</p><ul><li>Lets Encrypt support for automated certificate management</li><li>Traffic splitting based upon custom weight definitions</li><li>Flexibly route definitions including support for name and path based routing as well as route prioritization</li><li>Custom resource definitions that provide additional controller-specific enhancements</li></ul><p>By integrating controllers that align with their use cases, development teams can enjoy a variety of capabilities provided by Kubernetes for external access without having to become networking experts.</p><p>Want to learn more about <strong>Kubernetes Ingress</strong>? <a href=\"https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes\">Check out this video</a> that describes the <strong>different patterns for deploying external load balancers in Kubernetes.</strong></p>","url":"https://containous.ghost.io/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/","canonical_url":null,"uuid":"f0bf868a-e778-4b14-bfa8-cb19bbf59318","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e9890445df7fe004475aa62","reading_time":4}},{"node":{"id":"Ghost__Post__5ea754911468920044969864","title":"TraefikEE now available through new Red Hat Marketplace","slug":"traefikee-now-available-through-new-red-hat-marketplace","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/TraefikEE-now-available-through-new-Red-Hat-Marketplace.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b5d085f88ca752b912406ed1ebbb4611/47498/TraefikEE-now-available-through-new-Red-Hat-Marketplace.jpg","srcSet":"/static/b5d085f88ca752b912406ed1ebbb4611/9dc27/TraefikEE-now-available-through-new-Red-Hat-Marketplace.jpg 300w,\n/static/b5d085f88ca752b912406ed1ebbb4611/4fe8c/TraefikEE-now-available-through-new-Red-Hat-Marketplace.jpg 600w,\n/static/b5d085f88ca752b912406ed1ebbb4611/47498/TraefikEE-now-available-through-new-Red-Hat-Marketplace.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"We‚Äôre excited to announce that Traefik Enterprise Edition is now available through Red Hat Marketplace, an open cloud marketplace that makes it easier to discover and access certified software for container-based environments in the cloud and on-premises.","custom_excerpt":"We‚Äôre excited to announce that Traefik Enterprise Edition is now available through Red Hat Marketplace, an open cloud marketplace that makes it easier to discover and access certified software for container-based environments in the cloud and on-premises.","visibility":"public","created_at_pretty":"27 April, 2020","published_at_pretty":"April 28, 2020","updated_at_pretty":"14 May, 2020","created_at":"2020-04-27T21:54:25.000+00:00","published_at":"2020-04-28T13:01:11.000+00:00","updated_at":"2020-05-14T05:09:39.000+00:00","meta_title":"TraefikEE now available through new Red Hat Marketplace ","meta_description":"We‚Äôre excited to announce that Traefik Enterprise Edition is now available through Red Hat Marketplace","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/04/TraefikEE-now-available-through-new-Red-Hat-Marketplace-Twitter.jpg","twitter_title":null,"authors":[{"name":"Marie Ponseel","slug":"marie","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/profile-picture.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Marie Ponseel","slug":"marie","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/profile-picture.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Partners","slug":"partners","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Provides unified and automated network management in dynamic OpenShift\nenvironments\n\nWe‚Äôre excited to announce that Traefik Enterprise Edition [/traefikee/] is now\navailable through Red Hat Marketplace\n[https://marketplace.redhat.com/en-us/products/traefik-enterprise-edition], an\nopen cloud marketplace that makes it easier to discover and access certified\nsoftware for container-based environments in the cloud and on-premises. Traefik\nEnterprise Edition is the easiest way for organizations with large-scale or\nmission-critical applications to run container-based architectures at scale\neverywhere.\n\nCustomers can now benefit from the seamless deployment experience of TraefikEE\nthrough Red Hat Marketplace and can take advantage of responsive support,\nstreamlined purchasing and billing, simplified governance, and single-dashboard\nvisibility across clouds.\n\nTraefik Enterprise Edition, built on top of open-source Traefik [/traefik/],\nnatively integrates with Red Hat OpenShift to allow application teams to\nsimplify the complexity of managing dynamic network topologies and resources.\nWith just a few clicks, you can get access to enterprise distributed features\nwith high-performance capabilities enabling you to:\n\n * Load balance any application using any protocol\n * Easily scale out to meet production traffic needs\n * Add smart routing and fallback policies critical in multi-cloud scenarios\n * Better secure services with end-to-end network and application encryption\n * Provide real-time tracing, monitoring, and alerts for visibility and control\n   over topology, uptime, and performance\n\nBuilt in partnership by Red Hat and IBM, Red Hat Marketplace is designed to meet\nthe unique needs of developers, procurement teams and IT leaders through\nsimplified and streamlined access to popular enterprise software. All solutions\navailable through the marketplace have been tested and certified for Red Hat\nOpenShift Container Platform\n[https://www.redhat.com/en/technologies/cloud-computing/openshift], the\nindustry's most comprehensive enterprise Kubernetes platform, allowing them to\nrun anywhere OpenShift runs. A containers-based approach helps ensure that\napplications can be run and managed the exact same way, regardless of the\nunderlying cloud infrastructure. This gives companies the flexibility to run\ntheir workloads on-premises or in any public or private cloud with improved\nportability and confidence that their applications and data are protected\nagainst vendor lock-in.\n\nThrough the Red Hat Marketplace, we provide our customers with the best\nmulti-cloud experience to run their container-based applications, while giving\nthem the flexibility to deploy TraefikEE in the environment of their choice.\nNow, enterprises can deploy production-grade Kubernetes environments simply and\neasily with the peace of mind that their chosen stack will work anywhere and be\nsupported for years to come.\n\nGoing forward, you will be able to find the latest version of TraefikEE in the\nRed Hat Marketplace, starting with the recently announced TraefikEE v2.1\n[/blog/traefik-enterprise-edition-2-1-now-available/] which adds crucial new\ncapabilities with enhanced security options including support for LDAP and three\nnew authentication protocols: JWT, HMAC, and OAuth2 Token Introspection, that\ncan be used to easily improve security for both external and internal traffic.\nTo learn more about TraefikEE, watch the demo video\n[https://info.containo.us/request-demo-traefikee].\n\nRed Hat Marketplace and TraefikEE offer a true multi-cloud experience with the\nsupport you need for end-to-end solutions in one single platform. Try TraefikEE\nout at marketplace.redhat.com\n[https://marketplace.redhat.com/en-us/products/traefik-enterprise-edition].","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Provides unified and automated network management in dynamic OpenShift environments</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/04/RH-Marketplace-Partners-blog-bkg_wLogo.png\" class=\"kg-image\"></figure><p>We‚Äôre excited to announce that <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition</a> is now available through <a href=\"https://marketplace.redhat.com/en-us/products/traefik-enterprise-edition\">Red Hat Marketplace</a>, an open cloud marketplace that makes it easier to discover and access certified software for container-based environments in the cloud and on-premises. Traefik Enterprise Edition is the easiest way for organizations with large-scale or mission-critical applications to run container-based architectures at scale everywhere.</p><p>Customers can now benefit from the seamless deployment experience of TraefikEE through Red Hat Marketplace and can take advantage of responsive support, streamlined purchasing and billing, simplified governance, and single-dashboard visibility across clouds.</p><p>Traefik Enterprise Edition, built on top of open-source <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, natively integrates with Red Hat OpenShift to allow application teams to simplify the complexity of managing dynamic network topologies and resources. With just a few clicks, you can get access to enterprise distributed features with high-performance capabilities enabling you to:</p><ul><li>Load balance any application using any protocol</li><li>Easily scale out to meet production traffic needs</li><li>Add smart routing and fallback policies critical in multi-cloud scenarios</li><li>Better secure services with end-to-end network and application encryption</li><li>Provide real-time tracing, monitoring, and alerts for visibility and control over topology, uptime, and performance</li></ul><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/04/TraefikEE-RedHatMarketplace-1.jpg\" class=\"kg-image\"></figure><p>Built in partnership by Red Hat and IBM, Red Hat Marketplace is designed to meet the unique needs of developers, procurement teams and IT leaders through simplified and streamlined access to popular enterprise software. All solutions available through the marketplace have been tested and certified for <a href=\"https://www.redhat.com/en/technologies/cloud-computing/openshift\">Red Hat OpenShift Container Platform</a>, the industry's most comprehensive enterprise Kubernetes platform, allowing them to run anywhere OpenShift runs. A containers-based approach helps ensure that applications can be run and managed the exact same way, regardless of the underlying cloud infrastructure. This gives companies the flexibility to run their workloads on-premises or in any public or private cloud with improved portability and confidence that their applications and data are protected against vendor lock-in.</p><p>Through the Red Hat Marketplace, we provide our customers with the best multi-cloud experience to run their container-based applications, while giving them the flexibility to deploy TraefikEE in the environment of their choice. Now, enterprises can deploy production-grade Kubernetes environments simply and easily with the peace of mind that their chosen stack will work anywhere and be supported for years to come.</p><p>Going forward, you will be able to find the latest version of TraefikEE in the Red Hat Marketplace, starting with <a href=\"https://containous.ghost.io/blog/traefik-enterprise-edition-2-1-now-available/\">the recently announced TraefikEE v2.1</a> which adds crucial new capabilities with enhanced security options including support for LDAP and three new authentication protocols: JWT, HMAC, and OAuth2 Token Introspection, that can be used to easily improve security for both external and internal traffic. To learn more about TraefikEE, <a href=\"https://info.containo.us/request-demo-traefikee\">watch the demo video</a>.</p><p><em>Red Hat Marketplace and TraefikEE offer a true multi-cloud experience with the support you need for end-to-end solutions in one single platform.</em> Try TraefikEE out at <a href=\"https://marketplace.redhat.com/en-us/products/traefik-enterprise-edition\">marketplace.redhat.com</a>.</p>","url":"https://containous.ghost.io/blog/traefikee-now-available-through-new-red-hat-marketplace/","canonical_url":null,"uuid":"452d591e-0663-4e67-b36a-2d3d3b8f31b4","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ea754911468920044969864","reading_time":2}},{"node":{"id":"Ghost__Post__5e9116ed1afff4004456e002","title":"The Importance of Distributed Tracing and Monitoring in a Microservice Architecture","slug":"the-importance-of-distributed-tracing-and-monitoring-in-a-microservice-architecture","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/05/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/bc214844165f4ac2399fc1548c498842/47498/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg","srcSet":"/static/bc214844165f4ac2399fc1548c498842/9dc27/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg 300w,\n/static/bc214844165f4ac2399fc1548c498842/4fe8c/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg 600w,\n/static/bc214844165f4ac2399fc1548c498842/47498/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"How do teams diagnose latency between microservices or collate logs from dozens of loosely coupled services, while also ensuring that any logging overhead is kept to a minimum?","custom_excerpt":"How do teams diagnose latency between microservices or collate logs from dozens of loosely coupled services, while also ensuring that any logging overhead is kept to a minimum?","visibility":"public","created_at_pretty":"11 April, 2020","published_at_pretty":"May 5, 2020","updated_at_pretty":"22 May, 2020","created_at":"2020-04-11T01:01:33.000+00:00","published_at":"2020-05-05T14:40:44.000+00:00","updated_at":"2020-05-22T00:25:50.000+00:00","meta_title":"Distributed Tracing & Monitoring in a Microservice Architecture","meta_description":"Often microservices can be thought of as a single application, even though internally there may be several services involved in fulfilling requests.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/05/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Twitter.jpg","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Microservices","slug":"microservices","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Microservices have many advantages, such as the ability to independently deploy\ndecoupled services instead of having to deploy an entire monolithic application\nor scaling out components independently. However, for all their advantages,\nmicroservices also introduce complexities that should be understood by teams\nthat choose to implement them. One of those challenges is monitoring application\nhealth and tracing traffic flows through a distributed system.\n\nOften microservices can logically be thought of as a single application, even\nthough internally there may be several services involved in fulfilling requests\nto the end-user. If each request is routed through a series of services, how do\nteams trace and troubleshoot issues? Even if the system as a whole is working \nfunctionally, perhaps your overall transaction time is unacceptable. How do\nteams diagnose latency between microservices or collate logs from dozens of\nloosely coupled services, while also ensuring that any logging overhead is kept\nto a minimum?\n\nLogging, Monitoring, and Tracing\nBefore we continue, let us disambiguate logging, monitoring, and tracing. These\nterms are often used interchangeably, but there are some subtle differences.\n\nTypically, logging is focused on diagnosing errors or providing auditing\ncapabilities at the component (or microservice) level. Logging is also usually\nreactive in nature and is often the first tool that operators use when\ntroubleshooting service errors or investigating security incidents.\n\nMonitoring is focused on proactive metrics and thresholds that let operators\nknow how a service is handling its requests. These metrics are usually focused\non the underlying infrastructure, such as CPU, Memory, and I/O in addition to\nthe runtime metrics generated by the application itself. These include\nstatistics like heap size, thread count, and memory management (garbage\ncollection).\n\nTracing is typically focused on optimization and performance across multiple\nservices. It includes correlating a single ‚Äúlogical request‚Äù to multiple\nphysical requests as they propagate through multiple services. While tracing is\nconcerned with each service in a chain, it is usually focused at the application\nlevel. There are additional benefits to tracing as a troubleshooting tool since\nany exception or error is usually captured along with the entire context of a\nrequest.\n\nWhile logging is important, in this article we will focus on monitoring and\ntracing since they span multiple services.\n\nMonitoring\nMonitoring is the process of recording information, or predefined metrics,\nallowing operators to achieve visibility into their applications state. These\nmetrics help answer questions around resource allocation or to determine if\nrequests are going where they should. This becomes increasingly important when\ntraffic shifting and other advanced routing mechanisms like throttling or\ncircuit breakers are used within microservice applications. Knowing when a\nrequest hit a service is important but knowing why it was forwarded to that\nservice can be just as important. Monitoring can also help operators determine\nwhen circuit breakers are triggered on or off or which traffic shifting rule was\ninvoked in routing the request. Traefik generates metrics around these types of\nKey Performance Indicators (KPIs) and exposes that data through various\nimplementations such as Prometheus.\n\nTracing\nTracing starts at the entry-point of a request into an application. A trace is\nstarted for the request and will have a unique identifier\n[https://www.w3.org/TR/trace-context/] generated for that request. As traffic\nflows from service to service, each service adds some information to the trace,\nlike the time the request arrived at the service as well as how long it took to\nprocess. This allows open source tools such as Jaeger\n[https://www.jaegertracing.io/] and Elastic APM [https://www.elastic.co/apm] to\nvisualize the entire call flow.\n\nHow is tracing implemented in a microservices application? In most cases, there\nare libraries and tools to help instrument the most popular application runtimes\nand frameworks. You could also code it yourself, intercepting calls and adding\nheaders to downstream requests or using some other mechanism to add metadata to\ntraffic. In addition to these techniques, you can utilize tracing with Traefik\n[/traefik/] and Maesh [/maesh/] to gain additional observability within your\napplication environments.\n\nTraefik supports tracing via OpenTracing [https://opentracing.io/], an open\nstandard designed for distributed tracing. You enable tracing via configuration\nand can also specify which backend you want to utilize: Jaeger\n[https://www.jaegertracing.io/], Zipkin [https://zipkin.io/], or DataDog\n[https://www.datadoghq.com/].\n\nTracing or Monitoring, or Both?\nThe distinction between monitoring and tracing is often academic. Some teams\nutilize monitoring and metrics alongside distributed tracing, while other teams\nprefer to keep tracing and monitoring as separate but complementary concerns. In\nmany cases, the aggregate data provided by tracing generates the information\nthey need to determine when and where to scale out their services.\n\nMonitoring is typically easier to implement, so teams usually start their\ndiagnostic journey with metrics. Tracing allows a deeper (or wider) view but\ntypically requires more effort to implement because of the requirements in\ncollecting, storing, and analyzing the vast amounts of telemetry which is\ngenerated by tracing. Of course, there are vendors such as DataDog\n[https://www.datadoghq.com/] and Instana [https://www.instana.com/] which can\noffload most of that work, but those solutions are costly and hard to justify\nwhen first starting out.\n\nBoth monitoring and tracing can be used to help detect when individual services\nare not behaving as they should. Tracing, when properly implemented, will help\nyou not only detect anomalies but give you the information needed to understand\nwhat may be causing them. Ultimately, when you are to the point where you need\nto focus on optimization and improve end-to-end performance, then you‚Äôre going\nto have no choice but to utilize tracing. Tools such as Traefik [/traefik/] and \nMaesh [/maesh/] can be used to introduce distributed tracing without the\nsignificant overhead involved with instrumenting every service with open source\ntools and having to manage all that additional telemetry.\n\nConclusion\nBoth monitoring and tracing are important to creating stable, reliable, and\nperformant microservice-based applications. Monitoring provides health checks on\nplatform services and critical infrastructure, while tracing allows you to\ndiagnose end-to-end traffic for requests. As applications mature, they typically\nrequire both monitoring and tracing for efficient and optimal service\nmanagement.\n\nWant to learn more about microservice architecture best practices? Check out\nthis white paper\n[https://info.containo.us/request-white-paper-routing-in-the-cloud] that\naddresses production challenges (including tracing and monitoring) related to\nadopting microservices with a cloud-native mindset.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/05/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog.jpg\" class=\"kg-image\"></figure><p>Microservices have many advantages, such as the ability to independently deploy decoupled services instead of having to deploy an entire monolithic application or scaling out components independently. However, for all their advantages, microservices also introduce complexities that should be understood by teams that choose to implement them. One of those challenges is monitoring application health and tracing traffic flows through a distributed system.</p><p>Often microservices can <em>logically</em> be thought of as a single application, even though internally there may be several services involved in fulfilling requests to the end-user. If each request is routed through a series of services, how do teams trace and troubleshoot issues? Even if the system as a whole is working <em>functionally</em>, perhaps your overall transaction time is unacceptable. How do teams diagnose latency between microservices or collate logs from dozens of loosely coupled services, while also ensuring that any logging overhead is kept to a minimum?</p><h2 id=\"logging-monitoring-and-tracing\">Logging, Monitoring, and Tracing</h2><p>Before we continue, let us disambiguate logging, monitoring, and tracing. These terms are often used interchangeably, but there are some subtle differences.</p><p>Typically, logging is focused on diagnosing errors or providing auditing capabilities at the component (or microservice) level. Logging is also usually reactive in nature and is often the first tool that operators use when troubleshooting service errors or investigating security incidents.</p><p>Monitoring is focused on proactive metrics and thresholds that let operators know how a service is handling its requests. These metrics are usually focused on the underlying infrastructure, such as CPU, Memory, and I/O in addition to the runtime metrics generated by the application itself. These include statistics like heap size, thread count, and memory management (garbage collection).</p><p>Tracing is typically focused on optimization and performance across multiple services. It includes correlating a single ‚Äúlogical request‚Äù to multiple physical requests as they propagate through multiple services. While tracing is concerned with each service in a chain, it is usually focused at the application level. There are additional benefits to tracing as a troubleshooting tool since any exception or error is usually captured along with the entire context of a request.</p><p>While logging is important, in this article we will focus on monitoring and tracing since they span multiple services.</p><h2 id=\"monitoring\">Monitoring</h2><p>Monitoring is the process of recording information, or predefined metrics, allowing operators to achieve visibility into their applications state. These metrics help answer questions around resource allocation or to determine if requests are going where they should. This becomes increasingly important when traffic shifting and other advanced routing mechanisms like throttling or circuit breakers are used within microservice applications. Knowing when a request hit a service is important but knowing why it was forwarded to that service can be just as important. Monitoring can also help operators determine when circuit breakers are triggered on or off or which traffic shifting rule was invoked in routing the request. Traefik generates metrics around these types of Key Performance Indicators (KPIs) and exposes that data through various implementations such as Prometheus.</p><h2 id=\"tracing\">Tracing</h2><p>Tracing starts at the entry-point of a request into an application. A trace is started for the request and will have a <a href=\"https://www.w3.org/TR/trace-context/\">unique identifier</a> generated for that request. As traffic flows from service to service, each service adds some information to the trace, like the time the request arrived at the service as well as how long it took to process. This allows open source tools such as <a href=\"https://www.jaegertracing.io/\">Jaeger</a> and <a href=\"https://www.elastic.co/apm\">Elastic APM</a> to visualize the entire call flow.</p><p>How is tracing implemented in a microservices application? In most cases, there are libraries and tools to help instrument the most popular application runtimes and frameworks. You could also code it yourself, intercepting calls and adding headers to downstream requests or using some other mechanism to add metadata to traffic. In addition to these techniques, you can utilize tracing with <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> and <a href=\"https://containous.ghost.io/maesh/\">Maesh</a> to gain additional observability within your application environments.</p><p>Traefik supports tracing via <a href=\"https://opentracing.io/\">OpenTracing</a>, an open standard designed for distributed tracing. You enable tracing via configuration and can also specify which backend you want to utilize: <a href=\"https://www.jaegertracing.io/\">Jaeger</a>, <a href=\"https://zipkin.io/\">Zipkin</a>, or <a href=\"https://www.datadoghq.com/\">DataDog</a>.</p><h2 id=\"tracing-or-monitoring-or-both\">Tracing or Monitoring, or Both?</h2><p>The distinction between monitoring and tracing is often academic. Some teams utilize monitoring and metrics alongside distributed tracing, while other teams prefer to keep tracing and monitoring as separate but complementary concerns. In many cases, the aggregate data provided by tracing generates the information they need to determine when and where to scale out their services.</p><p>Monitoring is typically easier to implement, so teams usually start their diagnostic journey with metrics. Tracing allows a deeper (or wider) view but typically requires more effort to implement because of the requirements in collecting, storing, and analyzing the vast amounts of telemetry which is generated by tracing. Of course, there are vendors such as <a href=\"https://www.datadoghq.com/\">DataDog</a> and <a href=\"https://www.instana.com/\">Instana</a> which can offload most of that work, but those solutions are costly and hard to justify when first starting out.</p><p>Both monitoring and tracing can be used to help detect when individual services are not behaving as they should. Tracing, when properly implemented, will help you not only detect anomalies but give you the information needed to understand what may be causing them. Ultimately, when you are to the point where you need to focus on optimization and improve end-to-end performance, then you‚Äôre going to have no choice but to utilize tracing. Tools such as <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> and <a href=\"https://containous.ghost.io/maesh/\">Maesh</a> can be used to introduce distributed tracing without the significant overhead involved with instrumenting every service with open source tools and having to manage all that additional telemetry.</p><h2 id=\"conclusion\">Conclusion</h2><p>Both monitoring and tracing are important to creating stable, reliable, and performant microservice-based applications. Monitoring provides health checks on platform services and critical infrastructure, while tracing allows you to diagnose end-to-end traffic for requests. As applications mature, they typically require both monitoring and tracing for efficient and optimal service management.</p><p>Want to learn more about <strong>microservice architecture best practices</strong>? <a href=\"https://info.containo.us/request-white-paper-routing-in-the-cloud\">Check out this white paper</a> that addresses<strong> production challenges </strong>(including tracing and monitoring) <strong>related to adopting microservices with a cloud-native mindset</strong>.</p>","url":"https://containous.ghost.io/blog/the-importance-of-distributed-tracing-and-monitoring-in-a-microservice-architecture/","canonical_url":null,"uuid":"abf91c0f-1147-4f72-be6e-11329e668272","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e9116ed1afff4004456e002","reading_time":4}},{"node":{"id":"Ghost__Post__5eba1e92c49e39004576b665","title":"Announcing Maesh 1.2","slug":"announcing-maesh-1-2","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/05/Announcing-Maesh-1-2-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/eea388d034bc889f2b61ee6aec472465/47498/Announcing-Maesh-1-2-1.jpg","srcSet":"/static/eea388d034bc889f2b61ee6aec472465/9dc27/Announcing-Maesh-1-2-1.jpg 300w,\n/static/eea388d034bc889f2b61ee6aec472465/4fe8c/Announcing-Maesh-1-2-1.jpg 600w,\n/static/eea388d034bc889f2b61ee6aec472465/47498/Announcing-Maesh-1-2-1.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Maesh 1.2 brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.","custom_excerpt":"Maesh 1.2 brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.","visibility":"public","created_at_pretty":"12 May, 2020","published_at_pretty":"May 12, 2020","updated_at_pretty":"02 June, 2020","created_at":"2020-05-12T03:57:06.000+00:00","published_at":"2020-05-12T18:51:37.000+00:00","updated_at":"2020-06-02T14:24:48.000+00:00","meta_title":"Announcing Maesh 1.2 - Now with support for UDP, reworked ACL and more","meta_description":"Maesh 1.2 brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.","og_description":"Now with support for UDP, reworked ACL, and a more efficient installation!","og_image":null,"og_title":"Announcing Maesh 1.2","twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/05/Announcing-Maesh-1-2-Twitter.jpg","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Now with support for UDP, reworked ACL, and a more efficient installation!\n\nIn early March, we proudly announced the general availability of Maesh 1.1\n[/blog/traefik-maesh-1-1/]. Now, less than 3 months later we‚Äôre proud to\nintroduce Maesh 1.2, the latest release of our simpler service mesh. This\nrelease brings new additions such as UDP support and enhancing our internal\narchitecture to provide more flexibility and performance in large deployments.\n\nUDP Support\nAs you probably know, Maesh [/blog/maesh-1-0-802f4be9a9a7/] is built on top of \nTraefik [/traefik/], our popular Cloud Native Edge Router. Traefik introduced\nUDP support with the release of version 2.2 [/blog/traefik-2-2-ingress/] in\nearly March, and ¬†as a result, Maesh is now able to handle UDP connections\n[https://en.wikipedia.org/wiki/User_Datagram_Protocol] as well.\n\nThe only thing you need to do is modify your \"maesh.containo.us/traffic-type\"\nannotation and set it to udp.\n\n---\napiVersion: v1\nkind: Service\nmetadata: \n  annotations: \n    maesh.containo.us/traffic-type: udp\n  labels: \n    app: my-udp-service\n  name: udp-service\n  namespace: test\nspec: \n  ports: \n    - port: 8080\n      protocol: UDP\n  selector: \n    app: my-udp-service\n\n\nThat‚Äôs it! Maesh will now proxy the UDP protocol to that service.\n\nPull over Push Configuration\nAs a result of the architectural change mentioned above, we were able to improve\nthe way our proxy nodes ingest configuration.\n\nPrior to this release, the Maesh Controller pushed the current dynamic\nconfiguration to the proxy nodes. Of course, this solution was not optimal as it\neventually resulted in longer deployment times and became a bottleneck in large\nclusters.\n\nWe‚Äôve changed the configuration to a pull based system, so instead of waiting\nfor a push, the custom nodes will pull the configuration from the\ncontroller.This change improves both performance along with stability, and makes\nthe deployment of configuration not only more efficient but much easier.\n\nACL as a feature\nMaesh was designed from the ground up to be SMI [https://smi-spec.io/] \ncompliant. Therefore, we initially had a CLI flag to configure Maesh called \n--smi. This would set Maesh into the SMI Mode which made it possible to make use\nof TrafficSplits or ACL.\n\nAs a side-effect you were unable to use the retry annotation together with SMI\nbecause internally the two modes were incompatible.\n\nTo change that, we have reworked how Maesh discovers services. Maesh will now\nbuild an internal topology of every deployed service, including *nested\nTrafficSplits* through the SMI specification.\n\nAdditionally, if you want to use ACL (TrafficTarget in SMI) you may now activate\nthe ACL flag --acl similar to how you could activate the SMI flag before. Doing\nso, will activate the ACL feature on Maesh without impacting the SMI mode.\n\nMultiple Middlewares per service\nLast but not least, we also enhanced the handling of the annotations on your\nservices. It is now possible to combine middlewares, for example the\nretry-attempts with the rate-limiter to better control your services.\n\n---\napiVersion: v1\nkind: Service\nmetadata: \n  annotations:\n    maesh.containo.us/retry-attempts: 2\n    maesh.containo.us/ratelimit-burst: 200\n  labels: \n    app: my-udp-service\n  name: udp-service\n  namespace: test\nspec: \n  ports: \n    - port: 8080\n      protocol: UDP\n  selector: \n    app: my-udp-service\n\n\nThis configuration activates the retry feature and Maesh will simultaneously try\nto proxy the request twice in case of a network error and activate the rate\nlimiting for that service.\n\nNew Helm Major Version\nAs a result of all the architecture changes mentioned above, we needed to\nenhance the Major Version of our chart as we had some helm breaking changes. For\nassistance while upgrading your installation, please see here\n[https://docs.mae.sh/master/migration/helm-chart/].\n\nWhat‚Äôs Next\nWe‚Äôre just getting started. Work is underway to implement some of the most\nrequested features into Maesh, including End to End encryption. Of course, this\nis only made possible by you, an awesome community, which provides us such\nvaluable feedback that we‚Äôre able to define an exciting roadmap for a product\nyou‚Äôve helped us build. \n\nPlease don‚Äôt stop contributing, either in PR‚Äôs or just raising issues. For us it\nmatters a lot. \n\nThank you!\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Now with support for UDP, reworked ACL, and a more efficient installation!</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/05/Announcing-Maesh-1-2.jpg\" class=\"kg-image\"></figure><p>In early March, we proudly announced the general availability of <a href=\"https://containous.ghost.io/blog/traefik-maesh-1-1/\">Maesh 1.1</a>. Now, less than 3 months later we‚Äôre proud to introduce Maesh 1.2, the latest release of our simpler service mesh. This release brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.</p><h2 id=\"udp-support\">UDP Support</h2><p>As you probably know, <a href=\"https://containous.ghost.io/blog/maesh-1-0-802f4be9a9a7/\">Maesh</a> is built on top of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, our popular Cloud Native Edge Router. Traefik introduced UDP support with the <a href=\"https://containous.ghost.io/blog/traefik-2-2-ingress/\">release of version 2.2</a> in early March, and ¬†as a result, Maesh is now able to handle <a href=\"https://en.wikipedia.org/wiki/User_Datagram_Protocol\">UDP connections</a> as well.</p><p>The only thing you need to do is modify your \"maesh.containo.us/traffic-type\" annotation and set it to <strong>udp</strong>.</p><!--kg-card-begin: markdown--><pre><code>---\napiVersion: v1\nkind: Service\nmetadata: \n  annotations: \n    maesh.containo.us/traffic-type: udp\n  labels: \n    app: my-udp-service\n  name: udp-service\n  namespace: test\nspec: \n  ports: \n    - port: 8080\n      protocol: UDP\n  selector: \n    app: my-udp-service\n</code></pre>\n<!--kg-card-end: markdown--><p>That‚Äôs it! Maesh will now proxy the UDP protocol to that service.</p><h2 id=\"pull-over-push-configuration\">Pull over Push Configuration</h2><p>As a result of the architectural change mentioned above, we were able to improve the way our proxy nodes ingest configuration.</p><p>Prior to this release, the Maesh Controller pushed the current dynamic configuration to the proxy nodes. Of course, this solution was not optimal as it eventually resulted in longer deployment times and became a bottleneck in large clusters.</p><p>We‚Äôve changed the configuration to a pull based system, so instead of waiting for a push, the custom nodes will pull the configuration from the controller.This change improves both performance along with stability, and makes the deployment of configuration not only more efficient but much easier.</p><h2 id=\"acl-as-a-feature\">ACL as a feature</h2><p>Maesh was designed from the ground up to be <a href=\"https://smi-spec.io/\">SMI</a> compliant. Therefore, we initially had a CLI flag to configure Maesh called <strong>--smi</strong>. This would set Maesh into the SMI Mode which made it possible to make use of TrafficSplits or ACL.</p><p>As a side-effect you were unable to use the retry annotation together with SMI because internally the two modes were incompatible.</p><p>To change that, we have reworked how Maesh discovers services. Maesh will now build an internal topology of every deployed service, including *nested TrafficSplits* through the SMI specification.</p><p>Additionally, if you want to use ACL (TrafficTarget in SMI) you may now activate the ACL flag<strong> --acl</strong> similar to how you could activate the SMI flag before. Doing so, will activate the ACL feature on Maesh without impacting the SMI mode.</p><h2 id=\"multiple-middlewares-per-service\">Multiple Middlewares per service</h2><p>Last but not least, we also enhanced the handling of the annotations on your services. It is now possible to combine middlewares, for example the retry-attempts with the rate-limiter to better control your services.</p><!--kg-card-begin: markdown--><pre><code>---\napiVersion: v1\nkind: Service\nmetadata: \n  annotations:\n    maesh.containo.us/retry-attempts: 2\n    maesh.containo.us/ratelimit-burst: 200\n  labels: \n    app: my-udp-service\n  name: udp-service\n  namespace: test\nspec: \n  ports: \n    - port: 8080\n      protocol: UDP\n  selector: \n    app: my-udp-service\n</code></pre>\n<!--kg-card-end: markdown--><p>This configuration activates the retry feature and Maesh will simultaneously try to proxy the request twice in case of a network error and activate the rate limiting for that service.</p><h2 id=\"new-helm-major-version\">New Helm Major Version</h2><p>As a result of all the architecture changes mentioned above, we needed to enhance the Major Version of our chart as we had some helm breaking changes. For assistance while upgrading your installation, please see <a href=\"https://docs.mae.sh/master/migration/helm-chart/\">here</a>.</p><h2 id=\"what-s-next\">What‚Äôs Next</h2><p>We‚Äôre just getting started. Work is underway to implement some of the most requested features into Maesh, including End to End encryption. Of course, this is only made possible by you, an awesome community, which provides us such valuable feedback that we‚Äôre able to define an exciting roadmap for a product you‚Äôve helped us build. </p><p>Please don‚Äôt stop contributing, either in PR‚Äôs or just raising issues. For us it matters a lot. </p><p>Thank you!</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\">Community Forum</a><br></li></ul>","url":"https://containous.ghost.io/blog/announcing-maesh-1-2/","canonical_url":null,"uuid":"b766ba7b-fcf3-4d04-aca7-89caea3a0a44","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eba1e92c49e39004576b665","reading_time":3}},{"node":{"id":"Ghost__Post__5eb58b45c49e39004576b610","title":"Combining Ingress Controllers and External Load Balancers with Kubernetes","slug":"combining-ingress-controllers-and-external-load-balancers-with-kubernetes","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/05/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes-containous-2.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/9b55622b4567a60fc818e7ec45f13481/47498/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes-containous-2.jpg","srcSet":"/static/9b55622b4567a60fc818e7ec45f13481/9dc27/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes-containous-2.jpg 300w,\n/static/9b55622b4567a60fc818e7ec45f13481/4fe8c/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes-containous-2.jpg 600w,\n/static/9b55622b4567a60fc818e7ec45f13481/47498/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes-containous-2.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"The great promise of Kubernetes is the ability to easily deploy and scale containerized applications. How Load Balancers work together with the Ingress Controllers in a Kubernetes architecture?","custom_excerpt":"The great promise of Kubernetes is the ability to easily deploy and scale containerized applications. How Load Balancers work together with the Ingress Controllers in a Kubernetes architecture?","visibility":"public","created_at_pretty":"08 May, 2020","published_at_pretty":"May 14, 2020","updated_at_pretty":"09 June, 2020","created_at":"2020-05-08T16:39:33.000+00:00","published_at":"2020-05-14T05:05:21.000+00:00","updated_at":"2020-06-09T05:37:52.000+00:00","meta_title":"Combining Ingress Controllers & External Load Balancers with Kubernetes","meta_description":"The great promise of Kubernetes is the ability to easily deploy and scale containerized applications. How Load Balancers work together with the Ingress Controllers in a Kubernetes architecture?","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/05/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes-Twitter.jpg","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#kubernetes-ingress-related-resource","slug":"hash-kubernetes-ingress-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"The great promise of Kubernetes [https://kubernetes.io/] (k8s) is the ability to\neasily deploy and scale containerized applications. By automating the process of\nallocating and provisioning compute and storage resources for Pods across nodes,\nk8s reduces the operational complexity of day-to-day operations. However,\norchestrating containers alone doesn‚Äôt necessarily help engineers meet the\nconnectivity requirements for users. Specifically, a Kubernetes Deployment\nconfigures Pods with private IP addresses and precludes incoming traffic over\nthe network. Outside of Kubernetes, operators are typically familiar with\ndeploying external load balancers, either in cloud or physical data center\nenvironments, to route traffic to application instances. However, effectively\nmapping these operational patterns to k8s requires understanding how Load\nBalancers [https://kubernetes.io/docs/concepts/services-networking/] work\ntogether with the Ingress Controllers\n[https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/] \nin a Kubernetes architecture.\n\nExternal load balancers and Kubernetes\nOverview of external LBs and K8s\nIn order to expose application endpoints, Kubernetes networking allows users to\nexplicitly define Services\n[https://kubernetes.io/docs/concepts/services-networking/service/]. K8s then\nautomates provisioning appropriate networking resources based upon the service\ntype specified. The NodePort service type exposes an allocated port that can be\naccessed over the network on each node in the k8s cluster. The LoadBalancer\nservice type uses this same mechanism to deploy and configure an external load\nbalancer (often through a cloud-managed API) which forwards traffic to an\napplication using the NodePort. When a request is routed to the configured port\non a node, it forwards packets as needed to direct traffic to the destination\nPods using kube-proxy.\n\nFig. a: External load balancer defined for each applicationGiven the ability to\neasily define LoadBalancer services to route incoming traffic from external\nclients, the story may seemingly sound complete. However, in any real-life\nscenario, directly using external load balancers for every application (fig. a) \nthat needs external access has significant drawbacks including:\n\n * Cost overheads: External load balancers, whether cloud-managed or\n   instantiated through physical network appliances on-premises, can be\n   expensive. For k8s clusters with many applications, these costs will quickly\n   add up.\n * Operational complexity: Load balancers require various resources (IP\n   addresses, DNS, certificates, etc.) that can be painful to manage,\n   particularly in highly dynamic environments where there may be transient\n   endpoints for staging and development deployments.\n * Monitoring and logging: Given the importance of external load balancers in\n   the traffic flow, being able to effectively centralize monitoring and logging\n   data is critical. However, this may become challenging in practice when there\n   are multiple load balancers involved.\n\nThe perfect marriage: Load balancers and Ingress Controllers\nIt‚Äôs clear that external load balancers alone aren‚Äôt a practical solution for\nproviding the networking capabilities necessary for a k8s environment. Luckily,\nthe Kubernetes architecture allows users to combine load balancers with an\nIngress Controller. The core concepts are as follows: instead of provisioning an\nexternal load balancer for every application service that needs external\nconnectivity, users deploy and configure a single load balancer that targets an\nIngress Controller. The Ingress Controller serves as a single entrypoint and can\nthen route traffic to multiple applications in the cluster. Key elements of this\napproach include:\n\n * Ingress Controllers are k8s applications: While they may seem somewhat\n   magical, it‚Äôs useful to keep in mind that Ingress Controllers are nothing\n   more than standard Kubernetes applications instantiated via Pods.\n * Ingress Controllers are exposed as a service: The k8s application that\n   constitutes an Ingress Controller is exposed through a LoadBalancer service\n   type thereby mapping it to an external load balancer.\n * Ingress Controllers route to underlying applications using ClusterIPs: As an\n   intermediary between the external load balancer and applications, the Ingress\n   Controller uses ClusterIP service types to route and balance traffic across\n   application instances based upon operator-provided configurations.\n\nFig. b: Dynamic load balancing through ingressInjecting the Ingress Controller\nin the traffic path allows users to gain the benefits of external load balancer\ncapabilities while avoiding the pitfalls of relying upon them exclusively (fig.\nb). Indeed, the Kubernetes architecture allows operators to integrate multiple\nIngress Controllers, thereby providing a high degree of flexibility to meet\nspecific requirements. This can be a bit overwhelming for those new to\nKubernetes networking, so let‚Äôs review a few example deployment patterns.\n\nExample deployment patterns\nLoad balancer with NodePorts and traffic forwarding\nAs mentioned earlier, a LoadBalancer service type results in an external load\nbalancer that uses NodePorts to reach backend services. Since every node exposes\nthe target port, the load balancer can spread traffic across all of them.\nHowever, the underlying Pods may only be running on a subset of the k8s nodes\ncreating the potential need for traffic forwarding. As part of forwarding\ntraffic, the kube-proxy performs source network address translation (SNAT).\nWhile this obfuscates the source IP address of requestors, the use of HTTP\nheaders such as X-Forwarded-For (and its standardized variant Forwarded) can be\nutilized where business requirements require it (e.g. for compliance purposes).\n\nLoad balancer with NodePorts and no SNAT\nTo avoid SNAT in the traffic flow, we can modify the previous deployment pattern\nto force the external load balancer to only target nodes that reflect Pods\nrunning the Ingress Controller deployment. Specifically, the\nexternalTrafficPolicy on the LoadBalancer service for the Ingress Controller can\nbe set to Local instead of the default Cluster value. Some potential drawbacks\nof this pattern, however, include:\n\n * Reduced load-spreading: Since all traffic is funneled to a subset of nodes,\n   there may be traffic imbalances\n * Use of health checks: The external load balancer uses a health check to\n   determine which nodes to target, and these can result in transient errors\n   (e.g. due to rolling deployments, health check timeouts, etc.)\n\nMultiple external LBs and Ingress Controllers: Craft a solution that meets your\nneeds\nAs a final deployment pattern, we can create advanced configurations consisting\nof multiple external load balancers each of which map to a different Ingress\nController. Users can select a technology-specific Ingress Controller based upon\ndesired feature capabilities (e.g. NGINX or Traefik), and configure Ingress\nresources for underlying applications accordingly. Examples of potential\ncriteria\n[/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/] \nthat may be relevant when comparing candidate controllers include:\n\n * Protocol support: If your needs extend beyond just HTTP(S) and may require\n   routing TCP/UDP or gRPC, it‚Äôs important to recognize that not all controller\n   implementations support the full array of protocols\n * Zero-downtime configuration updates: Not all controllers support\n   configuration updates without incurring downtime\n * High availability (HA): If you want to avoid your ingress controller becoming\n   a potential single point of failure (SPOF) for external traffic, you should\n   identify controllers that support HA configurations\n * Enterprise support: While many open source controller options are available,\n   not all provide enterprise support options that teams can rely on when needed \n\nThe aspects of previous deployment patterns such as configuring\nexternalTrafficPolicy to allow for load spreading or avoiding SNAT can be\nincorporated, with each Ingress Controller potentially configured differently.\nThe ability to easily piece together external load balancers and Ingress\nControllers in a manner that meets the unique business needs of an organization\nexemplifies the benefits that the flexibility of k8s networking can provide.\n\nTo learn more, check out this video\n[https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes] \nwe recorded recently that further explains Kubernetes Ingress and the different\npatterns for external load balancers in k8s\n[https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes]\n.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/05/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes.jpg\" class=\"kg-image\"></figure><p>The great promise of <a href=\"https://kubernetes.io/\">Kubernetes</a> (k8s) is the ability to easily deploy and scale containerized applications. By automating the process of allocating and provisioning compute and storage resources for Pods across nodes, k8s reduces the operational complexity of day-to-day operations. However, orchestrating containers alone doesn‚Äôt necessarily help engineers meet the connectivity requirements for users. Specifically, a Kubernetes Deployment configures Pods with private IP addresses and precludes incoming traffic over the network. Outside of Kubernetes, operators are typically familiar with deploying external load balancers, either in cloud or physical data center environments, to route traffic to application instances. However, effectively mapping these operational patterns to k8s requires understanding how <a href=\"https://kubernetes.io/docs/concepts/services-networking/\">Load Balancers</a> work together with the <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/\">Ingress Controllers</a> in a Kubernetes architecture.</p><h2 id=\"external-load-balancers-and-kubernetes\">External load balancers and Kubernetes</h2><h3 id=\"overview-of-external-lbs-and-k8s\">Overview of external LBs and K8s</h3><p>In order to expose application endpoints, Kubernetes networking allows users to explicitly define <a href=\"https://kubernetes.io/docs/concepts/services-networking/service/\">Services</a>. K8s then automates provisioning appropriate networking resources based upon the service type specified. The NodePort service type exposes an allocated port that can be accessed over the network on each node in the k8s cluster. The LoadBalancer service type uses this same mechanism to deploy and configure an external load balancer (often through a cloud-managed API) which forwards traffic to an application using the NodePort. When a request is routed to the configured port on a node, it forwards packets as needed to direct traffic to the destination Pods using kube-proxy.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/05/services_loadbalancer.png\" class=\"kg-image\" alt=\"External-load-balancer\"><figcaption><strong>Fig. a</strong>: External load balancer defined for each application</figcaption></figure><p>Given the ability to easily define LoadBalancer services to route incoming traffic from external clients, the story may seemingly sound complete. However, in any real-life scenario, directly using external load balancers for every application <em>(fig. a)</em> that needs external access has significant drawbacks including:</p><ul><li><strong>Cost overheads</strong>: External load balancers, whether cloud-managed or instantiated through physical network appliances on-premises, can be expensive. For k8s clusters with many applications, these costs will quickly add up.</li><li><strong>Operational complexity</strong>: Load balancers require various resources (IP addresses, DNS, certificates, etc.) that can be painful to manage, particularly in highly dynamic environments where there may be transient endpoints for staging and development deployments.</li><li><strong>Monitoring and logging</strong>: Given the importance of external load balancers in the traffic flow, being able to effectively centralize monitoring and logging data is critical. However, this may become challenging in practice when there are multiple load balancers involved.</li></ul><h2 id=\"the-perfect-marriage-load-balancers-and-ingress-controllers\">The perfect marriage: Load balancers and Ingress Controllers</h2><p>It‚Äôs clear that external load balancers alone aren‚Äôt a practical solution for providing the networking capabilities necessary for a k8s environment. Luckily, the Kubernetes architecture allows users to combine load balancers with an Ingress Controller. The core concepts are as follows: instead of provisioning an external load balancer for every application service that needs external connectivity, users deploy and configure a single load balancer that targets an Ingress Controller. The Ingress Controller serves as a single entrypoint and can then route traffic to multiple applications in the cluster. Key elements of this approach include:</p><ul><li><strong>Ingress Controllers are k8s applications:</strong> While they may seem somewhat magical, it‚Äôs useful to keep in mind that Ingress Controllers are nothing more than standard Kubernetes applications instantiated via Pods.</li><li><strong>Ingress Controllers are exposed as a service:</strong> The k8s application that constitutes an Ingress Controller is exposed through a LoadBalancer service type thereby mapping it to an external load balancer.</li><li><strong>Ingress Controllers route to underlying applications using ClusterIPs</strong>: As an intermediary between the external load balancer and applications, the Ingress Controller uses ClusterIP service types to route and balance traffic across application instances based upon operator-provided configurations.</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/05/ingress_have_services_too.png\" class=\"kg-image\" alt=\"Dynamic-load-balancing-through-ingress\"><figcaption><strong>Fig. b</strong>: Dynamic load balancing through ingress</figcaption></figure><p>Injecting the Ingress Controller in the traffic path allows users to gain the benefits of external load balancer capabilities while avoiding the pitfalls of relying upon them exclusively <em>(fig. b)</em>. Indeed, the Kubernetes architecture allows operators to integrate multiple Ingress Controllers, thereby providing a high degree of flexibility to meet specific requirements. This can be a bit overwhelming for those new to Kubernetes networking, so let‚Äôs review a few example deployment patterns.</p><h2 id=\"example-deployment-patterns\">Example deployment patterns</h2><h3 id=\"load-balancer-with-nodeports-and-traffic-forwarding\">Load balancer with NodePorts and traffic forwarding</h3><p>As mentioned earlier, a LoadBalancer service type results in an external load balancer that uses NodePorts to reach backend services. Since every node exposes the target port, the load balancer can spread traffic across all of them. However, the underlying Pods may only be running on a subset of the k8s nodes creating the potential need for traffic forwarding. As part of forwarding traffic, the kube-proxy performs source network address translation (SNAT). While this obfuscates the source IP address of requestors, the use of HTTP headers such as X-Forwarded-For (and its standardized variant Forwarded) can be utilized where business requirements require it (e.g. for compliance purposes).</p><h3 id=\"load-balancer-with-nodeports-and-no-snat\">Load balancer with NodePorts and no SNAT</h3><p>To avoid SNAT in the traffic flow, we can modify the previous deployment pattern to force the external load balancer to only target nodes that reflect Pods running the Ingress Controller deployment. Specifically, the externalTrafficPolicy on the LoadBalancer service for the Ingress Controller can be set to Local instead of the default Cluster value. Some potential drawbacks of this pattern, however, include:</p><ul><li><strong>Reduced load-spreading:</strong> Since all traffic is funneled to a subset of nodes, there may be traffic imbalances</li><li><strong>Use of health checks:</strong> The external load balancer uses a health check to determine which nodes to target, and these can result in transient errors (e.g. due to rolling deployments, health check timeouts, etc.)</li></ul><h3 id=\"multiple-external-lbs-and-ingress-controllers-craft-a-solution-that-meets-your-needs\">Multiple external LBs and Ingress Controllers: Craft a solution that meets your needs</h3><p>As a final deployment pattern, we can create advanced configurations consisting of multiple external load balancers each of which map to a different Ingress Controller. Users can select a technology-specific Ingress Controller based upon desired feature capabilities (e.g. NGINX or Traefik), and configure Ingress resources for underlying applications accordingly. <a href=\"https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/\">Examples of potential criteria</a> that may be relevant when comparing candidate controllers include:</p><ul><li><strong>Protocol support</strong>: If your needs extend beyond just HTTP(S) and may require routing TCP/UDP or gRPC, it‚Äôs important to recognize that not all controller implementations support the full array of protocols</li><li><strong>Zero-downtime configuration updates</strong>: Not all controllers support configuration updates without incurring downtime</li><li><strong>High availability (HA)</strong>: If you want to avoid your ingress controller becoming a potential single point of failure (SPOF) for external traffic, you should identify controllers that support HA configurations</li><li><strong>Enterprise support</strong>: While many open source controller options are available, not all provide enterprise support options that teams can rely on when needed </li></ul><p>The aspects of previous deployment patterns such as configuring externalTrafficPolicy to allow for load spreading or avoiding SNAT can be incorporated, with each Ingress Controller potentially configured differently. The ability to easily piece together external load balancers and Ingress Controllers in a manner that meets the unique business needs of an organization exemplifies the benefits that the flexibility of k8s networking can provide.</p><p>To learn more, <strong><a href=\"https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes\">check out this video</a></strong> we recorded recently that further explains <strong><a href=\"https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes\">Kubernetes Ingress and the different patterns for external load balancers in k8s</a></strong>.<br></p>","url":"https://containous.ghost.io/blog/combining-ingress-controllers-and-external-load-balancers-with-kubernetes/","canonical_url":null,"uuid":"8e267865-103f-4587-bfe2-78d34b1a16c6","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eb58b45c49e39004576b610","reading_time":5}},{"node":{"id":"Ghost__Post__5ec861094e2e9a0045ce7983","title":"Five ways to control access to your applications on Kubernetes","slug":"five-ways-to-control-access-to-your-applications-on-kubernetes","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/05/5-ways-to-control-access-to-your-applications-on-Kubernetes-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b860b48631b12a5416a73a890556681c/47498/5-ways-to-control-access-to-your-applications-on-Kubernetes-1.jpg","srcSet":"/static/b860b48631b12a5416a73a890556681c/9dc27/5-ways-to-control-access-to-your-applications-on-Kubernetes-1.jpg 300w,\n/static/b860b48631b12a5416a73a890556681c/4fe8c/5-ways-to-control-access-to-your-applications-on-Kubernetes-1.jpg 600w,\n/static/b860b48631b12a5416a73a890556681c/47498/5-ways-to-control-access-to-your-applications-on-Kubernetes-1.jpg 1200w,\n/static/b860b48631b12a5416a73a890556681c/52258/5-ways-to-control-access-to-your-applications-on-Kubernetes-1.jpg 1800w,\n/static/b860b48631b12a5416a73a890556681c/a41d1/5-ways-to-control-access-to-your-applications-on-Kubernetes-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"How should developers implement access control, particularly authentication, within the context of k8s?","custom_excerpt":"How should developers implement access control, particularly authentication, within the context of k8s?","visibility":"public","created_at_pretty":"22 May, 2020","published_at_pretty":"May 27, 2020","updated_at_pretty":"16 June, 2020","created_at":"2020-05-22T23:32:25.000+00:00","published_at":"2020-05-27T05:20:11.000+00:00","updated_at":"2020-06-16T14:27:07.000+00:00","meta_title":"Five ways to control access to your applications on Kubernetes","meta_description":"How should developers implement access control, particularly authentication, within the context of k8s?","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/05/5-ways-to-control-access-to-your-applications-on-Kubernetes-Twitter.jpg","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Development teams have grown adept at leveraging modern programming languages\nand cloud technologies in a bid to increase their productivity and reduce\ndevelopment cycle times. Given the flexibility of the cloud-native ecosystem,\nthese advancements have also expanded the surface area of security-related\nissues such as access-control. While many organizations are adopting Kubernetes\n[https://kubernetes.io/] (K8s) as their platform of choice for deploying and\nmanaging containerized applications, a natural question arises: How should\ndevelopers implement access control, particularly authentication, within the\ncontext of k8s? In this article, we‚Äôll explore this question by covering the\nfollowing topics:\n\n 1. Reviewing common methods for authentication\n 2. Identifying how some of these methods can be readily integrated with\n    Kubernetes\n\nCommon authentication approaches\nLDAP\nMany organizations have historically adopted some form of directory service\nimplementation such as Active Directory (AD) for storing information including\nuser and organizational data. The majority of these systems support the open \nLightweight Directory Access Protocol (LDAP) protocol\n[https://tools.ietf.org/html/rfc4511] standard. By integrating with LDAP\napplications may seamlessly authenticate users within an organization by\nleveraging the existing user information managed by IT. Moreover, LDAP allows\napplications to utilize additional information such as groups and policies to\nenforce access-control. Therefore, integrating with LDAP for both is a\nreasonable option to consider for line-of-business and internal-facing\nworkloads.\n\nOAuth 2.0\nIn the context of third-party web applications, users often find themselves\nhaving to log in to many disparate systems where a central user identity service\nisn‚Äôt available. While creating unique accounts for each service is an option,\nthis solution does not scale. The OAuth 2.0 protocol\n[https://tools.ietf.org/html/rfc6749] is one approach that can help solve this\nchallenge, and it is commonly used as part of authentication flow\nimplementations such as the OpenID Connect [https://openid.net/connect/] \nstandard. The main benefit of using OAuth 2.0 is it gives the ability for the\nuser to approve delegated access for applications. This enables users to\nleverage existing identity providers (such as their Google account) to\nauthenticate themselves, allowing control over the information being shared,\nwith third-party applications.\n\nJSON Web Token (JWT)\nJSON web tokens [https://tools.ietf.org/html/rfc7519] are an increasingly\npopular choice for authentication, particularly for APIs. These tokens are\ncomposed of Base64URL [https://base64.guru/standards/base64url] encoded JSON\nobjects. Specifically, the token is constructed by concatenating a header JSON\nobject, payload JSON object, and signature. The cryptographic signature is\ncalculated using a shared secret or public/private key pair and can be used to\nauthenticate the source of the object. For example, given a shared secret, a JWT\nsignature can be computed using the HS256 (HMAC with SHA-256) algorithm as\nfollows:\n\nsignature = HS256(\n    Base64URLEncoding(header) + '.' + Base64URLEncoding(payload),\n    secret\n)\n\n\nThe final JWT is derived by concatenation of the three components:\n\nBase64URLEncoding(header) + '.' + Base64URLEncoding(payload) + '.' + signature\n\n\nIt‚Äôs worth noting these tokens won‚Äôt provide data security as they aren‚Äôt\nencrypted but their straight forward approach can be used by APIs to identify\ncallers. JWTs are a good option when integrating authentication providers with\nuser-facing APIs and inter-service communications, and are often implemented\nutilizing OAuth 2.0 flows [https://oauth.net/2/jwt/].\n\nHMAC\nThe JWT example above highlights the use of the HMAC with SHA-256 algorithm\n[https://tools.ietf.org/html/rfc2104.html] when computing the signature of the\ntoken header and payload. The use of HMACs can be generalized in that a\nsignature for any payload can be generated using any number of specifications.\nThe JWT is a special case where the payload happens to be a JSON object but the\nsame mechanism can be used with other data to achieve the objective of\nauthenticating a signed message.\n\nMutual TLS\nTLS authentication [https://en.wikipedia.org/wiki/Transport_Layer_Security] in\nthe context of web applications is fairly ubiquitous these days. The general\nidea is that certificates are used to authenticate a website (or web service) so\nthe client can be confident that the server is who it claims to be. Mutual TLS\nextends this model to be bidirectional. Not only does the client authenticate\nthe server identity, but the server confirms the identity of the client so that\nit may enforce access control and authorization policies. Mutual TLS\n[https://en.wikipedia.org/wiki/Mutual_authentication] is commonly deployed as\npart of inter-service and business-to-business communications where there are a\nlimited and known set of clients that are designed to access common endpoints.\n\nIntegrating application authentication with Kubernetes\nGiven our brief review of common authentication approaches, let‚Äôs turn to the\nquestion of how they can be incorporated when applications are deployed on\nKubernetes. As is often the case with K8s, there is a high degree of flexibility\nto implement a solution that meets the needs of individual organizations. Let‚Äôs\nreview a couple of important patterns that can be adopted for most use cases.\n\nIngress Controllers\nIngress Controllers are the most common mechanism used today when connecting\nusers to applications in Kubernetes\n[/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/].\nThere are many considerations to make when selecting a specific controller, as\neach is often implemented differently and based upon different underlying\ntechnology. Among the many decision criteria when comparing controllers\n[/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/]\n, one must consider how well candidates can support the relevant subset of\nauthentication approaches we‚Äôve highlighted.\n\nTraefik [/traefik/] comes with a built-in ForwardAuth middleware\n[https://docs.traefik.io/middlewares/forwardauth/] feature that can be used to\ndelegate authentication to an external service. By integrating this capability\nas part of your K8s Ingress strategy, all services exposed in the traffic flow\nobtain the benefits of authentication management without incurring the\ncomplexity at the individual service layer. TraefikEE [/traefikee/] simplifies\nthe management of auth providers even further by integrating support for LDAP,\nOAuth 2.0, JWT, and HMAC all within a unified solution.\n\nAuthentication servers\nThe pattern of integrating authentication capabilities through an Ingress\nController can be extended even further by employing dedicated authentication\nservers into the architecture. Authelia [https://github.com/authelia/authelia] \nis an example of an open-source authentication and authorization server which\nworks with K8s and has been successfully integrated with Ingress technologies\nsuch as Traefik. In addition to the mechanisms covered earlier, these\nfunction-specific services can provide advanced authentication capabilities such\nas 2FA [https://en.wikipedia.org/wiki/Multi-factor_authentication] and SSO\n[https://en.wikipedia.org/wiki/Single_sign-on].\n\nConclusion\nControlling application access through authentication is an important\nconsideration in any enterprise scenario, and its importance is only amplified\nwhen adopting Kubernetes. By thoughtfully selecting architectural patterns and\ntechnologies, users can easily integrate their choice of best-practice\nauthentication approaches with minimal additional effort.\n\nThere has never been a better time than now to get started with Traefik in\nKubernetes. Our open-source Traefik edition\n[https://github.com/containous/traefik] with the support of a large and active\ncommunity is available for free and includes support for the most recent\nadvancements in Kubernetes Ingress technology. If you‚Äôre an enterprise looking\nto implement the most popular cloud-native load balancer with commercial\nsupport, high-availability, and authentication modules already built-in you\nshould schedule a demo [https://info.containo.us/request-demo-traefikee] with\nour sales team and learn more about how we make networking boring.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/05/5-ways-to-control-access-to-your-applications-on-Kubernetes.jpg\" class=\"kg-image\" alt=\"Kubernetes Authentication\"></figure><!--kg-card-begin: markdown--><p>Development teams have grown adept at leveraging modern programming languages and cloud technologies in a bid to increase their productivity and reduce development cycle times. Given the flexibility of the cloud-native ecosystem, these advancements have also expanded the surface area of security-related issues such as access-control. While many organizations are adopting <a href=\"https://kubernetes.io/\">Kubernetes</a> (K8s) as their platform of choice for deploying and managing containerized applications, a natural question arises: How should developers implement access control, particularly authentication, within the context of k8s? In this article, we‚Äôll explore this question by covering the following topics:</p>\n<ol>\n<li>Reviewing common methods for authentication</li>\n<li>Identifying how some of these methods can be readily integrated with Kubernetes</li>\n</ol>\n<!--kg-card-end: markdown--><h2 id=\"common-authentication-approaches\">Common authentication approaches</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/05/Common-authentication-approaches@1x.jpg\" class=\"kg-image\" alt=\"Common Authentication Approach\"></figure><!--kg-card-begin: markdown--><h3 id=\"ldap\">LDAP</h3>\n<p>Many organizations have historically adopted some form of directory service implementation such as Active Directory (AD) for storing information including user and organizational data. The majority of these systems support the open <a href=\"https://tools.ietf.org/html/rfc4511\" target=\"_blank\" rel=\"nofollow\">Lightweight Directory Access Protocol (LDAP) protocol</a> standard. By integrating with LDAP applications may seamlessly authenticate users within an organization by leveraging the existing user information managed by IT. Moreover, LDAP allows applications to utilize additional information such as groups and policies to enforce access-control. Therefore, integrating with LDAP for both is a reasonable option to consider for line-of-business and internal-facing workloads.</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id=\"oauth20\">OAuth 2.0</h3>\n<p>In the context of third-party web applications, users often find themselves having to log in to many disparate systems where a central user identity service isn‚Äôt available. While creating unique accounts for each service is an option, this solution does not scale. The <a href=\"https://tools.ietf.org/html/rfc6749\" target=\"_blank\" rel=\"nofollow\">OAuth 2.0 protocol</a> is one approach that can help solve this challenge, and it is commonly used as part of authentication flow implementations such as the <a href=\"https://openid.net/connect/\" target=\"_blank\" rel=\"nofollow\">OpenID Connect</a> standard. The main benefit of using OAuth 2.0 is it gives the ability for the user to approve delegated access for applications. This enables users to leverage existing identity providers (such as their Google account) to authenticate themselves, allowing control over the information being shared, with third-party applications.</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id=\"jsonwebtokenjwt\">JSON Web Token (JWT)</h3>\n<p><a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"nofollow\">JSON web tokens</a> are an increasingly popular choice for authentication, particularly for APIs. These tokens are composed of <a href=\"https://base64.guru/standards/base64url\" target=\"_blank\" rel=\"nofollow\">Base64URL</a> encoded JSON objects. Specifically, the token is constructed by concatenating a header JSON object, payload JSON object, and signature. The cryptographic signature is calculated using a shared secret or public/private key pair and can be used to authenticate the source of the object. For example, given a shared secret, a JWT signature can be computed using the HS256 (HMAC with SHA-256) algorithm as follows:</p>\n<pre><code>signature = HS256(\n    Base64URLEncoding(header) + '.' + Base64URLEncoding(payload),\n    secret\n)\n</code></pre>\n<p>The final JWT is derived by concatenation of the three components:</p>\n<pre><code>Base64URLEncoding(header) + '.' + Base64URLEncoding(payload) + '.' + signature\n</code></pre>\n<p>It‚Äôs worth noting these tokens won‚Äôt provide data security as they aren‚Äôt encrypted but their straight forward approach can be used by APIs to identify callers. JWTs are a good option when integrating authentication providers with user-facing APIs and inter-service communications, and are often implemented utilizing <a href=\"https://oauth.net/2/jwt/\" target=\"_blank\" rel=\"nofollow\">OAuth 2.0 flows</a>.</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id=\"hmac\">HMAC</h3>\n<p>The JWT example above highlights the use of the <a href=\"https://tools.ietf.org/html/rfc2104.html\" target=\"_blank\" rel=\"nofollow\">HMAC with SHA-256 algorithm</a> when computing the signature of the token header and payload. The use of HMACs can be generalized in that a signature for any payload can be generated using any number of specifications. The JWT is a special case where the payload happens to be a JSON object but the same mechanism can be used with other data to achieve the objective of authenticating a signed message.</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id=\"mutualtls\">Mutual TLS</h3>\n<p><a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\" target=\"_blank\" rel=\"nofollow\">TLS authentication</a> in the context of web applications is fairly ubiquitous these days. The general idea is that certificates are used to authenticate a website (or web service) so the client can be confident that the server is who it claims to be. Mutual TLS extends this model to be bidirectional. Not only does the client authenticate the server identity, but the server confirms the identity of the client so that it may enforce access control and authorization policies. <a href=\"https://en.wikipedia.org/wiki/Mutual_authentication\" target=\"_blank\" rel=\"nofollow\">Mutual TLS</a> is commonly deployed as part of inter-service and business-to-business communications where there are a limited and known set of clients that are designed to access common endpoints.</p>\n<!--kg-card-end: markdown--><h2 id=\"integrating-application-authentication-with-kubernetes\">Integrating application authentication with Kubernetes</h2><p>Given our brief review of common authentication approaches, let‚Äôs turn to the question of how they can be incorporated when applications are deployed on Kubernetes. As is often the case with K8s, there is a high degree of flexibility to implement a solution that meets the needs of individual organizations. Let‚Äôs review a couple of important patterns that can be adopted for most use cases.</p><h3 id=\"ingress-controllers\">Ingress Controllers</h3><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/05/Traefik-Ingress-Controller.jpg\" class=\"kg-image\" alt=\"Ingress Controller with Traefik\"></figure><!--kg-card-begin: markdown--><p>Ingress Controllers are the most common mechanism used today when <a href=\"https://containous.ghost.io/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/\">connecting users to applications in Kubernetes</a>. There are many considerations to make when selecting a specific controller, as each is often implemented differently and based upon different underlying technology. Among the many <a href=\"https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/\">decision criteria when comparing controllers</a>, one must consider how well candidates can support the relevant subset of authentication approaches we‚Äôve highlighted.</p>\n<p><a href=\"https://containous.ghost.io/traefik/\">Traefik</a> comes with a built-in <a href=\"https://docs.traefik.io/middlewares/forwardauth/\">ForwardAuth middleware</a> feature that can be used to delegate authentication to an external service. By integrating this capability as part of your K8s Ingress strategy, all services exposed in the traffic flow obtain the benefits of authentication management without incurring the complexity at the individual service layer. <a href=\"https://containous.ghost.io/traefikee/\">TraefikEE</a> simplifies the management of auth providers even further by integrating support for LDAP, OAuth 2.0, JWT, and HMAC all within a unified solution.</p>\n<h3 id=\"authenticationservers\">Authentication servers</h3>\n<p>The pattern of integrating authentication capabilities through an Ingress Controller can be extended even further by employing dedicated authentication servers into the architecture. <a href=\"https://github.com/authelia/authelia\" target=\"_blank\" rel=\"nofollow\">Authelia</a> is an example of an open-source authentication and authorization server which works with K8s and has been successfully integrated with Ingress technologies such as Traefik. In addition to the mechanisms covered earlier, these function-specific services can provide advanced authentication capabilities such as <a href=\"https://en.wikipedia.org/wiki/Multi-factor_authentication\" target=\"_blank\" rel=\"nofollow\">2FA</a> and <a href=\"https://en.wikipedia.org/wiki/Single_sign-on\" target=\"_blank\" rel=\"nofollow\">SSO</a>.</p>\n<h3 id=\"conclusion\">Conclusion</h3>\n<p>Controlling application access through authentication is an important consideration in any enterprise scenario, and its importance is only amplified when adopting Kubernetes. By thoughtfully selecting architectural patterns and technologies, users can easily integrate their choice of best-practice authentication approaches with minimal additional effort.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/05/TraefikEE-Ingress-Controller.jpg\" class=\"kg-image\" alt=\"Ingress Controller with TraefikEE\"></figure><!--kg-card-begin: markdown--><p>There has never been a better time than now to get started with Traefik in Kubernetes. Our <a href=\"https://github.com/containous/traefik\">open-source Traefik edition</a> with the support of a large and active community is available for free and includes support for the most recent advancements in Kubernetes Ingress technology. If you‚Äôre an enterprise looking to implement the most popular cloud-native load balancer with commercial support, high-availability, and authentication modules already built-in you should <a href=\"https://info.containo.us/request-demo-traefikee\" target=\"_blank\" rel=\"nofollow\">schedule a demo</a> with our sales team and learn more about how we make networking boring.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/five-ways-to-control-access-to-your-applications-on-kubernetes/","canonical_url":null,"uuid":"26e84f80-3637-4600-82da-292eb70149e2","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ec861094e2e9a0045ce7983","reading_time":5}},{"node":{"id":"Ghost__Post__5ec2a072c49e39004576b7ad","title":"Kubernetes Ingress & Service API Demystified","slug":"kubernetes-ingress-service-api-demystified","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/d9aac10cdc9e917545bdb3e3680ce4f2/47498/Kubernetes-Ingress---Service-API-Demystified-1.jpg","srcSet":"/static/d9aac10cdc9e917545bdb3e3680ce4f2/9dc27/Kubernetes-Ingress---Service-API-Demystified-1.jpg 300w,\n/static/d9aac10cdc9e917545bdb3e3680ce4f2/4fe8c/Kubernetes-Ingress---Service-API-Demystified-1.jpg 600w,\n/static/d9aac10cdc9e917545bdb3e3680ce4f2/47498/Kubernetes-Ingress---Service-API-Demystified-1.jpg 1200w,\n/static/d9aac10cdc9e917545bdb3e3680ce4f2/52258/Kubernetes-Ingress---Service-API-Demystified-1.jpg 1800w,\n/static/d9aac10cdc9e917545bdb3e3680ce4f2/a41d1/Kubernetes-Ingress---Service-API-Demystified-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"The Ingress Object itself already has a long history with K8s. It is still considered beta, which is kinda surprising for something that has been so long present in K8s. But why is that? And when will that change?","custom_excerpt":"The Ingress Object itself already has a long history with K8s. It is still considered beta, which is kinda surprising for something that has been so long present in K8s. But why is that? And when will that change?","visibility":"public","created_at_pretty":"18 May, 2020","published_at_pretty":"June 2, 2020","updated_at_pretty":"14 October, 2020","created_at":"2020-05-18T14:49:22.000+00:00","published_at":"2020-06-02T14:24:25.000+00:00","updated_at":"2020-10-14T05:00:57.000+00:00","meta_title":"Kubernetes Ingress & Service API Demystified","meta_description":"This blog covers some of the long-standing issues with the current state of Ingress in Kubernetes, as well as the new Service API aimed at solving them.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified-2.jpg","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"The Ingress Object itself already has a long history with K8s. It is still\nconsidered beta, which is kinda surprising for something that has been so long\npresent in K8s. But why is that? And when will that change?\n\nWith the release of Kubernetes 1.18, some improvements\n[https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/] \nhave been made to Ingress, which have been overdue for a long time. However, the\nchanges introduced are minor, and some of the issues we‚Äôll be covering in this\nblog post have gone untackled. In addition to covering the issues mentioned\nabove, we‚Äôll be exploring the new Service API aimed at solving these issues.\n\nIssues\nIn this blog post we‚Äôll cover some of the long-standing issues with the current\nstate of Ingress in Kubernetes, including these topics:\n\n * Inflexible HTTP routing definitions\n * Schema differences across vendors\n * Extensibility of Ingress\n\nInflexible HTTP routing definitions\nA simple Ingress object example is the following:\n\n---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-ingress\nspec:\n  rules:\n  - http:\n      paths:\n      - Host: myhost.com\n  path: /testpath\n        pathType: Prefix\n        backend:\nserviceName: test\n \tservicePort: 80\n\n\nThe above Ingress object will route HTTP requests with the URI ¬†GET \nhttp://myhost.com/testpath and forward the request internally to the service\ncalled test on port 80. So far, so good.\n\nThe primary focus of an ingress resource is on solving simple HTTP routing\ncases, similar to the concept of Virtual Hosts with a Path Based routing\nextension. This leads us to the first issue: How would you configure cases like\na redirect?\n\nSchema differences across vendors\nFurther configuration is usually done through annotations on the Ingress\nresource. Annotations are like key-value pairs stored in the metadata of an\nobject.\n\n---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-ingress\n  nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - http:\n      paths:\n      - Host: myhost.com\n  path: /testpath\n        pathType: Prefix\n        backend:\nserviceName: test\n \tservicePort: 80\n\n\nThe above example shows that the Ingress Controller (nginx) would rewrite all\nrequests to / (slash) before forwarding to the backend.\n\nConsider that the same configuration in Traefik would look like this:\n\n--- \napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata: \n  name: rewrite-slash\nspec: \n  replacePath: \n    path: /\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: whoami-ingress\n  annotations:\n    kubernetes.io/ingress.class: traefik              \n    traefik.ingress.kubernetes.io/router.middlewares: default-rewrite-slash@kubernetescrd\nspec:\n  rules:\n  - host: whoami.localhost\n    http:\n      paths:\n      - path: /foobar\n        backend:\n          serviceName: whoami\n          servicePort: web\n\n\n\nAs you can see, it‚Äôs totally different! Which brings us to another issue:\nextensibility. \n\nExtensibility of Ingress\nExtending Ingress Objects is a requirement and the de-facto standard for that is\nusing annotations. However, annotations often differ between the many different\nimplementations of ¬†Ingress Controllers and it's therefore hard to manage for an\nend-user.\n\nThis unmanageability also translates back to the providers who must maintain\ntheir ingress controller implementation, who are often constrained by the\nsimplicity of the key / value pair approach.\n\nService API aka Ingress V2\nAnnounced at Kubecon NA in 2019 by Google there has been substantial effort in\n¬†creating an ‚ÄúIngress V2‚Äù which is now known as the Service API\n[https://github.com/kubernetes-sigs/service-apis].\n\nThis specification aims to solve a few problems:\n\n * Provide clean separation and role-based control\n * Uplevel the Ingress specification\n * Specify standard methods of extending the Ingress specification\n\nTo do so, the specification currently consists of 4 different CRD Ressources:\n\nGatewayclass\nThe GatewayClass is meant to be a Cluster Scoped resource, which is meant to\nrepresent a ‚Äúcategory‚Äù of gateways. It‚Äôs similar to the former `ingress.class`\nannotation or the now included IngressClass resource.\n\nThe expected use-case is to have more than one GatewayClass per Ingress\nController provider. These classes may have a variety of default settings, which\nare inherited by the cluster-level gateway. Also, this can be used to pass\nadditional configuration down to that gateway. Since it is a cluster scoped\nresource, it's expected to be managed by the Infrastructure provider.\n\n---\nkind: GatewayClass\nmetadata:\n  name: cluster-gateway\nspec:\n  controller: \"acme.io/gateway-controller\"\n  parametersRef:\n    apiVersion: core/v1\n    kind: ConfigMap\n    namespace: acme-system\n    name: internet-gateway\n\n\nGateway\nThe gateway has a life-cycle which is tied with the infrastructure. For\ninstance, one Gateway could be running an instance of Traefik or one AWS ELB. As\nalready mentioned, it‚Äôs linked to a Gateway class for inferring configuration.\n\nThe gateway sets listener bindings (Address, Ports, TLS‚Ä¶) and the routes served\nby the gateway.\n\n---\nkind: Gateway\nname: my-app-gw\nnamespace: my-app\nspec:\n  class: from-internet\n  listeners:\n  - address:\n      ip: 1.2.3.4\n    protocols: [\"http\"] # implies port 80.\n    routes:\n      ...\n  - address:\n      ip: 1.2.3.4\n    protocols: [\"https\"] # implies port 443\n    certificates:\n    - name: my-secret\n    - apiGroup: certmanager.k8s.io\n      kind: Certificate               \n      name: lets-encrypt-cert\n    routes:\n      - route:\n        name: http-app-1\n        namespace: app-1\n        kind: HTTPRoute\n\n\nIt also has some sane default protocols like: http, https, TCP‚Ä¶ which map to\npredefined ports.\n\nRoute\nLast but not least, a route is used to describe a way to handle traffic given\nprotocol level descriptions.\n\nA route can be of a different ressource (HTTPRoute, TLSRoute, TCPRoute‚Ä¶) and can\ntherefore have different protocol level descriptions taken into consideration\nfor routing. Each of these Protocols have different attributes which could be\nused for route matching. It can also be used to delegate to other Route\nResources in a multi-tenant scenario, for example, where ¬†one team offers a\nglobal authentication service where you would want to forward from within your\ncurrent scope.\n\n---\nkind: HTTPRoute\nname: delegate-1\nnamespace: other-team\nrules:\n- match:\n    http:\n      host: bar.com\n      path:\n        prefix: /store\n  action:\n    backend:                           \n      name: delegate-1                  \n      namespace: other-team             \n      kind: HTTPRoute\n      apiGroup: networking.k8s.io\n\n\nIn the above HTTPRoute example it‚Äôs listening for traffic with a host of bar.com\nand looking for a Pathprefix of /store, which is close to some of the examples\nwe‚Äôve explored on ¬†traditional Ingress but allows for some additional specifics.\n\nExtensibility\nTaking what we just learned to the next level, the question that arrives now is:\n‚ÄúHow can we extend that, for example, to implement Rewrites?‚Äù\n\nFor that purpose, the specification currently offers three different levels of\nsupport:\n\n * Core\n * Extended\n * Custom\n\nCore functionality is guaranteed between all solutions respecting a specific set\nof API‚Äôs. Extended is a standardised API, but functionality is not guaranteed\nbetween all solutions.\n\nFor special use-cases, which might be vendor specific, there‚Äôs a custom layer\nwhere the implementation can be custom built to meet specific requirements.\nUsually, these will end up in CRD‚Äôs or custom annotations.\n\nSumUp\nService API is a new set of forward-looking API‚Äôs attempting to solve some\nissues that have become apparent over the evolving usage of Ingress. However, as\nit‚Äôs a bit more complex and might not solve all the simple use cases Ingress is\ncapable of solving, it‚Äôs not meant to replace Ingress but rather provide an\nalternative for complex use cases.\n\nEventually, Traefik itself will support the new Service API spec. In the\nmeantime, we offer support for both native Kubernetes Ingress and have extended\nsupport for Ingress through the use of CRDs. Learn more about how we do both\nand\nempower developers with flexible and easy to use Kubernetes Ingress\n[/solutions/kubernetes-ingress/].","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg\" class=\"kg-image\" alt=\"Kubernetes Ingress &amp; Service API Demystified\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 1600w, https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>The Ingress Object itself already has a long history with K8s. It is still considered beta, which is kinda surprising for something that has been so long present in K8s. But why is that? And when will that change?</p><p>With the release of Kubernetes 1.18, some <a href=\"https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/\">improvements</a> have been made to Ingress, which have been overdue for a long time. However, the changes introduced are minor, and some of the issues we‚Äôll be covering in this blog post have gone untackled. In addition to covering the issues mentioned above, we‚Äôll be exploring the new Service API aimed at solving these issues.</p><h2 id=\"issues\">Issues</h2><p>In this blog post we‚Äôll cover some of the long-standing issues with the current state of Ingress in Kubernetes, including these topics:</p><ul><li>Inflexible HTTP routing definitions</li><li>Schema differences across vendors</li><li>Extensibility of Ingress</li></ul><h2 id=\"inflexible-http-routing-definitions\">Inflexible HTTP routing definitions</h2><p>A simple Ingress object example is the following:</p><!--kg-card-begin: markdown--><pre><code>---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-ingress\nspec:\n  rules:\n  - http:\n      paths:\n      - Host: myhost.com\n  path: /testpath\n        pathType: Prefix\n        backend:\nserviceName: test\n \tservicePort: 80\n</code></pre>\n<!--kg-card-end: markdown--><p>The above Ingress object will route HTTP requests with the URI ¬†GET <em>http://myhost.com/testpath</em> and forward the request internally to the service called test on port 80. So far, so good.</p><p>The primary focus of an ingress resource is on solving simple HTTP routing cases, similar to the concept of Virtual Hosts with a Path Based routing extension. This leads us to the first issue: How would you configure cases like a redirect?</p><h2 id=\"schema-differences-across-vendors\">Schema differences across vendors</h2><p>Further configuration is usually done through annotations on the Ingress resource. Annotations are like key-value pairs stored in the metadata of an object.</p><!--kg-card-begin: markdown--><pre><code>---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-ingress\n  nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - http:\n      paths:\n      - Host: myhost.com\n  path: /testpath\n        pathType: Prefix\n        backend:\nserviceName: test\n \tservicePort: 80\n</code></pre>\n<!--kg-card-end: markdown--><p>The above example shows that the Ingress Controller (nginx) would rewrite all requests to / (slash) before forwarding to the backend.</p><p>Consider that the same configuration in Traefik would look like this:</p><!--kg-card-begin: markdown--><pre><code>--- \napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata: \n  name: rewrite-slash\nspec: \n  replacePath: \n    path: /\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: whoami-ingress\n  annotations:\n    kubernetes.io/ingress.class: traefik              \n    traefik.ingress.kubernetes.io/router.middlewares: default-rewrite-slash@kubernetescrd\nspec:\n  rules:\n  - host: whoami.localhost\n    http:\n      paths:\n      - path: /foobar\n        backend:\n          serviceName: whoami\n          servicePort: web\n\n</code></pre>\n<!--kg-card-end: markdown--><p>As you can see, it‚Äôs totally different! Which brings us to another issue: extensibility. </p><h2 id=\"extensibility-of-ingress\">Extensibility of Ingress</h2><p>Extending Ingress Objects is a requirement and the de-facto standard for that is using annotations. However, annotations often differ between the many different implementations of ¬†Ingress Controllers and it's therefore hard to manage for an end-user.</p><p>This unmanageability also translates back to the providers who must maintain their ingress controller implementation, who are often constrained by the simplicity of the key / value pair approach.</p><h2 id=\"service-api-aka-ingress-v2\">Service API aka Ingress V2</h2><p>Announced at Kubecon NA in 2019 by Google there has been substantial effort in ¬†creating an ‚ÄúIngress V2‚Äù which is now known as the <a href=\"https://github.com/kubernetes-sigs/service-apis\">Service API</a>.</p><p>This specification aims to solve a few problems:</p><ul><li>Provide clean separation and role-based control</li><li>Uplevel the Ingress specification</li><li>Specify standard methods of extending the Ingress specification</li></ul><p>To do so, the specification currently consists of 4 different CRD Ressources:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh4.googleusercontent.com/bVzQquzU0GRBFEZBpOLTIniju6zwytLAlLcRP52swLC2GF4Vqw4855Uu-OQFVZdPG5bZ-C8kg9EfLb5L21JpXegV6wwkOJnXDh5EaY2do5--ouHYeDfUbARTSOdWCBhpv2jXVWUM\" class=\"kg-image\" alt></figure><h2 id=\"gatewayclass\">Gatewayclass</h2><p>The GatewayClass is meant to be a Cluster Scoped resource, which is meant to represent a ‚Äúcategory‚Äù of gateways. It‚Äôs similar to the former `ingress.class` annotation or the now included IngressClass resource.</p><p>The expected use-case is to have more than one GatewayClass per Ingress Controller provider. These classes may have a variety of default settings, which are inherited by the cluster-level gateway. Also, this can be used to pass additional configuration down to that gateway. Since it is a cluster scoped resource, it's expected to be managed by the Infrastructure provider.</p><!--kg-card-begin: markdown--><pre><code>---\nkind: GatewayClass\nmetadata:\n  name: cluster-gateway\nspec:\n  controller: &quot;acme.io/gateway-controller&quot;\n  parametersRef:\n    apiVersion: core/v1\n    kind: ConfigMap\n    namespace: acme-system\n    name: internet-gateway\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"gateway\">Gateway</h2><p>The gateway has a life-cycle which is tied with the infrastructure. For instance, one Gateway could be running an instance of Traefik or one AWS ELB. As already mentioned, it‚Äôs linked to a Gateway class for inferring configuration.</p><p>The gateway sets listener bindings (Address, Ports, TLS‚Ä¶) and the routes served by the gateway.</p><!--kg-card-begin: markdown--><pre><code>---\nkind: Gateway\nname: my-app-gw\nnamespace: my-app\nspec:\n  class: from-internet\n  listeners:\n  - address:\n      ip: 1.2.3.4\n    protocols: [&quot;http&quot;] # implies port 80.\n    routes:\n      ...\n  - address:\n      ip: 1.2.3.4\n    protocols: [&quot;https&quot;] # implies port 443\n    certificates:\n    - name: my-secret\n    - apiGroup: certmanager.k8s.io\n      kind: Certificate               \n      name: lets-encrypt-cert\n    routes:\n      - route:\n        name: http-app-1\n        namespace: app-1\n        kind: HTTPRoute\n</code></pre>\n<!--kg-card-end: markdown--><p>It also has some sane default protocols like: http, https, TCP‚Ä¶ which map to predefined ports.</p><h2 id=\"route\">Route</h2><p>Last but not least, a route is used to describe a way to handle traffic given protocol level descriptions.</p><p>A route can be of a different ressource (HTTPRoute, TLSRoute, TCPRoute‚Ä¶) and can therefore have different protocol level descriptions taken into consideration for routing. Each of these Protocols have different attributes which could be used for route matching. It can also be used to delegate to other Route Resources in a multi-tenant scenario, for example, where ¬†one team offers a global authentication service where you would want to forward from within your current scope.</p><!--kg-card-begin: markdown--><pre><code>---\nkind: HTTPRoute\nname: delegate-1\nnamespace: other-team\nrules:\n- match:\n    http:\n      host: bar.com\n      path:\n        prefix: /store\n  action:\n    backend:                           \n      name: delegate-1                  \n      namespace: other-team             \n      kind: HTTPRoute\n      apiGroup: networking.k8s.io\n</code></pre>\n<!--kg-card-end: markdown--><p>In the above HTTPRoute example it‚Äôs listening for traffic with a host of bar.com and looking for a Pathprefix of /store, which is close to some of the examples we‚Äôve explored on ¬†traditional Ingress but allows for some additional specifics.</p><h2 id=\"extensibility\">Extensibility</h2><p>Taking what we just learned to the next level, the question that arrives now is: ‚ÄúHow can we extend that, for example, to implement Rewrites?‚Äù</p><p>For that purpose, the specification currently offers three different levels of support:</p><ul><li>Core</li><li>Extended</li><li>Custom</li></ul><p>Core functionality is guaranteed between all solutions respecting a specific set of API‚Äôs. Extended is a standardised API, but functionality is not guaranteed between all solutions.</p><p>For special use-cases, which might be vendor specific, there‚Äôs a custom layer where the implementation can be custom built to meet specific requirements. Usually, these will end up in CRD‚Äôs or custom annotations.</p><h2 id=\"sumup\">SumUp</h2><p>Service API is a new set of forward-looking API‚Äôs attempting to solve some issues that have become apparent over the evolving usage of Ingress. However, as it‚Äôs a bit more complex and might not solve all the simple use cases Ingress is capable of solving, it‚Äôs not meant to replace Ingress but rather provide an alternative for complex use cases.</p><p>Eventually, Traefik itself will support the new Service API spec. In the meantime, we offer support for both native Kubernetes Ingress and have extended support for Ingress through the use of CRDs. Learn more about <a href=\"https://containous.ghost.io/solutions/kubernetes-ingress/\">how we do both and empower developers with flexible and easy to use Kubernetes Ingress</a>.<br></p>","url":"https://containous.ghost.io/blog/kubernetes-ingress-service-api-demystified/","canonical_url":null,"uuid":"a1c9986a-1406-40fe-9274-993271aed29f","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ec2a072c49e39004576b7ad","reading_time":5}},{"node":{"id":"Ghost__Post__5ec806bb4e2e9a0045ce791f","title":"Gradual Migration from Traefik 1.x to 2.x","slug":"gradual-migration-from-traefik-1-to-2","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/47498/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg","srcSet":"/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/9dc27/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 300w,\n/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/4fe8c/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 600w,\n/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/47498/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 1200w,\n/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/52258/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 1800w,\n/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/a41d1/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"In this post, I will share a migration strategy that helped me move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback.","custom_excerpt":"In this post, I will share a migration strategy that helped me move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback.","visibility":"public","created_at_pretty":"22 May, 2020","published_at_pretty":"June 9, 2020","updated_at_pretty":"25 August, 2020","created_at":"2020-05-22T17:07:07.000+00:00","published_at":"2020-06-09T05:33:17.000+00:00","updated_at":"2020-08-25T22:50:45.000+00:00","meta_title":"Gradual Migration from Traefik 1.x to 2.x","meta_description":"This post shares a migration strategy that helped move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x-Twitter.png","twitter_title":null,"authors":[{"name":"Juan Carlos Mej√≠as Rodr√≠guez","slug":"greenled","bio":"DevOps engineer and lecturer at the University of Camag√ºey, Cuba. Specialized on continuous integration, Linux and Docker containers. Developing, deploying and monitoring web applications since 2015.","profile_image":"//www.gravatar.com/avatar/23f5bab61dffbd57974ca32a6d65dba5?s=250&d=mm&r=x","twitter":"@greenled2013","facebook":null,"website":"https://greenled.github.io"}],"primary_author":{"name":"Juan Carlos Mej√≠as Rodr√≠guez","slug":"greenled","bio":"DevOps engineer and lecturer at the University of Camag√ºey, Cuba. Specialized on continuous integration, Linux and Docker containers. Developing, deploying and monitoring web applications since 2015.","profile_image":"//www.gravatar.com/avatar/23f5bab61dffbd57974ca32a6d65dba5?s=250&d=mm&r=x","twitter":"@greenled2013","facebook":null,"website":"https://greenled.github.io"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#community-related-resource","slug":"hash-community-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"},{"name":"#traefik-related-resource","slug":"hash-traefik-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Guest post by Juan Carlos Mej√≠as, Traefik Ambassador\n\nAre you a happy Traefik user? Join the club! I use Traefik as a reverse proxy to\nmanage the ingress of several dozen services in a Docker Swarm cluster, and\ncouldn't be happier with it. Since its introduction in early 2015, Traefik has\ngrown in maturity and popularity (don't take my word, look at the project's\nstargazers over time [https://star-history.t9t.io/#containous/traefik]. When\nTraefik v2 was released I couldn't help but think about migrating, but I had one\nmajor concern: downtime.\n\nTraefik's documentation explains how to migrate configurations from 1.x format\nto 2.x format however, as in any system with some degree of complexity,\nmigrating is not just about changing configurations but managing them. You have\nto make sure everything keeps running smoothly and be prepared to rollback in\ncase something goes wrong -have you heard of Murphy's Law? Also, you probably\ndon't want to migrate the whole system at a time, or you could quickly find\nyourself trying to put out more fires than you can handle.\n\nIn this post, I will share a migration strategy that helped me move to Traefik 2\nwith very little downtime, one service at a time, with an easy way to rollback.\nFor the sake of clarity and brevity, I will start from a single Traefik instance\nwith two backend services and will keep everything in a single Docker Swarm\nstack. The same strategy could be used in a clustered Traefik deployment with\nmany more backend services as well. In fact, this scenario is where Traefik\nshines the brightest.\n\nInitial setup\nLet's start from the following setup, with a Traefik 1 instance as a reverse\nproxy and two Nginx services, all running on Docker Swarm:\n\nInitial setup. Traefik 1 handling all routingThis configuration can be deployed\nto the swarm with the following stack definition:\n\n# docker-compose.yaml\n\n# Version >= 3.3 so configs are available\nversion: \"3.4\"\n\nnetworks:\n  traefik-public:\n    external: true\n\nconfigs:\n  index1:\n    # Contains string \"1\"\n    file: ./index1.html\n  index2:\n    # Contains string \"2\"\n    file: ./index2.html\n\nservices:\n  traefik1:\n    image: traefik:v1.7\n    ports:\n      - \"80:80\"\n    volumes:\n      # So that Traefik can listen to the Docker events\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: >\n      --docker\n      --docker.swarmmode\n      --entrypoints='Name:http Address::80'\n    networks:\n      - traefik-public\n\n  web1:\n    image: nginx:1-alpine\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.frontend.rule=Host:web1.docker.local\n        - traefik.port=80\n        - traefik.webservice.frontend.entryPoints=http\n    configs:\n      - source: index1\n        target: /usr/share/nginx/html/index.html\n    networks:\n      - traefik-public\n\n  web2:\n    image: nginx:1-alpine\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.frontend.rule=Host:web2.docker.local\n        - traefik.port=80\n        - traefik.webservice.frontend.entryPoints=http\n    configs:\n      - source: index2\n        target: /usr/share/nginx/html/index.html\n    networks:\n      - traefik-public\n\n\nFiles index1.html and index1.html contain strings 1 and 2 respectively:\n\necho 1 > index1.html\necho 2 > index2.html\n\n\nWith the above configuration, you can now create a Docker Swarm (if you don't\nalready have one), an overlay network for Traefik and deploy the stack:\n\ndocker swarm init\ndocker network create --driver=overlay traefik-public\ndocker stack deploy -c docker-compose.yaml traefik\n\n\nWhen the stack deployment finishes you will be able to query the defined Nginx\nservices as web1.docker.local and web2.docker.local. In the example below I‚Äôm\nusing curl:\n\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 2\n\n\nIt may take a few seconds to start the containers so if you get a 404 page not\nfound response just wait and try again.\n\nTraefik 2 with fallback to Traefik 1\nYou now have a working Traefik 1.x reverse proxy and two backend services. Let's\nmigrate it to 2.x! Next you are going to add a Traefik 2 service which will run\nalongside and proxy requests to the existing one. Incoming requests will be\nrouted to the Traefik 2 service and if no routes are matched they will then be\nrouted to the Traefik 1 service.\n\nTraefik 2 routing all requests to Traefik 1Deploy these changes to the stack\ndefinition file:\n\n # docker-compose.yaml\n\n ...\n configs:\n   ...\n+  # Dynamic configuration for Traefik 2 (see below)\n+  traefik2-providers:\n+    file: ./traefik2-providers.yaml\n\n services:\n   traefik1:\n     image: traefik:v1.7\n-    ports:\n-      - \"80:80\"\n   ...\n+  traefik2:\n+    image: traefik:v2.1\n+    ports:\n+      # The HTTP port\n+      - \"80:80\"\n+    volumes:\n+      # So that Traefik can listen to the Docker events\n+      - /var/run/docker.sock:/var/run/docker.sock\n+    command: >\n+      --providers.docker\n+      --providers.docker.swarmMode\n+      --providers.file.directory=/etc/traefik\n+      --providers.file.filename=providers.yaml\n+      --entryPoints.http.address=:80\n+      --api.insecure\n+    configs:\n+      - source: traefik2-providers\n+        target: /etc/traefik/providers.yaml\n+    networks:\n+      - traefik-public\n\n\nThe traefik2-providers.yaml file used in the traefik2-providers config directive\nfor the traefik2 service defines a catch-all route that forwards unmatched\nrequests to the traefik1 service:\n\n# traefik2-providers.yaml\n\nhttp:\n  routers:\n    # Define a catch-all router that forwards requests to legacy Traefik\n    to-traefik1:\n      # Catch all domains (regex matches all strings)\n      # See https://github.com/google/re2/wiki/Syntax\n      rule: \"HostRegexp(`{domain:.+}`)\"\n      # If the rule matches, forward to the traefik1 service (see below)\n      service: traefik1\n      # Set the lowest priority, so this route is only used as a last resort\n      priority: 1\n\n  services:\n    # Define how to reach legacy Traefik\n    traefik1:\n      loadBalancer:\n        servers:\n          # Legacy Traefik is part of the same stack so,\n          # hostname defaults to service name\n          - url: http://traefik1\n\n\nRedeploy the stack and check everything is still working as expected:\n\ndocker stack deploy -c docker-compose.yaml traefik\n# ...\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web2.docker.local http://127.0.0.1\n# 2\n\n\nTraefik 2 replacing Traefik 1\nNext let's set up Traefik 2 to handle requests to web1, as in Image 3:\n\nTraefik 2 handling web1 service's routingThis setup can be achieved by updating web1 service labels to match Traefik 2\nformat as follows:\n\n...\nservices:\n  ...\n  web1:\n    ...\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.http.routers.web1.rule=Host(`web1.docker.local`)\n        - traefik.http.services.web1.loadbalancer.server.port=80\n    ...\n\n\nRedeploy the stack and again check everything is still working as expected:\n\ndocker stack deploy -c docker-compose.yaml traefik\n# ...\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web2.docker.local http://127.0.0.1\n# 2\n\n\nNow repeat the process for web2 service. If something goes wrong, you just need\nto revert to a previous working configuration for the affected service,\nredeploy, and start over. In a real-world scenario with lots of services,\nmigration can take place one service at a time like this, reducing downtime.\nWhen you finish migrating to Traefik 2, take down the Traefik 1 service. You\nwill then end up with this scenario:\n\nTraefik 2 handling all routingWrapping Up\nAnd that's it! You‚Äôve successfully migrated from Traefik [/traefik/] 1.x to 2.x\none service at a time. This step by step migration strategy comes from the\nStranglerFigApplication pattern, as described by Martin Fowler\n[https://martinfowler.com/bliki/StranglerFigApplication.html]. As a final note,\nI would highly recommend putting your configurations under version control as\nthat would make it very easy to roll back changes when needed.\n\nAuthor's Bio\nJuan Carlos is a lecturer at the Informatics and Exact Sciences Faculty of the\nUniversity of Camag√ºey, Cuba, [https://www.reduc.edu.cu/] and also DevOps\nengineer at the same institution. He has specialized on version control,\ncontinuous integration and deployment, Linux, and Docker containers. Since 2015\nhe has developed, deployed and monitored web applications for the University's\nIT infrastructure.","html":"<p><strong>Guest post by Juan Carlos Mej√≠as, Traefik Ambassador</strong></p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg\" class=\"kg-image\" alt=\"Gradual Migration from Traefik 1.x to 2.x\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 1600w, https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><!--kg-card-begin: markdown--><p>Are you a happy Traefik user? Join the club! I use Traefik as a reverse proxy to manage the ingress of several dozen services in a Docker Swarm cluster, and couldn't be happier with it. Since its introduction in early 2015, Traefik has grown in maturity and popularity (don't take my word, look at <a href=\"https://star-history.t9t.io/#containous/traefik\" target=\"_blank\" rel=\"nofollow\">the project's stargazers over time</a>. When Traefik v2 was released  I couldn't help but think about migrating, but I had one major concern: downtime.</p>\n<p>Traefik's documentation explains how to migrate configurations from 1.x format to 2.x format however, as in any system with some degree of complexity, migrating is not just about changing configurations but managing them. You have to make sure everything keeps running smoothly and be prepared to rollback in case something goes wrong -have you heard of Murphy's Law? Also, you probably don't want to migrate the whole system at a time, or you could quickly find yourself trying to put out more fires than you can handle.</p>\n<p>In this post, I will share a migration strategy that helped me move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback. For the sake of clarity and brevity, I will start from a single Traefik instance with two backend services and will keep everything in a single Docker Swarm stack. The same strategy could be used in a clustered Traefik deployment with many more backend services as well. In fact, this scenario is where Traefik shines the brightest.</p>\n<h2 id=\"initialsetup\">Initial setup</h2>\n<p>Let's start from the following setup, with a Traefik 1 instance as a reverse proxy and two Nginx services, all running on Docker Swarm:</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/06/1-diagram1-traefik1-handling-all-routing.png\" class=\"kg-image\" alt=\"Initial setup. Traefik 1 handling all routing\"><figcaption>Initial setup. Traefik 1 handling all routing</figcaption></figure><!--kg-card-begin: markdown--><p>This configuration can be deployed to the swarm with the following stack definition:</p>\n<pre><code class=\"language-yaml\"># docker-compose.yaml\n\n# Version &gt;= 3.3 so configs are available\nversion: &quot;3.4&quot;\n\nnetworks:\n  traefik-public:\n    external: true\n\nconfigs:\n  index1:\n    # Contains string &quot;1&quot;\n    file: ./index1.html\n  index2:\n    # Contains string &quot;2&quot;\n    file: ./index2.html\n\nservices:\n  traefik1:\n    image: traefik:v1.7\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      # So that Traefik can listen to the Docker events\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: &gt;\n      --docker\n      --docker.swarmmode\n      --entrypoints='Name:http Address::80'\n    networks:\n      - traefik-public\n\n  web1:\n    image: nginx:1-alpine\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.frontend.rule=Host:web1.docker.local\n        - traefik.port=80\n        - traefik.webservice.frontend.entryPoints=http\n    configs:\n      - source: index1\n        target: /usr/share/nginx/html/index.html\n    networks:\n      - traefik-public\n\n  web2:\n    image: nginx:1-alpine\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.frontend.rule=Host:web2.docker.local\n        - traefik.port=80\n        - traefik.webservice.frontend.entryPoints=http\n    configs:\n      - source: index2\n        target: /usr/share/nginx/html/index.html\n    networks:\n      - traefik-public\n</code></pre>\n<p>Files <code>index1.html</code> and <code>index1.html</code> contain strings <code>1</code> and <code>2</code> respectively:</p>\n<pre><code class=\"language-bash\">echo 1 &gt; index1.html\necho 2 &gt; index2.html\n</code></pre>\n<p>With the above configuration, you can now create a Docker Swarm (if you don't already have one), an overlay network for Traefik and deploy the stack:</p>\n<pre><code class=\"language-bash\">docker swarm init\ndocker network create --driver=overlay traefik-public\ndocker stack deploy -c docker-compose.yaml traefik\n</code></pre>\n<p>When the stack deployment finishes you will be able to query the defined Nginx services as <code>web1.docker.local</code> and <code>web2.docker.local</code>. In the example below I‚Äôm using curl:</p>\n<pre><code class=\"language-bash\">curl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 2\n</code></pre>\n<p>It may take a few seconds to start the containers so if you get a <code>404 page not found</code> response just wait and try again.</p>\n<h2 id=\"traefik2withfallbacktotraefik1\">Traefik 2 with fallback to Traefik 1</h2>\n<p>You now  have a working Traefik 1.x reverse proxy and two backend services. Let's migrate it to 2.x! Next you are going to add a Traefik 2 service which will run alongside and proxy requests to the existing one. Incoming requests will be routed to the Traefik 2 service and if no routes are matched they will then be routed to the  Traefik 1 service.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/06/2-diagram2-traefik2-routing-requests-to-traefik1.png\" class=\"kg-image\" alt=\"Traefik 2 routing all requests to Traefik 1\"><figcaption>Traefik 2 routing all requests to Traefik 1</figcaption></figure><!--kg-card-begin: markdown--><p>Deploy these changes to the stack definition file:</p>\n<pre><code class=\"language-diff\"> # docker-compose.yaml\n\n ...\n configs:\n   ...\n+  # Dynamic configuration for Traefik 2 (see below)\n+  traefik2-providers:\n+    file: ./traefik2-providers.yaml\n\n services:\n   traefik1:\n     image: traefik:v1.7\n-    ports:\n-      - &quot;80:80&quot;\n   ...\n+  traefik2:\n+    image: traefik:v2.1\n+    ports:\n+      # The HTTP port\n+      - &quot;80:80&quot;\n+    volumes:\n+      # So that Traefik can listen to the Docker events\n+      - /var/run/docker.sock:/var/run/docker.sock\n+    command: &gt;\n+      --providers.docker\n+      --providers.docker.swarmMode\n+      --providers.file.directory=/etc/traefik\n+      --providers.file.filename=providers.yaml\n+      --entryPoints.http.address=:80\n+      --api.insecure\n+    configs:\n+      - source: traefik2-providers\n+        target: /etc/traefik/providers.yaml\n+    networks:\n+      - traefik-public\n</code></pre>\n<p>The <code>traefik2-providers.yaml</code> file used in the <code>traefik2-providers</code> config directive for the <code>traefik2</code> service defines a catch-all route that forwards unmatched requests to the <code>traefik1</code> service:</p>\n<pre><code class=\"language-yaml\"># traefik2-providers.yaml\n\nhttp:\n  routers:\n    # Define a catch-all router that forwards requests to legacy Traefik\n    to-traefik1:\n      # Catch all domains (regex matches all strings)\n      # See https://github.com/google/re2/wiki/Syntax\n      rule: &quot;HostRegexp(`{domain:.+}`)&quot;\n      # If the rule matches, forward to the traefik1 service (see below)\n      service: traefik1\n      # Set the lowest priority, so this route is only used as a last resort\n      priority: 1\n\n  services:\n    # Define how to reach legacy Traefik\n    traefik1:\n      loadBalancer:\n        servers:\n          # Legacy Traefik is part of the same stack so,\n          # hostname defaults to service name\n          - url: http://traefik1\n</code></pre>\n<p>Redeploy the stack and check everything is still  working as expected:</p>\n<pre><code class=\"language-bash\">docker stack deploy -c docker-compose.yaml traefik\n# ...\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web2.docker.local http://127.0.0.1\n# 2\n</code></pre>\n<h2 id=\"traefik2replacingtraefik1\">Traefik 2 replacing Traefik 1</h2>\n<p>Next let's set up Traefik 2 to handle requests to <code>web1</code>, as in Image 3:</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/06/3-diagram3-traefik2-handling-web1-routing.png\" class=\"kg-image\" alt=\"Traefik 2 handling web1 service's routing\"><figcaption>Traefik 2 handling web1 service's routing</figcaption></figure><!--kg-card-begin: markdown--><p>This setup can be achieved by updating <code>web1</code> service labels to match Traefik 2 format as follows:</p>\n<pre><code class=\"language-yaml\">...\nservices:\n  ...\n  web1:\n    ...\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.http.routers.web1.rule=Host(`web1.docker.local`)\n        - traefik.http.services.web1.loadbalancer.server.port=80\n    ...\n</code></pre>\n<p>Redeploy the stack and again check everything is still working as expected:</p>\n<pre><code class=\"language-bash\">docker stack deploy -c docker-compose.yaml traefik\n# ...\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web2.docker.local http://127.0.0.1\n# 2\n</code></pre>\n<p>Now repeat the process for <code>web2</code> service. If something goes wrong, you just need to revert to a previous working configuration for the affected service, redeploy, and start over. In a real-world scenario with lots of services, migration can take place one service at a time like this, reducing downtime.<br>\nWhen you finish migrating to Traefik 2, take down the Traefik 1 service. You will then end up with this scenario:</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/06/4-diagram4-traefik2-handling-all-routing.png\" class=\"kg-image\" alt=\"Traefik 2 handling all routing\"><figcaption>Traefik 2 handling all routing</figcaption></figure><!--kg-card-begin: markdown--><h2 id=\"wrappingup\">Wrapping Up</h2>\n<p>And that's it! You‚Äôve successfully migrated from <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> 1.x to 2.x one service at a time. This step by step migration strategy comes from the StranglerFigApplication pattern, as <a href=\"https://martinfowler.com/bliki/StranglerFigApplication.html\" target=\"_blank\" rel=\"nofollow\">described by Martin Fowler</a>. As a final note, I would highly recommend putting your configurations under version control as that would make it very easy to roll back changes when needed.</p>\n<h3 id=\"authorsbio\">Author's Bio</h3>\n<p>Juan Carlos is a lecturer at the <a href=\"https://www.reduc.edu.cu/\">Informatics and Exact Sciences Faculty of the University of Camag√ºey, Cuba,</a> and also DevOps engineer at the same institution. He has specialized on version control, continuous integration and deployment, Linux, and Docker containers. Since 2015 he has developed, deployed and monitored web applications for the University's IT infrastructure.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/gradual-migration-from-traefik-1-to-2/","canonical_url":null,"uuid":"54e054d8-0db0-4a41-9c09-13d3db8daeb1","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ec806bb4e2e9a0045ce791f","reading_time":6}},{"node":{"id":"Ghost__Post__5ee81ca7292c470045af26fe","title":"Securing your Kubernetes environment against external traffic threats","slug":"securing-your-kubernetes-environment-against-external-traffic-threats","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/06/Securing-your-Kubernetes-environment-against-external-traffic-threats-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/c597de81abf63dccc70c384729c03cf7/47498/Securing-your-Kubernetes-environment-against-external-traffic-threats-1.jpg","srcSet":"/static/c597de81abf63dccc70c384729c03cf7/9dc27/Securing-your-Kubernetes-environment-against-external-traffic-threats-1.jpg 300w,\n/static/c597de81abf63dccc70c384729c03cf7/4fe8c/Securing-your-Kubernetes-environment-against-external-traffic-threats-1.jpg 600w,\n/static/c597de81abf63dccc70c384729c03cf7/47498/Securing-your-Kubernetes-environment-against-external-traffic-threats-1.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Kubernetes is often used to manage external-facing applications, so the need for protecting applications from harmful external traffic is nearly universal.","custom_excerpt":"Kubernetes is often used to manage external-facing applications, so the need for protecting applications from harmful external traffic is nearly universal.","visibility":"public","created_at_pretty":"16 June, 2020","published_at_pretty":"June 16, 2020","updated_at_pretty":"10 September, 2020","created_at":"2020-06-16T01:13:11.000+00:00","published_at":"2020-06-16T14:27:27.000+00:00","updated_at":"2020-09-10T05:14:27.000+00:00","meta_title":"Securing Kubernetes environment against external traffic threats","meta_description":"Kubernetes is often used to manage external-facing applications, so the need for protecting applications from harmful external traffic is nearly universal.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/06/Securing-your-Kubernetes-environment-against-external-traffic-threats-Twitter.jpg","twitter_title":null,"authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Kubernetes delivers many quality-of-life improvements for software engineering\nteams out of the box by automating the deployment and lifecycle management of\ncontainerized applications. However, security is one area where developers must\nstill be proactive, by identifying threat models and applying appropriate\nKubernetes security best practices to address them. \n\nGiven that Kubernetes is often used to manage external-facing applications, the\nneed for protecting applications from harmful external traffic is nearly\nuniversal. In this article we‚Äôll review some of the general concerns that\ndevelopers should keep in mind in this context, and then discuss relevant\nKubernetes security approaches.\n\nTop external traffic concerns\nWhen it comes to security issues from external traffic, there are myriad\nconcerns that range from unintentional but detrimental behavior to organized,\nmalevolent attacks.\n\nUnfair usage\nAny application of even moderate complexity will exhibit significant variance in\nresource usage and execution time of requests. For example, certain operations\nmight trigger backend batch jobs or invoke complicated queries to datastores.\nAccordingly, the overall load imposed by a specific external client will be a\nfunction of the request types it sends and their distribution over time (for\nexample, bursty versus parallel requests). Because of this, it‚Äôs possible for a\nclient to unintentionally use an unfair portion of provisioned resources and\nnegatively impact other users.\n\nMisconfigured clients\nParticularly for API services, it‚Äôs common for incoming external traffic to have\nbeen generated by automated systems or client software whose behavior is driven\nby user-specific configuration settings. Settings that are misconfigured ‚Äì\nwhether maliciously or unintentionally ‚Äì can lead to anomalous behavior, which\ncan easily lead to undesirable load on the Kubernetes-managed application.\n\nMalicious clients\nAn unfortunate reality for any internet-facing application is that it will\ninevitably face nefarious attempts to identify and/or exploit potential security\nvulnerabilities in the software and gain some form of unauthorized access. Such\nattacks include zero-day exploits and brute-force attempts to penetrate the\nsystem, among others. If successful, these attacks can have significant negative\nconsequences beyond application downtime, including data breaches.\n\nDenial-of-service (DDoS) and distributed denial-of-service (DDoS)\nA malicious attacker may also intentionally try to limit or disrupt the resource\navailability for legitimate traffic, in what is known as a denial-of-service\n(DoS) attack. Such attacks often combine several of the previously mentioned\nelements. In their more sophisticated form, known as distributed\ndenial-of-service (DDoS), they can also be orchestrated such that a distributed\nand possible dynamic set of clients works together to send malformed or\nexcessive traffic simultaneously.\n\nMitigation strategies\nHaving reviewed the top concerns that harmful external traffic creates for\napplications, let‚Äôs look at some approaches to mitigating them. Specifically, by\nemploying an Ingress controller for Kubernetes\n[https://containo.us/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/]\n, multiple options become available to consider as part of a comprehensive\nsecurity strategy.\n\nIP allow/deny lists\nOne approach to integrating security best practices is to employ network-level\nmechanisms. Specifically, the IP addresses of external traffic can be used to\nmake binary decisions on whether the traffic should be allowed at all. If\napplications have a stable set of known clients, a proactive allow list approach\nin which unknown IP addresses are ignored may be applicable. On the other hand,\nif valid traffic could come from anywhere, a reactive deny list can be\nmaintained based upon the identification of malicious traffic sources.\n\nConnection limits\nAnother network-level option is to limit the number of connections that an\nexternal client can create, which can help limit the impact of misconfigured\nclients as well as malicious users. One potential challenge, however, lies in\ndetermining an appropriate value to set for the connection limit. Many\nimplementations require a global setting that impacts all sources of traffic.\nParticularly when imposing connection limits by source IP address, scenarios in\nwhich multiple clients may share an IP address ‚Äì such as NAT, for example ‚Äì\nshould be considered.\n\nRate limiting\nMoving up the networking stack, an Ingress controller can be used to enable rate\nlimiting at the request level. These limits gate the number of requests in a\ngiven time window (for example, requests per second) and can be enforced in a\nvariety of ways. Common options include setting rate limits based upon client IP\naddress or a value in the HTTP header. Rate limits can also be configured so a\nmaximum request rate is enforced at service hosts.\n\nLimiting simultaneous requests\nAs mentioned earlier, request-processing times may vary based on a variety of\nfactors. While rate limits can enforce the number of external requests submitted\nby a client in a given time frame, the number of concurrent requests being\nprocessed may vary significantly depending upon the relative processing time of\neach type of request. To address this dimension, external traffic can be managed\nby setting limits so that services don‚Äôt become overwhelmed by a large number of\nsimultaneous, resource-intensive requests.\n\nAudit logging\nA question that often arises is how operations engineers can determine when the\naforementioned mitigation mechanisms should be invoked, as well as their overall\neffectiveness. For example, it‚Äôs preferable to detect DDoS attacks in their\nearliest stages to minimize disruption to end users. How to spot them when they\nstart? Access logs can be invaluable for this purpose. They are commonly\nincorporated as part of a broader security information and event management\n(SIEM) system. When employed with Kubernetes Ingress controllers like Traefik,\nthese logs also make it possible to automate remediation strategies based upon\ndetected external traffic patterns.\n\nStay vigilant\nWhen considering how best to protect workloads from harmful external traffic,\nthe most effective approach will likely require a combination of several of the\nmechanisms we‚Äôve discussed. But which ones? The need for any one measure may not\nbe immediately apparent, so its utility should be continuously reviewed with the\nhelp of data from audit logs. It‚Äôs important that applications teams consider\nthe ability of their Kubernetes platform to provide a broad set of mechanisms\nthat can be called upon as security requirements change and evolve. \n\nSolutions like TraefikEE [https://containo.us/traefikee/] align well with this\nmindset by providing a rich and robust set of security features for managing\nexternal traffic embedded in the Kubernetes Ingress controller\n[https://containo.us/solutions/kubernetes-ingress/]. Learn more about TraefikEE\nin this 5-minute video [https://info.containo.us/request-demo-traefikee].","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/06/Securing-your-Kubernetes-environment-against-external-traffic-threats.jpg\" class=\"kg-image\" alt=\"Securing your Kubernetes environment\"></figure><p>Kubernetes delivers many quality-of-life improvements for software engineering teams out of the box by automating the deployment and lifecycle management of containerized applications. However, security is one area where developers must still be proactive, by identifying threat models and applying appropriate Kubernetes security best practices to address them. </p><p>Given that Kubernetes is often used to manage external-facing applications, the need for protecting applications from harmful external traffic is nearly universal. In this article we‚Äôll review some of the general concerns that developers should keep in mind in this context, and then discuss relevant Kubernetes security approaches.</p><h2 id=\"top-external-traffic-concerns\">Top external traffic concerns</h2><p>When it comes to security issues from external traffic, there are myriad concerns that range from unintentional but detrimental behavior to organized, malevolent attacks.</p><h3 id=\"unfair-usage\">Unfair usage</h3><p>Any application of even moderate complexity will exhibit significant variance in resource usage and execution time of requests. For example, certain operations might trigger backend batch jobs or invoke complicated queries to datastores. Accordingly, the overall load imposed by a specific external client will be a function of the request types it sends and their distribution over time (for example, bursty versus parallel requests). Because of this, it‚Äôs possible for a client to unintentionally use an unfair portion of provisioned resources and negatively impact other users.</p><h3 id=\"misconfigured-clients\">Misconfigured clients</h3><p>Particularly for API services, it‚Äôs common for incoming external traffic to have been generated by automated systems or client software whose behavior is driven by user-specific configuration settings. Settings that are misconfigured ‚Äì whether maliciously or unintentionally ‚Äì can lead to anomalous behavior, which can easily lead to undesirable load on the Kubernetes-managed application.</p><h3 id=\"malicious-clients\">Malicious clients</h3><p>An unfortunate reality for any internet-facing application is that it will inevitably face nefarious attempts to identify and/or exploit potential security vulnerabilities in the software and gain some form of unauthorized access. Such attacks include zero-day exploits and brute-force attempts to penetrate the system, among others. If successful, these attacks can have significant negative consequences beyond application downtime, including data breaches.</p><h3 id=\"denial-of-service-ddos-and-distributed-denial-of-service-ddos-\">Denial-of-service (DDoS) and distributed denial-of-service (DDoS)</h3><p>A malicious attacker may also intentionally try to limit or disrupt the resource availability for legitimate traffic, in what is known as a denial-of-service (DoS) attack. Such attacks often combine several of the previously mentioned elements. In their more sophisticated form, known as distributed denial-of-service (DDoS), they can also be orchestrated such that a distributed and possible dynamic set of clients works together to send malformed or excessive traffic simultaneously.</p><h2 id=\"mitigation-strategies\">Mitigation strategies</h2><p>Having reviewed the top concerns that harmful external traffic creates for applications, let‚Äôs look at some approaches to mitigating them. Specifically, by employing an <a href=\"https://containo.us/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/\">Ingress controller for Kubernetes</a>, multiple options become available to consider as part of a comprehensive security strategy.</p><h3 id=\"ip-allow-deny-lists\">IP allow/deny lists</h3><p>One approach to integrating security best practices is to employ network-level mechanisms. Specifically, the IP addresses of external traffic can be used to make binary decisions on whether the traffic should be allowed at all. If applications have a stable set of known clients, a proactive allow list approach in which unknown IP addresses are ignored may be applicable. On the other hand, if valid traffic could come from anywhere, a reactive deny list can be maintained based upon the identification of malicious traffic sources.</p><h3 id=\"connection-limits\">Connection limits</h3><p>Another network-level option is to limit the number of connections that an external client can create, which can help limit the impact of misconfigured clients as well as malicious users. One potential challenge, however, lies in determining an appropriate value to set for the connection limit. Many implementations require a global setting that impacts all sources of traffic. Particularly when imposing connection limits by source IP address, scenarios in which multiple clients may share an IP address ‚Äì such as NAT, for example ‚Äì should be considered.</p><h3 id=\"rate-limiting\">Rate limiting</h3><p>Moving up the networking stack, an Ingress controller can be used to enable rate limiting at the request level. These limits gate the number of requests in a given time window (for example, requests per second) and can be enforced in a variety of ways. Common options include setting rate limits based upon client IP address or a value in the HTTP header. Rate limits can also be configured so a maximum request rate is enforced at service hosts.</p><h3 id=\"limiting-simultaneous-requests\">Limiting simultaneous requests</h3><p>As mentioned earlier, request-processing times may vary based on a variety of factors. While rate limits can enforce the number of external requests submitted by a client in a given time frame, the number of concurrent requests being processed may vary significantly depending upon the relative processing time of each type of request. To address this dimension, external traffic can be managed by setting limits so that services don‚Äôt become overwhelmed by a large number of simultaneous, resource-intensive requests.</p><h3 id=\"audit-logging\">Audit logging</h3><p>A question that often arises is how operations engineers can determine when the aforementioned mitigation mechanisms should be invoked, as well as their overall effectiveness. For example, it‚Äôs preferable to detect DDoS attacks in their earliest stages to minimize disruption to end users. How to spot them when they start? Access logs can be invaluable for this purpose. They are commonly incorporated as part of a broader security information and event management (SIEM) system. When employed with Kubernetes Ingress controllers like Traefik, these logs also make it possible to automate remediation strategies based upon detected external traffic patterns.</p><h2 id=\"stay-vigilant\">Stay vigilant</h2><p>When considering how best to protect workloads from harmful external traffic, the most effective approach will likely require a combination of several of the mechanisms we‚Äôve discussed. But which ones? The need for any one measure may not be immediately apparent, so its utility should be continuously reviewed with the help of data from audit logs. It‚Äôs important that applications teams consider the ability of their Kubernetes platform to provide a broad set of mechanisms that can be called upon as security requirements change and evolve. </p><!--kg-card-begin: markdown--><p>Solutions like <a href=\"https://containo.us/traefikee/\">TraefikEE</a> align well with this mindset by providing a rich and robust set of security features for managing external traffic embedded in the <a href=\"https://containo.us/solutions/kubernetes-ingress/\">Kubernetes Ingress controller</a>. Learn more about TraefikEE in <a href=\"https://info.containo.us/request-demo-traefikee\" target=\"_blank\" rel=\"nofollow\">this 5-minute video</a>.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/securing-your-kubernetes-environment-against-external-traffic-threats/","canonical_url":null,"uuid":"2da8c425-5cf1-4594-83bf-f9732530e7e0","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ee81ca7292c470045af26fe","reading_time":4}},{"node":{"id":"Ghost__Post__5ef263fe60f25700399d089d","title":"Beyond Kubernetes: Bringing Microservices Together with Service Mesh","slug":"beyond-kubernetes-bringing-microservices-together-with-service-mesh","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/06/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/9c9a2faffb966d5a2991625087a01021/47498/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh.jpg","srcSet":"/static/9c9a2faffb966d5a2991625087a01021/9dc27/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh.jpg 300w,\n/static/9c9a2faffb966d5a2991625087a01021/4fe8c/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh.jpg 600w,\n/static/9c9a2faffb966d5a2991625087a01021/47498/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"When adopting microservices, Kubernetes alone may not be enough to handle more complex networking challenges that arise. This is the job of a service mesh.","custom_excerpt":"When adopting microservices, Kubernetes alone may not be enough to handle more complex networking challenges that arise. This is the job of a service mesh.","visibility":"public","created_at_pretty":"23 June, 2020","published_at_pretty":"June 24, 2020","updated_at_pretty":"16 July, 2020","created_at":"2020-06-23T20:20:14.000+00:00","published_at":"2020-06-24T06:43:11.000+00:00","updated_at":"2020-07-16T13:26:09.000+00:00","meta_title":"Beyond Kubernetes: Bringing Microservices Together with Service Mesh","meta_description":"When adopting microservices, Kubernetes alone may not be enough to handle more complex networking challenges that arise. This is the job of a service mesh.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/06/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh---Twitter.jpg","twitter_title":null,"authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"When adopting the microservices application model, Kubernetes is a natural\nstarting point. Extensible, open source, and with a thriving ecosystem,\nKubernetes has emerged as the go-to orchestrator for containerized\ninfrastructure. When used as the foundation for microservices, however, you may\nfind that Kubernetes alone isn‚Äôt enough to handle the more complex networking\nchallenges that arise. This is the job of a service mesh.\n\nOne of the most important aspects to consider about the microservices model is\nits heavy dependence on networking. Unfortunately, a network is seldom as\nreliable or resilient as its hypothetical diagram suggests. Services fail,\nnetwork routes change or disappear, and unexpected traffic can disrupt normal\nusage patterns. This is even more true for containerized microservices, which by\ntheir nature tend to be stateless, ephemeral, and disposable. Maintaining the\nperformance and stability of such an environment is anything but simple.\nKubernetes addresses the first part of this challenge by automating the\nlifecycles of containers and their associated applications. When coupled with an \nIngress controller\n[https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/],\nsuch as Contour or Traefik [/traefik/], Kubernetes also manages communications\nfrom the external network to workloads running in the cluster and vice versa\n(sometimes called north-south traffic).\n\nService Mesh BasicsOf equal importance in a microservices environment, however,\nare communications between services within the cluster (known as east-west \ntraffic). While basic networking within the cluster is handled by Kubernetes\nitself, a service mesh is a dedicated infrastructure layer that handles many of\nthe routine networking tasks that are necessary for a loose collection of\ncontainerized services to work together as a cohesive application.\n\nThe Role of Service Mesh\nAn important property of a service mesh is that it decouples east-west\nnetworking functions from application logic. As the environment scales and new\nservices are added to the mix, they should be able to expect the same level of\nmanagement as their peers, without code changes or refactoring. Examples of\nfunctions of a service mesh include:\n\nTraffic control. Communications between the cluster and the external network\nrequire routing and management, and so do communications between services on the\ncluster. Tasks such as advanced load balancing\n[https://en.wikipedia.org/wiki/Load_balancing_(computing)] and rate limiting\n[https://cloud.google.com/solutions/rate-limiting-strategies-techniques] of\nservice-to-service traffic are primary functions of the service mesh, which\nhelps to prevent and contain disruptions and performance degradations that\nmisconfigured or misbehaving services can cause.\n\nSecurity. Even when ingress controls are in place to protect the cluster from\nexternal networking threats, attackers may still attempt to exploit trusted\nrelationships between services on the cluster. A service mesh can help here by\nproviding seamless authentication, access control, and management of encrypted\nlinks between services, among other security features.\n\nObservability. Another important factor is the ability of a service mesh to\nprovide consistent logging, metrics, and visibility into the inner workings of a\ncluster. The insights gained from these functions are invaluable for maintaining\nthe health and proper operation of microservices-based applications.\n\nOptions and Standards\nOver the years, various forms of application middleware have implemented\neast-west networking functions in various ways. It is only since the rise of\ncontainerized infrastructure, and Kubernetes in particular, that the concept of\na service mesh as a dedicated layer has truly crystallized. Even so, opinions on\nhow a mesh should be implemented still differ.\n\nStandardization offers some hope for clarity. Recently, a consortium of\ncloud-native software vendors has begun collaborating on the Service Mesh\nInterface (SMI) [https://smi-spec.io/], an evolving effort that is shepherded by\nthe Cloud Native Computing Foundation (CNCF) [https://cncf.io/]. The SMI\nspecification defines APIs for many of the networking functions described\nearlier. Still, these APIs can be implemented in multiple ways.\n\nThe sidecar pattern\n[https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/#example-1-sidecar-containers] \nis one way to design a service mesh for Kubernetes. In this model, a so-called\nsidecar container is deployed alongside each instance of a service within a pod\nto handle east-west traffic for that instance. This is a popular pattern for\nimplementing a service mesh, and is the method adopted by the likes of Istio and\nLinkerd (the latter a CNCF incubating project).\n\nAn alternative method is to deploy a service mesh proxy endpoint that runs as\nits own pod on each node of a cluster, using the Kubernetes concept of a \nDaemonSet [https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/]\n. This method has the advantage of being less invasive, in that the mesh proxy\ndoes not need to modify any Kubernetes objects and no network traffic is\nmodified without a service owner‚Äôs consent. This is the model adopted by Maesh\n[/maesh/].\n\nHow to Move Forward\nSo, while standardization helps make it easier to know what to expect from a\nservice mesh, important decisions remain before adopting a specific solution.\nEven choosing how to begin deploying a mesh can be challenging, owing to the\npotential for disruption of existing communication patterns within a cluster.\n\nThese decisions are made significantly easier when dealing with so-called\ngreenfield projects, where the clustered, microservices-based application is\nbuilt from the ground up, without dependencies on legacy infrastructure. This is\na happy situation to have, but it‚Äôs not always realistic, especially in\nenvironments where adoption of containerization is already mature.\n\nIf it will be necessary to run some services on a service mesh alongside other\nservices for which it is preferable to have them manage their own east-west\ntraffic, it may be worth looking for a loosely coupled solution, such as Maesh.\nThis has the advantage of allowing the teams that own individual services to opt\ninto the mesh when they are ready, rather than forcing a mass migration with\ninterdependencies that may be difficult to test.\n\nHowever you choose to proceed, the key takeaway should be that service mesh for\nKubernetes, while still an emerging technology, can often provide the ‚Äúmissing\npiece‚Äù that Kubernetes alone does not. By abstracting key east-west networking\nfeatures away from application logic, mesh solutions enable distributed,\nmicroservices-based applications to operate in a way that is managed,\nobservable, and secure, both when communicating with the outside world and\nwithin the cluster itself.\n\nTo learn more, check out this video\n[https://info.containo.us/video-understanding-service-mesh] about the advantages\nand disadvantages of a service mesh, and the appropriate situations for using\none.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/06/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh-1.jpg\" class=\"kg-image\" alt=\"Bringing microservices together with service mesh\"></figure><p>When adopting the microservices application model, Kubernetes is a natural starting point. Extensible, open source, and with a thriving ecosystem, Kubernetes has emerged as the go-to orchestrator for containerized infrastructure. When used as the foundation for microservices, however, you may find that Kubernetes alone isn‚Äôt enough to handle the more complex networking challenges that arise. This is the job of a <strong>service mesh</strong>.</p><p>One of the most important aspects to consider about the microservices model is its heavy dependence on networking. Unfortunately, a network is seldom as reliable or resilient as its hypothetical diagram suggests. Services fail, network routes change or disappear, and unexpected traffic can disrupt normal usage patterns. This is even more true for containerized microservices, which by their nature tend to be stateless, ephemeral, and disposable. Maintaining the performance and stability of such an environment is anything but simple. Kubernetes addresses the first part of this challenge by automating the lifecycles of containers and their associated applications. When coupled with an <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/\">Ingress controller</a>, such as Contour or <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, Kubernetes also manages communications from the external network to workloads running in the cluster and vice versa (sometimes called <em>north-south</em> traffic).</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/06/Service-Mesh-Diagram@2x.jpg\" class=\"kg-image\" alt=\"Service Mesh Basics\"><figcaption>Service Mesh Basics</figcaption></figure><p>Of equal importance in a microservices environment, however, are communications between services within the cluster (known as <em>east-west</em> traffic). While basic networking within the cluster is handled by Kubernetes itself, a service mesh is a dedicated infrastructure layer that handles many of the routine networking tasks that are necessary for a loose collection of containerized services to work together as a cohesive application.</p><h2 id=\"the-role-of-service-mesh\">The Role of Service Mesh</h2><p>An important property of a service mesh is that it decouples east-west networking functions from application logic. As the environment scales and new services are added to the mix, they should be able to expect the same level of management as their peers, without code changes or refactoring. Examples of functions of a service mesh include:</p><!--kg-card-begin: markdown--><p><strong>Traffic control.</strong> Communications between the cluster and the external network require routing and management, and so do communications between services on the cluster. Tasks such as advanced <a href=\"https://en.wikipedia.org/wiki/Load_balancing_(computing)\" target=\"_blank\" rel=\"nofollow\">load balancing</a> and <a href=\"https://cloud.google.com/solutions/rate-limiting-strategies-techniques\" target=\"_blank\" rel=\"nofollow\">rate limiting</a> of service-to-service traffic are primary functions of the service mesh, which helps to prevent and contain disruptions and performance degradations that misconfigured or misbehaving services can cause.</p>\n<!--kg-card-end: markdown--><p><strong>Security. </strong>Even when ingress controls are in place to protect the cluster from external networking threats, attackers may still attempt to exploit trusted relationships between services on the cluster. A service mesh can help here by providing seamless authentication, access control, and management of encrypted links between services, among other security features.</p><p><strong>Observability. </strong>Another important factor is the ability of a service mesh to provide consistent logging, metrics, and visibility into the inner workings of a cluster. The insights gained from these functions are invaluable for maintaining the health and proper operation of microservices-based applications.</p><h2 id=\"options-and-standards\">Options and Standards</h2><p>Over the years, various forms of application middleware have implemented east-west networking functions in various ways. It is only since the rise of containerized infrastructure, and Kubernetes in particular, that the concept of a service mesh as a dedicated layer has truly crystallized. Even so, opinions on how a mesh should be implemented still differ.</p><p>Standardization offers some hope for clarity. Recently, a consortium of cloud-native software vendors has begun collaborating on the<a href=\"https://smi-spec.io/\"> Service Mesh Interface (SMI)</a>, an evolving effort that is shepherded by the Cloud Native<a href=\"https://cncf.io/\"> Computing Foundation (CNCF)</a>. The SMI specification defines APIs for many of the networking functions described earlier. Still, these APIs can be implemented in multiple ways.</p><!--kg-card-begin: markdown--><p>The <a href=\"https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/#example-1-sidecar-containers\" target=\"_blank\" rel=\"nofollow\">sidecar pattern</a> is one way to design a service mesh for Kubernetes. In this model, a so-called sidecar container is deployed alongside each instance of a service within a pod to handle east-west traffic for that instance. This is a popular pattern for implementing a service mesh, and is the method adopted by the likes of Istio and Linkerd (the latter a CNCF incubating project).</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>An alternative method is to deploy a service mesh proxy endpoint that runs as its own pod on each node of a cluster, using the Kubernetes concept of a <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/\" target=\"_blank\" rel=\"nofollow\">DaemonSet</a>. This method has the advantage of being less invasive, in that the mesh proxy does not need to modify any Kubernetes objects and no network traffic is modified without a service owner‚Äôs consent. This is the model adopted by <a href=\"https://containous.ghost.io/maesh/\">Maesh</a>.</p>\n<!--kg-card-end: markdown--><h2 id=\"how-to-move-forward\">How to Move Forward</h2><p>So, while standardization helps make it easier to know what to expect from a service mesh, important decisions remain before adopting a specific solution. Even choosing how to begin deploying a mesh can be challenging, owing to the potential for disruption of existing communication patterns within a cluster.</p><p>These decisions are made significantly easier when dealing with so-called greenfield projects, where the clustered, microservices-based application is built from the ground up, without dependencies on legacy infrastructure. This is a happy situation to have, but it‚Äôs not always realistic, especially in environments where adoption of containerization is already mature.</p><p>If it will be necessary to run some services on a service mesh alongside other services for which it is preferable to have them manage their own east-west traffic, it may be worth looking for a loosely coupled solution, such as Maesh. This has the advantage of allowing the teams that own individual services to opt into the mesh when they are ready, rather than forcing a mass migration with interdependencies that may be difficult to test.</p><p>However you choose to proceed, the key takeaway should be that service mesh for Kubernetes, while still an emerging technology, can often provide the ‚Äúmissing piece‚Äù that Kubernetes alone does not. By abstracting key east-west networking features away from application logic, mesh solutions enable distributed, microservices-based applications to operate in a way that is managed, observable, and secure, both when communicating with the outside world and within the cluster itself.</p><p>To learn more, <a href=\"https://info.containo.us/video-understanding-service-mesh\">check out this video</a> about the advantages and disadvantages of a <strong>service mesh</strong>, and the appropriate situations for using one.</p>","url":"https://containous.ghost.io/blog/beyond-kubernetes-bringing-microservices-together-with-service-mesh/","canonical_url":null,"uuid":"4b55f40d-0afe-4880-8a03-6815bd0e7bb9","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ef263fe60f25700399d089d","reading_time":4}},{"node":{"id":"Ghost__Post__5efbfbdc1555240039b0bf80","title":"Announcing Maesh 1.3","slug":"announcing-maesh-1-3","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/07/Announcing-Maesh-1.3-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/efb1b1925cac747fc113d310e892bbdd/47498/Announcing-Maesh-1.3-1.jpg","srcSet":"/static/efb1b1925cac747fc113d310e892bbdd/9dc27/Announcing-Maesh-1.3-1.jpg 300w,\n/static/efb1b1925cac747fc113d310e892bbdd/4fe8c/Announcing-Maesh-1.3-1.jpg 600w,\n/static/efb1b1925cac747fc113d310e892bbdd/47498/Announcing-Maesh-1.3-1.jpg 1200w,\n/static/efb1b1925cac747fc113d310e892bbdd/52258/Announcing-Maesh-1.3-1.jpg 1800w,\n/static/efb1b1925cac747fc113d310e892bbdd/a41d1/Announcing-Maesh-1.3-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Maesh 1.3, the latest version of the simpler service mesh, is now even more reliable, flexible, and widely available. ","custom_excerpt":"Maesh 1.3, the latest version of the simpler service mesh, is now even more reliable, flexible, and widely available. ","visibility":"public","created_at_pretty":"01 July, 2020","published_at_pretty":"July 9, 2020","updated_at_pretty":"21 July, 2020","created_at":"2020-07-01T02:58:36.000+00:00","published_at":"2020-07-09T05:45:40.000+00:00","updated_at":"2020-07-21T13:59:12.000+00:00","meta_title":"Announcing Maesh 1.3","meta_description":"Maesh 1.3, the latest version of the simpler service mesh, is now even more reliable, flexible, and widely available. ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/07/Announcing-Maesh-1.3---Twitter@2x.jpg","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"The simpler service mesh, now even more reliable, flexible, and widely\navailable.\n\nMaesh 1.3, the latest version of the simpler service mesh, is available today.\nThis release introduces new configuration options and brings important\nenhancements to the project‚Äôs architecture.\n\nNamespace watchlists\nPreviously, it was possible to configure a set of namespaces to be ignored by\nthe Maesh Controller, via the ignoreNamespaces option. Operators of large\nclusters found themselves having to define a large number of exceptions if they\nwere only interested in a small subset of namespaces.\n\nMaesh 1.3 introduces an option that enables operators to specify which\nnamespaces they want to be observed by the Maesh controller called \nwatchNamespaces:\n\nhelm install maesh maesh/maesh --set controller.watchNamespaces={first,second}\n\n\nFor those who rely on ignoreNamespaces, it will still continue to work, we\naren‚Äôt planning to remove that configuration option.\n\nSupport for named TargetPort in Service resources\nA typical service definition in Kubernetes might look like this:\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: MyApp\n  ports:\n    - port: 80\n      targetPort: http\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp-deployment\n  labels:\n    app: MyApp\nspec:\n  selector:\n    matchLabels:\n      app: MyApp\n  template:\n    metadata:\n      labels:\n        app: MyApp\n    spec:\n      containers:\n        - name: nginx\n          image: nginx:1.14.2\n          ports:\n            - containerPort: 80\n              name: http\n\n\nKubernetes will look for the corresponding Pod matching the selector and for a\nport on the pod named http. Maesh now supports this and will do the reverse\nlookup of the targetPort as well, greatly enhancing flexibility.\n\nReal-Time In-Memory Port Mapping\nOne of the architectural components of earlier versions of Maesh is a database\nreferred to as StateTable, whose job included keeping track of port allocations\nand holding entries for port mappings. Before Maesh 1.3, port allocations and\nstates were managed inside of a Kubernetes resource called a ConfigMap.\n\nMaintaining that state externally seems reasonable, but there is always a catch.\nWhat if another process or user modifies the table? What if it becomes\nunavailable due to misconfigured permissions, or becomes so large as to\nintroduce performance issues within the Kubernetes database back-end?\n\nBecause of this, starting in Maesh 1.3, ConfigMaps\n[https://kubernetes.io/docs/concepts/configuration/configmap/] that store \nStateTable objects are gone. Instead, the Maesh Controller keeps in-memory state\ntables generated on every initialization and kept in sync with every service\nupdate.\n\nA More Reliable Controller Loop\nAs a consequence of removing the state tables mentioned above, the mechanism\nwith which a controller performs updates in the clusters required a redesign.\nPreviously, it just watched for changes and updated the configuration as they\nhappened. With the state now being stored in memory, that behavior was no longer\nsufficient, colliding events may impact Maesh's proxy nodes' performance.\n\nTo address that issue, Maesh 1.3 now leverages Kubernetes Work Queues\n[https://kubernetes.io/docs/tasks/job/fine-parallel-processing-work-queue/] to\nguarantee the correct processing of events that are responsible for updating the\nin-memory database. The queues help Maesh perform reliably in situations where\nit must process concurrent events.\n\nSupport for CoreDNS on AKS\nAs already mentioned in a previous release [/blog/maesh-1-0-802f4be9a9a7/],\nMaesh relies heavily on CoreDNS for name resolution. Because of this dependency,\nMaesh is designed to patch CoreDNS through its initialization process. On AKS,\nthere is a specific process\n[https://docs.microsoft.com/en-us/azure/aks/coredns-custom] to follow when\ncustomizing CoreDNS and we‚Äôve updated Maesh to conform to that process. As a\nresult of this update, Maesh is now supported on Azure Kubernetes Service.\n\nNext Steps\nThe changes introduced in this release represent the next step in evolving the\nMaesh project into a solution the community has been requesting. Research is\nunderway on how Maesh can implement simple, easy to use, end-to-end encryption.\nDeveloping and shipping this capability will be the next significant milestone\nto hit.\n\nYour participation with the Maesh project is invaluable, and your suggestions\nare responsible for the improvements and direction this project undergoes. We\nwelcome your continued feedback, PRs, and contributions because that is what\nkeeps Maesh going in the right direction.\n\nThank you!\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">The simpler service mesh, now even more reliable, flexible, and widely available.</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/07/Announcing-Maesh-1.3.jpg\" class=\"kg-image\" alt=\"Announcing Maesh 1.3\"></figure><p>Maesh 1.3, the latest version of the simpler service mesh, is available today. This release introduces new configuration options and brings important enhancements to the project‚Äôs architecture.</p><h2 id=\"namespace-watchlists\">Namespace watchlists</h2><p>Previously, it was possible to configure a set of namespaces to be ignored by the Maesh Controller, via the <code>ignoreNamespaces</code> option. Operators of large clusters found themselves having to define a large number of exceptions if they were only interested in a small subset of namespaces.</p><p>Maesh 1.3 introduces an option that enables operators to specify which namespaces they want to be observed by the Maesh controller called <code>watchNamespaces</code>:</p><!--kg-card-begin: markdown--><pre><code>helm install maesh maesh/maesh --set controller.watchNamespaces={first,second}\n</code></pre>\n<!--kg-card-end: markdown--><p>For those who rely on <code>ignoreNamespaces</code>, it will still continue to work, we aren‚Äôt planning to remove that configuration option.</p><h2 id=\"support-for-named-targetport-in-service-resources\">Support for named TargetPort in Service resources</h2><p>A typical service definition in Kubernetes might look like this:</p><!--kg-card-begin: markdown--><pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: MyApp\n  ports:\n    - port: 80\n      targetPort: http\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp-deployment\n  labels:\n    app: MyApp\nspec:\n  selector:\n    matchLabels:\n      app: MyApp\n  template:\n    metadata:\n      labels:\n        app: MyApp\n    spec:\n      containers:\n        - name: nginx\n          image: nginx:1.14.2\n          ports:\n            - containerPort: 80\n              name: http\n</code></pre>\n<!--kg-card-end: markdown--><p>Kubernetes will look for the corresponding Pod matching the selector and for a port on the pod named <code>http</code>. Maesh now supports this and will do the reverse lookup of the targetPort as well, greatly enhancing flexibility.</p><h2 id=\"real-time-in-memory-port-mapping\">Real-Time In-Memory Port Mapping</h2><p>One of the architectural components of earlier versions of Maesh is a database referred to as <code>StateTable</code>, whose job included keeping track of port allocations and holding entries for port mappings. Before Maesh 1.3, port allocations and states were managed inside of a Kubernetes resource called a ConfigMap.</p><p>Maintaining that state externally seems reasonable, but there is always a catch. What if another process or user modifies the table? What if it becomes unavailable due to misconfigured permissions, or becomes so large as to introduce performance issues within the Kubernetes database back-end?</p><!--kg-card-begin: markdown--><p>Because of this, starting in Maesh 1.3, <a href=\"https://kubernetes.io/docs/concepts/configuration/configmap/\" target=\"_blank\" rel=\"nofollow\">ConfigMaps</a> that store <code>StateTable</code> objects are gone. Instead, the Maesh Controller keeps in-memory state tables generated on every initialization and kept in sync with every service update.</p>\n<!--kg-card-end: markdown--><h2 id=\"a-more-reliable-controller-loop\">A More Reliable Controller Loop</h2><p>As a consequence of removing the state tables mentioned above, the mechanism with which a controller performs updates in the clusters required a redesign. Previously, it just watched for changes and updated the configuration as they happened. With the state now being stored in memory, that behavior was no longer sufficient, colliding events may impact Maesh's proxy nodes' performance.</p><!--kg-card-begin: markdown--><p>To address that issue, Maesh 1.3 now leverages <a href=\"https://kubernetes.io/docs/tasks/job/fine-parallel-processing-work-queue/\" target=\"_blank\" rel=\"nofollow\">Kubernetes Work Queues</a> to guarantee the correct processing of events that are responsible for updating the in-memory database. The queues help Maesh perform reliably in situations where it must process concurrent events.</p>\n<!--kg-card-end: markdown--><h2 id=\"support-for-coredns-on-aks\">Support for CoreDNS on AKS</h2><!--kg-card-begin: markdown--><p>As already mentioned in <a href=\"https://containous.ghost.io/blog/maesh-1-0-802f4be9a9a7/\">a previous release</a>, Maesh relies heavily on CoreDNS for name resolution. Because of this dependency, Maesh is designed to patch CoreDNS through its initialization process. On AKS, there is a <a href=\"https://docs.microsoft.com/en-us/azure/aks/coredns-custom\" target=\"_blank\" rel=\"nofollow\">specific process</a> to follow when customizing CoreDNS and we‚Äôve updated Maesh to conform to that process. As a result of this update, Maesh is now supported on Azure Kubernetes Service.</p>\n<!--kg-card-end: markdown--><h2 id=\"next-steps\">Next Steps</h2><p>The changes introduced in this release represent the next step in evolving the Maesh project into a solution the community has been requesting. Research is underway on how Maesh can implement simple, easy to use, end-to-end encryption. Developing and shipping this capability will be the next significant milestone to hit.</p><p>Your participation with the Maesh project is invaluable, and your suggestions are responsible for the improvements and direction this project undergoes. We welcome your continued feedback, PRs, and contributions because that is what keeps Maesh going in the right direction.</p><p>Thank you!</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\">Community Forum</a><br></li></ul>","url":"https://containous.ghost.io/blog/announcing-maesh-1-3/","canonical_url":null,"uuid":"789a57a8-4c4e-4359-91fb-c3e96dfbb7c5","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5efbfbdc1555240039b0bf80","reading_time":3}},{"node":{"id":"Ghost__Post__5f0dd2aeda8b5600395a511a","title":"Traefik and Docker Swarm: A Dynamic Duo for Cloud-Native Container Networking","slug":"traefik-and-docker-swarm-a-dynamic-duo-for-cloud-native-container-networking","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/18df5978b96c83450e231d3c075238b8/47498/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking-1.jpg","srcSet":"/static/18df5978b96c83450e231d3c075238b8/9dc27/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking-1.jpg 300w,\n/static/18df5978b96c83450e231d3c075238b8/4fe8c/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking-1.jpg 600w,\n/static/18df5978b96c83450e231d3c075238b8/47498/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking-1.jpg 1200w,\n/static/18df5978b96c83450e231d3c075238b8/52258/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking-1.jpg 1800w,\n/static/18df5978b96c83450e231d3c075238b8/a41d1/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"External reverse proxy and load balancing software like Traefik offer networking features and control that Docker Swarm cannot provide on its own.","custom_excerpt":"External reverse proxy and load balancing software like Traefik offer networking features and control that Docker Swarm cannot provide on its own.","visibility":"public","created_at_pretty":"14 July, 2020","published_at_pretty":"July 15, 2020","updated_at_pretty":"28 July, 2020","created_at":"2020-07-14T15:43:42.000+00:00","published_at":"2020-07-15T05:37:39.000+00:00","updated_at":"2020-07-28T14:41:45.000+00:00","meta_title":"Traefik and Docker Swarm: A Dynamic Duo for Container Networking","meta_description":"External reverse proxy and load balancing software like Traefik offer networking features and control that Docker Swarm cannot provide on its own.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking---Twitter@2x.png","twitter_title":null,"authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Docker","slug":"docker","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Docker didn‚Äôt invent application containers, but it put them on the map. Docker\nsoftware helped containers become the most important innovation in application\ndelivery since virtual machines. And with the introduction of Swarm mode, Docker\nadded container orchestration to its toolbox, making it possible to build\ndistributed applications from large collections of containerized microservices.\n\nDocker Swarm has a lot going for it. For starters, it‚Äôs built into the Docker\nEngine, so it‚Äôs available to anyone who can launch Docker containers. It‚Äôs also\neasy to get up and running in a variety of cloud and on-premises environments,\nunlike more complex tools such as Kubernetes and Mesos.\n\nUnfortunately, Swarm alone will only get you partway to production. Its ‚Äúrouting\nmesh‚Äù networking model doesn‚Äôt supply the availability, security, observability,\nand control that you‚Äôll need when exposing your applications to the open\ninternet, particularly as they scale to more complex usage scenarios.\n\nLoad Balancing and Reverse Proxies\nThe smart way to gain these capabilities is to pair Docker Swarm with external\nreverse proxy and load balancing software. These networking tools act as\nconcierge for requests coming from the external network. They not only route\nrequests to where they need to go (also known as ingress routing), but they also\nhelp ensure that backend applications and services don‚Äôt become overwhelmed by\ntraffic spikes.\n\nAt its most basic, this type of routing software handles HTTP requests, which\nsit at Layer 7 of the OSI networking model, known as the application layer. More\nadvanced load balancers extend their capabilities to Layer 4, the transport\nlayer, by also handling TCP requests.\n\nTraefik [/traefik/] is one such offering that‚Äôs particularly well-suited for use\nwith Docker Swarm. Like Swarm mode itself, Traefik aims to eliminate much of the\ndrudgery of maintaining containerized environments by automating routine\nconfiguration tasks.Traefik automatically discovers\n[https://docs.traefik.io/providers/docker/] information about the network and\nservices available in a Docker Swarm cluster, dynamically updating its\nconfiguration as the environment changes. This sets it apart from Interlock, the\ningress routing component of the commercial Docker Enterprise product, which can\nbecome unreliable when its configuration is updated. At the same time, Traefik\noffers comprehensive observability into the functioning of the network, so\noperations teams are never left in the dark.\n\nAdvanced Routing\nThe ability to update network routes efficiently is particularly important for\nmicroservices deployments. By their nature, microservices tend to be stateless\nand short-lived. New versions of services are typically deployed frequently and\ninstances are scaled dynamically to meet demand. Because of this, routers and\nload balancers should be able to respond quickly as new container instances\nappear and disappear.\n\nThis capability of external routers also makes it easy to test new fixes and\nfeature upgrades in ways that are not possible with Docker Swarm alone,\nincluding blue-green deployments, canary releases, and similar methods\n[https://www.infoworld.com/article/3565750/4-deployment-strategies-for-resilient-microservices.html]\n. By crafting routing rules that split traffic between old and new versions of\nservices in user-defined proportions, it‚Äôs possible to roll out updates\ngradually and even roll them back when necessary with zero downtime.\n\nAnother important feature of a reverse proxy is the ability to terminate\nencrypted TLS traffic. Users have come to expect the HTTPS URL and padlock icon\nthat indicate secure connections. In this aspect, Traefik not only supports TLS\nbut ‚Äì in keeping with the Docker Swarm ethos of easy configuration ‚Äì it also\nsupports automated certificate management\n[/blog/traefik-2-tls-101-23b4fbee81f1/] via a built-in client for Let's Encrypt\n[http://letsencrypt.org/].\n\nFuture-Proof Your Apps\nSeparating the functions of networking and container orchestration has benefits\nfor application lifecycles, too. As an application scales and evolves,\ninevitably its infrastructure needs will also change. Because Traefik works\nconsistently across on-premises and public cloud environments, it makes it\nsimple to port your Docker Swarm clusters when the time comes, without dramatic\nconfiguration changes.\n\nThe commercial product Traefik Enterprise Edition (TraefikEE) [/traefikee/] also\nincludes features aimed at enterprise deployments. For example, it supports a\nvariety of identity and authentication protocols, including LDAP, JWT, and\nOpenID Connect. It runs as a cluster for high availability, including clustered\nsupport for Let‚Äôs Encrypt. And it‚Äôs fully compliant with Docker‚Äôs Universal\nControl Plane, giving operations teams centralized control of networking as part\nof the underlying infrastructure.\n\nAnd we must not ignore that it may become necessary to move applications away\nfrom Docker Swarm to a more feature-rich orchestrator, such as Kubernetes. A\nTraefik configuration can be ported from Docker Swarm to Kubernetes without\nsignificant changes, meaning the choice you make for routing and load balancing\ntoday will not negatively affect your future plans. By comparison, Interlock\nonly works with Docker Enterprise.\n\nThe Route Forward\nContainers are likely to remain the dominant means of application deployment for\nyears to come, and with good reason. What‚Äôs more, as the microservices model of\napplication development gains traction, container orchestration will\nincreasingly become an essential component of IT infrastructure.\n\nNetworking, on the other hand, is essential now and for the future. External\nreverse proxy and load balancing software offer networking features and control\nthat an orchestration layer like Docker Swarm cannot provide on its own. What‚Äôs\nmore, the auto-discovery and configuration capabilities of Traefik make it an\nideal partner for Docker Swarm and Kubernetes alike.\n\nTo learn more about using Traefik as an ingress proxy and load balancer for\nDocker Swarm environments, watch our recent webinar, ‚ÄúApplication Routing for\nDocker Swarm\n[https://info.containo.us/webinar-recording-powerful-application-routing-for-docker-swarm]\n‚Äù.","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg\" class=\"kg-image\" alt=\"Traefik and Docker Swarm: A Dynamic Duo for Cloud-Native Container Networking\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg 1600w, https://containous.ghost.io/content/images/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p>Docker didn‚Äôt invent application containers, but it put them on the map. Docker software helped containers become the most important innovation in application delivery since virtual machines. And with the introduction of Swarm mode, Docker added <em>container orchestration</em> to its toolbox, making it possible to build distributed applications from large collections of containerized microservices.</p><p>Docker Swarm has a lot going for it. For starters, it‚Äôs built into the Docker Engine, so it‚Äôs available to anyone who can launch Docker containers. It‚Äôs also easy to get up and running in a variety of cloud and on-premises environments, unlike more complex tools such as Kubernetes and Mesos.</p><p>Unfortunately, Swarm alone will only get you partway to production. Its ‚Äúrouting mesh‚Äù networking model doesn‚Äôt supply the availability, security, observability, and control that you‚Äôll need when exposing your applications to the open internet, particularly as they scale to more complex usage scenarios.</p><h2 id=\"load-balancing-and-reverse-proxies\">Load Balancing and Reverse Proxies</h2><p>The smart way to gain these capabilities is to pair Docker Swarm with external reverse proxy and load balancing software. These networking tools act as concierge for requests coming from the external network. They not only route requests to where they need to go (also known as <em>ingress routing</em>), but they also help ensure that backend applications and services don‚Äôt become overwhelmed by traffic spikes.</p><p>At its most basic, this type of routing software handles HTTP requests, which sit at Layer 7 of the OSI networking model, known as the <em>application layer</em>. More advanced load balancers extend their capabilities to Layer 4, the <em>transport layer</em>, by also handling TCP requests.</p><p><a href=\"https://containous.ghost.io/traefik/\">Traefik</a> is one such offering that‚Äôs particularly well-suited for use with Docker Swarm. Like Swarm mode itself, Traefik aims to eliminate much of the drudgery of maintaining containerized environments by automating routine configuration tasks.Traefik <a href=\"https://docs.traefik.io/providers/docker/\">automatically discovers</a> information about the network and services available in a Docker Swarm cluster, dynamically updating its configuration as the environment changes. This sets it apart from Interlock, the ingress routing component of the commercial Docker Enterprise product, which can become unreliable when its configuration is updated. At the same time, Traefik offers comprehensive observability into the functioning of the network, so operations teams are never left in the dark.</p><h2 id=\"advanced-routing\"><strong>Advanced Routing</strong></h2><p>The ability to update network routes efficiently is particularly important for microservices deployments. By their nature, microservices tend to be stateless and short-lived. New versions of services are typically deployed frequently and instances are scaled dynamically to meet demand. Because of this, routers and load balancers should be able to respond quickly as new container instances appear and disappear.</p><!--kg-card-begin: markdown--><p>This capability of external routers also makes it easy to test new fixes and feature upgrades in ways that are not possible with Docker Swarm alone, including blue-green deployments, canary releases, and <a href=\"https://www.infoworld.com/article/3565750/4-deployment-strategies-for-resilient-microservices.html\" target=\"_blank\" rel=\"nofollow\">similar methods</a>. By crafting routing rules that split traffic between old and new versions of services in user-defined proportions, it‚Äôs possible to roll out updates gradually and even roll them back when necessary with zero downtime.</p>\n<p>Another important feature of a reverse proxy is the ability to terminate encrypted TLS traffic. Users have come to expect the HTTPS URL and padlock icon that indicate secure connections. In this aspect, Traefik not only supports TLS but ‚Äì in keeping with the Docker Swarm ethos of easy configuration ‚Äì it also supports <a href=\"https://containous.ghost.io/blog/traefik-2-tls-101-23b4fbee81f1/\">automated certificate management</a> via a built-in client for <a href=\"http://letsencrypt.org/\" target=\"_blank\" rel=\"nofollow\">Let's Encrypt</a>.</p>\n<!--kg-card-end: markdown--><h2 id=\"future-proof-your-apps\">Future-Proof Your Apps</h2><p>Separating the functions of networking and container orchestration has benefits for application lifecycles, too. As an application scales and evolves, inevitably its infrastructure needs will also change. Because Traefik works consistently across on-premises and public cloud environments, it makes it simple to port your Docker Swarm clusters when the time comes, without dramatic configuration changes.</p><p>The commercial product <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition (TraefikEE)</a> also includes features aimed at enterprise deployments. For example, it supports a variety of identity and authentication protocols, including LDAP, JWT, and OpenID Connect. It runs as a cluster for high availability, including clustered support for Let‚Äôs Encrypt. And it‚Äôs fully compliant with Docker‚Äôs Universal Control Plane, giving operations teams centralized control of networking as part of the underlying infrastructure.</p><p>And we must not ignore that it may become necessary to move applications away from Docker Swarm to a more feature-rich orchestrator, such as Kubernetes. A Traefik configuration can be ported from Docker Swarm to Kubernetes without significant changes, meaning the choice you make for routing and load balancing today will not negatively affect your future plans. By comparison, Interlock only works with Docker Enterprise.</p><h2 id=\"the-route-forward\"><strong>The Route Forward</strong></h2><p>Containers are likely to remain the dominant means of application deployment for years to come, and with good reason. What‚Äôs more, as the microservices model of application development gains traction, container orchestration will increasingly become an essential component of IT infrastructure.</p><p>Networking, on the other hand, is essential now and for the future. External reverse proxy and load balancing software offer networking features and control that an orchestration layer like Docker Swarm cannot provide on its own. What‚Äôs more, the auto-discovery and configuration capabilities of Traefik make it an ideal partner for Docker Swarm and Kubernetes alike.</p><p>To learn more about using Traefik as an ingress proxy and load balancer for Docker Swarm environments, watch our recent webinar, ‚Äú<a href=\"https://info.containo.us/webinar-recording-powerful-application-routing-for-docker-swarm\">Application Routing for Docker Swarm</a>‚Äù.<br></p>","url":"https://containous.ghost.io/blog/traefik-and-docker-swarm-a-dynamic-duo-for-cloud-native-container-networking/","canonical_url":null,"uuid":"4e6b82bf-2338-49c7-8188-b8522c5430d8","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f0dd2aeda8b5600395a511a","reading_time":4}},{"node":{"id":"Ghost__Post__5f0f2f71554944004519ecc4","title":"Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik","slug":"introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b55bc938e5dafa9f9ee2110650843365/47498/Introducing-Traefik-Pilot---Blog-1.jpg","srcSet":"/static/b55bc938e5dafa9f9ee2110650843365/9dc27/Introducing-Traefik-Pilot---Blog-1.jpg 300w,\n/static/b55bc938e5dafa9f9ee2110650843365/4fe8c/Introducing-Traefik-Pilot---Blog-1.jpg 600w,\n/static/b55bc938e5dafa9f9ee2110650843365/47498/Introducing-Traefik-Pilot---Blog-1.jpg 1200w,\n/static/b55bc938e5dafa9f9ee2110650843365/52258/Introducing-Traefik-Pilot---Blog-1.jpg 1800w,\n/static/b55bc938e5dafa9f9ee2110650843365/a41d1/Introducing-Traefik-Pilot---Blog-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Today, we‚Äôre excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production.","custom_excerpt":"Today, we‚Äôre excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production.","visibility":"public","created_at_pretty":"15 July, 2020","published_at_pretty":"July 16, 2020","updated_at_pretty":"04 August, 2020","created_at":"2020-07-15T16:31:45.000+00:00","published_at":"2020-07-16T13:25:52.000+00:00","updated_at":"2020-08-04T22:37:55.000+00:00","meta_title":"Introducing Traefik Pilot: a New SaaS Control Platform for Traefik","meta_description":"We're excited to announce the preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production.","og_description":null,"og_image":null,"og_title":null,"twitter_description":"We‚Äôre excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production.","twitter_image":"https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Twitter@2x.png","twitter_title":"Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik","authors":[{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#pilot-related-resource","slug":"hash-pilot-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Today, we‚Äôre excited to announce the early-access preview of Traefik Pilot, a\nnew SaaS global control plane, to simplify the management of Traefik running in\nproduction. Pilot extends the capabilities of Traefik, providing a powerful\nobservability and control platform for every one of your Traefik instances in a\nsingle unified dashboard.\n\nIn addition, Traefik Pilot introduces plugins for Traefik, including a first of\nits kind open marketplace, which extends Traefik middleware with custom,\npurpose-built requests and responses processing.\n\nThe preview release of Pilot includes:\n\n * Custom Middleware Plugins! Our brand new plugins marketplace including\n   examples of custom middleware\n * Centralized view of your production Traefik instances\n * Availability and security vulnerability alerts with notifications\n\nGet started with Pilot ‚Ä∫ [https://pilot.traefik.io/]\n\nCustom Middleware Plugins\nOne of the most frequently requested features from the Traefik community is the \nability to easily create and share custom\n[https://github.com/containous/traefik/issues/1336] plugins and extend the\nfunctionality of our existing middleware catalog. Built on Yaegi\n[/blog/announcing-yaegi-263a1e2d070a/], the new plugin system offers an elegant,\nextensible, and high-performance way to augment Traefik's capabilities without\nthe need to modify or compile the Traefik source code.\n\nTraefik plugins are add-on packages that empower users to apply transformations\nand enhancements to both requests and responses, which are handled by Traefik.\nThere have been several middleware pull requests\n[https://github.com/containous/traefik/pulls?q=is%3Apr+label%3Aarea%2Fmiddleware+label%3Aresolution%2Fdeclined+is%3Aclosed] \ndeclined due to implementations that are tied to a specific use case or for\nlacking the abstraction necessary to be accepted upstream into Traefik.\nDevelopers are now equipped with the tools needed to write plugins in Go\n[https://github.com/containous/plugindemo], and sharing them with the world is\nas easy as publishing them on GitHub. The new plugin engine enables the\ncommunity to install their custom middleware using Traefik Pilot without\ncompiling a single line of code.\n\nThe initial release of Pilot includes a free to use plugin marketplace that\nextends Traefik by installing middleware plugins directly from the catalog. In\naddition, you can just as easily create, publish, and install your own. On\nlaunch day, the catalog will contain a few sample plugins that serve as advanced\ntutorials for developers to build their own. We expect the catalog to expand\nrapidly, especially as the Traefik community begins to write and share their new\ncreations.\n\nLearn more ‚Ä∫ [https://docs.traefik.io/v2.3/plugins/overview/]\n\nSecurity and Availability Alerting\nKeeping track of your Traefik installations and ensuring they are healthy,\navailable, and secure has, until today, required a significant amount of effort.\nTypically this involved deploying a system to gather metrics and creating an\nalerting system to notify you if there is a problem. With Pilot's introduction,\nwe're now the first managed SaaS provider to offer security and availability\nmonitoring of your cloud-native software load balancers, for free.\n\nOnce Traefik is registered, a built-in heartbeat mechanism will check-in with\nPilot periodically and report the health and availability of your Traefik\ninstance. In addition, Pilot will check for common vulnerabilities and exposure\n(CVE) [https://cve.mitre.org/] bulletins that apply to your Traefik installation\nand configuration, which may indicate a security risk to your Traefik\ndeployments. You may now use the dashboard to configure your alert settings and\nget notified of issues through email or custom webhooks before they become\nemergencies.\n\nGet Started by Connecting Your Traefik Instance\nPilot requires the most recent version of Traefik, v2.3 RC. You will also now\nfind a convenient link on the Traefik dashboard to register your instance with\nPilot.\n\nOnce logged into Pilot, registering your Traefik instance by adding a unique\ntoken to your static configuration. This will automatically extend your\ninstallation's functionality by monitoring the health of your installation,\nenabling the use of custom middleware plugins, and reporting relevant\nvulnerabilities that apply to your environment.\n\nJust the Beginning\nThis initial preview release brings exciting and new capabilities to the Traefik\necosystem, and this is just the beginning. We're even more excited by what we\nalready have queued up for future iterations. Keep an eye out for Pilot to\nbroaden the range and reach of your existing Traefik deployments. We're just\ngetting started and have plans for additional capabilities from microservices\nrouting and orchestrator ingress to expanding out to the global edge.\n\nJump in the cockpit with Pilot today and let us know what you think. What kinds\nof plugins will you write [https://github.com/containous/plugindemo]?\n\nUseful links\n * Get started with Pilot ‚Ä∫ [https://pilot.traefik.io/]\n * Pilot documentation [https://docs.traefik.io/v2.3/plugins/overview/]\n * Traefik [/traefik/]\n * Community forum [https://community.containo.us/c/traefik/5]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog.jpg\" class=\"kg-image\" alt=\"Introducing Traefik Pilot\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Introducing-Traefik-Pilot---Blog.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Introducing-Traefik-Pilot---Blog.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Introducing-Traefik-Pilot---Blog.jpg 1600w, https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p>Today, we‚Äôre excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production. Pilot extends the capabilities of Traefik, providing a powerful observability and control platform for every one of your Traefik instances in a single unified dashboard.</p><p>In addition, Traefik Pilot introduces plugins for Traefik, including a first of its kind open marketplace, which extends Traefik middleware with custom, purpose-built requests and responses processing.</p><p>The preview release of Pilot includes:</p><ul><li>Custom Middleware Plugins! Our brand new plugins marketplace including examples of custom middleware</li><li>Centralized view of your production Traefik instances</li><li>Availability and security vulnerability alerts with notifications</li></ul><p><a href=\"https://pilot.traefik.io/\">Get started with Pilot ‚Ä∫</a></p><h2 id=\"custom-middleware-plugins\">Custom Middleware Plugins</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png\" class=\"kg-image\" alt=\"Traefik Pilot Plugins Marketplace\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 1600w, https://containous.ghost.io/content/images/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 2094w\" sizes=\"(min-width: 720px) 720px\"></figure><p>One of the most frequently requested features from the Traefik community is the <a href=\"https://github.com/containous/traefik/issues/1336\">ability to easily create and share custom</a> plugins and extend the functionality of our existing middleware catalog. Built on <a href=\"https://containous.ghost.io/blog/announcing-yaegi-263a1e2d070a/\">Yaegi</a>, the new plugin system offers an elegant, extensible, and high-performance way to augment Traefik's capabilities without the need to modify or compile the Traefik source code.</p><p>Traefik plugins are add-on packages that empower users to apply transformations and enhancements to both requests and responses, which are handled by Traefik. There have been several middleware <a href=\"https://github.com/containous/traefik/pulls?q=is%3Apr+label%3Aarea%2Fmiddleware+label%3Aresolution%2Fdeclined+is%3Aclosed\">pull requests</a> declined due to implementations that are tied to a specific use case or for lacking the abstraction necessary to be accepted upstream into Traefik. Developers are now equipped with the tools needed to <a href=\"https://github.com/containous/plugindemo\">write plugins in Go</a>, and sharing them with the world is as easy as publishing them on GitHub. The new plugin engine enables the community to install their custom middleware using Traefik Pilot without compiling a single line of code.</p><p>The initial release of Pilot includes a free to use plugin marketplace that extends Traefik by installing middleware plugins directly from the catalog. In addition, you can just as easily create, publish, and install your own. On launch day, the catalog will contain a few sample plugins that serve as advanced tutorials for developers to build their own. We expect the catalog to expand rapidly, especially as the Traefik community begins to write and share their new creations.</p><p><a href=\"https://docs.traefik.io/v2.3/plugins/overview/\">Learn more ‚Ä∫</a></p><h2 id=\"security-and-availability-alerting\">Security and Availability Alerting</h2><p>Keeping track of your Traefik installations and ensuring they are healthy, available, and secure has, until today, required a significant amount of effort. Typically this involved deploying a system to gather metrics and creating an alerting system to notify you if there is a problem. With Pilot's introduction, we're now the first managed SaaS provider to offer security and availability monitoring of your cloud-native software load balancers, for free.</p><!--kg-card-begin: markdown--><p>Once Traefik is registered, a built-in heartbeat mechanism will check-in with Pilot periodically and report the health and availability of your Traefik instance. In addition, Pilot will check for <a href=\"https://cve.mitre.org/\" target=\"_blank\" rel=\"nofollow\">common vulnerabilities and exposure (CVE)</a> bulletins that apply to your Traefik installation and configuration, which may indicate a security risk to your Traefik deployments. You may now use the dashboard to configure your alert settings and get notified of issues through email or custom webhooks before they become emergencies.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Profile-Settings-1.png\" class=\"kg-image\" alt=\"Traefik Pilot Profile Settings\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Traefik-Pilot-Profile-Settings-1.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Traefik-Pilot-Profile-Settings-1.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Traefik-Pilot-Profile-Settings-1.png 1600w, https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Profile-Settings-1.png 2158w\" sizes=\"(min-width: 720px) 720px\"></figure><h2 id=\"get-started-by-connecting-your-traefik-instance\">Get Started by Connecting Your Traefik Instance</h2><p>Pilot requires the most recent version of Traefik, v2.3 RC. You will also now find a convenient link on the Traefik dashboard to register your instance with Pilot.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh4.googleusercontent.com/bEKbwjNoD7pW83nqgjE4LdndIcQnNihoDJsN77_Vk5A4a5ZUwbaWDiIbYgalA3TQ6fnMeFeQc5upiceLRWoRSLIDZamSg6yTBskb-EzDngqIfts-kQk6bl6M7E7Sy5_BePfJ1KY\" class=\"kg-image\" alt=\"Traefik Dashboard including Pilot\"></figure><p>Once logged into Pilot, registering your Traefik instance by adding a unique token to your static configuration. This will automatically extend your installation's functionality by monitoring the health of your installation, enabling the use of custom middleware plugins, and reporting relevant vulnerabilities that apply to your environment.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Instance-Registration.png\" class=\"kg-image\" alt=\"Traefik Pilot Instance Registration\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Traefik-Pilot-Instance-Registration.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Traefik-Pilot-Instance-Registration.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Traefik-Pilot-Instance-Registration.png 1600w, https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Instance-Registration.png 2156w\" sizes=\"(min-width: 720px) 720px\"></figure><h2 id=\"just-the-beginning\">Just the Beginning</h2><p>This initial preview release brings exciting and new capabilities to the Traefik ecosystem, and this is just the beginning. We're even more excited by what we already have queued up for future iterations. Keep an eye out for Pilot to broaden the range and reach of your existing Traefik deployments. We're just getting started and have plans for additional capabilities from microservices routing and orchestrator ingress to expanding out to the global edge.</p><p>Jump in the cockpit with Pilot today and let us know what you think. <a href=\"https://github.com/containous/plugindemo\">What kinds of plugins will you write</a>?</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://pilot.traefik.io/\">Get started with Pilot ‚Ä∫</a></li><li><a href=\"https://docs.traefik.io/v2.3/plugins/overview/\">Pilot documentation</a></li><li><a href=\"https://containous.ghost.io/traefik/\">Traefik</a></li><li><a href=\"https://community.containo.us/c/traefik/5\">Community forum</a></li></ul>","url":"https://containous.ghost.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/","canonical_url":null,"uuid":"bc637eb4-bfba-4246-9d92-c79db48c2d7b","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f0f2f71554944004519ecc4","reading_time":4}},{"node":{"id":"Ghost__Post__5f161889d90a6e003946cbaa","title":"Simplified security for Kubernetes with Traefik and Let‚Äôs Encrypt","slug":"simplified-security-for-kubernetes-with-traefik-and-lets-encrypt","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b529a4995103e2123aa83cf7cf178170/47498/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt.jpg","srcSet":"/static/b529a4995103e2123aa83cf7cf178170/9dc27/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt.jpg 300w,\n/static/b529a4995103e2123aa83cf7cf178170/4fe8c/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt.jpg 600w,\n/static/b529a4995103e2123aa83cf7cf178170/47498/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt.jpg 1200w,\n/static/b529a4995103e2123aa83cf7cf178170/52258/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt.jpg 1800w,\n/static/b529a4995103e2123aa83cf7cf178170/a41d1/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Encryption for network security is a non-trivial matter, particularly in complex environments. Traefik and Let‚Äôs Encrypt can make the process of securing Kubernetes clusters simpler, speedier, and more resilient.","custom_excerpt":"Encryption for network security is a non-trivial matter, particularly in complex environments. Traefik and Let‚Äôs Encrypt can make the process of securing Kubernetes clusters simpler, speedier, and more resilient.","visibility":"public","created_at_pretty":"20 July, 2020","published_at_pretty":"July 21, 2020","updated_at_pretty":"11 August, 2020","created_at":"2020-07-20T22:19:53.000+00:00","published_at":"2020-07-21T13:58:29.000+00:00","updated_at":"2020-08-11T15:37:49.000+00:00","meta_title":"Simplified security for Kubernetes with Traefik & Let‚Äôs Encrypt","meta_description":"Traefik and Let‚Äôs Encrypt can make the process of securing Kubernetes clusters simpler, speedier, and more resilient.","og_description":null,"og_image":null,"og_title":null,"twitter_description":"Traefik and Let‚Äôs Encrypt can make the process of securing Kubernetes clusters simpler, speedier, and more resilient.","twitter_image":"https://containous.ghost.io/content/images/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt---Twitter.png","twitter_title":"Simplified security for Kubernetes with Traefik and Let‚Äôs Encrypt","authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Network encryption ‚Äì also known as transport layer security (TLS) ‚Äì is a must\nfor today‚Äôs online apps and services. Beyond the obvious need to prevent data\nbreaches and other malicious attacks, there are also regulatory concerns to\nconsider. Network encryption can be an important step in proving GDPR\n[https://gdpr.eu/] compliance, passing a financial audit, or complying with\ndomain-specific regulations such as HIPAA\n[https://www.hhs.gov/hipaa/for-professionals/security/laws-regulations/index.html] \nor PCI DSS [https://www.pcisecuritystandards.org/], to name just a few examples.\n\nUnfortunately, getting encryption right is a non-trivial matter, and throwing\ncontainers and Kubernetes into the mix only compounds the issue. The distributed\nnature of Kubernetes environments and the often-brief lifecycles of\ncontainerized workloads both multiply the challenges of network security.\n\nStill, there‚Äôs hope. Newer tools and services ‚Äì including Traefik and Let‚Äôs\nEncrypt [https://letsencrypt.org/] ‚Äì can make the process of securing Kubernetes\nclusters simpler, speedier, and more resilient.\n\nLowering barriers to encryption\nHistorically, network encryption has been both laborious and costly. By some\nestimates, managing a typical certificate and private key can take four hours\nper year. That may not sound like much, but when multiplied by the requirements\nof a large infrastructure, this essential maintenance can quickly become\nburdensome, particularly given the current push by Apple and other vendors to\nlimit the validity of certificates to no more than 398 days\n[https://support.apple.com/en-us/HT211025].\n\nThe alternative, however, is even worse. Expired or invalid certificates can\nlead to outages and reduced service, resulting in untold losses in productivity\nand revenue [https://www.google.com/search?q=post-mortem+ssl+cert+expired].\n\nLet‚Äôs Encrypt was founded to address these issues. A project of the Internet\nSecurity Research Group [https://www.abetterinternet.org/], Let‚Äôs Encrypt is a\nfree, nonprofit, automated, and open certificate authority (CA), created with\nthe goal of promoting universal internet security and data privacy through\nencryption. Its sponsors include some of the largest software vendors and online\nservices in the industry.\n\nLet‚Äôs Encrypt will issue an unlimited number of domain-validated\n[https://casecurity.org/2013/08/07/what-are-the-different-types-of-ssl-certificates/] \ncertificates with 90-day validity to the owner of any domain name, free of\ncharge. As of this writing, the project has issued more than 1 billion\ncertificates and it counts some 200 million websites as its clients.\n\nAutomation: Let‚Äôs Encrypt‚Äôs secret sauce\nCost reduction is of course welcome, but the most important benefit of Let‚Äôs\nEncrypt is labor reduction via automation. For Kubernetes operators, automation\nis a way of life. Let‚Äôs Encrypt brings that spirit to the world of network\nsecurity.Central to how Let‚Äôs Encrypt works is the ACME (Automated Certificate\nManagement Environment) protocol, which was made an IETF standard\n[https://tools.ietf.org/html/rfc8555] in 2019. It defines a method whereby a\ncomputing service and a CA (typically Let‚Äôs Encrypt itself) can complete the\nprocess of requesting, issuing, and verifying certificates without manual\nintervention.\n\n7 Steps to Automated Domain Validation with Let‚Äôs EncryptThe ACME domain validation process [https://letsencrypt.org/how-it-works/] \nrelies on public key cryptography to establish trust. ACME client software\n[https://letsencrypt.org/docs/client-options/], also known as a certificate\nmanagement agent, generates a public-private key pair and presents it to a\nserver on the CA‚Äôs end, along with a domain name. The server then asks the\nclient to prove that it controls the domain in question by satisfying one or\nmore challenges [https://letsencrypt.org/docs/challenge-types/]. If the client\ncompletes the challenges and signs some temporary data (a ‚Äúnonce‚Äù) with its\nprivate key, the server gives the client‚Äôs key pair its stamp of approval.\n\nOnce the client has an authorized key pair, it can use it to request, renew, or\nrevoke certificates from the CA, as long as the keys remain valid. Automating\nthese tasks can eliminate as much as 95% of the labor involved in managing TLS\nencryption.\n\nACME and Traefik\nSo how to get this level of automated certificate management for a Kubernetes\ncluster? One of the easier ways is to deploy the open source Traefik [/traefik/] \nedge router as a Kubernetes Ingress controller\n[https://docs.traefik.io/providers/kubernetes-ingress/]. Traefik includes a \nbuilt-in ACME client [https://docs.traefik.io/https/acme/], so no additional\nsoftware is needed to begin working with Let‚Äôs Encrypt.\n\nWhen used as an Ingress controller, Traefik ferries requests from the external\nnetwork to services running within the Kubernetes cluster, using routes defined\nby Kubernetes Ingress resources\n[https://kubernetes.io/docs/concepts/services-networking/ingress/]. Traefik‚Äôs\nACME client can automatically request and provision certificates for any domain\nassigned to the cluster, making it possible to add TLS-encrypted routes.\n\nTraefik aims to reduce setup times by automatically discovering the right\nconfiguration for a given infrastructure, so putting the pieces in place is\nstraightforward. Instructions on how to install Traefik into a Kubernetes\ncluster and enable Let‚Äôs Encrypt are available in the official documentation\n[https://docs.traefik.io/user-guides/crd-acme/].\n\nA secure starting point\nTraefik and Let‚Äôs Encrypt together offer to set up basic TLS routing for\nKubernetes. As mentioned earlier, however, encryption for network security is a\nnon-trivial matter, particularly in more complex environments. Just for\nstarters, you‚Äôll need genuine domain names that point to servers that are\naccessible by the public internet for Let‚Äôs Encrypt‚Äôs domain-validation\nchallenge process to work.\n\nFurther challenges arise when you want to run more than one instance of Traefik,\nto ensure high availability. It‚Äôs currently not possible to run more than one\ninstance of the community-maintained version of Traefik on a cluster with Let‚Äôs\nEncrypt enabled, because there‚Äôs no guarantee that any request will be handled\nby the correct instance of Traefik. One way to address this is to use the\ncommercial Traefik Enterprise Edition (TraefikEE) [/traefikee/] product, which\noffers distributed Let‚Äôs Encrypt as a supported feature.\n\nOrganizations with more specific needs ‚Äì such as interfacing with enterprise\nvault providers ‚Äì and who aren‚Äôt afraid to take a hands-on, DIY approach may\nneed to install additional, dedicated certificate management software. One such\noption that‚Äôs proven popular is cert-manager [https://cert-manager.io/docs/],\nwhich can work in tandem with both Traefik and TraefikEE.\n\nThe key point, however, is that TLS encryption should be everywhere, and today\nit can be. The ACME protocol, Let‚Äôs Encrypt, and self-configuring software like\nTraefik can automate away much of the hard work that was once involved with\ncertificate management and secure request routing. In turn, that frees you to\nconcentrate on what really matters, which is how to deliver the most value with\nyour services, rather than how to secure them.\n\nYou can try out the features of TraefikEE, including distributed Let‚Äôs Encrypt,\nby starting a 30-day free trial\n[https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days].","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg\" class=\"kg-image\" alt=\"Simplified security for Kubernetes with Traefik and Let's Encrypt\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg 1600w, https://containous.ghost.io/content/images/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><!--kg-card-begin: markdown--><p>Network encryption ‚Äì also known as transport layer security (TLS) ‚Äì is a must for today‚Äôs online apps and services. Beyond the obvious need to prevent data breaches and other malicious attacks, there are also regulatory concerns to consider. Network encryption can be an important step in proving <a href=\"https://gdpr.eu/\" target=\"_blank\" rel=\"nofollow\">GDPR</a> compliance, passing a financial audit, or complying with domain-specific regulations such as <a href=\"https://www.hhs.gov/hipaa/for-professionals/security/laws-regulations/index.html\" target=\"_blank\" rel=\"nofollow\">HIPAA</a> or <a href=\"https://www.pcisecuritystandards.org/\" target=\"_blank\" rel=\"nofollow\">PCI DSS</a>, to name just a few examples.</p>\n<!--kg-card-end: markdown--><p>Unfortunately, getting encryption right is a non-trivial matter, and throwing containers and Kubernetes into the mix only compounds the issue. The distributed nature of Kubernetes environments and the often-brief lifecycles of containerized workloads both multiply the challenges of network security.</p><!--kg-card-begin: markdown--><p>Still, there‚Äôs hope. Newer tools and services ‚Äì including Traefik and <a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"nofollow\">Let‚Äôs Encrypt</a> ‚Äì can make the process of securing Kubernetes clusters simpler, speedier, and more resilient.</p>\n<!--kg-card-end: markdown--><h2 id=\"lowering-barriers-to-encryption\"><strong>Lowering barriers to encryption</strong></h2><!--kg-card-begin: markdown--><p>Historically, network encryption has been both laborious and costly. By some estimates, managing a typical certificate and private key can take four hours per year. That may not sound like much, but when multiplied by the requirements of a large infrastructure, this essential maintenance can quickly become burdensome, particularly given the current push by Apple and other vendors to limit the validity of certificates to <a href=\"https://support.apple.com/en-us/HT211025\" target=\"_blank\" rel=\"nofollow\">no more than 398 days</a>.</p>\n<p>The alternative, however, is even worse. Expired or invalid certificates can lead to outages and reduced service, resulting in untold <a href=\"https://www.google.com/search?q=post-mortem+ssl+cert+expired\" target=\"_blank\" rel=\"nofollow\">losses in productivity and revenue</a>.</p>\n<p>Let‚Äôs Encrypt was founded to address these issues. A project of the <a href=\"https://www.abetterinternet.org/\" target=\"_blank\" rel=\"nofollow\">Internet Security Research Group</a>, Let‚Äôs Encrypt is a free, nonprofit, automated, and open certificate authority (CA), created with the goal of promoting universal internet security and data privacy through encryption. Its sponsors include some of the largest software vendors and online services in the industry.</p>\n<p>Let‚Äôs Encrypt will issue an unlimited number of <a href=\"https://casecurity.org/2013/08/07/what-are-the-different-types-of-ssl-certificates/\" target=\"_blank\" rel=\"nofollow\">domain-validated</a> certificates with 90-day validity to the owner of any domain name, free of charge. As of this writing, the project has issued more than 1 billion certificates and it counts some 200 million websites as its clients.</p>\n<!--kg-card-end: markdown--><h2 id=\"automation-let-s-encrypt-s-secret-sauce\"><strong>Automation: Let‚Äôs Encrypt‚Äôs secret sauce</strong></h2><!--kg-card-begin: markdown--><p>Cost reduction is of course welcome, but the most important benefit of Let‚Äôs Encrypt is labor reduction via automation. For Kubernetes operators, automation is a way of life. Let‚Äôs Encrypt brings that spirit to the world of network security.Central to how Let‚Äôs Encrypt works is the ACME (Automated Certificate Management Environment) protocol, which was made an <a href=\"https://tools.ietf.org/html/rfc8555\" target=\"_blank\" rel=\"nofollow\">IETF standard</a> in 2019. It defines a method whereby a computing service and a CA (typically Let‚Äôs Encrypt itself) can complete the process of requesting, issuing, and verifying certificates without manual intervention.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/07/7-Steps-to-Automated-Domain-Validation-with-Lets-Encrypt.png\" class=\"kg-image\" alt=\"7 Steps to Automated Domain Validation with Let‚Äôs Encrypt\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/7-Steps-to-Automated-Domain-Validation-with-Lets-Encrypt.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/7-Steps-to-Automated-Domain-Validation-with-Lets-Encrypt.png 1000w, https://containous.ghost.io/content/images/2020/07/7-Steps-to-Automated-Domain-Validation-with-Lets-Encrypt.png 1050w\" sizes=\"(min-width: 720px) 720px\"><figcaption><strong>7 Steps to Automated Domain Validation with Let‚Äôs Encrypt</strong></figcaption></figure><!--kg-card-begin: markdown--><p>The ACME <a href=\"https://letsencrypt.org/how-it-works/\" target=\"_blank\" rel=\"nofollow\">domain validation process</a> relies on public key cryptography to establish trust. <a href=\"https://letsencrypt.org/docs/client-options/\" target=\"_blank\" rel=\"nofollow\">ACME client software</a>, also known as a certificate management agent, generates a public-private key pair and presents it to a server on the CA‚Äôs end, along with a domain name. The server then asks the client to prove that it controls the domain in question by satisfying <a href=\"https://letsencrypt.org/docs/challenge-types/\" target=\"_blank\" rel=\"nofollow\">one or more challenges</a>. If the client completes the challenges and signs some temporary data (a ‚Äúnonce‚Äù) with its private key, the server gives the client‚Äôs key pair its stamp of approval.</p>\n<!--kg-card-end: markdown--><p>Once the client has an authorized key pair, it can use it to request, renew, or revoke certificates from the CA, as long as the keys remain valid. Automating these tasks can eliminate as much as 95% of the labor involved in managing TLS encryption.</p><h2 id=\"acme-and-traefik\"><strong>ACME and Traefik</strong></h2><p>So how to get this level of automated certificate management for a Kubernetes cluster? One of the easier ways is to deploy the open source<a href=\"https://containous.ghost.io/traefik/\"> Traefik</a> edge router as a<a href=\"https://docs.traefik.io/providers/kubernetes-ingress/\"> Kubernetes Ingress controller</a>. Traefik includes a<a href=\"https://docs.traefik.io/https/acme/\"> built-in ACME client</a>, so no additional software is needed to begin working with Let‚Äôs Encrypt.</p><p>When used as an Ingress controller, Traefik ferries requests from the external network to services running within the Kubernetes cluster, using routes defined by Kubernetes<a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress/\"> Ingress resources</a>. Traefik‚Äôs ACME client can automatically request and provision certificates for any domain assigned to the cluster, making it possible to add TLS-encrypted routes.</p><p>Traefik aims to reduce setup times by automatically discovering the right configuration for a given infrastructure, so putting the pieces in place is straightforward. Instructions on how to install Traefik into a Kubernetes cluster and enable Let‚Äôs Encrypt are available in the<a href=\"https://docs.traefik.io/user-guides/crd-acme/\"> official documentation</a>.</p><h2 id=\"a-secure-starting-point\"><strong>A secure starting point</strong></h2><p>Traefik and Let‚Äôs Encrypt together offer to set up basic TLS routing for Kubernetes. As mentioned earlier, however, encryption for network security is a non-trivial matter, particularly in more complex environments. Just for starters, you‚Äôll need genuine domain names that point to servers that are accessible by the public internet for Let‚Äôs Encrypt‚Äôs domain-validation challenge process to work.</p><p>Further challenges arise when you want to run more than one instance of Traefik, to ensure high availability. It‚Äôs currently not possible to run more than one instance of the community-maintained version of Traefik on a cluster with Let‚Äôs Encrypt enabled, because there‚Äôs no guarantee that any request will be handled by the correct instance of Traefik. One way to address this is to use the commercial<a href=\"https://containous.ghost.io/traefikee/\"> Traefik Enterprise Edition (TraefikEE)</a> product, which offers distributed Let‚Äôs Encrypt as a supported feature.</p><!--kg-card-begin: markdown--><p>Organizations with more specific needs ‚Äì such as interfacing with enterprise vault providers ‚Äì and who aren‚Äôt afraid to take a hands-on, DIY approach may need to install additional, dedicated certificate management software. One such option that‚Äôs proven popular is <a href=\"https://cert-manager.io/docs/\" target=\"_blank\" rel=\"nofollow\">cert-manager</a>, which can work in tandem with both Traefik and TraefikEE.</p>\n<!--kg-card-end: markdown--><p>The key point, however, is that TLS encryption should be everywhere, and today it can be. The ACME protocol, Let‚Äôs Encrypt, and self-configuring software like Traefik can automate away much of the hard work that was once involved with certificate management and secure request routing. In turn, that frees you to concentrate on what really matters, which is how to deliver the most value with your services, rather than how to secure them.</p><p>You can try out the features of TraefikEE, including distributed Let‚Äôs Encrypt, by starting a <a href=\"https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days\">30-day free trial</a>.</p>","url":"https://containous.ghost.io/blog/simplified-security-for-kubernetes-with-traefik-and-lets-encrypt/","canonical_url":null,"uuid":"45235829-73db-4937-a45e-83147ba3995b","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f161889d90a6e003946cbaa","reading_time":4}},{"node":{"id":"Ghost__Post__5efb70c61555240039b0bf3d","title":"Do Machines Learn? Testing in Production with Traefik","slug":"do-machines-learn-testing-in-production-with-traefik","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/1a0b7b5f2141923692e66f755823a69d/47498/Do-Machines-Learn--Testing-in-Production-with-Traefik-1.jpg","srcSet":"/static/1a0b7b5f2141923692e66f755823a69d/9dc27/Do-Machines-Learn--Testing-in-Production-with-Traefik-1.jpg 300w,\n/static/1a0b7b5f2141923692e66f755823a69d/4fe8c/Do-Machines-Learn--Testing-in-Production-with-Traefik-1.jpg 600w,\n/static/1a0b7b5f2141923692e66f755823a69d/47498/Do-Machines-Learn--Testing-in-Production-with-Traefik-1.jpg 1200w,\n/static/1a0b7b5f2141923692e66f755823a69d/52258/Do-Machines-Learn--Testing-in-Production-with-Traefik-1.jpg 1800w,\n/static/1a0b7b5f2141923692e66f755823a69d/a41d1/Do-Machines-Learn--Testing-in-Production-with-Traefik-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Here is the story about the personalization of a large-scale book reading service and building the infrastructure to evaluate new models utilizing Traefik.","custom_excerpt":"Here is the story about the personalization of a large-scale book reading service and building the infrastructure to evaluate new models utilizing Traefik.","visibility":"public","created_at_pretty":"30 June, 2020","published_at_pretty":"July 28, 2020","updated_at_pretty":"25 August, 2020","created_at":"2020-06-30T17:05:10.000+00:00","published_at":"2020-07-28T14:30:00.000+00:00","updated_at":"2020-08-25T22:48:13.000+00:00","meta_title":"Do Machines Learn? Testing in Production with Traefik","meta_description":"Here is the story about the personalization of a large-scale book reading service and building the infrastructure to evaluate new models utilizing Traefik.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik-Twitter.png","twitter_title":null,"authors":[{"name":"Alexander Dmitriev","slug":"datahoarder","bio":"I am passionate about recommendation systems and personalization, love to think more about the product than the code, know that weeks of coding saves hours of planning.","profile_image":"https://containous.ghost.io/content/images/2020/06/Screen-Shot-2020-06-20-at-21.27.08.png","twitter":null,"facebook":null,"website":"https://github.com/uSasha"}],"primary_author":{"name":"Alexander Dmitriev","slug":"datahoarder","bio":"I am passionate about recommendation systems and personalization, love to think more about the product than the code, know that weeks of coding saves hours of planning.","profile_image":"https://containous.ghost.io/content/images/2020/06/Screen-Shot-2020-06-20-at-21.27.08.png","twitter":null,"facebook":null,"website":"https://github.com/uSasha"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#community-related-resource","slug":"hash-community-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Guest post by Alexander Dmitriev, Traefik Ambassador\n\nAnyone who runs machine learning models in production while trying to improve\nmodel performance most likely knows about A/B tests\n[https://en.wikipedia.org/wiki/A/B_testing]. But what if you are the only\nmachine learning engineer on the project? You must automate these tests as much\nas possible. And what if you have to make dozens of iterations per year and\nsometimes deploy new versions several times a week? Here is my story about the\npersonalization of a large-scale book reading service and building the\ninfrastructure to evaluate new models utilizing Traefik.\n\nAbout MyBook\nMyBook [https://mybook.ru/] is a subscription reading service that publishes\nbook apps for multiple platforms while striving to provide the best reading\nexperience for our users. We've collected a huge catalog of books, audiobooks,\nratings, and summaries that are conveniently always in your pocket. Bookmarks\nare synced across all our user‚Äôs devices and text-audiobook versions. Avid\nreaders can use a subscription with unlimited reading, and those who want just\none book can rent it for half price. My name is Alexander Dmitriev, and I am a\nmachine learning engineer. My field of interest is personalization: recommender\nsystems [https://en.wikipedia.org/wiki/Recommender_system], user satisfaction\nmeasurement [https://en.wikipedia.org/wiki/Computer_user_satisfaction], and\ninfrastructure for these systems. I love to solve problems end-to-end: discuss\nthe user interface with the product manager, prepare data, train machine\nlearning models, write the service, deploy to production, and support it.\n\nBuilding a Smart(er) Recommendation Engine\nHelping customers find books that are interesting to them is essential for a\nretail service like ours. MyBook already has talented editors curating popular\nbook selections, so the next logical step was adding frequently updated personal\nrecommendations. When I started at MyBook, my goal was to build a recommender\nsystem that discovered and suggested books that a customer might find\ninteresting based on their behaviors. This service is known internally as recsys\n, and I'll be focusing on the evolution, automation, and maturation of that\nsystem in this post.\n\nProduction testing is critical for the development of machine learning systems\nlike recsys. Simulating ephemeral properties such as serendipity, variety, and\nrelevance is not feasible with more traditional approaches to testing such as\nunit or integration methodologies used during software development.\n\nWhen the first version of the recommender service was ready, I added a Flask\nserver, built a Docker container, and deployed it on a newly purchased cloud\nserver. Backend engineers added NGINX as a reverse proxy with SSL support\nbecause it had been used for many years on our production systems. The recsys \napplication Flask port was published to the host, and all requests were\nforwarded.\n\nSo, at first, the architecture looked like this:\n\nThe Growing Pains of Productionized Testing\nWe regularly performed A/B tests where we measured the mean number\n[https://en.wikipedia.org/wiki/Mean] of books our users added to their\nbookshelves during a single session. The end results showed us that personalized\nsets performed 30% better than a fixed set of bestsellers handpicked by our\neditors. Eventually, all new versions of recsys rolled out through the A/B test\nagainst the previous one in production. And it looked something like this:\n\nAs time passed and new services appeared, the situation became messy and\nunmanageable:\n\n * Many of the recsys services ports were hardcoded on the backend\n * Prior to each A/B test the health checks, Prometheus exports, alerting rules,\n   and Grafana dashboards had to be configured by hand\n * This process was required any time a new version of recsys was deployed\n\nAs mentioned before, user tests are must-have in personalization tasks and it's\ncrucial to be able to set up and teardown one as quickly and easily as possible,\notherwise this overhead would have driven our velocity and impact close to zero.\n\nMachine Learning at Scale\nAt this stage, it was clear that a better solution was required. I spent some\ntime researching concepts such as service discovery, canary deployments, and\ncloud-native. Eventually, I discovered Traefik [/traefik/], a nice and easy to\nuse reverse-proxy and load balancer which works natively with Docker containers\nand Docker Swarm.\n\nAfter reading the Traefik documentation [https://docs.traefik.io] I discovered\nthat I would get:\n\n * auto-discovery of new containers\n * health checks and routing only to healthy containers\n * metrics endpoint for Prometheus\n * configuration via Docker labels which means all my infrastructure will be\n   described alongside my deployment manifests, perfect\n * no more exposed ports on my containers, now they are secure and accessible\n   only inside the Docker network\n\nFor a long time, I was curious about the the multi-armed bandit\n[https://en.wikipedia.org/wiki/Multi-armed_bandit] approach for recsys tests.\nThe idea of this approach is to optimize some kind of reward (e.g. user\nsatisfaction) during the constant test with adjustments made on the fly and to\nminimize resources (e.g. user sessions) used during the exploration of new\nchoices (recsys models). It seems perfect if you want to test every small\niteration or even several versions of service at the same time.\n\nI ended up building a couple of different prototypes and came to this solution:\n\nEvery service became a router in Traefik terminology, and each recommender\nengine container became a service [https://docs.traefik.io/routing/services/].\n\nTraefik made it possible to assign multiple Docker services to one routing rule\n[https://docs.traefik.io/routing/routers/] and split traffic between services\nwhile assigning\n[https://docs.traefik.io/routing/services/#weighted-round-robin-service] weights\nto each one. So here is the most interesting part:\n\n * The sum of all weights for different versions of the recsys would always\n   equal 100\n * All new versions were deployed with weight 1, so they received only 1% of\n   user traffic\n * Several times a day Python script recalculated recommender performance\n   metrics for each version of recommender (for simplicity let's say CTR or \n   click-through rate [https://en.wikipedia.org/wiki/Click-through_rate]) and\n   updated weights for models; so better performing ones receive more user\n   requests while others receive less\n\nTesting a new version of the recommender engine is as simple as adding a service\ndefinition to the docker-compose file and updating the stack. Docker Swarm finds\nthe difference between the desired and current state, starts a new Docker\ncontainer with `weight = 1`. Traefik finds this container and, after successful\nhealth checks, routes 1% of requests to the new version, all while exporting the\nmetrics required for monitoring by our automated scripts. After a set amount of\ntime the CTR metrics are recalculated and if users like the new version, it is\nreconfigured to receive a larger share of the traffic, and it is constantly\nbeing reevaluated against new models.\n\nTraefik Helps Me Do What I Love Most\nWe are a small team and I am the only MLE on the project, so I insist on\nresearching and utilizing tools that are easy to use and built with love for the\nend-user. Traefik definitely meets that criteria. Maintenance costs are close to\nzero, and the learning curve is flat. This approach is pretty universal no\nmatter which container orchestrator you use and how you configure Traefik,\nwhether you‚Äôre using Kubernetes, Docker labels, Consul, Etcd, or something else.\n\nIn summary, I‚Äôd recommend Traefik [/traefik/] to anyone who needs reverse proxy\nwith all necessary features such as service discovery, monitoring, and metrics\nexporting, which is easy to set up and maintain. It saved me a ton of time so\nthat I could now spend fine-tuning algorithms and adding personal ranking to\neditors' handpicked book sets, which help users find the books they like. All\nthis effort yielded book consumption increase by tens of percent.\n\nAuthor's Bio\nAlex Dmitriev is an engineer in embedded electronics and data scientist in\nmetallurgy. Since 2018, he's been a machine learning engineer at MyBook, and is\nfocused on personalization of user experience and infrastructure for ML\nservices.","html":"<p><strong>Guest post by Alexander Dmitriev, Traefik Ambassador</strong></p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg\" class=\"kg-image\" alt=\"Do Machines Learn? Testing in Production with Traefik\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg 1600w, https://containous.ghost.io/content/images/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><!--kg-card-begin: markdown--><p>Anyone who runs machine learning models in production while trying to improve model performance most likely knows about <a href=\"https://en.wikipedia.org/wiki/A/B_testing\" target=\"_blank\" rel=\"nofollow\">A/B tests</a>. But what if you are the only machine learning engineer on the project? You must automate these tests as much as possible. And what if you have to make dozens of iterations per year and sometimes deploy new versions several times a week? Here is my story about the personalization of a large-scale book reading service and building the infrastructure to evaluate new models utilizing Traefik.</p>\n<!--kg-card-end: markdown--><h2 id=\"about-mybook\">About MyBook</h2><!--kg-card-begin: markdown--><p><a href=\"https://mybook.ru/\" target=\"_blank\" rel=\"nofollow\">MyBook</a> is a subscription reading service that publishes book apps for multiple platforms while striving to provide the best reading experience for our users. We've collected a huge catalog of books, audiobooks, ratings, and summaries that are conveniently always in your pocket. Bookmarks are synced across all our user‚Äôs devices and text-audiobook versions. Avid readers can use a subscription with unlimited reading, and those who want just one book can rent it for half price. My name is Alexander Dmitriev, and I am a machine learning engineer. My field of interest is personalization: <a href=\"https://en.wikipedia.org/wiki/Recommender_system\" target=\"_blank\" rel=\"nofollow\">recommender systems</a>, <a href=\"https://en.wikipedia.org/wiki/Computer_user_satisfaction\" target=\"_blank\" rel=\"nofollow\">user satisfaction measurement</a>, and infrastructure for these systems. I love to solve problems end-to-end: discuss the user interface with the product manager, prepare data, train machine learning models, write the service, deploy to production, and support it.</p>\n<!--kg-card-end: markdown--><h2 id=\"building-a-smart-er-recommendation-engine\">Building a Smart(er) Recommendation Engine</h2><p>Helping customers find books that are interesting to them is essential for a retail service like ours. MyBook already has talented editors curating popular book selections, so the next logical step was adding frequently updated personal recommendations. When I started at MyBook, my goal was to build a recommender system that discovered and suggested books that a customer might find interesting based on their behaviors. This service is known internally as <em>recsys</em>, and I'll be focusing on the evolution, automation, and maturation of that system in this post.</p><p>Production testing is critical for the development of machine learning systems like <em>recsys</em>. Simulating ephemeral properties such as serendipity, variety, and relevance is not feasible with more traditional approaches to testing such as unit or integration methodologies used during software development.</p><p>When the first version of the recommender service was ready, I added a Flask server, built a Docker container, and deployed it on a newly purchased cloud server. Backend engineers added NGINX as a reverse proxy with SSL support because it had been used for many years on our production systems. The <em>recsys </em>application Flask port was published to the host, and all requests were forwarded.</p><p>So, at first, the architecture looked like this:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_01@2x.jpg\" class=\"kg-image\" alt=\"Architecture with Nginx as reverse proxy\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/06/MyBook_Diagram_01@2x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/06/MyBook_Diagram_01@2x.jpg 1000w, https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_01@2x.jpg 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><h2 id=\"the-growing-pains-of-productionized-testing\">The Growing Pains of Productionized Testing</h2><!--kg-card-begin: markdown--><p>We regularly performed A/B tests where we measured the <a href=\"https://en.wikipedia.org/wiki/Mean\" target=\"_blank\" rel=\"nofollow\">mean number</a> of books our users added to their bookshelves during a single session. The end results showed us that personalized sets performed 30% better than a fixed set of bestsellers handpicked by our editors. Eventually, all new versions of recsys rolled out through the A/B test against the previous one in production. And it looked something like this:</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_02@2x.jpg\" class=\"kg-image\" alt=\"Second version of the architecture with Nginx as reverse proxy\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/06/MyBook_Diagram_02@2x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/06/MyBook_Diagram_02@2x.jpg 1000w, https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_02@2x.jpg 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><p>As time passed and new services appeared, the situation became messy and unmanageable:</p><ul><li>Many of the recsys services ports were hardcoded on the backend</li><li>Prior to each A/B test the health checks, Prometheus exports, alerting rules, and Grafana dashboards had to be configured by hand</li><li>This process was required any time a new version of recsys was deployed</li></ul><p>As mentioned before, user tests are must-have in personalization tasks and it's crucial to be able to set up and teardown one as quickly and easily as possible, otherwise this overhead would have driven our velocity and impact close to zero.</p><h2 id=\"machine-learning-at-scale\">Machine Learning at Scale</h2><p>At this stage, it was clear that a better solution was required. I spent some time researching concepts such as service discovery, canary deployments, and cloud-native. Eventually, I discovered <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, a nice and easy to use reverse-proxy and load balancer which works natively with Docker containers and Docker Swarm.</p><p>After reading the Traefik <a href=\"https://docs.traefik.io\">documentation</a> I discovered that I would get:</p><ul><li>auto-discovery of new containers</li><li>health checks and routing only to healthy containers</li><li>metrics endpoint for Prometheus</li><li>configuration via Docker labels which means all my infrastructure will be described alongside my deployment manifests, perfect</li><li>no more exposed ports on my containers, now they are secure and accessible only inside the Docker network</li></ul><!--kg-card-begin: markdown--><p>For a long time, I was curious about the <a href=\"https://en.wikipedia.org/wiki/Multi-armed_bandit\" target=\"_blank\" rel=\"nofollow\">the multi-armed bandit</a> approach for recsys tests. The idea of this approach is to optimize some kind of reward (e.g. user satisfaction) during the constant test with adjustments made on the fly and to minimize resources (e.g. user sessions) used during the exploration of new choices (recsys models). It seems perfect if you want to test every small iteration or even several versions of service at the same time.</p>\n<!--kg-card-end: markdown--><p>I ended up building a couple of different prototypes and came to this solution:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_03@2x.jpg\" class=\"kg-image\" alt=\"Architecture with Traefik as reverse proxy\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/06/MyBook_Diagram_03@2x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/06/MyBook_Diagram_03@2x.jpg 1000w, https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_03@2x.jpg 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Every service became a router in Traefik terminology, and each recommender engine container became a <a href=\"https://docs.traefik.io/routing/services/\">service</a>.</p><p>Traefik made it possible to assign multiple Docker services to one <a href=\"https://docs.traefik.io/routing/routers/\">routing rule</a> and split traffic between services while <a href=\"https://docs.traefik.io/routing/services/#weighted-round-robin-service\">assigning</a> weights to each one. So here is the most interesting part:</p><!--kg-card-begin: markdown--><ul>\n<li>The sum of all weights for different versions of the recsys would always equal 100</li>\n<li>All new versions were deployed with weight 1, so they received only 1% of user traffic</li>\n<li>Several times a day Python script recalculated recommender performance metrics for each version of recommender (for simplicity let's say CTR or <a href=\"https://en.wikipedia.org/wiki/Click-through_rate\" target=\"_blank\" rel=\"nofollow\">click-through rate</a>) and updated weights for models; so better performing ones receive more user requests while others receive less</li>\n</ul>\n<!--kg-card-end: markdown--><p>Testing a new version of the recommender engine is as simple as adding a service definition to the docker-compose file and updating the stack. Docker Swarm finds the difference between the desired and current state, starts a new Docker container with `weight = 1`. Traefik finds this container and, after successful health checks, routes 1% of requests to the new version, all while exporting the metrics required for monitoring by our automated scripts. After a set amount of time the CTR metrics are recalculated and if users like the new version, it is reconfigured to receive a larger share of the traffic, and it is constantly being reevaluated against new models.</p><h2 id=\"traefik-helps-me-do-what-i-love-most\">Traefik Helps Me Do What I Love Most</h2><p>We are a small team and I am the only MLE on the project, so I insist on researching and utilizing tools that are easy to use and built with love for the end-user. Traefik definitely meets that criteria. Maintenance costs are close to zero, and the learning curve is flat. This approach is pretty universal no matter which container orchestrator you use and how you configure Traefik, whether you‚Äôre using Kubernetes, Docker labels, Consul, Etcd, or something else.</p><p>In summary, I‚Äôd recommend <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> to anyone who needs reverse proxy with all necessary features such as service discovery, monitoring, and metrics exporting, which is easy to set up and maintain. It saved me a ton of time so that I could now spend fine-tuning algorithms and adding personal ranking to editors' handpicked book sets, which help users find the books they like. All this effort yielded book consumption increase by tens of percent.</p><h3 id=\"author-s-bio\">Author's Bio</h3><p>Alex Dmitriev is an engineer in embedded electronics and data scientist in metallurgy. Since 2018, he's been a machine learning engineer at MyBook, and is focused on personalization of user experience and infrastructure for ML services.</p>","url":"https://containous.ghost.io/blog/do-machines-learn-testing-in-production-with-traefik/","canonical_url":null,"uuid":"6fdd3d47-70da-43f9-bdfb-c7f840c91d02","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5efb70c61555240039b0bf3d","reading_time":5}},{"node":{"id":"Ghost__Post__5f1f5d0faf4f3b0045f36388","title":"Traefik 2.3: Towards Plugins and Beyond!","slug":"traefik-plugins-pilot","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/08/Blog@1x-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/bcd2c09a2eb9c87798dde34e7c3139a7/47498/Blog%401x-1.jpg","srcSet":"/static/bcd2c09a2eb9c87798dde34e7c3139a7/9dc27/Blog%401x-1.jpg 300w,\n/static/bcd2c09a2eb9c87798dde34e7c3139a7/4fe8c/Blog%401x-1.jpg 600w,\n/static/bcd2c09a2eb9c87798dde34e7c3139a7/47498/Blog%401x-1.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"In this post, Teddy Ferdinand talks about Traefik 2.3, and its features. He dives into Traefik Pilot, our new SaaS control platform, and the middleware plugin management. ","custom_excerpt":"In this post, Teddy Ferdinand talks about Traefik 2.3, and its features. He dives into Traefik Pilot, our new SaaS control platform, and the middleware plugin management. ","visibility":"public","created_at_pretty":"27 July, 2020","published_at_pretty":"August 4, 2020","updated_at_pretty":"25 August, 2020","created_at":"2020-07-27T23:02:39.000+00:00","published_at":"2020-08-04T14:30:00.000+00:00","updated_at":"2020-08-25T14:37:55.000+00:00","meta_title":"Traefik 2.3: Towards Plugins and Beyond!","meta_description":"In this post, Teddy Ferdinand talks about Traefik 2.3, and its features. He dives into Traefik Pilot, our new SaaS control platform, and middlewares.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/08/Twitter@2x.jpg","twitter_title":null,"authors":[{"name":"Teddy Ferdinand","slug":"tferdinand","bio":"Cloud Security Architect at WeScale, Cloud experts in France. I'm a former Ops,  self-taught, and passionate by containers and automatation. I think that knowledge is a wealth that must be shared.","profile_image":"https://containous.ghost.io/content/images/2020/07/portrait.png","twitter":"@TeddyFERDINAND1","facebook":null,"website":"https://tferdinand.net/en/"}],"primary_author":{"name":"Teddy Ferdinand","slug":"tferdinand","bio":"Cloud Security Architect at WeScale, Cloud experts in France. I'm a former Ops,  self-taught, and passionate by containers and automatation. I think that knowledge is a wealth that must be shared.","profile_image":"https://containous.ghost.io/content/images/2020/07/portrait.png","twitter":"@TeddyFERDINAND1","facebook":null,"website":"https://tferdinand.net/en/"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#community-related-resource","slug":"hash-community-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"},{"name":"#traefik-related-resource","slug":"hash-traefik-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"},{"name":"#pilot-related-resource","slug":"hash-pilot-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Traefik 2.3 (codename: Picodon - the cheese you can see illustrated below) and\nis available as a release candidate since mid-July 2020. More than a simple\nversion increment, this release brings a lot of new features. Two significant\nnew features caught my attention:\n\n * Introduction of Traefik Pilot\n   [/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/]\n   : a new SaaS platform\n * Middleware plugin management\n\nThere are other new features that I won't cover in this post, such as\ncompatibility with ECS, but be sure to check out my blog\n[https://tferdinand.net/en/], I'll be posting an article on that soon.\n\nPicodonIs there a pilot in the plane?\nTraefik is a complete and powerful reverse proxy, as I already presented in a \nprevious article\n[https://tferdinand.net/en/traefik-2-reverse-proxy-in-kubernetes/].\nNevertheless, it lacked a managed health check solution.\n\nIt is now possible for free! The new service was launched in conjunction with\nthe Traefik 2.3 release candidate.\n\nTraefik Pilot is a new concept, delivering an entirely new approach to network\nmanagement in the cloud. At the moment, it only facilitates the health check of\nyour Traefik instances, allowing you to receive a notification if it becomes\nunavailable or unhealthy. Traefik Pilot is available now at pilot.traefik.io\n[https://pilot.traefik.io/]. Additional features are planned and will launch in\nthe coming months!\n\nAfter a quick sign-up, it is now possible to register one or more instances of\nTraefik.\n\nI added the command line parameter in the Traefik startup arguments in my\nKubernetes manifest, and after a reboot, the status changed to Green (OK).\n\nHowever, there are a few things to keep in mind:\n\n * This status currently only corresponds to your Traefik container's state and\n   does not mean that the backends are functional.\n * This health check is sent from your instance, in \"heartbeat\" mode, and does\n   not necessarily mean that your server is reachable.\n * As the signal transmitted is a heartbeat, it is possible to monitor instances\n   in the Pilot application area.\n\nBy clicking on your profile name at the top right, it is possible to define\nalarms, via webhooks or by e-mail.\n\nIt is worth noting that it is possible to indicate you wish to receive security\nalarms linked to the discovery of possible CVE that corresponds to your version\nof Traefik.\n\nWarm up the plugins\nFor many years I've been using the ubiquitous Apache HTTP web server.\nUndoubtedly, one of the enormous strengths of this product is its modularity,\nallowing the community to extend its functionality.\n\nTraefik now allows the use of plugins as well. The list is currently rather\nsmall, but I do not doubt that the catalog will snowball as the community begins\npublishing its creations!\n\nIt is possible to contribute plugins written in Go by following the guide\nprovided by Containous [https://github.com/containous/plugindemo].\n\n\nFor this article, I chose the \"Block Path\" plugin written by Containous\n[https://github.com/containous/plugin-blockpath]. This plugin allows us to block\naccess to individual pages based on regular expressions dynamically.\n\nBlocked pages will directly return a 403 (Forbidden) error.\n\nThe interest of this kind of plugins, already existing in most reverse proxies,\nis to be able to intercept access to individual pages and prevent the backend\nfrom receiving the request.\n\nThis type of middleware enables operators:\n\n * To not generate a load (for example, in the case of an admin page that could\n   be brute-forced/DDOS).\n * To avoid exposing an undiscovered zero-day flaw, since the backend does not\n   receive any requests.\n\nInstall the Plugin\nPlugins load via the static configuration\n[https://docs.traefik.io/v1.7/basics/#static-traefik-configuration] of Traefik.\nFor this part, I loaded it via the command line parameters, since this is how I\napproach loading my entire configuration in Kubernetes.\n\nargs:\n  - --providers.kubernetescrd\n  - --accesslog=true\n  - --accesslog.filepath=/var/log/traefik/access.log\n  - --accesslog.fields.headers.defaultmode=keep\n  - --entrypoints.web.address=:80\n  - --entrypoints.websecure.address=:443\n  - --certificatesresolvers.le.acme.email=myawesomemail@mail.com\n  - --certificatesresolvers.le.acme.storage=/cert/acme.json\n  - --certificatesResolvers.le.acme.httpChallenge.entryPoint=web\n  - --experimental.pilot.token=mytoken\n  - --experimental.plugins.demo.moduleName=github.com/containous/plugin-blockpath\n  - --experimental.plugins.demo.version=v0.1.2\n\nAs you can see above, declaring the plugins is manageable via the \nexperimental.plugins arguments.\n\nIn my command line example, \"demo\" is the name I gave to the plugin before\nmoduleName. Thus, it contains the path to the GitHub repository containing the\nplugin, version being the Git version to checkout.\n\nOnce this configuration is in place, it is necessary to restart Traefik.\n\nConfiguring the plugin\nThe plugin then behaves like a traditional middleware; which I explain in my\nprevious article on Traefik TLS configuration, middlewares are components that\nexist between Traefik and your backend and modify the normal behavior. For\nexample, in the article mentioned above, the middleware I used allows you to\ndefine the necessary security headers for ranking A+ on SSL Labs.\n\nThe plugin then behaves like a traditional middleware; which I explain in my \nprevious article on Traefik TLS configuration\n[https://tferdinand.net/en/traefik-2-tls-configuration/], middlewares are\ncomponents that exist between Traefik and your backend and modify the normal\nbehavior. For example, in the article mentioned above, the middleware I used\nallows you to define the necessary security headers for ranking A+ on SSL Labs.\n\nFor this example, I have declared a new middleware for use by Traefik in\nKubernetes:\n\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: demo\nspec:\n  plugin:\n    demo:\n      regex: [\"^/demo-[a-z]{1,5}\"]\n\nConfiguring the plugin declared in the command line arguments requires\nreferencing it in the manifest above in the metadata.name field. In the spec \nfield, we can now configure the plugin according to the schema defined in the\nplugin's documentation. In the example above, I've used regex to indicate that\nTraefik should block any request whose path starts with \"/demo-\" with 1 to 5\nlowercase letters.\n\nLoad middleware\nNow that I have defined my middleware, I have to load it into my IngressRoute.\n\nI modify my IngressRoute by declaring it should load this middleware too. As a\nreminder, you can define multiple middlewares on your IngressRoutes, which will\nexecute in the order specified.\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: traefik-web-ui-tls\n  namespace: default\nspec:\n  entryPoints:\n    - websecure\n  routes:\n  - kind: Rule\n    priority: 1\n    match: (Host(`www.tferdinand.net`) || Host(`tferdinand.net`)) && PathPrefix(`/`)\n    services:\n    - name: ghost-tfe-fr\n      port: 2368\n      helthcheck:\n        path: /\n        host: tferdinand.net\n        intervalSeconds: 10\n        timeoutSeconds: 5\n    middlewares:\n      - name: security\n      - name: demo\n  tls:\n    certResolver: le\n    options:\n      name: mytlsoption\n      namespace: default\n\n\nAs you can see in spec.routes[0].middlewares, I've added a reference to the demo \nmiddleware that I installed and configured in the previous steps.\n\nLet's test the plugin\nNow, it's time to test my plugin configuration.\n\nYes, I also use Windows, and I assume it ;)\n\nAs you can see, the behavior we anticipated is present. Legitimate queries work\nas expected, and Traefik is blocking the requests which match the schema defined\nin the demo plugin configuration before ever reaching the backend service.\n\nIn conclusion: A small step for Containous, a big step for the community.\nTraefik Plugins and Traefik Pilot are technology previews and only scratch the\nsurface of their true potential; however, this open modularity will enable the\ncommunity to extend the core features of Traefik without the necessity of custom\nforks or compiled code.\n\nTraefik Pilot and Plugins will potentially allow companies to develop plugins on\ntheir own and thus adapt Traefik to their needs.\n\nTraefik Pilot is an excellent initiative, and I can't wait to see how Containous\nwill take-off with these new features! \n\nUseful links\n * Get started with Pilot ‚Ä∫ [https://pilot.traefik.io/]\n * Pilot documentation [https://docs.traefik.io/v2.3/plugins/overview/]\n * Traefik [/traefik/]\n * Community forum [https://community.containo.us/c/traefik/5]\n\nAuthor's Bio\nTeddy [https://twitter.com/TeddyFERDINAND1] is a Cloud Security Architect at\nWeScale, an organization made up of cloud experts. He's former Ops, self-taught,\nand is passionate about containers and automation. He believes that knowledge is\nwealth that must be shared.","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/08/Blog@1x.jpg\" class=\"kg-image\" alt srcset=\"https://containous.ghost.io/content/images/size/w600/2020/08/Blog@1x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Blog@1x.jpg 1000w, https://containous.ghost.io/content/images/2020/08/Blog@1x.jpg 1200w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p>Traefik 2.3 (codename: Picodon - the cheese you can see illustrated below) and is available as a release candidate since mid-July 2020. More than a simple version increment, this release brings a lot of new features. Two significant new features caught my attention:</p><ul><li>Introduction of <a href=\"https://containous.ghost.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/\">Traefik Pilot</a>: a new SaaS platform</li><li>Middleware plugin management</li></ul><!--kg-card-begin: markdown--><p>There are other new features that I won't cover in this post, such as compatibility with ECS, but be sure to check out <a href=\"https://tferdinand.net/en/\" target=\"_blank\" rel=\"nofollow\">my blog</a>, I'll be posting an article on that soon.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/07/picodon.jpeg\" class=\"kg-image\" alt=\"Credit: https://fr.wikipedia.org/wiki/Picodon\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/picodon.jpeg 600w, https://containous.ghost.io/content/images/2020/07/picodon.jpeg 700w\"><figcaption>Picodon</figcaption></figure><h2 id=\"is-there-a-pilot-in-the-plane\"><strong>Is there a pilot in the plane?</strong></h2><!--kg-card-begin: markdown--><p>Traefik is a complete and powerful reverse proxy, as I already presented in a <a href=\"https://tferdinand.net/en/traefik-2-reverse-proxy-in-kubernetes/\" target=\"_blank\">previous article</a>. Nevertheless, it lacked a managed health check solution.</p>\n<!--kg-card-end: markdown--><p>It is now possible for free! The new service was launched in conjunction with the Traefik 2.3 release candidate.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/07/Blog@1x-1.png\" class=\"kg-image\" alt srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Blog@1x-1.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Blog@1x-1.png 1000w, https://containous.ghost.io/content/images/2020/07/Blog@1x-1.png 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Traefik Pilot is a new concept, delivering an entirely new approach to network management in the cloud. At the moment, it only facilitates the health check of your Traefik instances, allowing you to receive a notification if it becomes unavailable or unhealthy. Traefik Pilot is available now at <a href=\"https://pilot.traefik.io/\">pilot.traefik.io</a>. Additional features are planned and will launch in the coming months!</p><p>After a quick sign-up, it is now possible to register one or more instances of Traefik.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh3.googleusercontent.com/z6Z52Ixrg3i3IOK0enPGeICQHWk7LVud62tda2goLUx_aHBYmIfO5YuaddKj-IXC28SIpZMkDc5i4F6R1clLQdL39j2z_xog2llgcbnkHnc3HrSEk-sP6NoQfBE6IgKuyZ3Nv85V\" class=\"kg-image\" alt></figure><p>I added the command line parameter in the Traefik startup arguments in my Kubernetes manifest, and after a reboot, the status changed to Green (OK).</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh3.googleusercontent.com/Af6WNGucCMKrTTea7SOK4wU0AXfIhm1hvrWiK06FmFBbZThMMoDToRz3l6AOHLIeWyQQLzSJ8xH3yWWtqwwVXbB3nuTdnK3YEym8TZM0NYLkmtryauJe7F06_PqJCzGTlZOP-cgQ\" class=\"kg-image\" alt></figure><p>However, there are a few things to keep in mind:</p><ul><li>This status currently only corresponds to your Traefik container's state and does not mean that the backends are functional.</li><li>This health check is sent from your instance, in \"heartbeat\" mode, and does not necessarily mean that your server is reachable.</li><li>As the signal transmitted is a heartbeat, it is possible to monitor instances in the Pilot application area.</li></ul><p>By clicking on your profile name at the top right, it is possible to define alarms, via webhooks or by e-mail.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh3.googleusercontent.com/mIpE_f8Is091urCMzXAkgCrrCJARJScSjDRF9LmemzbNfmiEW_DYxPXXdL-6Fc3xYp3OAC3q-Ir04Mbn89CFjLykbenlZaB9FdgzNmiXCFt2DbPzwSR4-Aq5epjCZpLx69zNP4zg\" class=\"kg-image\" alt></figure><p>It is worth noting that it is possible to indicate you wish to receive security alarms linked to the discovery of possible CVE that corresponds to your version of Traefik.</p><h2 id=\"warm-up-the-plugins\"><strong>Warm up the plugins</strong></h2><p>For many years I've been using the ubiquitous Apache HTTP web server. Undoubtedly, one of the enormous strengths of this product is its modularity, allowing the community to extend its functionality.</p><p>Traefik now allows the use of plugins as well. The list is currently rather small, but I do not doubt that the catalog will snowball as the community begins publishing its creations!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh3.googleusercontent.com/R5F_9k2vb-vT_4BTOh1_q0cUn8vfnJNRPgiKjTUi8-UazGQk6EBXA-Rxq9ILZlXQE-dPdUmU4WXIMNadjXcT1qxAsXX21vyY-4gX5SEwxHX6JDZltW4u6Cah9BGRXItAo9_IfrbD\" class=\"kg-image\" alt></figure><p>It is possible to contribute plugins written in Go by following <a href=\"https://github.com/containous/plugindemo\">the guide provided by Containous</a>.<br></p><p>For this article, I chose the <a href=\"https://github.com/containous/plugin-blockpath\">\"Block Path\" plugin written by Containous</a>. This plugin allows us to block access to individual pages based on regular expressions dynamically.</p><p>Blocked pages will directly return a 403 (Forbidden) error.</p><p>The interest of this kind of plugins, already existing in most reverse proxies, is to be able to intercept access to individual pages and prevent the backend from receiving the request.</p><p>This type of middleware enables operators:</p><ul><li>To not generate a load (for example, in the case of an admin page that could be brute-forced/DDOS).</li><li>To avoid exposing an undiscovered zero-day flaw, since the backend does not receive any requests.</li></ul><h3 id=\"install-the-plugin\"><strong>Install the Plugin</strong></h3><p>Plugins load via <a href=\"https://docs.traefik.io/v1.7/basics/#static-traefik-configuration\">the static configuration</a> of Traefik. For this part, I loaded it via the command line parameters, since this is how I approach loading my entire configuration in Kubernetes.</p><pre><code class=\"language-yaml\">args:\n  - --providers.kubernetescrd\n  - --accesslog=true\n  - --accesslog.filepath=/var/log/traefik/access.log\n  - --accesslog.fields.headers.defaultmode=keep\n  - --entrypoints.web.address=:80\n  - --entrypoints.websecure.address=:443\n  - --certificatesresolvers.le.acme.email=myawesomemail@mail.com\n  - --certificatesresolvers.le.acme.storage=/cert/acme.json\n  - --certificatesResolvers.le.acme.httpChallenge.entryPoint=web\n  - --experimental.pilot.token=mytoken\n  - --experimental.plugins.demo.moduleName=github.com/containous/plugin-blockpath\n  - --experimental.plugins.demo.version=v0.1.2</code></pre><p>As you can see above, declaring the plugins is manageable via the <code>experimental.plugins</code> arguments.</p><p>In my command line example, \"demo\" is the name I gave to the plugin before moduleName. Thus, it contains the path to the GitHub repository containing the plugin, version being the Git version to checkout.</p><p>Once this configuration is in place, it is necessary to restart Traefik.</p><h3 id=\"configuring-the-plugin\"><strong>Configuring the plugin</strong></h3><!--kg-card-begin: markdown--><p>The plugin then behaves like a traditional middleware; which I explain in my previous article on Traefik TLS configuration, middlewares are components that exist between Traefik and your backend and modify the normal behavior. For example, in the article mentioned above, the middleware I used allows you to define the necessary security headers for ranking A+ on SSL Labs.</p>\n<!--kg-card-end: markdown--><p>The plugin then behaves like a traditional middleware; which I explain in my <a href=\"https://tferdinand.net/en/traefik-2-tls-configuration/\">previous article on Traefik TLS configuration</a>, middlewares are components that exist between Traefik and your backend and modify the normal behavior. For example, in the article mentioned above, the middleware I used allows you to define the necessary security headers for ranking A+ on SSL Labs.</p><p>For this example, I have declared a new middleware for use by Traefik in Kubernetes:</p><pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: demo\nspec:\n  plugin:\n    demo:\n      regex: [\"^/demo-[a-z]{1,5}\"]</code></pre><p>Configuring the plugin declared in the command line arguments requires referencing it in the manifest above in the <code>metadata.name</code> field. In the <code>spec</code> field, we can now configure the plugin according to the schema defined in the plugin's documentation. In the example above, I've used regex to indicate that Traefik should block any request whose path starts with \"/demo-\" with 1 to 5 lowercase letters.</p><h3 id=\"load-middleware\"><strong>Load middleware</strong></h3><p>Now that I have defined my middleware, I have to load it into my IngressRoute.</p><p>I modify my IngressRoute by declaring it should load this middleware too. As a reminder, you can define multiple middlewares on your IngressRoutes, which will execute in the order specified.</p><pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: traefik-web-ui-tls\n  namespace: default\nspec:\n  entryPoints:\n    - websecure\n  routes:\n  - kind: Rule\n    priority: 1\n    match: (Host(`www.tferdinand.net`) || Host(`tferdinand.net`)) &amp;&amp; PathPrefix(`/`)\n    services:\n    - name: ghost-tfe-fr\n      port: 2368\n      helthcheck:\n        path: /\n        host: tferdinand.net\n        intervalSeconds: 10\n        timeoutSeconds: 5\n    middlewares:\n      - name: security\n      - name: demo\n  tls:\n    certResolver: le\n    options:\n      name: mytlsoption\n      namespace: default\n</code></pre><p>As you can see in <code>spec.routes[0].middlewares</code>, I've added a reference to the <code>demo</code> middleware that I installed and configured in the previous steps.</p><h3 id=\"let-s-test-the-plugin\"><strong>Let's test the plugin</strong></h3><p>Now, it's time to test my plugin configuration.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh4.googleusercontent.com/q752UlNP9VLB7Quofs1dfL6MWZIoqLSTopZbxsASgxu2nhJsLpwo_h0ldRuYhbq4_d4m6pq-uiJHDJyqwqnd7X3ZeT9c2-2qd1PnOfItAUmfXoL17ooOXrm7Q6OAQ-13ezfikOHc\" class=\"kg-image\" alt></figure><p>Yes, I also use Windows, and I assume it ;)</p><p>As you can see, the behavior we anticipated is present. Legitimate queries work as expected, and Traefik is blocking the requests which match the schema defined in the demo plugin configuration before ever reaching the backend service.</p><h2 id=\"in-conclusion-a-small-step-for-containous-a-big-step-for-the-community-\"><strong>In conclusion: A small step for Containous, a big step for the community.</strong></h2><p>Traefik Plugins and Traefik Pilot are technology previews and only scratch the surface of their true potential; however, this open modularity will enable the community to extend the core features of Traefik without the necessity of custom forks or compiled code.</p><p>Traefik Pilot and Plugins will potentially allow companies to develop plugins on their own and thus adapt Traefik to their needs.</p><p>Traefik Pilot is an excellent initiative, and I can't wait to see how Containous will take-off with these new features! </p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://pilot.traefik.io/\">Get started with Pilot ‚Ä∫</a></li><li><a href=\"https://docs.traefik.io/v2.3/plugins/overview/\">Pilot documentation</a></li><li><a href=\"https://containous.ghost.io/traefik/\">Traefik</a></li><li><a href=\"https://community.containo.us/c/traefik/5\">Community forum</a></li></ul><h3 id=\"author-s-bio\">Author's Bio</h3><!--kg-card-begin: markdown--><p><a href=\"https://twitter.com/TeddyFERDINAND1\" target=\"_blank\" rel=\"nofollow\">Teddy</a> is a Cloud Security Architect at WeScale, an organization made up of cloud experts. He's former Ops, self-taught, and is passionate about containers and automation. He believes that knowledge is wealth that must be shared.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/traefik-plugins-pilot/","canonical_url":null,"uuid":"8f55b279-8cc8-4932-aa5b-fffc61d38439","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f1f5d0faf4f3b0045f36388","reading_time":6}},{"node":{"id":"Ghost__Post__5f1f638faf4f3b0045f363d9","title":"William & Mary uses Traefik to Streamline Complex Deployments Across Multiple Clouds","slug":"william-mary-uses-traefik-to-streamline-complex-deployments-across-multiple-clouds","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/734489a52f33e0d6290fb7981082dd0e/47498/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog-1.jpg","srcSet":"/static/734489a52f33e0d6290fb7981082dd0e/9dc27/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog-1.jpg 300w,\n/static/734489a52f33e0d6290fb7981082dd0e/4fe8c/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog-1.jpg 600w,\n/static/734489a52f33e0d6290fb7981082dd0e/47498/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog-1.jpg 1200w,\n/static/734489a52f33e0d6290fb7981082dd0e/52258/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog-1.jpg 1800w,\n/static/734489a52f33e0d6290fb7981082dd0e/a41d1/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Learn how William & Mary uses Traefik to streamline complex deployments across multiple clouds in a heterogenous ecosystem with Docker and Kubernetes. ","custom_excerpt":"Learn how William & Mary uses Traefik to streamline complex deployments across multiple clouds in a heterogenous ecosystem with Docker and Kubernetes. ","visibility":"public","created_at_pretty":"27 July, 2020","published_at_pretty":"August 10, 2020","updated_at_pretty":"17 September, 2020","created_at":"2020-07-27T23:30:23.000+00:00","published_at":"2020-08-10T23:02:00.000+00:00","updated_at":"2020-09-17T17:10:42.000+00:00","meta_title":"W&M uses Traefik to Streamline Complex Deployments Across Clouds ","meta_description":"Learn how William & Mary uses Traefik to streamline complex deployments across multiple clouds in a heterogenous ecosystem with Docker and Kubernetes. ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/08/William---Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Twitter.png","twitter_title":"William & Mary uses Traefik to Streamline Complex Deployments Across Multiple Clouds","authors":[{"name":"Patricia Dugan ","slug":"patricia","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/01/me-looking-cute.JPG","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Patricia Dugan ","slug":"patricia","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/01/me-looking-cute.JPG","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Case Studies","slug":"case-studies","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":"Learn from our users and customers why they choose Traefik and TraefikEE as a modern load balancer to manage network traffic.","meta_title":"Case studies | Containous","visibility":"public"}],"plaintext":"About William & Mary\nWilliam & Mary [https://www.wm.edu/] is a top public research university and one\nof only eight ‚ÄúPublic Ivy‚Äù schools in the United States, known for its rigorous\nacademic program. The W&M IT team manages the entire university‚Äôs technical\ninfrastructure, ensuring smooth operations for approximately 8,000 students and\n1,300 staff. The IT team of roughly 100 people administers campus networking,\ndesktop support, business and administrative faculty support, end-user client\nsupport, research, and high-performance computing.\n\nOverview\nAs a residential campus, W&M sees high application load and data volumes that\npeak at specific times in the academic calendar, especially during registration.\nThey operate within a heterogeneous technical infrastructure and host a wide\narray of technical integrations. Using proprietary software such as their ERP\nsystem, which requires updates that adhere to industry-specific regulations, are\ncentral to their infrastructure. The team selects open source software when\npossible, as it enables developer collaboration with industry and other colleges\nand universities.\n\nThe University‚Äôs technical infrastructure has successfully transformed from\nrunning primarily on legacy systems to boasting a diverse technical stack,\ninclusive of bare metal, containers, and the public cloud. It now supports a\nwide range of services from behind traditional load balancers and VMs, in\naddition to auto-scaling containerized distributed computing platforms, using\nTraefik and Kubernetes.\n\nChallenge\nPhil Fenstermacher, the Lead Linux Engineer, is part of the leadership team\nresponsible for building and managing the platforms used by the students and\nstaff at W&M. They are governed by a charter to provide functional solutions\nthat adhere to ever-changing, strict regulatory demands of industry-specific\nsoftware. There is an expectation to address these technological needs on a lean\nbudget. As innovation continues to change rapidly, and as their workload has\ngrown, the need to evolve from a virtualized environment to an environment\nfacilitating the use of containers and Kubernetes was a priority. \n\nAs an initial step towards transitioning to a container environment, they\nimplemented Docker Swarm and used the internal load balancer that ships with\nSwarm. Over time, the team at W&M needed a cloud-native reverse proxy as more\nworkloads were containerized and adopted into this new environment. These\nfeatures included the ability to use persistent sessions, while handling bursty,\nlarge workloads along with providing integrations with commercial software\nrequired for core business systems. The successful implementation of complex\nsystems such as ERP, CMS, and procurement software was critical. Docker Swarm\nwas easy to use, but these new requirements demanded a feature-rich and\nprotocol-aware load balancer to meet their needs.\n\nInspired by an upcoming ERP update, which would require managing hundreds of\nproduction and non-production virtual machines, Phil‚Äôs team sought to leverage\nthe inherent benefits of containers. Core requirements for this update forbade\nany rewrites of the commercial software, creating massive amounts of custom\nwrapper scripts, or changing the fundamental architecture of these applications.\nFinding a load balancer which seamlessly handled multiple integrations, and\nfunctioned well with Kubernetes and Docker Swarm, was the challenge.\n\nThey sought options to evaluate and came across Traefik.\n\nSolution\nTraefik checked many of the boxes: it is open source, highly cost-effective, has\na great user community [/community/], walks in close step with the expanding\nKubernetes community, but also works in the existing Docker Swarm environment.\nIn the spirit of academic rigor, though, Phil‚Äôs team wanted to test a variety of\nsolutions in the marketplace, such as NGINX, and HAproxy, making comparisons\nside by side with Traefik. \n\nPhil‚Äôs team observed that Traefik ran smoothly out-of-the-box and surpassed\nalternatives in the ways that mattered. The other solutions required large\namounts of manual configuration and lacked some service discovery capabilities.\nAlso, features one would expect from a modern cloud-native load balancer were\nsuspiciously absent. Traefik offered the functionality the team at W&M needed,\nincluding service discovery, persistent sessions, header modifications,\nPrometheus integration, a visually intuitive dashboard for monitoring, and easy\ndeployment and operation.\n\n> ‚ÄúThe simplicity of using Traefik for persistent sessions, by simply copy and\npasting a line of code has been a game-changer.‚Äù - Phil Fenstermacher, Lead\nLinux Engineer\nThe University currently runs approximately 100 services through an on-premises\ndeployment of Traefik on Docker Swarm, and another 30 services on Kubernetes in\nthe cloud. A smaller on-premise ¬†Kubernetes cluster hosts everything from\nacademic and enterprise applications. William & Mary‚Äôs small engineering team\ncan easily manage the 150+ services and 400+ containers because Traefik‚Äôs\nconfiguration is kept alongside application configurations using labels in\nDocker Swarm or an Ingress object in Kubernetes. A similar configuration scheme\nfor both orchestrators means the same engineers can support both without the\noverhead of another unique system.\n\nW&M has used Traefik since version 1.3 and has since migrated to Version 2.2 on\nKubernetes, which has support for native Ingress resource annotations. The\nlatest version of Traefik makes their engineering workflow more straightforward,\nnotably due to the flexibility of having both Ingress and Traefik's CRDs, which\nallow for less manual configuration and managing more complex settings with only\na single solution.\n\n> ‚ÄúIt's like the Traefik load balancer is almost the boring piece. We don't spend\na lot of time talking about it. We use Traefik, it does what we need, what it's\nexpected to do, and reliably.‚Äù\nBottom line \nWilliam & Mary selects only high-performance, reliable, and budget-savvy\nsoftware solutions. They have chosen Traefik to manage the university's load\nbalancing needs, as the software is easy to implement, maintain, and trust.\nWithout Traefik, W&M faced the deployment of its new ERP system in a legacy\nenvironment using a traditional load balancer. Ultimately, this would have meant\nhigher costs for both operation and maintenance, all with less predictability,\nfunctionality, and consistency.\n\nWhat‚Äôs Next?\n * Get started with Traefik [/traefik/] today\n * Ready for production deployments? Discover Traefik Enterprise Edition\n   [/traefikee/], and request your demo\n   [https://info.containo.us/request-demo-traefikee]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg\" class=\"kg-image\" alt=\"William &amp; Mary uses Traefik to Streamline Complex Deployments Across Multiple Clouds\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg 1600w, https://containous.ghost.io/content/images/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><h2 id=\"about-william-mary\">About William &amp; Mary</h2><!--kg-card-begin: markdown--><p><a href=\"https://www.wm.edu/\" target=\"_blank\" rel=\"nofollow\">William &amp; Mary</a> is a top public research university and one of only eight ‚ÄúPublic Ivy‚Äù schools in the United States, known for its rigorous academic program. The W&amp;M IT team manages the entire university‚Äôs technical infrastructure, ensuring smooth operations for approximately 8,000 students and 1,300 staff. The IT team of roughly 100 people administers campus networking, desktop support, business and administrative faculty support, end-user client support, research, and high-performance computing.</p>\n<!--kg-card-end: markdown--><h2 id=\"overview\">Overview</h2><p>As a residential campus, W&amp;M sees high application load and data volumes that peak at specific times in the academic calendar, especially during registration. They operate within a heterogeneous technical infrastructure and host a wide array of technical integrations. Using proprietary software such as their ERP system, which requires updates that adhere to industry-specific regulations, are central to their infrastructure. The team selects open source software when possible, as it enables developer collaboration with industry and other colleges and universities.</p><p>The University‚Äôs technical infrastructure has successfully transformed from running primarily on legacy systems to boasting a diverse technical stack, inclusive of bare metal, containers, and the public cloud. It now supports a wide range of services from behind traditional load balancers and VMs, in addition to auto-scaling containerized distributed computing platforms, using Traefik and Kubernetes.</p><h2 id=\"challenge\">Challenge</h2><p>Phil Fenstermacher, the Lead Linux Engineer, is part of the leadership team responsible for building and managing the platforms used by the students and staff at W&amp;M. They are governed by a charter to provide functional solutions that adhere to ever-changing, strict regulatory demands of industry-specific software. There is an expectation to address these technological needs on a lean budget. As innovation continues to change rapidly, and as their workload has grown, the need to evolve from a virtualized environment to an environment facilitating the use of containers and Kubernetes was a priority. </p><p>As an initial step towards transitioning to a container environment, they implemented Docker Swarm and used the internal load balancer that ships with Swarm. Over time, the team at W&amp;M needed a cloud-native reverse proxy as more workloads were containerized and adopted into this new environment. These features included the ability to use persistent sessions, while handling bursty, large workloads along with providing integrations with commercial software required for core business systems. The successful implementation of complex systems such as ERP, CMS, and procurement software was critical. Docker Swarm was easy to use, but these new requirements demanded a feature-rich and protocol-aware load balancer to meet their needs.</p><p>Inspired by an upcoming ERP update, which would require managing hundreds of production and non-production virtual machines, Phil‚Äôs team sought to leverage the inherent benefits of containers. Core requirements for this update forbade any rewrites of the commercial software, creating massive amounts of custom wrapper scripts, or changing the fundamental architecture of these applications. Finding a load balancer which seamlessly handled multiple integrations, and functioned well with Kubernetes and Docker Swarm, was the challenge.</p><p>They sought options to evaluate and came across Traefik.</p><h2 id=\"solution\">Solution</h2><p>Traefik checked many of the boxes: it is open source, highly cost-effective, has a <a href=\"https://containous.ghost.io/community/\">great user community</a>, walks in close step with the expanding Kubernetes community, but also works in the existing Docker Swarm environment. In the spirit of academic rigor, though, Phil‚Äôs team wanted to test a variety of solutions in the marketplace, such as NGINX, and HAproxy, making comparisons side by side with Traefik. </p><p>Phil‚Äôs team observed that Traefik ran smoothly out-of-the-box and surpassed alternatives in the ways that mattered. The other solutions required large amounts of manual configuration and lacked some service discovery capabilities. Also, features one would expect from a modern cloud-native load balancer were suspiciously absent. Traefik offered the functionality the team at W&amp;M needed, including service discovery, persistent sessions, header modifications, Prometheus integration, a visually intuitive dashboard for monitoring, and easy deployment and operation.</p><blockquote><em>‚ÄúThe simplicity of using Traefik for persistent sessions, by simply copy and pasting a line of code has been a game-changer.‚Äù - Phil Fenstermacher, Lead Linux Engineer</em></blockquote><p>The University currently runs approximately 100 services through an on-premises deployment of Traefik on Docker Swarm, and another 30 services on Kubernetes in the cloud. A smaller on-premise ¬†Kubernetes cluster hosts everything from academic and enterprise applications. William &amp; Mary‚Äôs small engineering team can easily manage the 150+ services and 400+ containers because Traefik‚Äôs configuration is kept alongside application configurations using labels in Docker Swarm or an Ingress object in Kubernetes. A similar configuration scheme for both orchestrators means the same engineers can support both without the overhead of another unique system.</p><p>W&amp;M has used Traefik since version 1.3 and has since migrated to Version 2.2 on Kubernetes, which has support for native Ingress resource annotations. The latest version of Traefik makes their engineering workflow more straightforward, notably due to the flexibility of having both Ingress and Traefik's CRDs, which allow for less manual configuration and managing more complex settings with only a single solution.</p><blockquote><em>‚ÄúIt's like the Traefik load balancer is almost the boring piece. We don't spend a lot of time talking about it. We use Traefik, it does what we need, what it's expected to do, and reliably.</em>‚Äù</blockquote><h2 id=\"bottom-line\">Bottom line </h2><p>William &amp; Mary selects only high-performance, reliable, and budget-savvy software solutions. They have chosen Traefik to manage the university's load balancing needs, as the software is easy to implement, maintain, and trust. Without Traefik, W&amp;M faced the deployment of its new ERP system in a legacy environment using a traditional load balancer. Ultimately, this would have meant higher costs for both operation and maintenance, all with less predictability, functionality, and consistency.</p><h2 id=\"what-s-next\">What‚Äôs Next?</h2><ul><li>Get started with <a href=\"https://containous.ghost.io/traefik/\" rel=\"noopener nofollow\">Traefik</a> today</li><li>Ready for production deployments? <a href=\"https://containous.ghost.io/traefikee/\">Discover Traefik Enterprise Edition</a>, and <a href=\"https://info.containo.us/request-demo-traefikee\" rel=\"noopener nofollow\">request your demo</a></li></ul>","url":"https://containous.ghost.io/blog/william-mary-uses-traefik-to-streamline-complex-deployments-across-multiple-clouds/","canonical_url":null,"uuid":"974a28c8-dadf-4a34-8dfa-af19016186b3","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f1f638faf4f3b0045f363d9","reading_time":4}},{"node":{"id":"Ghost__Post__5f3b0d665751e70039ad7abe","title":"Unleash custom networking logic with Traefik Plugins","slug":"unleash-custom-networking-logic-with-traefik-plugins","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/0d60ce787ca95ce21c1cef9ebdcf1b51/47498/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog-1.jpg","srcSet":"/static/0d60ce787ca95ce21c1cef9ebdcf1b51/9dc27/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog-1.jpg 300w,\n/static/0d60ce787ca95ce21c1cef9ebdcf1b51/4fe8c/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog-1.jpg 600w,\n/static/0d60ce787ca95ce21c1cef9ebdcf1b51/47498/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog-1.jpg 1200w,\n/static/0d60ce787ca95ce21c1cef9ebdcf1b51/52258/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog-1.jpg 1800w,\n/static/0d60ce787ca95ce21c1cef9ebdcf1b51/a41d1/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"With Traefik plugins, you can now easily build, use, and share your own custom extensions to Traefik‚Äôs functionality, with minimal development overhead.","custom_excerpt":"With Traefik plugins, you can now easily build, use, and share your own custom extensions to Traefik‚Äôs functionality, with minimal development overhead.","visibility":"public","created_at_pretty":"17 August, 2020","published_at_pretty":"August 19, 2020","updated_at_pretty":"10 September, 2020","created_at":"2020-08-17T23:06:14.000+00:00","published_at":"2020-08-19T15:32:38.000+00:00","updated_at":"2020-09-10T14:19:52.000+00:00","meta_title":"Unleash custom networking logic with Traefik Plugins","meta_description":"With Traefik plugins, you can now easily build, use, and share your own custom extensions to Traefik‚Äôs functionality, with minimal development overhead.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Twitter.png","twitter_title":null,"authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#pilot-related-resource","slug":"hash-pilot-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Traefik is built to handle the application networking functions that are\nessential to modern IT. In today‚Äôs cloud-native environments, containerized\napplications and microservices must be in constant communication across\nnetworks. Functions like load balancing, inbound traffic management, and network\nsecurity are more critical than ever. Fortunately, Traefik addresses these needs\nelegantly and reliably.\n\nAlmost inevitably, however, situations arise that can't easily be handled using\nstandard features and methods. Perhaps an unusual application design requires\nunorthodox routing, or abnormal traffic conditions call for a novel, short-term\nfix. Ideally, you should be able to deploy custom logic to handle such niche\ncases.\n\nThat‚Äôs precisely the goal of Traefik plugins, which were introduced in the\nrelease-candidate builds of Traefik 2.3. Traefik has always been modular and\nextensible, and its feature set has grown with the addition of each new provider\n[https://docs.traefik.io/providers/overview/] and middleware\n[https://docs.traefik.io/middlewares/overview/]. With the addition of plugins,\nhowever, you can now easily build, use, and share their own custom extensions to\nTraefik‚Äôs functionality, with minimal development overhead.\n\nExtensibility for everyone\nApplication plugins themselves are nothing new. Monolithic desktop apps from the\nlikes of Adobe and Microsoft were among the first to introduce extension\nmechanisms, and web browsers weren‚Äôt far behind. But the earliest plugins\nshipped as prebuilt binaries, like the applications themselves. That meant they\nwere often quirky to use, difficult to develop, and incompatible across\nplatforms or even application versions.\n\nAs web browsers evolved into the most-used software in the world, however, they\nalso blazed the path for how plugins should be built. As a result of work by\nGoogle, Mozilla, and others, creating extensions for today‚Äôs web browsers is\nboth simpler and more open than in the past, thanks to key characteristics of\ntheir second-generation plugin model:\n\n * Modern browser extensions are written in JavaScript, a language that‚Äôs\n   familiar to browser users and anyone involved with web development.\n * They are simple to develop and test, requiring no elaborate toolchains or\n   build processes.\n * They are shared and distributed securely via a centralized, online\n   marketplace.\n\nTraefik the way you want it\nTraefik‚Äôs new plugins take cues from modern browser extensions, with the aim of\nmaking it as easy to extend Traefik as it is to extend your browser. While\ntraditional Traefik middlewares resemble the older style of binary plugins,\nTraefik‚Äôs new plugin mechanism follows the pattern set by the likes of Chrome\nand Firefox:\n\n * Traefik plugins are written in Go [https://golang.org/], the language used to\n   develop Docker, Kubernetes, the Traefik family of projects, and other\n   cloud-native infrastructure software.\n * Traefik‚Äôs embedded Yaegi interpreter [/blog/announcing-yaegi-263a1e2d070a/] \n   makes plugin development and testing easy. No code needs to be compiled or\n   linked, making this the first true interpreted Go language plugin\n   mechanism.Plugins are distributed and shared online via an open marketplace\n   that integrates with Traefik Pilot\n   [/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/]\n   , the new SaaS control plane for Traefik.\n\nNaturally, in designing an extension mechanism for Traefik, security is a top\nconcern. Hosting plugins in the centralized Traefik Pilot hub makes it possible\nto block plugins containing malicious or malformed code for all Traefik users,\nprotecting the entire community. Only open source plugins are allowed, so that\ntheir code can be reviewed and inspected for potential defects. And Traefik\noperators have ultimate control over which plugins are installed and allowed to\nrun in their Traefik instances, as plugins can only be loaded and activated from\nTraefik‚Äôs static configuration at startup.\n\nPlugins utilize the Go module downloading and verification system to protect\nusers from unauthorized changes to code. We'll share more in-depth details on\nthis and the security features of the runtime interpreter in a later post.\n\nPlugging in\nBecause Traefik‚Äôs plugin mechanism follows industry best practices, working with\nTraefik plugins is almost as easy as working with browser extensions. To get up\nand running with your first plugin involves four key steps:\n\n1. Register your Traefik instances\nPlugins are only available to Traefik instances that are registered with the\nTraefik Pilot SaaS service. Registering is as easy aa logging into your Pilot\naccount [https://pilot.traefik.io/] and clicking a button to request a token.\nOnce you add that token to your Traefik instance‚Äôs static configuration, you‚Äôre\nready to begin working with plugins from the catalog\n[https://pilot.traefik.io/plugins] or to create your own. You‚Äôll also gain the\nbenefits of health monitoring and security vulnerability updates for your\nregistered instances.\n\n2. Develop your plugin\nTraefik‚Äôs embedded Yaegi interpreter can handle virtually any Go code you throw\nat it. A good way to start is to read the documentation\n[https://github.com/containous/plugindemo] and review the source code of the\nDemo plugin that‚Äôs provided with Traefik Pilot. You can gain further inspiration\nby browsing the source code of contributed plugins in their own repositories\n[https://github.com/topics/traefik-plugin].\n\n3. Host your plugin on GitHub\nMost developers will already be familiar with GitHub as a way to share code with\nthe community. Every 30 minutes, Traefik Pilot polls GitHub, looking for\nrepositories hosting plugins to add to the public catalog. For your plugin to be\nrecognized, you need only set the topic `traefik-plugin` on your repo and\ninclude a manifest, as described in the developer documentation\n[https://github.com/containous/plugindemo/blob/master/readme.md].\n\n4. Load and activate your plugin\nOnce your plugin is available in the Traefik Pilot catalog, it‚Äôs ready for use\nin your Traefik instances. As mentioned earlier, for security reasons, plugin\nactivation code must be included in an instance‚Äôs static configuration. No\nplugins can be installed or modified while Traefik is running. Some plugins may\nalso need to have options set in the dynamic configuration. Clicking the\n‚ÄúInstall Plugin‚Äù button from the plugin‚Äôs page in the Traefik Pilot catalog\nsupplies cut-and-paste templates of the code you‚Äôll need for both the static and\ndynamic configurations.\n\nMore to come\nThis first iteration of the Traefik plugin interface gives you what you need to\nstart building and deploying plugins that enable custom routing behaviors, like\nTraefik middlewares. You can expect forthcoming releases to make plugins even\nmore powerful. For example, future plugins will be able to act as providers,\nmaking it possible to use these techniques to extend Traefik‚Äôs auto-discovery\ncapabilities to include new orchestrators, cloud providers, key-value stores,\nand other infrastructure components.\n\nFor now, we hope you‚Äôll take this opportunity to explore how plugins expand the\npossibilities of Traefik. Join the Traefik community forums\n[https://community.containo.us/c/traefik/5] to continue the discussion and help\nmake Traefik the most powerful, versatile, and extensible tool for your\napplication networking needs.","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg\" class=\"kg-image\" alt=\"Unleash custom networking logic with Traefik Plugins\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg 1600w, https://containous.ghost.io/content/images/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p>Traefik is built to handle the application networking functions that are essential to modern IT. In today‚Äôs cloud-native environments, containerized applications and microservices must be in constant communication across networks. Functions like load balancing, inbound traffic management, and network security are more critical than ever. Fortunately, Traefik addresses these needs elegantly and reliably.</p><p>Almost inevitably, however, situations arise that can't easily be handled using standard features and methods. Perhaps an unusual application design requires unorthodox routing, or abnormal traffic conditions call for a novel, short-term fix. Ideally, you should be able to deploy custom logic to handle such niche cases.</p><p>That‚Äôs precisely the goal of Traefik plugins, which were introduced in the release-candidate builds of Traefik 2.3. Traefik has always been modular and extensible, and its feature set has grown with the addition of each new <a href=\"https://docs.traefik.io/providers/overview/\">provider</a> and <a href=\"https://docs.traefik.io/middlewares/overview/\">middleware</a>. With the addition of plugins, however, you can now easily build, use, and share their own custom extensions to Traefik‚Äôs functionality, with minimal development overhead.</p><h2 id=\"extensibility-for-everyone\"><strong>Extensibility for everyone</strong></h2><p>Application plugins themselves are nothing new. Monolithic desktop apps from the likes of Adobe and Microsoft were among the first to introduce extension mechanisms, and web browsers weren‚Äôt far behind. But the earliest plugins shipped as prebuilt binaries, like the applications themselves. That meant they were often quirky to use, difficult to develop, and incompatible across platforms or even application versions.</p><p>As web browsers evolved into the most-used software in the world, however, they also blazed the path for how plugins should be built. As a result of work by Google, Mozilla, and others, creating extensions for today‚Äôs web browsers is both simpler and more open than in the past, thanks to key characteristics of their second-generation plugin model:</p><ul><li>Modern browser extensions are written in JavaScript, a language that‚Äôs familiar to browser users and anyone involved with web development.</li><li>They are simple to develop and test, requiring no elaborate toolchains or build processes.</li><li>They are shared and distributed securely via a centralized, online marketplace.</li></ul><h2 id=\"traefik-the-way-you-want-it\"><strong>Traefik the way you want it</strong></h2><p>Traefik‚Äôs new plugins take cues from modern browser extensions, with the aim of making it as easy to extend Traefik as it is to extend your browser. While traditional Traefik middlewares resemble the older style of binary plugins, Traefik‚Äôs new plugin mechanism follows the pattern set by the likes of Chrome and Firefox:</p><ul><li>Traefik plugins are written in <a href=\"https://golang.org/\">Go</a>, the language used to develop Docker, Kubernetes, the Traefik family of projects, and other cloud-native infrastructure software.</li><li>Traefik‚Äôs embedded <a href=\"https://containous.ghost.io/blog/announcing-yaegi-263a1e2d070a/\">Yaegi interpreter</a> makes plugin development and testing easy. No code needs to be compiled or linked, making this the first true interpreted Go language plugin mechanism.Plugins are distributed and shared online via an open marketplace that integrates with <a href=\"https://containous.ghost.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/\">Traefik Pilot</a>, the new SaaS control plane for Traefik.</li></ul><figure class=\"kg-card kg-image-card\"><img src=\"https://lh4.googleusercontent.com/By5DYG5wjOdErYmc54JCuNGPw3M8ICAULWs-1xD9BlCrzm5CpfS6ob2Kx71PKY5xBw8slQQzvbNuxbZqD8SDJiAQChSQYxr0YCoxqdO6MrxhK62exH5MPHpITuxLbiZTE96KA2U\" class=\"kg-image\" alt=\"Traefik Pilot Plugins page\"></figure><p>Naturally, in designing an extension mechanism for Traefik, security is a top concern. Hosting plugins in the centralized Traefik Pilot hub makes it possible to block plugins containing malicious or malformed code for all Traefik users, protecting the entire community. Only open source plugins are allowed, so that their code can be reviewed and inspected for potential defects. And Traefik operators have ultimate control over which plugins are installed and allowed to run in their Traefik instances, as plugins can only be loaded and activated from Traefik‚Äôs static configuration at startup.</p><p>Plugins utilize the Go module downloading and verification system to protect users from unauthorized changes to code. We'll share more in-depth details on this and the security features of the runtime interpreter in a later post.</p><h2 id=\"plugging-in\"><strong>Plugging in</strong></h2><p>Because Traefik‚Äôs plugin mechanism follows industry best practices, working with Traefik plugins is almost as easy as working with browser extensions. To get up and running with your first plugin involves four key steps:</p><h3 id=\"1-register-your-traefik-instances\"><strong>1. Register your Traefik instances</strong></h3><p>Plugins are only available to Traefik instances that are registered with the Traefik Pilot SaaS service. Registering is as easy aa <a href=\"https://pilot.traefik.io/\">logging into your Pilot account</a> and clicking a button to request a token. Once you add that token to your Traefik instance‚Äôs static configuration, you‚Äôre ready to begin working with <a href=\"https://pilot.traefik.io/plugins\">plugins from the catalog</a> or to create your own. You‚Äôll also gain the benefits of health monitoring and security vulnerability updates for your registered instances.</p><h3 id=\"2-develop-your-plugin\"><strong>2. Develop your plugin</strong></h3><p>Traefik‚Äôs embedded Yaegi interpreter can handle virtually any Go code you throw at it. A good way to start is to read the <a href=\"https://github.com/containous/plugindemo\">documentation</a> and review the source code of the Demo plugin that‚Äôs provided with Traefik Pilot. You can gain further inspiration by browsing the source code of contributed plugins in <a href=\"https://github.com/topics/traefik-plugin\">their own repositories</a>.</p><h3 id=\"3-host-your-plugin-on-github\"><strong>3. Host your plugin on GitHub</strong></h3><p>Most developers will already be familiar with GitHub as a way to share code with the community. Every 30 minutes, Traefik Pilot polls GitHub, looking for repositories hosting plugins to add to the public catalog. For your plugin to be recognized, you need only set the topic `traefik-plugin` on your repo and include a manifest, as described in the <a href=\"https://github.com/containous/plugindemo/blob/master/readme.md\">developer documentation</a>.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh6.googleusercontent.com/g8H6MFQddfIOzxLGl7xfgtTztNPaS-iE6cAE3tR6sJWnRHbCUUny1u_mGf1skj3aZCj3JSdD_F5RJ23Q7WlxlRyBy1neUSg9gHV63UaGP7KctsJrMkt2acXy3Z5B9cOFJfmitwg\" class=\"kg-image\" alt=\"How to install a plugin in Traefik\"></figure><h3 id=\"4-load-and-activate-your-plugin\"><strong>4. Load and activate your plugin</strong></h3><p>Once your plugin is available in the Traefik Pilot catalog, it‚Äôs ready for use in your Traefik instances. As mentioned earlier, for security reasons, plugin activation code must be included in an instance‚Äôs static configuration. No plugins can be installed or modified while Traefik is running. Some plugins may also need to have options set in the dynamic configuration. Clicking the ‚ÄúInstall Plugin‚Äù button from the plugin‚Äôs page in the Traefik Pilot catalog supplies cut-and-paste templates of the code you‚Äôll need for both the static and dynamic configurations.</p><h2 id=\"more-to-come\"><strong>More to come</strong></h2><p>This first iteration of the Traefik plugin interface gives you what you need to start building and deploying plugins that enable custom routing behaviors, like Traefik middlewares. You can expect forthcoming releases to make plugins even more powerful. For example, future plugins will be able to act as <em>providers</em>, making it possible to use these techniques to extend Traefik‚Äôs auto-discovery capabilities to include new orchestrators, cloud providers, key-value stores, and other infrastructure components.</p><p>For now, we hope you‚Äôll take this opportunity to explore how plugins expand the possibilities of Traefik. Join the <a href=\"https://community.containo.us/c/traefik/5\">Traefik community forums</a> to continue the discussion and help make Traefik the most powerful, versatile, and extensible tool for your application networking needs.</p>","url":"https://containous.ghost.io/blog/unleash-custom-networking-logic-with-traefik-plugins/","canonical_url":null,"uuid":"6da65ef9-cc77-4eef-8199-620264e72c38","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f3b0d665751e70039ad7abe","reading_time":5}},{"node":{"id":"Ghost__Post__5f29efcbaf4f3b0045f364ec","title":"Naologic Selects Traefik to Effortlessly Scale Networking to Meet Fast Business Growth","slug":"naologic-surpasses-scaling-demands-of-microservice-infrastructure-by-using-traefik","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/c7fe0bc1fd91cfa55d4a7a6241be4aba/47498/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth-1.jpg","srcSet":"/static/c7fe0bc1fd91cfa55d4a7a6241be4aba/9dc27/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth-1.jpg 300w,\n/static/c7fe0bc1fd91cfa55d4a7a6241be4aba/4fe8c/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth-1.jpg 600w,\n/static/c7fe0bc1fd91cfa55d4a7a6241be4aba/47498/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth-1.jpg 1200w,\n/static/c7fe0bc1fd91cfa55d4a7a6241be4aba/52258/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth-1.jpg 1800w,\n/static/c7fe0bc1fd91cfa55d4a7a6241be4aba/a41d1/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Implementing Traefik at Naologic saved them over a thousand hours of engineering time, and eliminated time-consuming manual configuration of NGINX.","custom_excerpt":"Implementing Traefik at Naologic saved them over a thousand hours of engineering time, and eliminated time-consuming manual configuration of NGINX.","visibility":"public","created_at_pretty":"04 August, 2020","published_at_pretty":"August 25, 2020","updated_at_pretty":"17 September, 2020","created_at":"2020-08-04T23:31:23.000+00:00","published_at":"2020-08-25T14:30:00.000+00:00","updated_at":"2020-09-17T17:11:08.000+00:00","meta_title":"Naologic Selects Traefik to Scale Networking to Meet Business Growth","meta_description":"Implementing Traefik at Naologic saved them over a thousand hours of engineering time, and eliminated time-consuming manual configuration of NGINX.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/08/Twitter.png","twitter_title":"Naologic Selects Traefik to Effortlessly Scale Networking to Meet Fast Business Growth","authors":[{"name":"Patricia Dugan ","slug":"patricia","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/01/me-looking-cute.JPG","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Patricia Dugan ","slug":"patricia","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/01/me-looking-cute.JPG","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Case Studies","slug":"case-studies","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":"Learn from our users and customers why they choose Traefik and TraefikEE as a modern load balancer to manage network traffic.","meta_title":"Case studies | Containous","visibility":"public"}],"plaintext":"About Naologic\nNaologic [https://naologic.com/] is an end-to-end business management solution\nthat allows service providers to manage their teams, finances, and integrate\nproducts. Their low-code Software as a Service ERP platform provides wholesale\nand B2B e-commerce companies with the ability to configure and deploy custom ERP\nsystems with just a few clicks.\n\nOverview\nNaologic empowers customers to build customizable and scalable ERP systems\nwithout the complexity of building functionalities such as searching, invoicing,\norder processing, and reporting.\n\nTheir main offering, the back-office builder (BOB), is an online editor used to\ncreate powerful applications without the need to write code.\n\nTo deliver the platform performance necessary for their customers, Naologic\nbuilt their infrastructure in a highly elastic and dynamic manner, running on\nthree clusters, with over 100 nodes total. The entire software platform is\nmanaged and deployed automatically using Kubernetes, and a Gitlab build\npipeline, relying on open source solutions as a fundamental part of the CI/CD\ntoolchain. \n\nChallenge\nIn order to service the growing customer base, Naologic uses a managed platform\nthat continuously launches thousands of automated, secure systems with complex\nconfigurations behind SSL-capable proxies. At any given time, 20 to 40 ports may\nbe opened for microservices communications (WebSockets, HTTP), using multiple\nDocker networks. Before implementing Traefik, Naologic was using NGINX and\nconstrained by the sheer volume of configuration changes requiring frequent\nrestarts (causing connection drops), making for an increasingly complex and\ntime-consuming process.\n\nSolution\nIn order to simplify the ¬†maintenance of their large scale microservice\ninfrastructure, the team at Naologic decided to move the entire platform to\nKubernetes with Traefik as their Ingress Controller\n[/solutions/kubernetes-ingress/] for managing routing and load balancing of\ntheir applications. \n\n> ‚ÄúThe ease of implementation with Traefik saved us over 1,000 engineering hours.\nThe biggest win was being able to launch new developer environments within days\ninstead of weeks.‚Äù - Gabriel Paunescu, CEO\nAs an additional benefit, Traefik‚Äôs auto-discovery feature, with the ability to\nseamlessly forward Docker network configurations into Traefik, has allowed them\nto streamline efforts when deploying Docker containers using temporary DNS\nconfigurations with their build tool. Since Naologic is operating multiple\nplatforms, including Docker Swarm and Kubernetes, Traefik‚Äôs universal approach\nto configuration means they no longer have to maintain independent routing\nsolutions for their various environments.\n\nBottom Line\nImplementing Traefik at Naologic saved them over a thousand hours of engineering\ntime, and eliminated time-consuming manual configuration of NGINX. With this new\ncombination, Naologic is ready and capable of meeting the high-projected growth\nthat they envision for the future.\n\nWhat‚Äôs Next?\n * Get started with Traefik [/traefik/] today\n * Ready for production deployments? Discover Traefik Enterprise Edition\n   [/traefikee/], and request your demo\n   [https://info.containo.us/request-demo-traefikee]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg\" class=\"kg-image\" alt=\"Naologic Selects Traefik to Effortlessly Scale Networking to Meet Fast Business Growth\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg 1600w, https://containous.ghost.io/content/images/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><h2 id=\"about-naologic\">About Naologic</h2><!--kg-card-begin: markdown--><p><a href=\"https://naologic.com/\" target=\"_blank\" rel=\"nofollow\">Naologic</a> is an end-to-end business management solution that allows service providers to manage their teams, finances, and integrate products. Their low-code Software as a Service ERP platform provides wholesale and B2B e-commerce companies with the ability to configure and deploy custom ERP systems with just a few clicks.</p>\n<!--kg-card-end: markdown--><h2 id=\"overview\">Overview</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://lh4.googleusercontent.com/-g2XXPxWFVe0LuNdf3fpNzvHZOc5U3GGIKfiZ0UHGVbwQU6a0zjOQpEBH20TeqZzifME7Wacj6iyk3VEpLYwooGL-UNUdGNxrBobSK-Oksbk8SHYiMJeyddauxuWs_3zC-NqTURE\" class=\"kg-image\" alt=\"Naologic Apps\"></figure><p>Naologic empowers customers to build customizable and scalable ERP systems without the complexity of building functionalities such as searching, invoicing, order processing, and reporting.</p><p>Their main offering, the back-office builder (BOB), is an online editor used to create powerful applications without the need to write code.</p><p>To deliver the platform performance necessary for their customers, Naologic built their infrastructure in a highly elastic and dynamic manner, running on three clusters, with over 100 nodes total. The entire software platform is managed and deployed automatically using Kubernetes, and a Gitlab build pipeline, relying on open source solutions as a fundamental part of the CI/CD toolchain. </p><h2 id=\"challenge\">Challenge</h2><p>In order to service the growing customer base, Naologic uses a managed platform that continuously launches thousands of automated, secure systems with complex configurations behind SSL-capable proxies. At any given time, 20 to 40 ports may be opened for microservices communications (WebSockets, HTTP), using multiple Docker networks. Before implementing Traefik, Naologic was using NGINX and constrained by the sheer volume of configuration changes requiring frequent restarts (causing connection drops), making for an increasingly complex and time-consuming process.</p><h2 id=\"solution\">Solution</h2><p>In order to simplify the ¬†maintenance of their large scale microservice infrastructure, the team at Naologic decided to move the entire platform to Kubernetes with <a href=\"https://containous.ghost.io/solutions/kubernetes-ingress/\">Traefik as their Ingress Controller</a> for managing routing and load balancing of their applications. </p><blockquote><em>‚ÄúThe ease of implementation with Traefik saved us over 1,000 engineering hours. The biggest win was being able to launch new developer environments within days instead of weeks.‚Äù - Gabriel Paunescu, CEO</em></blockquote><p>As an additional benefit, Traefik‚Äôs auto-discovery feature, with the ability to seamlessly forward Docker network configurations into Traefik, has allowed them to streamline efforts when deploying Docker containers using temporary DNS configurations with their build tool. Since Naologic is operating multiple platforms, including Docker Swarm and Kubernetes, Traefik‚Äôs universal approach to configuration means they no longer have to maintain independent routing solutions for their various environments.</p><h2 id=\"bottom-line\">Bottom Line</h2><p>Implementing Traefik at Naologic saved them over a thousand hours of engineering time, and eliminated time-consuming manual configuration of NGINX. With this new combination, Naologic is ready and capable of meeting the high-projected growth that they envision for the future.</p><h2 id=\"what-s-next\">What‚Äôs Next?</h2><ul><li>Get started with <a href=\"https://containous.ghost.io/traefik/\" rel=\"noopener nofollow\">Traefik</a> today</li><li>Ready for production deployments? <a href=\"https://containous.ghost.io/traefikee/\">Discover Traefik Enterprise Edition</a>, and <a href=\"https://info.containo.us/request-demo-traefikee\" rel=\"noopener nofollow\">request your demo</a></li></ul>","url":"https://containous.ghost.io/blog/naologic-surpasses-scaling-demands-of-microservice-infrastructure-by-using-traefik/","canonical_url":null,"uuid":"6d83966e-8856-45c2-ace6-b750226d7ae5","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f29efcbaf4f3b0045f364ec","reading_time":2}},{"node":{"id":"Ghost__Post__5f4ee6313a6f7f00398c1198","title":"Unlock the potential of data APIs with strong authentication and Traefik Enterprise","slug":"unlock-the-potential-of-data-apis-with-strong-authentication-and-traefik-enterprise","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/cfaeda0f50c979152fc15e686c80b150/47498/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise-1.jpg","srcSet":"/static/cfaeda0f50c979152fc15e686c80b150/9dc27/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise-1.jpg 300w,\n/static/cfaeda0f50c979152fc15e686c80b150/4fe8c/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise-1.jpg 600w,\n/static/cfaeda0f50c979152fc15e686c80b150/47498/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise-1.jpg 1200w,\n/static/cfaeda0f50c979152fc15e686c80b150/52258/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise-1.jpg 1800w,\n/static/cfaeda0f50c979152fc15e686c80b150/a41d1/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"One of the top goals for enterprises today is to open up the data held within legacy systems and expose it through APIs, microservices, and other modern means.","custom_excerpt":"One of the top goals for enterprises today is to open up the data held within legacy systems and expose it through APIs, microservices, and other modern means.","visibility":"public","created_at_pretty":"02 September, 2020","published_at_pretty":"September 2, 2020","updated_at_pretty":"23 September, 2020","created_at":"2020-09-02T00:24:17.000+00:00","published_at":"2020-09-02T14:30:58.000+00:00","updated_at":"2020-09-23T12:31:19.000+00:00","meta_title":"Unlock the potential of data APIs with strong authentication & Traefik","meta_description":"One of the top goals for enterprises today is to open up data held within legacy systems and expose it through APIs, microservices, and other modern means","og_description":null,"og_image":null,"og_title":null,"twitter_description":"One of the top goals for enterprises today is to open up the data held within legacy systems and expose it through APIs, microservices, and other modern means.","twitter_image":"https://containous.ghost.io/content/images/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise---Twitter.png","twitter_title":"Unlock the potential of data APIs with strong authentication and Traefik Enterprise","authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#api-gateway-related-resource","slug":"hash-api-gateway-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"When it comes to enterprise IT infrastructure, security is of paramount\nimportance. Between the need for data protection and privacy, regulatory\nrequirements, and the constant threat of bad actors on the network, there is\nlittle room for error when designing and maintaining enterprise systems.\n\nBecause of this, strong authentication is a critical component of any IT\nmodernization project. One of the top goals for enterprises today is to open up\nthe data held within legacy systems and expose it through APIs, microservices,\nand other modern means. And yet, while this data represents untapped business\nvalue, it‚Äôs essential to only expose it in controlled ways by using\nauthentication to ensure each request‚Äôs validity.\n\nTraefik can help. As a modern, cloud-native edge router, Traefik‚Äôs goal is to\ndirect valid requests from the external network to applications and services,\nwhile minimizing the risk posed by malformed, malicious, or fraudulent requests.\nOne way it can do this is by acting as an intermediary to ensure that\ntransactions are authorized. What‚Äôs more, Traefik Enterprise (TraefikEE) bundles\nadditional, exclusive features to provide enterprise-grade authentication ‚Äì\nincluding, most recently, support for OpenID Connect.\n\nWho goes there?\nOne of Traefik‚Äôs key concepts is its use of middlewares\n[https://docs.traefik.io/v2.2/middlewares/overview/], which are pluggable\ncomponents that provide conditional controls over network traffic. These\ncontrols can take various forms, including enabling security features such as\nrate limiting, restricting requests by IP address, and authentication.\n\nTraefikEE‚Äôs enterprise authentication middlewares work by referencing external \nauthentication sources. For example, the LDAP middleware connects to an LDAP\nserver to verify credentials. In this way, Traefik can act as a gatekeeper at\nthe edge of the internal network by intercepting incoming requests and\nauthenticating them against the external source before forwarding them to the\nappropriate applications.\n\nThis model can be particularly critical for legacy modernization projects\nbecause it allows authentication to occur externally to the application. One\nbenefit of this is that it makes it possible to add modern authentication\nmethods to legacy applications to satisfy the latest security requirements,\nwithout making any direct modifications to legacy code.\n\nEnterprise options\nIn addition to LDAP, Traefik Enterprise offers several other middlewares for\nenterprise authentication, and the collection continues to grow. Among the\nmethods that TraefikEE supports are:\n\nHMAC\nHash-based message authentication codes (HMAC\n[https://docs.containo.us/middlewares/hmac/]) is a method of using cryptographic\nhash functions with a shared secret (also known as a symmetric key) to ensure\nthe content delivered in an HTTP request is valid and genuine. Like digital\nsignatures, HMAC can verify a message sender‚Äôs identity and that the message‚Äôs\ncontent is unaltered from the moment of the HMAC‚Äôs ¬†creation. The technique can\nbe used to secure file transfers, API calls, and other machine-to-machine\ninteractions.\n\nJWT\nJSON web tokens (JWT [https://docs.containo.us/middlewares/jwt/]) is another\npopular tool used to authenticate API calls and SSO applications. It‚Äôs a method\nof digitally signing information as a JSON object. The JWT includes a set of\n‚Äúclaims,‚Äù which typically describe the things that an authenticated user is\nallowed to do. TraefikEE‚Äùs JWT middleware also includes support for JSON web key\nsets.\n\nOpenID Connect\nTraefikEE also includes support for OpenID Connect\n[https://docs.containo.us/middlewares/oidc/], an authentication layer built on\ntop of the OAuth 2.0 protocol. OpenID Connect allows an application to obtain\nuser login information by exchanging cryptographic tokens with an identity\nprovider, and is often used to implement federated single sign-on (SSO) between\nmultiple applications.\n\nOpenID Connect has become a popular option for enterprises because it allows\noperators to self-host their on-premises identity provider or choose from a\ngrowing number of third-party options. Okta\n[https://www.okta.com/openid-connect/], for example, is a cloud-hosted\nenterprise identity platform that supports authentication via OpenID Connect.\nSeveral public options are also available, allowing users to authenticate based\non their logins for services such as Google\n[https://developers.google.com/identity/protocols/oauth2/openid-connect] and \nPaypal [https://developer.paypal.com/docs/connect-with-paypal/].If full\nauthentication isn‚Äôt needed, TraefikEE also supplies a middleware for verifying\nthe authorization of requests via the OAuth 2.0 token introspection\n[https://docs.containo.us/middlewares/oauth-intro/] method.\n\nAuthentication the easy way\nThe best thing about implementing enterprise authentication using TraefikEE,\nhowever, is how easy it is to do. Enabling any of the authentication middleware\nmentioned here is generally as simple as adding a few lines to your Traefik\nconfiguration to supply the necessary credentials and point the middleware to\nyour authentication source.\n\nThe authentication options available in TraefikEE today offer a powerful range\nof options for exposing enterprise applications and data securely, without\nrequiring extensive and risky legacy code changes. You can expect other such\nfeatures to be included over time, as we continue our commitment to ensure\nTraefikEE is a premier tool for enterprise application networking.To learn more\nabout how Traefik and Traefik Enterprise can help you lock down enterprise data\nwith secure authentication, watch our recent webinar, ‚ÄúEnterprise best\npractices\nto expose and secure microservices and APIs\n[https://info.containo.us/webinar-recording-enterprise-best-practices-to-expose-and-secure-microservices-apis]\n‚Äù. We‚Äôll discuss deploying OAuth and OpenID Connect with Okta to secure user\nlogins, and we‚Äôll also walk through enabling mutual TLS (mTLS) for secure\nmachine-to-machine communications.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg\" class=\"kg-image\" alt=\"Unlock the potential of data APIs with strong authentication and Traefik\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>When it comes to enterprise IT infrastructure, security is of paramount importance. Between the need for data protection and privacy, regulatory requirements, and the constant threat of bad actors on the network, there is little room for error when designing and maintaining enterprise systems.</p><p>Because of this, strong authentication is a critical component of any IT modernization project. One of the top goals for enterprises today is to open up the data held within legacy systems and expose it through APIs, microservices, and other modern means. And yet, while this data represents untapped business value, it‚Äôs essential to only expose it in controlled ways by using authentication to ensure each request‚Äôs validity.</p><p>Traefik can help. As a modern, cloud-native edge router, Traefik‚Äôs goal is to direct valid requests from the external network to applications and services, while minimizing the risk posed by malformed, malicious, or fraudulent requests. One way it can do this is by acting as an intermediary to ensure that transactions are authorized. What‚Äôs more, Traefik Enterprise (TraefikEE) bundles additional, exclusive features to provide enterprise-grade authentication ‚Äì including, most recently, support for OpenID Connect.</p><h2 id=\"who-goes-there\">Who goes there?</h2><p>One of Traefik‚Äôs key concepts is its use of<a href=\"https://docs.traefik.io/v2.2/middlewares/overview/\"> <em>middlewares</em></a>, which are pluggable components that provide conditional controls over network traffic. These controls can take various forms, including enabling security features such as rate limiting, restricting requests by IP address, and authentication.</p><p>TraefikEE‚Äôs enterprise authentication middlewares work by referencing external <em>authentication sources</em>. For example, the LDAP middleware connects to an LDAP server to verify credentials. In this way, Traefik can act as a gatekeeper at the edge of the internal network by intercepting incoming requests and authenticating them against the external source before forwarding them to the appropriate applications.</p><p>This model can be particularly critical for legacy modernization projects because it allows authentication to occur externally to the application. One benefit of this is that it makes it possible to add modern authentication methods to legacy applications to satisfy the latest security requirements, without making any direct modifications to legacy code.</p><h2 id=\"enterprise-options\"><strong>Enterprise options</strong></h2><p>In addition to LDAP, Traefik Enterprise offers several other middlewares for enterprise authentication, and the collection continues to grow. Among the methods that TraefikEE supports are:</p><h3 id=\"hmac\"><strong>HMAC</strong></h3><p>Hash-based message authentication codes (<a href=\"https://docs.containo.us/middlewares/hmac/\">HMAC</a>) is a method of using cryptographic hash functions with a shared secret (also known as a symmetric key) to ensure the content delivered in an HTTP request is valid and genuine. Like digital signatures, HMAC can verify a message sender‚Äôs identity and that the message‚Äôs content is unaltered from the moment of the HMAC‚Äôs ¬†creation. The technique can be used to secure file transfers, API calls, and other machine-to-machine interactions.</p><h3 id=\"jwt\"><strong>JWT</strong></h3><p>JSON web tokens (<a href=\"https://docs.containo.us/middlewares/jwt/\">JWT</a>) is another popular tool used to authenticate API calls and SSO applications. It‚Äôs a method of digitally signing information as a JSON object. The JWT includes a set of ‚Äúclaims,‚Äù which typically describe the things that an authenticated user is allowed to do. TraefikEE‚Äùs JWT middleware also includes support for JSON web key sets.</p><h3 id=\"openid-connect\"><strong>OpenID Connect</strong></h3><p>TraefikEE also includes<a href=\"https://docs.containo.us/middlewares/oidc/\"> support for OpenID Connect</a>, an authentication layer built on top of the OAuth 2.0 protocol. OpenID Connect allows an application to obtain user login information by exchanging cryptographic tokens with an identity provider, and is often used to implement federated single sign-on (SSO) between multiple applications.</p><!--kg-card-begin: markdown--><p>OpenID Connect has become a popular option for enterprises because it allows operators to self-host their on-premises identity provider or choose from a growing number of third-party options. <a href=\"https://www.okta.com/openid-connect/\" target=\"_blank\" rel=\"nofollow\">Okta</a>, for example, is a cloud-hosted enterprise identity platform that supports authentication via OpenID Connect. Several public options are also available, allowing users to authenticate based on their logins for services such as <a href=\"https://developers.google.com/identity/protocols/oauth2/openid-connect\" target=\"_blank\" rel=\"nofollow\">Google</a> and <a href=\"https://developer.paypal.com/docs/connect-with-paypal/\" target=\"_blank\" rel=\"nofollow\">Paypal</a>.If full authentication isn‚Äôt needed, TraefikEE also supplies a middleware for verifying the authorization of requests via the <a href=\"https://docs.containo.us/middlewares/oauth-intro/\">OAuth 2.0 token introspection</a> method.</p>\n<!--kg-card-end: markdown--><h2 id=\"authentication-the-easy-way\"><strong>Authentication the easy way</strong></h2><p>The best thing about implementing enterprise authentication using TraefikEE, however, is how easy it is to do. Enabling any of the authentication middleware mentioned here is generally as simple as adding a few lines to your Traefik configuration to supply the necessary credentials and point the middleware to your authentication source.</p><p>The authentication options available in TraefikEE today offer a powerful range of options for exposing enterprise applications and data securely, without requiring extensive and risky legacy code changes. You can expect other such features to be included over time, as we continue our commitment to ensure TraefikEE is a premier tool for enterprise application networking.To learn more about how Traefik and Traefik Enterprise can help you lock down enterprise data with secure authentication, watch our recent webinar, ‚Äú<a href=\"https://info.containo.us/webinar-recording-enterprise-best-practices-to-expose-and-secure-microservices-apis\">Enterprise best practices to expose and secure microservices and APIs</a>‚Äù. We‚Äôll discuss deploying OAuth and OpenID Connect with Okta to secure user logins, and we‚Äôll also walk through enabling mutual TLS (mTLS) for secure machine-to-machine communications.</p>","url":"https://containous.ghost.io/blog/unlock-the-potential-of-data-apis-with-strong-authentication-and-traefik-enterprise/","canonical_url":null,"uuid":"b5745b78-cc68-4b41-ae52-2ec9bec07a62","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f4ee6313a6f7f00398c1198","reading_time":3}},{"node":{"id":"Ghost__Post__5f5970b6ff947b00398fd523","title":"Achieve zero-downtime deployments with Traefik and Kubernetes","slug":"achieve-zero-downtime-deployments-with-traefik-and-kubernetes","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/bb8460cc002da7893c5dd6af9f4fc7a0/47498/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes-1.jpg","srcSet":"/static/bb8460cc002da7893c5dd6af9f4fc7a0/9dc27/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes-1.jpg 300w,\n/static/bb8460cc002da7893c5dd6af9f4fc7a0/4fe8c/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes-1.jpg 600w,\n/static/bb8460cc002da7893c5dd6af9f4fc7a0/47498/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes-1.jpg 1200w,\n/static/bb8460cc002da7893c5dd6af9f4fc7a0/52258/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes-1.jpg 1800w,\n/static/bb8460cc002da7893c5dd6af9f4fc7a0/a41d1/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Containers and Kubernetes have revolutionized software delivery. Releasing apps and services as stateless container images makes it easy to create and destroy container instances as demand requires.","custom_excerpt":"Containers and Kubernetes have revolutionized software delivery. Releasing apps and services as stateless container images makes it easy to create and destroy container instances as demand requires.","visibility":"public","created_at_pretty":"10 September, 2020","published_at_pretty":"September 10, 2020","updated_at_pretty":"12 October, 2020","created_at":"2020-09-10T00:17:58.000+00:00","published_at":"2020-09-10T14:18:42.000+00:00","updated_at":"2020-10-12T23:57:15.000+00:00","meta_title":"Achieve zero-downtime deployments with Traefik and Kubernetes","meta_description":"Blue-green deployments, canary releases, and A/B testing are three popular network-centric approaches to software testing and deployment.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes---Twitter.png","twitter_title":null,"authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Rapid release cycles are the hallmark of modern software development. The\ncloud-native ecosystem tooling includes containers, Kubernetes, microservices,\nand agile development methods, all of which support and encourage frequent\ndelivery and deployment. The hidden downside, however, is that every change to\nproduction is another chance for something to go wrong.\n\nIn the worst-case scenario, that \"something\" means downtime.\n\nTesting is always the first line of defense against service disruption.\nUnfortunately, cloud-native application architectures can be surprisingly\ncomplex, and the full extent of the interactions between APIs and services can\nbe hard to map and predict. Because of this, the traditional testing march from\ndevelopment through staging is unlikely to catch every issue before new code\nreaches production.\n\nToday‚Äôs network-centric applications call for new, network-centric approaches to\nsoftware testing and deployment. As a modern, cloud-native edge router, Traefik\nis ready to help.\n\nRouting around downtime\nContainers and Kubernetes have revolutionized software delivery. Releasing apps\nand services as stateless container images makes it easy to create and destroy\ncontainer instances as demand requires. Is an application experiencing a traffic\nspike? Operators may add additional instances to the cluster and use a load\nbalancer to distribute requests accordingly.\n\nThis model gets really interesting, however, when instances of more than one\nversion of the same software serve requests within the same cluster. Mixing old\nand new versions like this makes it possible to configure routing rules to test\nthe production environment's latest version. More importantly, the new version\ncan be released gradually ‚Äì and even withdrawn, should problems arise ‚Äì all with\nvirtually no downtime.\n\nThree popular variations on this idea are blue-green deployments, canary\nreleases, and A/B testing. Although all three are related, each is also\ndistinct.\n\nBlue-green deployments\nIn this pattern, ‚Äúgreen‚Äù refers to the current, stable version of the software,\nwhile ‚Äúblue‚Äù refers to an upcoming release that introduces new features and\nfixes. Instances of both versions operate simultaneously in the same production\nenvironment. Concurrently, a proxy router (such as Traefik) ensures that only\nrequests sent to a private address can reach the blue instances.\n\nThere are two ways to test such a setup. The first is to run synthetic tests\nagainst the blue instances, confident that they are being staged in an\nenvironment that matches production exactly. A more ambitious method involves \ntraffic mirroring, in which the green instances handle incoming requests, but a\nduplicate of every request is also sent to the blue instances. Although this can\nbe resource intensive, it creates an accurate simulation of what would happen if\nthe blue instances were running the show.\n\nOnce all test cases and integrations are satisfied, switching over from the\ngreen to the blue version is as simple as updating the routing rules. In effect,\nblue becomes green, and eventually the next iteration of the software is\ndeployed as the new blue. Equally important, it‚Äôs just as easy to revert the\nrouting rules and roll back to the earlier green version, should some\nlast-minute catastrophe occur.\n\nCanary releases\nThe canary release model takes blue-green testing a step further by deploying\nnew features and patches into active production, albeit in a measured way. The\nrouter is configured such that the current, stable version of the software\nhandles most requests, but a limited percentage of requests route to instances\nof the new, ‚Äúcanary‚Äù version.\n\nTrue to the ‚Äúcanary in a coal mine‚Äù metaphor, if instances of the canary release\nstart dropping dead (or exhibiting problems in some way), they can be withdrawn\nfor bug fixes while the stable release carries on as before. If things go\nsmoothly, on the other hand, the proportion of requests handled by the canary\nrelease can be gradually increased until it reaches 100 percent.\n\nThis model breaks down quickly, however, when the canary release is too large\nand introduces too many changes at once. It works best for microservice\narchitectures, where features or fixes can be released incrementally and\nevaluated on their particular merits.\n\nA/B testing\nThis technique is sometimes confused with the previous two, but it has its own\npurpose, which is to evaluate two distinct versions of an upcoming release to\nsee which will be more successful. This tactic is common for UI development. For\nexample, suppose a new feature will soon roll out to an application, but it‚Äôs\nunclear how best to expose it to users. To find out, two versions of the UI\nincluding the the feature, run in tandem ‚Äì Version A and Version B ‚Äì and the\nproxy router sends a limited number of requests to each one.\n\nFrom there, metrics can help determine which version is the better choice. Does\nVersion A do a better job of convincing users to try the new feature? Do users\ncomplete the UI sequence faster using Version B, or do they tend to cancel\nbefore the end? Each version of the new UI can be trialed with a small number of\nusers while routing rules ensure that the stable version continues to serve the\nmajority of requests.\n\nNetwork effects\nThese techniques can be invaluable for testing modern, cloud-native software\narchitectures, especially when compared to traditional waterfall-style\ndeployment models. When used correctly, they can help spot unforeseen\nregressions, integration failures, performance bottlenecks, and usability issues\nwithin the production environment, but before new code graduates to a stable,\nproduction release.\n\nWhat all three approaches share in common is that they rely on the ease of\ndeployment afforded by containers and Kubernetes, coupled with cloud-native\nnetworking techniques, to route requests to testable deployments while\nminimizing disruptions to production code. That‚Äôs a powerful combination ‚Äì one\nthat‚Äôs squarely within Traefik‚Äôs wheelhouse ‚Äì and if employed judiciously, it\ncan effectively bring overall application downtime to zero. \n\nClick here [https://containo.us/solutions/kubernetes-ingress/] to learn more\nabout Traefik, a centralized routing solution for any Kubernetes cluster, that\nenables better application uptime.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg\" class=\"kg-image\" alt=\"Achieve zero-downtime deployments with Traefik and Kubernetes\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Rapid release cycles are the hallmark of modern software development. The cloud-native ecosystem tooling includes containers, Kubernetes, microservices, and agile development methods, all of which support and encourage frequent delivery and deployment. The hidden downside, however, is that every change to production is another chance for something to go wrong.</p><p>In the worst-case scenario, that \"something\" means downtime.</p><p>Testing is always the first line of defense against service disruption. Unfortunately, cloud-native application architectures can be surprisingly complex, and the full extent of the interactions between APIs and services can be hard to map and predict. Because of this, the traditional testing march from development through staging is unlikely to catch every issue before new code reaches production.</p><p>Today‚Äôs network-centric applications call for new, network-centric approaches to software testing and deployment. As a modern, cloud-native edge router, Traefik is ready to help.</p><h2 id=\"routing-around-downtime\"><strong>Routing around downtime</strong></h2><p>Containers and Kubernetes have revolutionized software delivery. Releasing apps and services as stateless container images makes it easy to create and destroy container instances as demand requires. Is an application experiencing a traffic spike? Operators may add additional instances to the cluster and use a load balancer to distribute requests accordingly.</p><p>This model gets really interesting, however, when instances of more than one version of the same software serve requests within the same cluster. Mixing old and new versions like this makes it possible to configure routing rules to test the production environment's latest version. More importantly, the new version can be released gradually ‚Äì and even withdrawn, should problems arise ‚Äì all with virtually no downtime.</p><p>Three popular variations on this idea are <strong>blue-green deployments</strong>, <strong>canary releases</strong>, and <strong>A/B testing</strong>. Although all three are related, each is also distinct.</p><h3 id=\"blue-green-deployments\"><strong>Blue-green deployments</strong></h3><p>In this pattern, ‚Äúgreen‚Äù refers to the current, stable version of the software, while ‚Äúblue‚Äù refers to an upcoming release that introduces new features and fixes. Instances of both versions operate simultaneously in the same production environment. Concurrently, a proxy router (such as Traefik) ensures that only requests sent to a private address can reach the blue instances.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Diagram-Blue-green-deployments.png\" class=\"kg-image\" alt=\"Blue-green deployment\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Diagram-Blue-green-deployments.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Diagram-Blue-green-deployments.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Diagram-Blue-green-deployments.png 1600w, https://containous.ghost.io/content/images/2020/09/Diagram-Blue-green-deployments.png 1695w\" sizes=\"(min-width: 720px) 720px\"></figure><p>There are two ways to test such a setup. The first is to run synthetic tests against the blue instances, confident that they are being staged in an environment that matches production exactly. A more ambitious method involves <em>traffic mirroring</em>, in which the green instances handle incoming requests, but a duplicate of every request is also sent to the blue instances. Although this can be resource intensive, it creates an accurate simulation of what would happen if the blue instances were running the show.</p><p>Once all test cases and integrations are satisfied, switching over from the green to the blue version is as simple as updating the routing rules. In effect, blue becomes green, and eventually the next iteration of the software is deployed as the new blue. Equally important, it‚Äôs just as easy to revert the routing rules and roll back to the earlier green version, should some last-minute catastrophe occur.</p><h3 id=\"canary-releases\"><strong>Canary releases</strong></h3><p>The canary release model takes blue-green testing a step further by deploying new features and patches into active production, albeit in a measured way. The router is configured such that the current, stable version of the software handles most requests, but a limited percentage of requests route to instances of the new, ‚Äúcanary‚Äù version.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Diagram-canary-releases.png\" class=\"kg-image\" alt=\"Canary release model\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Diagram-canary-releases.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Diagram-canary-releases.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Diagram-canary-releases.png 1600w, https://containous.ghost.io/content/images/2020/09/Diagram-canary-releases.png 1695w\" sizes=\"(min-width: 720px) 720px\"></figure><p>True to the ‚Äúcanary in a coal mine‚Äù metaphor, if instances of the canary release start dropping dead (or exhibiting problems in some way), they can be withdrawn for bug fixes while the stable release carries on as before. If things go smoothly, on the other hand, the proportion of requests handled by the canary release can be gradually increased until it reaches 100 percent.</p><p>This model breaks down quickly, however, when the canary release is too large and introduces too many changes at once. It works best for microservice architectures, where features or fixes can be released incrementally and evaluated on their particular merits.</p><h3 id=\"a-b-testing\"><strong>A/B testing</strong></h3><p>This technique is sometimes confused with the previous two, but it has its own purpose, which is to evaluate two distinct versions of an upcoming release to see which will be more successful. This tactic is common for UI development. For example, suppose a new feature will soon roll out to an application, but it‚Äôs unclear how best to expose it to users. To find out, two versions of the UI including the the feature, run in tandem ‚Äì Version A and Version B ‚Äì and the proxy router sends a limited number of requests to each one.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Diagram-A-B-Testing.png\" class=\"kg-image\" alt=\"A/B testing\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Diagram-A-B-Testing.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Diagram-A-B-Testing.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Diagram-A-B-Testing.png 1600w, https://containous.ghost.io/content/images/2020/09/Diagram-A-B-Testing.png 1695w\" sizes=\"(min-width: 720px) 720px\"></figure><p>From there, metrics can help determine which version is the better choice. Does Version A do a better job of convincing users to try the new feature? Do users complete the UI sequence faster using Version B, or do they tend to cancel before the end? Each version of the new UI can be trialed with a small number of users while routing rules ensure that the stable version continues to serve the majority of requests.</p><h2 id=\"network-effects\"><strong>Network effects</strong></h2><p>These techniques can be invaluable for testing modern, cloud-native software architectures, especially when compared to traditional waterfall-style deployment models. When used correctly, they can help spot unforeseen regressions, integration failures, performance bottlenecks, and usability issues within the production environment, but before new code graduates to a stable, production release.</p><p>What all three approaches share in common is that they rely on the ease of deployment afforded by containers and Kubernetes, coupled with cloud-native networking techniques, to route requests to testable deployments while minimizing disruptions to production code. That‚Äôs a powerful combination ‚Äì one that‚Äôs squarely within Traefik‚Äôs wheelhouse ‚Äì and if employed judiciously, it can effectively bring overall application downtime to zero. </p><p><a href=\"https://containo.us/solutions/kubernetes-ingress/\">Click here</a> to learn more about Traefik, a centralized routing solution for any Kubernetes cluster, that enables better application uptime. </p>","url":"https://containous.ghost.io/blog/achieve-zero-downtime-deployments-with-traefik-and-kubernetes/","canonical_url":null,"uuid":"a656bf3f-d4a9-4122-9793-2487b9b1d472","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f5970b6ff947b00398fd523","reading_time":4}},{"node":{"id":"Ghost__Post__5f61f4b1a72a090039800f54","title":"Announcing the Inaugural Traefik Hackaethon 2020 in October","slug":"announcing-the-inaugural-traefik-hackaethon-2020-in-october","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/ba50fc1aabb024410cdee0199dc261fc/47498/Announcing-the-Inaugural-Traefik-Hackaethon-2020-1.jpg","srcSet":"/static/ba50fc1aabb024410cdee0199dc261fc/9dc27/Announcing-the-Inaugural-Traefik-Hackaethon-2020-1.jpg 300w,\n/static/ba50fc1aabb024410cdee0199dc261fc/4fe8c/Announcing-the-Inaugural-Traefik-Hackaethon-2020-1.jpg 600w,\n/static/ba50fc1aabb024410cdee0199dc261fc/47498/Announcing-the-Inaugural-Traefik-Hackaethon-2020-1.jpg 1200w,\n/static/ba50fc1aabb024410cdee0199dc261fc/52258/Announcing-the-Inaugural-Traefik-Hackaethon-2020-1.jpg 1800w,\n/static/ba50fc1aabb024410cdee0199dc261fc/a41d1/Announcing-the-Inaugural-Traefik-Hackaethon-2020-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Join the team of engineers who maintain Traefik and the Traefik Ambassadors for a week of virtual hacking and collaboration on the open source projects Traefik and Maesh.","custom_excerpt":"Join the team of engineers who maintain Traefik and the Traefik Ambassadors for a week of virtual hacking and collaboration on the open source projects Traefik and Maesh.","visibility":"public","created_at_pretty":"16 September, 2020","published_at_pretty":"September 17, 2020","updated_at_pretty":"12 October, 2020","created_at":"2020-09-16T11:19:13.000+00:00","published_at":"2020-09-17T17:09:59.000+00:00","updated_at":"2020-10-12T23:56:50.000+00:00","meta_title":"Announcing the Inaugural Traefik Hackaethon 2020 in October","meta_description":"Join the team of engineers who maintain Traefik and Traefik Ambassadors for a week of virtual hacking on the open source projects Traefik and Maesh.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020---Twitter.png","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Join the team of engineers who maintain Traefik and the Traefik Ambassadors for\na week of virtual hacking and collaboration on the open source projects Traefik\nand Maesh. The hackathon will take place for three days, across multiple time\nzones, on October 20th through the 22nd. All participants who sign up today\n[https://info.containo.us/traefik-hackaethon-2020] will receive an invitation to\nthe Discord server a few days before the event where they will be able to\nconnect, collaborate, and pair up with other participants and developers to\ncontribute towards making Traefik even better.\n\nAll participants will receive a limited edition t-shirt, stickers, and bonus\nprizes are up for grabs including multiple $100 gift card bounties for plugins,\nand grand prizes of $500, $250, and $100.\n\nParticipate and Collaborate\nTo be eligible as a participant, be sure to sign up for the event below and\ncheck-in for at least one day during the hackaethon and participate in the\nactivities! During the event, you‚Äôll be provided a link where you can provide\ndetails about your contribution, whether you‚Äôve created a Traefik Plugin,\ncontributed to an issue or PR, or had a PR merged in one of our projects. Be\nsure to include your address so we can send you some swag, and enter you for the\ngrand prize drawings.\n\nIn the coming weeks, we‚Äôll post more about the event, so be sure to sign up now\n[https://info.containo.us/traefik-hackaethon-2020] so you can be notified about\nupcoming meetups and blog posts that are related to the event. We‚Äôll be hosting\na meetup about building your own plugin, and posting a blog on ideas for plugin\ndevelopment so keep an eye out.\n\nThere are plenty of cool activities to get involved in, and not all of them\ninvolve writing code:\n\n * Build Traefik Plugins for the newly announced Traefik Pilot Plugin\n   Marketplace\n * Contribute new features, fix bugs, or even reproduce some hard to find bugs\n   in Traefik and Maesh\n * Pair up with other developers and contributors to write documentation, tests,\n   feature requests, and more\n\nSign Up for the Hackaethon 2020 Invitation\n[https://info.containo.us/traefik-hackaethon-2020]\n\nPlugin Bounties\nPlugins are eligible to be awarded a $100 gift card bounty. Successful\nimplementations of a plugin during the Hackaethon may be awarded a bounty after\nmeeting the quality criteria by the judges. Participants may implement their own\nplugin ideas or implement the suggested plugins from the blog post, either are\nequally eligible for the bounty. Up to 10 plugins will each be awarded a $100\ngift card bounty.\n\nQuality Criteria:\n\n * Functionality - Does it do what it says it does\n * Testing - Are there functional unit tests that confirm the functionality\n * Value - Will the community actually use this\n\nGrand Prizes\nEvery participant who contributes during the Hackaethon is eligible to be\nawarded the grand prize. Judges will determine the winners based on their level\nof participation, contributions, and engagement with the community during the\nevent.\n\n * 1st Prize -- $500 gift card and exclusive Hackaethon Hoodie\n * 2nd Prize - $250 gift card\n * 3rd Prize - $100 gift card\n\nSee You in October\nWe are really excited about engaging with the community, collaborating with\nother developers, our ambassadors, and working together to make the most\npowerful and easiest to use open source cloud native networking tools on the\nplanet. We are looking forward to seeing you all in October.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg\" class=\"kg-image\" alt=\"Announcing the Inaugural Traefik Hackaethon 2020\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Join the team of engineers who maintain Traefik and the Traefik Ambassadors for a week of virtual hacking and collaboration on the open source projects Traefik and Maesh. The hackathon will take place for three days, across multiple time zones, on October 20th through the 22nd. All participants who <a href=\"https://info.containo.us/traefik-hackaethon-2020\">sign up today</a> will receive an invitation to the Discord server a few days before the event where they will be able to connect, collaborate, and pair up with other participants and developers to contribute towards making Traefik even better.</p><p>All participants will receive a limited edition t-shirt, stickers, and bonus prizes are up for grabs including multiple $100 gift card bounties for plugins, and grand prizes of $500, $250, and $100.</p><h2 id=\"participate-and-collaborate\">Participate and Collaborate</h2><p>To be eligible as a participant, be sure to sign up for the event below and check-in for at least one day during the hackaethon and participate in the activities! During the event, you‚Äôll be provided a link where you can provide details about your contribution, whether you‚Äôve created a Traefik Plugin, contributed to an issue or PR, or had a PR merged in one of our projects. Be sure to include your address so we can send you some swag, and enter you for the grand prize drawings.</p><p>In the coming weeks, we‚Äôll post more about the event, so be sure to <a href=\"https://info.containo.us/traefik-hackaethon-2020\">sign up now</a> so you can be notified about upcoming meetups and blog posts that are related to the event. We‚Äôll be hosting a meetup about building your own plugin, and posting a blog on ideas for plugin development so keep an eye out.</p><p>There are plenty of cool activities to get involved in, and not all of them involve writing code:</p><ul><li>Build Traefik Plugins for the newly announced Traefik Pilot Plugin Marketplace</li><li>Contribute new features, fix bugs, or even reproduce some hard to find bugs in Traefik and Maesh</li><li>Pair up with other developers and contributors to write documentation, tests, feature requests, and more</li></ul><!--kg-card-begin: html--><p style=\"text-align: center\"><a href=\"https://info.containo.us/traefik-hackaethon-2020\" target=\"_blank\"><b>Sign Up for the Hackaethon 2020 Invitation</b></a></p><!--kg-card-end: html--><h3 id=\"plugin-bounties\">Plugin Bounties</h3><p>Plugins are eligible to be awarded a $100 gift card bounty. Successful implementations of a plugin during the Hackaethon may be awarded a bounty after meeting the quality criteria by the judges. Participants may implement their own plugin ideas or implement the suggested plugins from the blog post, either are equally eligible for the bounty. Up to 10 plugins will each be awarded a $100 gift card bounty.</p><p><strong>Quality Criteria:</strong></p><ul><li>Functionality - Does it do what it says it does</li><li>Testing - Are there functional unit tests that confirm the functionality</li><li>Value - Will the community actually use this</li></ul><h3 id=\"grand-prizes\">Grand Prizes</h3><p>Every participant who contributes during the Hackaethon is eligible to be awarded the grand prize. Judges will determine the winners based on their level of participation, contributions, and engagement with the community during the event.</p><ul><li>1st Prize -- $500 gift card and exclusive Hackaethon Hoodie</li><li>2nd Prize - $250 gift card</li><li>3rd Prize - $100 gift card</li></ul><h2 id=\"see-you-in-october\">See You in October</h2><p>We are really excited about engaging with the community, collaborating with other developers, our ambassadors, and working together to make the most powerful and easiest to use open source cloud native networking tools on the planet. We are looking forward to seeing you all in October.</p>","url":"https://containous.ghost.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/","canonical_url":null,"uuid":"4c52c64f-3b90-421d-a920-f898028e5c3c","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f61f4b1a72a090039800f54","reading_time":2}},{"node":{"id":"Ghost__Post__5f6ab0a66bd3ed003915e68a","title":"Traefik Labs: Incubating the Future of Cloud Native Networking","slug":"traefik-labs-incubating-the-future-of-cloud-native-networking","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/cb96aa821662fe8a96c37390e3b30e87/47498/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking-1.jpg","srcSet":"/static/cb96aa821662fe8a96c37390e3b30e87/9dc27/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking-1.jpg 300w,\n/static/cb96aa821662fe8a96c37390e3b30e87/4fe8c/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking-1.jpg 600w,\n/static/cb96aa821662fe8a96c37390e3b30e87/47498/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking-1.jpg 1200w,\n/static/cb96aa821662fe8a96c37390e3b30e87/52258/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking-1.jpg 1800w,\n/static/cb96aa821662fe8a96c37390e3b30e87/a41d1/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Today is a big day for Containous and the entire Traefik community! As Traefik crosses yet another major download milestone, we continue on our mission of simplifying cloud-native networking by launching our first cloud offering.¬†","custom_excerpt":"Today is a big day for Containous and the entire Traefik community! As Traefik crosses yet another major download milestone, we continue on our mission of simplifying cloud-native networking by launching our first cloud offering.¬†","visibility":"public","created_at_pretty":"23 September, 2020","published_at_pretty":"September 23, 2020","updated_at_pretty":"12 October, 2020","created_at":"2020-09-23T02:19:18.000+00:00","published_at":"2020-09-23T12:30:48.000+00:00","updated_at":"2020-10-12T23:57:34.000+00:00","meta_title":"Traefik Labs: Incubating the Future of Cloud Native Networking","meta_description":"As Traefik crosses yet another major download milestone, we continue on our mission of simplifying cloud-native networking by launching our first cloud offering","og_description":null,"og_image":null,"og_title":null,"twitter_description":"Today is a big day for Containous and the entire Traefik community! As Traefik crosses yet another major download milestone, we continue on our mission of simplifying cloud-native networking by launching our first cloud offering.¬†","twitter_image":"https://containous.ghost.io/content/images/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking---Twitter.png","twitter_title":"Traefik Labs: Incubating the Future of Cloud Native Networking","authors":[{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null}],"primary_author":{"name":"Emile Vauge","slug":"emile","bio":null,"profile_image":"//www.gravatar.com/avatar/68e7fb947bb29dffbd46ac8aae45b6de?s=250&d=mm&r=x","twitter":"@emilevauge","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#homepage-featured-post-3","slug":"hash-homepage-featured-post-3","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Today is a big day for Containous and the entire Traefik community. As we cross\nyet another major download milestone with Traefik, we continue to execute and\ndeliver on our mission of simplifying cloud-native networking by launching a new\nproduct, our first cloud offering. And in recognition of the impact that Traefik\nhas made to enterprise organizations all around the world, we are very proud to\nannounce a refreshed brand and new company name that pays homage to our\nopen-source roots.\n\nFrom Humble Beginnings to Great Success\nIt‚Äôs hard to believe, but it was five years ago, in 2015, when I wrote the very\nfirst lines of code for Traefik. I started developing Traefik because of a basic\nneed for an application proxy that was highly automated, open-source, and\ndesigned from the ground up for DevOps organizations and microservices\nplatforms. Following the initial public announcement, a strong community of\npassionate people quickly gathered around the project. Some of these people\neventually contributed code. Some contributed ideas. Countless more used the\nsoftware and provided feedback. At that time, I could never have imagined that\nthis idea would become a huge success.\n\nFast forward to today, Traefik just crossed the 2 billion downloads mark, with\n30,000+ GitHub stars, more than 500 active contributors from all around the\nglobe, and users from the world‚Äôs largest companies like Conde Nast, eBay, and\nMailchimp. As a result, Traefik is now one of the most popular open-source\nprojects in the world. Unlike other successful open-source projects, Traefik\ndidn‚Äôt emerge from a large establishment like Google, Microsoft or Facebook. It\nwas willed into existence, built by a dedicated community of people who shared a\ncommon need. The success of Traefik is a testament to every single person who\njoined us on this journey.\n\nA Tribute to our Origins\nIn recognition of Traefik‚Äôs momentum and its importance to our mission, we felt\nit was an appropriate and opportune time to pay tribute to our ‚Äúheritage‚Äù. Thus,\nwe are officially changing our company name to Traefik Labs and tweaking our\nproduct names to further support the Traefik brand. The product lineup will now\ninclude: Traefik Proxy (the original Traefik), Traefik Enterprise and Traefik\nMesh (formerly Maesh).\n\nYet despite the name change, our organization‚Äôs mission remains unchanged. In\nfact, it serves as an opportunity for us to better align our products with the\nbroader cloud-native networking challenges we continue to see plaguing\nenterprises. Traefik is, and will continue to be, the core engine of our product\nstack, even as the company builds new solutions that deliver additional\nfunctionality beyond Traefik. And as we introduce new products and services\ngoing forward, our new company name will better reflect the continued role of\nopen source around a strong community as a foundational pillar in driving\ninnovation.\n\nThe (Cloud-Native Networking) Struggle is Real\nAs companies press forward with their cloud-native strategies, many are facing\nthe harsh realization of just how different it is to run and operate\ncontainerized applications and microservices at scale. Gone are the days where\nyou could deploy and manage applications one-by-one via a manual, almost\nartisanal, process. Simply put, automation is no longer a ‚Äúnice to have‚Äù, but a\nrequirement in order to realize the promised benefits of faster software\nreleases, better reliability, simpler management, and more.\n\nTo address this need, an entire ecosystem of technologies, vendors, and\ncommunities have emerged in recent years to drive the DevOps movement and\nculture, where huge progress has been made in automating compute and storage\ninfrastructure within cloud-native environments. Unfortunately, the same can‚Äôt\nbe said for networking, where silos of technologies make integration and\nautomation extremely difficult.\n\nIn my (pre-pandemic) travels around the world, countless enterprises articulated\nthis same networking challenge when deploying applications as microservices in\nproduction. They are investing in container orchestration platforms (on-premises\nand in the public cloud), and investing in DevOps tools. But they are also\ndesperately looking for that same fundamental transformation in networking,\nwhich is becoming increasingly urgent as they accelerate their digital\ntransformation plans due to the pandemic.\n\nBuilding the Traefik Cloud-Native Networking ‚ÄòStack‚Äô\nWith that challenge in mind, our strategy at Traefik Labs is clear: we are\ncreating the simplest, most comprehensive cloud-native stack to help enterprises\nmanage their entire network across data centers, on-premises servers and public\nclouds all the way to the edge. We have already revolutionized the application\nnetworking layer with Traefik Proxy, Enterprise and Mesh, bringing open-source\nbased, cloud-native and simple solutions to DevOps organizations. We are now\nreusing this successful pattern to expand to the rest of the networking stack. \n\nWe‚Äôre taking a step in this direction today with the official release of Traefik\nPilot. Traefik Pilot is a platform that provides monitoring and control of your\nTraefik Proxy instances through a unified dashboard, serving as the control\ncenter for the entire network stack. It also introduces a new hub for hosting\nuser-created plug-ins built on the open-source Yaegi\n[https://traefik.io/blog/announcing-yaegi-263a1e2d070a/] project we‚Äôve been\nnurturing in the recent years.\n\nThe Traefik Cloud-Native Networking ‚ÄòStack‚ÄôAs a result, Traefik Pilot [https://pilot.traefik.io/] is now a cornerstone\npiece within the Traefik ‚ÄòStack‚Äô. By leveraging and integrating our existing\nproducts, Traefik ‚ÄòStack‚Äô represents the single, integrated, networking solution\nenterprises need for cloud-native applications and microservices. As we look\ntoward the future, the Traefik ‚ÄòStack‚Äô will soon encompass edge services like\nWeb Application Firewall, multi-region load balancing and much more, to meet the\nevolving needs of application and operations teams alike.\n\nLastly, it should go without saying, that the core of this new ‚ÄòStack‚Äô will\nforever be open-source. The cloud-native revolution was built on open-source\ntechnologies and strong communities. We will continue to take the same simple,\nopen-source, cloud-native approach we used in building Traefik and apply it to\neverything we do. This is our commitment to our customers and our community,\ntogether we will build the future of cloud-native networking.\n\nWe‚Äôll have a lot more to say about these projects in the upcoming weeks and\nmonths, so watch this space for more details. In the meantime, I want to again\nextend our thanks to everyone who has joined us in our Traefik journey. As\nalways, we‚Äôre eager to hear from you and we look forward to shaping the future\nof cloud-native networking together!","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg\" class=\"kg-image\" alt=\"Traefik Labs: Incubating the Future of Cloud Native Networking\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Today is a big day for Containous and the entire Traefik community. As we cross yet another major download milestone with Traefik, we continue to execute and deliver on our mission of simplifying cloud-native networking by launching a new product, our first cloud offering. And in recognition of the impact that Traefik has made to enterprise organizations all around the world, we are very proud to announce a refreshed brand and new company name that pays homage to our open-source roots.</p><h2 id=\"from-humble-beginnings-to-great-success\">From Humble Beginnings to Great Success</h2><p>It‚Äôs hard to believe, but it was five years ago, in 2015, when I wrote the very first lines of code for Traefik. I started developing Traefik because of a basic need for an application proxy that was highly automated, open-source, and designed from the ground up for DevOps organizations and microservices platforms. Following the initial public announcement, a strong community of passionate people quickly gathered around the project. Some of these people eventually contributed code. Some contributed ideas. Countless more used the software and provided feedback. At that time, I could never have imagined that this idea would become a huge success.</p><p>Fast forward to today, Traefik just crossed the 2 billion downloads mark, with 30,000+ GitHub stars, more than 500 active contributors from all around the globe, and users from the world‚Äôs largest companies like Conde Nast, eBay, and Mailchimp. As a result, Traefik is now one of the most popular open-source projects in the world. Unlike other successful open-source projects, Traefik didn‚Äôt emerge from a large establishment like Google, Microsoft or Facebook. It was willed into existence, built by a dedicated community of people who shared a common need. The success of Traefik is a testament to every single person who joined us on this journey.</p><h2 id=\"a-tribute-to-our-origins\">A Tribute to our Origins</h2><p>In recognition of Traefik‚Äôs momentum and its importance to our mission, we felt it was an appropriate and opportune time to pay tribute to our ‚Äúheritage‚Äù. Thus, we are officially changing our company name to Traefik Labs and tweaking our product names to further support the Traefik brand. The product lineup will now include: Traefik Proxy (the original Traefik), Traefik Enterprise and Traefik Mesh (formerly Maesh).</p><p>Yet despite the name change, our organization‚Äôs mission remains unchanged. In fact, it serves as an opportunity for us to better align our products with the broader cloud-native networking challenges we continue to see plaguing enterprises. Traefik is, and will continue to be, the core engine of our product stack, even as the company builds new solutions that deliver additional functionality beyond Traefik. And as we introduce new products and services going forward, our new company name will better reflect the continued role of open source around a strong community as a foundational pillar in driving innovation.</p><h2 id=\"the-cloud-native-networking-struggle-is-real\">The (Cloud-Native Networking) Struggle is Real</h2><p>As companies press forward with their cloud-native strategies, many are facing the harsh realization of just how different it is to run and operate containerized applications and microservices at scale. Gone are the days where you could deploy and manage applications one-by-one via a manual, almost artisanal, process. Simply put, automation is no longer a ‚Äúnice to have‚Äù, but a requirement in order to realize the promised benefits of faster software releases, better reliability, simpler management, and more.</p><p>To address this need, an entire ecosystem of technologies, vendors, and communities have emerged in recent years to drive the DevOps movement and culture, where huge progress has been made in automating compute and storage infrastructure within cloud-native environments. Unfortunately, the same can‚Äôt be said for networking, where silos of technologies make integration and automation extremely difficult.</p><p>In my (pre-pandemic) travels around the world, countless enterprises articulated this same networking challenge when deploying applications as microservices in production. They are investing in container orchestration platforms (on-premises and in the public cloud), and investing in DevOps tools. But they are also desperately looking for that same fundamental transformation in networking, which is becoming increasingly urgent as they accelerate their digital transformation plans due to the pandemic.</p><h2 id=\"building-the-traefik-cloud-native-networking-stack-\">Building the Traefik Cloud-Native Networking ‚ÄòStack‚Äô</h2><p>With that challenge in mind, our strategy at Traefik Labs is clear: we are creating the simplest, most comprehensive cloud-native stack to help enterprises manage their entire network across data centers, on-premises servers and public clouds all the way to the edge. We have already revolutionized the application networking layer with Traefik Proxy, Enterprise and Mesh, bringing open-source based, cloud-native and simple solutions to DevOps organizations. We are now reusing this successful pattern to expand to the rest of the networking stack. </p><p>We‚Äôre taking a step in this direction today with the official release of Traefik Pilot. Traefik Pilot is a platform that provides monitoring and control of your Traefik Proxy instances through a unified dashboard, serving as the control center for the entire network stack. It also introduces a new hub for hosting user-created plug-ins built on the open-source <a href=\"https://traefik.io/blog/announcing-yaegi-263a1e2d070a/\">Yaegi</a> project we‚Äôve been nurturing in the recent years.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png\" class=\"kg-image\" alt=\"The Traefik Cloud-Native Networking ‚ÄòStack‚Äô\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png 1600w, https://containous.ghost.io/content/images/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png 2048w\" sizes=\"(min-width: 720px) 720px\"><figcaption>The Traefik Cloud-Native Networking ‚ÄòStack‚Äô</figcaption></figure><p>As a result, <a href=\"https://pilot.traefik.io/\">Traefik Pilot</a> is now a cornerstone piece within the Traefik ‚ÄòStack‚Äô. By leveraging and integrating our existing products, Traefik ‚ÄòStack‚Äô represents the single, integrated, networking solution enterprises need for cloud-native applications and microservices. As we look toward the future, the Traefik ‚ÄòStack‚Äô will soon encompass edge services like Web Application Firewall, multi-region load balancing and much more, to meet the evolving needs of application and operations teams alike.</p><p>Lastly, it should go without saying, that the core of this new ‚ÄòStack‚Äô will forever be open-source. The cloud-native revolution was built on open-source technologies and strong communities. We will continue to take the same simple, open-source, cloud-native approach we used in building Traefik and apply it to everything we do. This is our commitment to our customers and our community, together we will build the future of cloud-native networking.</p><p>We‚Äôll have a lot more to say about these projects in the upcoming weeks and months, so watch this space for more details. In the meantime, I want to again extend our thanks to everyone who has joined us in our Traefik journey. As always, we‚Äôre eager to hear from you and we look forward to shaping the future of cloud-native networking together!</p>","url":"https://containous.ghost.io/blog/traefik-labs-incubating-the-future-of-cloud-native-networking/","canonical_url":null,"uuid":"5182a941-0774-4d05-9cfa-fee3232d796a","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f6ab0a66bd3ed003915e68a","reading_time":4}},{"node":{"id":"Ghost__Post__5f61e3c3a72a090039800ee6","title":"Houston, we have Plugins! Traefik 2.3 Announcement","slug":"houston-we-have-plugins-traefik-2-3-announcement","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Traefik2-3-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/d9c38c8baef3f8781df7d002f1b7005a/47498/Traefik2-3-1.jpg","srcSet":"/static/d9c38c8baef3f8781df7d002f1b7005a/9dc27/Traefik2-3-1.jpg 300w,\n/static/d9c38c8baef3f8781df7d002f1b7005a/4fe8c/Traefik2-3-1.jpg 600w,\n/static/d9c38c8baef3f8781df7d002f1b7005a/47498/Traefik2-3-1.jpg 1200w,\n/static/d9c38c8baef3f8781df7d002f1b7005a/52258/Traefik2-3-1.jpg 1800w,\n/static/d9c38c8baef3f8781df7d002f1b7005a/a41d1/Traefik2-3-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik 2.3, the latest version of the most popular open source cloud native proxy, is now available. With plugins, ECS provider, and more!","custom_excerpt":"Traefik 2.3, the latest version of the most popular open source cloud native proxy, is now available. With plugins, ECS provider, and more!","visibility":"public","created_at_pretty":"16 September, 2020","published_at_pretty":"September 23, 2020","updated_at_pretty":"01 October, 2020","created_at":"2020-09-16T10:06:59.000+00:00","published_at":"2020-09-23T14:30:00.000+00:00","updated_at":"2020-10-01T15:17:34.000+00:00","meta_title":"Houston, we have Plugins! Traefik 2.3 Announcement","meta_description":"Traefik 2.3 brings in new capabilities, including the Traefik Plugin system, support for Amazon ECS and support for the Kubernetes IngressClass API resource","og_description":null,"og_image":null,"og_title":null,"twitter_description":"Traefik 2.3 brings in new capabilities, including the Traefik Plugin system, integration with Traefik Pilot, support for Amazon ECS, and support for the Kubernetes IngressClass API resource launched in Kubernetes 1.18. ","twitter_image":"https://containous.ghost.io/content/images/2020/09/Traefik2-3-Twitter.png","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Today we're proud to announce the latest release of Traefik! Traefik 2.3 brings\nin new capabilities, including the Traefik Plugin system, integration with\nTraefik Pilot, support for Amazon ECS, and support for the Kubernetes\nIngressClass API resource launched in Kubernetes 1.18. Let‚Äôs dive in and explore\nwhat these features mean for you, our users.\n\nTraefik Plugins\nWith Go 1.8's release in March 2017, our community's most requested feature\n[https://github.com/traefik/traefik/issues/1336] has been to add middleware\nplugin support to Traefik. Well, it's here. Traefik now supports the ability to\nadd custom middleware functionality to your environment easily. Today, several\nuseful plugins in the marketplace are waiting for you to use, such as BlockPath\n[https://pilot.traefik.io/plugins/276809782519661056/block-path] and Deny Ip\n[https://pilot.traefik.io/plugins/276812076107694611/deny-ip-plugin]. Plugins\nare designed to function and operate just like any other native middlewares\n[https://docs.traefik.io/middlewares/overview/] already distributed with\nTraefik.\n\nThe plugin system operates in conjunction with Traefik Pilot, which maintains a\ncatalog of community created plugins and a hash for each version published by\nthe author. For security, Pilot ensures that you are running the actual code\ncommitted and tagged on GitHub every time Traefik launches.\n\nCustom middleware plugins for the community, by the communityYou can either get started\n[https://doc.traefik.io/traefik/v2.3/plugins/using-plugins/] using the existing\nplugins marketplace [https://pilot.traefik.io/plugins] or create your own plugin\n[https://github.com/traefik/plugindemo]. We can't wait to see what the community\nis going to build!\n\nTraefik Pilot Integration\nTraefik Pilot is a managed SaaS application offered by Traefik Labs that helps\noperators of Traefik ensure their environments are operating efficiently and\nsecurely. This new integration brings users not only the plugins mentioned above\nbut a centralized platform that provides performance metrics, security, and\nupdate notifications in real time. You can get started with Traefik Pilot today\nby signing up and configuring your Traefik instances with a uniquely generated\nkey.\n\nTraefik Pilot automatically collects performance metrics from your Traefik\ninstancesOnce registered and activated, your Traefik instance will periodically\nsend information to Traefik Pilot, providing you with insight into the\nperformance, security, and availability of your Traefik instances.\n\nTraefik Pilot will monitor the following data points on every Traefik instance\nyou register:\n\n * Health Status and Availability Alerts\n * Version Information and Security Alerts\n * Performance Metrics * Requests per second\n    * Total requests\n    * Request duration\n   \n   \n\nFor additional details about Traefik Pilot and the features available upon\nregistration of your Traefik instance, please check out the product announcement\nfor Pilot.\n\nAmazon ECS Provider\nAmazon ECS is a managed orchestration service that can be used either on its own\nor in conjunction with Fargate, the AWS serverless compute engine for\ncontainers. The ECS provider for Traefik allows for the dynamic configuration of\nthe provider using labels attached to your ECS containers.\n\nThis feature was contributed by alekitto [https://github.com/alekitto], a\ncommunity member, who refactored code from v1.x to support ECS by implementing\nthe provider for the latest versions of Traefik. Thanks to his time and effort,\nthe rest of the Traefik community can benefit while running their ECS workloads.\n\nMore information on how to activate or configure the provider is available here: \nhttps://doc.traefik.io/v2.3/providers/ecs/\n[https://doc.traefik.io/traefik/v2.3/providers/ecs/]\n\nKubernetes IngressClass\nWith the release of Kubernetes 1.18, improvements made to the Ingress API\n[https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/] \nhave made possible new capabilities in Traefik 2.3. This release includes the\nability to specify how Ingress paths should match, and features a new\nIngressClass resource that allows users to specify how controllers should\nimplement Ingress resources. You can use these new APIs in Traefik with this\nrelease, which means better interoperability and vendor neutrality.\n\nAlso, Ingress resources utilizing the new pathType field will be supported\naccordingly. More information on how to utilize the support for the new\nIngressClass resource can be found both in our documentation\n[https://doc.traefik.io/traefik/providers/kubernetes-ingress/#ingressclass] and\nthe Kubernetes official docs\n[https://v1-18.docs.kubernetes.io/docs/concepts/services-networking/ingress/].\n\nThe Road Ahead\nWe're excited about the work we have ahead of us for the next release, Traefik\n2.4. We are planning to revamp the Getting Started guides for 2.x, and with that\nwill include common use case examples with introductions to more complex topics\nfor popular platforms such as Kubernetes and Docker Swarm. This work comes after\nhearing from the community how we could improve the documentation and begin with\nmore transparent explanations on the new configuration approaches and how to get\nstarted with it.\n\nAlso, we're looking at the configuration of Traefik itself and how we can\nabstract everyday use cases into a simpler and easy to use format. You'll be\nhearing more about this and other enhancements to Traefik, including support for\nthe latest Kubernetes Service API that the team at Google has been working on,\nand features to support the inclusion of mTLS in Traefik Mesh.\n\nWe love hearing from the community on how you're using Traefik and what features\nyou'd like to see in the future. Let us know by opening a Feature Request\n[https://github.com/traefik/traefik/issues/new?template=Feature_request.md] or\nreaching out to us on our community forums.\n\nUseful links\n * Website [https://traefik.io/traefik/]\n * Documentation [https://doc.traefik.io/traefik/v2.3/]\n * Github [https://github.com/traefik/traefik]\n * Forum [https://community.traefik.io/c/traefik/traefik-v2]","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Traefik2-3.jpg\" class=\"kg-image\" alt=\"Traefik 2.3 features integration with Traefik Pilot, Middleware Plugins, ECS provider, and support for K8S IngressClass\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Traefik2-3.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Traefik2-3.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Traefik2-3.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Traefik2-3.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Today we're proud to announce the latest release of Traefik! Traefik 2.3 brings in new capabilities, including the Traefik Plugin system, integration with Traefik Pilot, support for Amazon ECS, and support for the Kubernetes IngressClass API resource launched in Kubernetes 1.18. Let‚Äôs dive in and explore what these features mean for you, our users.</p><h3 id=\"traefik-plugins\">Traefik Plugins</h3><p>With Go 1.8's release in March 2017, our community's <a href=\"https://github.com/traefik/traefik/issues/1336\">most requested feature</a> has been to add middleware plugin support to Traefik. Well, it's here. Traefik now supports the ability to add custom middleware functionality to your environment easily. Today, several useful plugins in the marketplace are waiting for you to use, such as <a href=\"https://pilot.traefik.io/plugins/276809782519661056/block-path\">BlockPath</a> and <a href=\"https://pilot.traefik.io/plugins/276812076107694611/deny-ip-plugin\">Deny Ip</a>. Plugins are designed to function and operate just like any other native <a href=\"https://docs.traefik.io/middlewares/overview/\">middlewares</a> already distributed with Traefik.</p><p>The plugin system operates in conjunction with Traefik Pilot, which maintains a catalog of community created plugins and a hash for each version published by the author. For security, Pilot ensures that you are running the actual code committed and tagged on GitHub every time Traefik launches.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/09/image-3.png\" class=\"kg-image\" alt=\"Custom middleware plugins for the community, by the community\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/image-3.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/image-3.png 1000w, https://containous.ghost.io/content/images/2020/09/image-3.png 1359w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Custom middleware plugins for the community, by the community</figcaption></figure><p>You can either <a href=\"https://doc.traefik.io/traefik/v2.3/plugins/using-plugins/\">get started</a> using the <a href=\"https://pilot.traefik.io/plugins\">existing plugins marketplace</a> or <a href=\"https://github.com/traefik/plugindemo\">create your own plugin</a>. We can't wait to see what the community is going to build!</p><h3 id=\"traefik-pilot-integration\">Traefik Pilot Integration</h3><p>Traefik Pilot is a managed SaaS application offered by Traefik Labs that helps operators of Traefik ensure their environments are operating efficiently and securely. This new integration brings users not only the plugins mentioned above but a centralized platform that provides performance metrics, security, and update notifications in real time. You can get started with Traefik Pilot today by signing up and configuring your Traefik instances with a uniquely generated key.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/09/image-2.png\" class=\"kg-image\" alt=\"Traefik Pilot automatically collects performance metrics from your Traefik instances\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/image-2.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/image-2.png 1000w, https://containous.ghost.io/content/images/2020/09/image-2.png 1359w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Traefik Pilot automatically collects performance metrics from your Traefik instances</figcaption></figure><p>Once registered and activated, your Traefik instance will periodically send information to Traefik Pilot, providing you with insight into the performance, security, and availability of your Traefik instances.</p><p>Traefik Pilot will monitor the following data points on every Traefik instance you register:</p><!--kg-card-begin: markdown--><ul>\n<li>Health Status and Availability Alerts</li>\n<li>Version Information and Security Alerts</li>\n<li>Performance Metrics\n<ul>\n<li>Requests per second</li>\n<li>Total requests</li>\n<li>Request duration</li>\n</ul>\n</li>\n</ul>\n<!--kg-card-end: markdown--><p>For additional details about Traefik Pilot and the features available upon registration of your Traefik instance, please check out the product announcement for Pilot.</p><h2 id=\"amazon-ecs-provider\"><strong>Amazon ECS Provider</strong></h2><p>Amazon ECS is a managed orchestration service that can be used either on its own or in conjunction with Fargate, the AWS serverless compute engine for containers. The ECS provider for Traefik allows for the dynamic configuration of the provider using labels attached to your ECS containers.</p><!--kg-card-begin: markdown--><p>This feature was contributed by <a href=\"https://github.com/alekitto\" target=\"_blank\" rel=\"nofollow\">alekitto</a>, a community member, who refactored code from v1.x to support ECS by implementing the provider for the latest versions of Traefik. Thanks to his time and effort, the rest of the Traefik community can benefit while running their ECS workloads.</p>\n<!--kg-card-end: markdown--><p>More information on how to activate or configure the provider is available here: <a href=\"https://doc.traefik.io/traefik/v2.3/providers/ecs/\">https://doc.traefik.io/v2.3/providers/ecs/</a></p><h2 id=\"kubernetes-ingressclass\"><strong>Kubernetes IngressClass</strong></h2><!--kg-card-begin: markdown--><p>With the release of Kubernetes 1.18, <a href=\"https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/\" target=\"_blank\" rel=\"nofollow\">improvements made to the Ingress API</a> have made possible new capabilities in Traefik 2.3. This release includes the ability to specify how Ingress paths should match, and features a new IngressClass resource that allows users to specify how controllers should implement Ingress resources. You can use these new APIs in Traefik with this release, which means better interoperability and vendor neutrality.</p>\n<p>Also, Ingress resources utilizing the new <code>pathType</code> field will be supported accordingly. More information on how to utilize the support for the new IngressClass resource can be found both in <a href=\"https://doc.traefik.io/traefik/providers/kubernetes-ingress/#ingressclass\">our documentation</a> and the Kubernetes <a href=\"https://v1-18.docs.kubernetes.io/docs/concepts/services-networking/ingress/\" target=\"_blank\" rel=\"nofollow\">official docs</a>.</p>\n<!--kg-card-end: markdown--><h2 id=\"the-road-ahead\">The Road Ahead</h2><p>We're excited about the work we have ahead of us for the next release, Traefik 2.4. We are planning to revamp the Getting Started guides for 2.x, and with that will include common use case examples with introductions to more complex topics for popular platforms such as Kubernetes and Docker Swarm. This work comes after hearing from the community how we could improve the documentation and begin with more transparent explanations on the new configuration approaches and how to get started with it.</p><p>Also, we're looking at the configuration of Traefik itself and how we can abstract everyday use cases into a simpler and easy to use format. You'll be hearing more about this and other enhancements to Traefik, including support for the latest Kubernetes Service API that the team at Google has been working on, and features to support the inclusion of mTLS in Traefik Mesh.</p><p>We love hearing from the community on how you're using Traefik and what features you'd like to see in the future. Let us know by opening a <a href=\"https://github.com/traefik/traefik/issues/new?template=Feature_request.md\">Feature Request</a> or reaching out to us on our community forums.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://traefik.io/traefik/\">Website</a></li><li><a href=\"https://doc.traefik.io/traefik/v2.3/\">Documentation</a></li><li><a href=\"https://github.com/traefik/traefik\">Github</a></li><li><a href=\"https://community.traefik.io/c/traefik/traefik-v2\">Forum</a></li></ul>","url":"https://containous.ghost.io/blog/houston-we-have-plugins-traefik-2-3-announcement/","canonical_url":null,"uuid":"539200bd-c9d6-473d-b170-daf87e7dfb8f","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f61e3c3a72a090039800ee6","reading_time":4}},{"node":{"id":"Ghost__Post__5f6c0a086bd3ed003915e724","title":"Introducing Traefik Pilot 1.0: the Traefik Control Center","slug":"introducing-traefik-pilot-1-0-one-place-to-manage-all-your-traefik-instances","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Traefik-Pilot-the-control-center-for-Traefik-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/73f93d6e162817680e5d06dd1583b732/47498/Traefik-Pilot-the-control-center-for-Traefik-1.jpg","srcSet":"/static/73f93d6e162817680e5d06dd1583b732/9dc27/Traefik-Pilot-the-control-center-for-Traefik-1.jpg 300w,\n/static/73f93d6e162817680e5d06dd1583b732/4fe8c/Traefik-Pilot-the-control-center-for-Traefik-1.jpg 600w,\n/static/73f93d6e162817680e5d06dd1583b732/47498/Traefik-Pilot-the-control-center-for-Traefik-1.jpg 1200w,\n/static/73f93d6e162817680e5d06dd1583b732/52258/Traefik-Pilot-the-control-center-for-Traefik-1.jpg 1800w,\n/static/73f93d6e162817680e5d06dd1583b732/a41d1/Traefik-Pilot-the-control-center-for-Traefik-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Today, we‚Äôre announcing that Traefik Pilot 1.0 is available and ready to connect with all Traefik instances, everywhere.","custom_excerpt":"Today, we‚Äôre announcing that Traefik Pilot 1.0 is available and ready to connect with all Traefik instances, everywhere.","visibility":"public","created_at_pretty":"24 September, 2020","published_at_pretty":"September 24, 2020","updated_at_pretty":"12 October, 2020","created_at":"2020-09-24T02:52:56.000+00:00","published_at":"2020-09-24T15:38:23.000+00:00","updated_at":"2020-10-12T23:56:34.000+00:00","meta_title":"Introducing Traefik Pilot 1.0: the Traefik Control Center","meta_description":"Today, we‚Äôre announcing that Traefik Pilot 1.0 is available and ready to connect with all Traefik instances, everywhere.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/09/Traefik-Pilot-the-control-center-for-Traefik---Twitter.png","twitter_title":null,"authors":[{"name":"Pierre Erraud","slug":"pierre","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/pierre-erraud.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Pierre Erraud","slug":"pierre","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/pierre-erraud.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"In July, we debuted a preview release\n[https://traefik.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/] \nof Traefik Pilot [https://traefik.io/traefik-pilot/], a new SaaS platform that\nextends the functionality of Traefik. Today, we‚Äôre announcing that Traefik Pilot\n1.0 is available and ready to connect with all Traefik instances, everywhere.\n\nTraefik is known for its extensive compatibility with third-party vendors and\nits ability to adapt to multiple topologies. Traefik Pilot extends this\nflexibility and ease-of-use beyond the data center to provide a similar\nexperience for the entire ecosystem of components that make up a complete\napplication. It achieves this in a number of ways.\n\nFirst, Traefik Pilot provides visibility into cloud-native architectures.\nContainerized applications and microservices are dynamic by nature, and they\ntypically involve multiple network connections linking diverse components. Apps\nteams want to know what is happening within their installations: to visualize\nthe history and durations of requests, to analyze changes in behavior, and to\nsee when load has peaked and for how long. Such capabilities are essential to\npinpoint the root causes of issues within the infrastructure.\n\nWhile visibility is good, however, being notified or alerted is better. Traefik\nPilot‚Äôs timely alerts allow operators to mitigate issues, apply processes, or\nanalyze anomalous situations in real time, which leads to higher availability\nand improved end user experience.\n\nIn addition to these features, Traefik Pilot also introduces the ability for\nTraefik operators to create their own plugins\n[https://traefik.io/blog/unleash-custom-networking-logic-with-traefik-plugins/],\nincluding custom middlewares, and easily find and share plugins with others\nthrough the Traefik Pilot online plugin catalog.\n\nTraefik Pilot 1.0 brings a number of enhancements since the release candidate.\nLet‚Äôs take a look at some of the most significant ones.\n\nImproved web UI\nWe heard users‚Äô feedback from the preview release, and as a result, we have\ntransformed the UI to make the Traefik Pilot user experience even more\nstraightforward. We think you‚Äôll agree that these modifications allow everyone\nto use Traefik Pilot in the most natural way possible.\n\nNew metrics dashboard\nWould you like metrics for your Traefik instances? Just connect your instances\nto Traefik Pilot, and voil√†!\n\nStarting today, all instances registered in Traefik Pilot will benefit from this\nnew feature, which allows you to diagnose and record changes in the usage of the\ninstances or services behind Traefik through graphs spanning a day, a week, or a\nmonth.\n\nEnhanced alerts\nTraefik Pilot 1.0 offers two types of alerts. They can be enabled in your\nprofile settings and can be delivered either by email or through a webhook.\n\nFirst, Traefik Pilot can notify you when a Traefik instance no longer has access\nto the internet. If a connected Traefik instance fails to contact Traefik Pilot\nfor 5 minutes, it will be marked as unreachable in the Traefik Pilot dashboard.\nIf the instance still does not contact Traefik Pilot after 10 minutes, the\ninstance will disappear from the dashboard and you will be notified of the lack\nof connectivity..\n\nTraefik Pilot can also raise an alert when a security vulnerability is found in\nTraefik. Starting today, for any CVE involving Traefik, if your instance is\nconnected to Traefik Pilot and is vulnerable, you will receive a notification\nthrough the same communication channels.\n\nGrowing plugin ecosystem\nSince the preview release, Traefik Pilot has made it possible to extend the\nfunctionality of Traefik with plugins. We are proud and encouraged to see the\nplugins that have already been created by the community.\n\nPlugins are a feature that opens up a wide range of possibilities with Traefik.\nAlthough this feature is still experimental, we are looking forward to seeing\nhow the community around plugins continues to grow. To learn more about creating\nyour own plugins, consult the developer documentation\n[https://github.com/traefik/plugindemo].\n\nOnward and upward\nWe have a lot of ideas for the continuation of Traefik Pilot, including\nadditional types of alerts and more. \n\nOne particular area of focus is on multi-cluster management, with the aim of\nmaking it possible to easily manage multiple datacenters. Because most (but not\nall) HTTP traffic is now encrypted with TLS, we plan to provide tools for\nTraefik Pilot to simplify certificate management. \n\nWe are also working on connecting Traefik Enterprise to Traefik Pilot, to bring\nall the features of Traefik Pilot to your Traefik Enterprise instances. \n\nFinally, there will probably be one or more surprises. For now, we hope you\nenjoy all the features that Traefik Pilot 1.0 [https://pilot.traefik.io/] has to\noffer, and we welcome your feedback\n[https://community.traefik.io/c/traefik-pilot/18].\n\nUseful links\n * Traefik Pilot [https://traefik.io/traefik-pilot]\n * Get started [https://pilot.traefik.io/]\n * Pilot documentation [https://docs.traefik.io/v2.3/plugins/overview/]\n * Traefik [https://traefik.io/traefik/]\n * Community forum [https://community.containo.us/c/traefik/5]","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg\" class=\"kg-image\" alt=\"Introducing Traefik Pilot 1.0: the Traefik Control Center\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>In July, we debuted a <a href=\"https://traefik.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/\">preview release</a> of <a href=\"https://traefik.io/traefik-pilot/\">Traefik Pilot</a>, a new SaaS platform that extends the functionality of Traefik. Today, we‚Äôre announcing that Traefik Pilot 1.0 is available and ready to connect with all Traefik instances, everywhere.</p><p>Traefik is known for its extensive compatibility with third-party vendors and its ability to adapt to multiple topologies. Traefik Pilot extends this flexibility and ease-of-use beyond the data center to provide a similar experience for the entire ecosystem of components that make up a complete application. It achieves this in a number of ways.</p><p>First, Traefik Pilot provides visibility into cloud-native architectures. Containerized applications and microservices are dynamic by nature, and they typically involve multiple network connections linking diverse components. Apps teams want to know what is happening within their installations: to visualize the history and durations of requests, to analyze changes in behavior, and to see when load has peaked and for how long. Such capabilities are essential to pinpoint the root causes of issues within the infrastructure.</p><p>While visibility is good, however, being notified or alerted is better. Traefik Pilot‚Äôs timely alerts allow operators to mitigate issues, apply processes, or analyze anomalous situations in real time, which leads to higher availability and improved end user experience.</p><p>In addition to these features, Traefik Pilot also introduces the ability for Traefik operators to <a href=\"https://traefik.io/blog/unleash-custom-networking-logic-with-traefik-plugins/\">create their own plugins</a>, including custom middlewares, and easily find and share plugins with others through the Traefik Pilot online plugin catalog.</p><p>Traefik Pilot 1.0 brings a number of enhancements since the release candidate. Let‚Äôs take a look at some of the most significant ones.</p><h2 id=\"improved-web-ui\">Improved web UI</h2><p>We heard users‚Äô feedback from the preview release, and as a result, we have transformed the UI to make the Traefik Pilot user experience even more straightforward. We think you‚Äôll agree that these modifications allow everyone to use Traefik Pilot in the most natural way possible.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh5.googleusercontent.com/u6I9Ey-FC64mBgKTk9ywWLDvwXsn321r_5OQXYUuT2PBk7yXc7HsKPMbOUFDg4vMINBq7fuXt77SL0BO5QylRbaaLtjUmRH-wmRBN0lSk6rslkbfJl6PrSSHmv5VeOD4SiQ4DBA\" class=\"kg-image\" alt=\"Traefik Pilot Web UI\"></figure><h2 id=\"new-metrics-dashboard\">New metrics dashboard</h2><p>Would you like metrics for your Traefik instances? Just connect your instances to Traefik Pilot, and voil√†!</p><p>Starting today, all instances registered in Traefik Pilot will benefit from this new feature, which allows you to diagnose and record changes in the usage of the instances or services behind Traefik through graphs spanning a day, a week, or a month.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh5.googleusercontent.com/GzICwYarm48ofOcT8G-lXWxhWKyH7HwYvdl05uKsQ_fFmTyzRkatHfgpto1TTh4rv7JJppjUhX4_Ong4HcRzQPLwNUbMOdthbJ4Q-BWYEMSAPFfk6CKRHp_nCmNlW1QA0T__uos\" class=\"kg-image\" alt=\"Traefik Pilot - Metrics\"></figure><h2 id=\"enhanced-alerts\">Enhanced alerts</h2><p>Traefik Pilot 1.0 offers two types of alerts. They can be enabled in your profile settings and can be delivered either by email or through a webhook.</p><p>First, Traefik Pilot can notify you when a Traefik instance no longer has access to the internet. If a connected Traefik instance fails to contact Traefik Pilot for 5 minutes, it will be marked as unreachable in the Traefik Pilot dashboard. If the instance still does not contact Traefik Pilot after 10 minutes, the instance will disappear from the dashboard and you will be notified of the lack of connectivity..</p><p>Traefik Pilot can also raise an alert when a security vulnerability is found in Traefik. Starting today, for any CVE involving Traefik, if your instance is connected to Traefik Pilot and is vulnerable, you will receive a notification through the same communication channels.</p><h2 id=\"growing-plugin-ecosystem\">Growing plugin ecosystem</h2><p>Since the preview release, Traefik Pilot has made it possible to extend the functionality of Traefik with plugins. We are proud and encouraged to see the plugins that have already been created by the community.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh3.googleusercontent.com/_c72__zIyl4c8BGJYXRRKGoy6Pb8JZh9WKBLbft_y4my0QN-WvNb0gdaThyKBqIBBImOUTqi5gqg4_JR3lSFokyMY8mwVjfby5r_HxXTM5m08vY3oZAIHyPW43LOZprJnXYtuL4\" class=\"kg-image\" alt=\"Traefik Pilot - Plugins\"></figure><p>Plugins are a feature that opens up a wide range of possibilities with Traefik. Although this feature is still experimental, we are looking forward to seeing how the community around plugins continues to grow. To learn more about creating your own plugins, consult the <a href=\"https://github.com/traefik/plugindemo\">developer documentation</a>.</p><h2 id=\"onward-and-upward\">Onward and upward</h2><p>We have a lot of ideas for the continuation of Traefik Pilot, including additional types of alerts and more. </p><p>One particular area of focus is on multi-cluster management, with the aim of making it possible to easily manage multiple datacenters. Because most (but not all) HTTP traffic is now encrypted with TLS, we plan to provide tools for Traefik Pilot to simplify certificate management. </p><p>We are also working on connecting Traefik Enterprise to Traefik Pilot, to bring all the features of Traefik Pilot to your Traefik Enterprise instances. </p><p>Finally, there will probably be one or more surprises. For now, we hope you enjoy all the features that <a href=\"https://pilot.traefik.io/\">Traefik Pilot 1.0</a> has to offer, and we <a href=\"https://community.traefik.io/c/traefik-pilot/18\">welcome your feedback</a>.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://traefik.io/traefik-pilot\">Traefik Pilot</a></li><li><a href=\"https://pilot.traefik.io/\">Get started</a></li><li><a href=\"https://docs.traefik.io/v2.3/plugins/overview/\">Pilot documentation</a></li><li><a href=\"https://traefik.io/traefik/\">Traefik</a></li><li><a href=\"https://community.containo.us/c/traefik/5\">Community forum</a></li></ul>","url":"https://containous.ghost.io/blog/introducing-traefik-pilot-1-0-one-place-to-manage-all-your-traefik-instances/","canonical_url":null,"uuid":"a6738098-d9e1-4748-afbd-aa1351fb99e4","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f6c0a086bd3ed003915e724","reading_time":4}},{"node":{"id":"Ghost__Post__5f6531426bd3ed003915e5e9","title":"Announcing Traefik Enterprise 2.2, now an all-in-one ingress, API management, and service mesh solution","slug":"announcing-traefik-enterprise-2-2-now-an-all-in-one-ingress-api-management-and-service-mesh-solution","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Enterprise-2.2-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/5c0105c02d13b29de458f43e7bf61629/47498/Announcing-Traefik-Enterprise-2.2-1.jpg","srcSet":"/static/5c0105c02d13b29de458f43e7bf61629/9dc27/Announcing-Traefik-Enterprise-2.2-1.jpg 300w,\n/static/5c0105c02d13b29de458f43e7bf61629/4fe8c/Announcing-Traefik-Enterprise-2.2-1.jpg 600w,\n/static/5c0105c02d13b29de458f43e7bf61629/47498/Announcing-Traefik-Enterprise-2.2-1.jpg 1200w,\n/static/5c0105c02d13b29de458f43e7bf61629/52258/Announcing-Traefik-Enterprise-2.2-1.jpg 1800w,\n/static/5c0105c02d13b29de458f43e7bf61629/a41d1/Announcing-Traefik-Enterprise-2.2-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik Enterprise 2.2 includes integrated service mesh capabilities, an improved web UI, support for OpenID Connect authentication, and more.","custom_excerpt":"Traefik Enterprise 2.2 includes integrated service mesh capabilities, an improved web UI, support for OpenID Connect authentication, and more.","visibility":"public","created_at_pretty":"18 September, 2020","published_at_pretty":"September 29, 2020","updated_at_pretty":"12 October, 2020","created_at":"2020-09-18T22:14:26.000+00:00","published_at":"2020-09-29T14:00:00.000+00:00","updated_at":"2020-10-12T23:56:05.000+00:00","meta_title":"Announcing Traefik Enterprise 2.2 - now shipping with a service mesh","meta_description":"Traefik Enterprise 2.2 includes integrated service mesh capabilities, an improved web UI, support for OpenID Connect authentication, and more.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Enterprise-2.2---Twitter.png","twitter_title":"Announcing Traefik Enterprise 2.2, now an all-in-one ingress, API management, and service mesh solution","authors":[{"name":"Nicolas Mengin","slug":"nicolas","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/02/wam.jpeg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Nicolas Mengin","slug":"nicolas","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/02/wam.jpeg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Traefik Enterprise 2.2 [https://traefik.io/traefik-enterprise/] is here,\nbringing with it a number of new features and enhancements to our\nenterprise-grade, cloud-native edge router built on Traefik technology. This\nlatest release includes integrated service mesh capabilities, an improved web\nUI, support for OpenID Connect authentication, and more.\n\nIntegrated Service Mesh\nManaging a microservice architecture built on Kubernetes requires dealing with\nexternal and internal connections (sometimes called north-south and east-west\nconnections, respectively). An ingress controller is the software that routes\nthe north-south connections from the external network, while a service mesh is\nthe increasingly popular choice for managing east-west connections between\nservices on the internal network..\n\nThe usual case is to split the responsibilities between a separate ingress\ncontroller and service mesh. But the downside of this architecture is that it\nmeans that you have to install, configure, and maintain two different tools,\noften with very different capabilities and configuration styles.\n\nThat's where Traefik Enterprise 2.2 comes in.\n\nTraefik Enterprise can now act as both a Kubernetes ingress controller, based on\nthe well-known Traefik edge router, and a service mesh based on Traefik Mesh,\nthe lightweight and simpler service mesh.\n\nThus, Traefik Enterprise simplifies your workflow:\n\n * It enables you to install both your ingress controller and your service mesh\n   with a single command\n * It requires a single configuration file to manage them together\n * It comes with a dashboard to monitor your whole network environment easily\n\nTraefik Enterprise‚Äôs service mesh is designed to be non-invasive. It requires no\nsidecar containers and does not modify your Kubernetes objects, and it‚Äôs 100%\nopt-in.\n\nTake advantage of this feature by following the comprehensive guide in the\ndocumentation.\n[https://doc.traefik.io/traefik-enterprise/operations/service-mesh/]\n\nImproved WebUI\nThe key to managing microservices infrastructure is monitoring. You can‚Äôt fix\nthe problems in your infrastructure if you don‚Äôt know what and where they are.\n\nTo this end, we‚Äôve updated the Traefik Enterprise dashboard with features that\nallow you to monitor your cluster alerts at a glance.\n\nIf an error occurs in your cluster, your services, routers, or middlewares\nconfiguration, it will be reported on the new welcome page. From there, you will\nbe able to navigate to the error source to fix it.\n\nAdditionally, if you choose to enable the new service mesh option, Traefik\nEnterprise 2.2‚Äôs enhanced dashboard provides a diagram to monitor your service\nmesh connections.\n\nUsing it, you won't have to read through all of your Kubernetes configuration\nfiles to know why your Kubernetes services don‚Äôt communicate as expected!\n\nOpenID Connect\nWhether you expose one API or hundreds, if you want to sleep well at night, you\nwill have to secure your infrastructure. Authentication is a critical component\nof this.\n\nTraefik Enterprise has acknowledged this need. That's why, on top of the\nexisting authentication middlewares (such as LDAP, OAuth 2.0 token\nintrospection, and JWT), v2.2 adds a new OpenID Connect (OIDC) middleware\n[https://doc.traefik.io/traefik-enterprise/middlewares/oidc/].\n\nOIDC [https://openid.net/connect/] is a very popular framework built on top of\nOAuth 2.0 to handle authentication workflows.\n\nUsing the OIDC middleware, you'll secure your applications by delegating the\nauthentication to an external provider (such as GitHub, Google Accounts,\nLinkedIn, etc.) with a straightforward configuration. Here‚Äôs an example:\n\nhttp:\nmiddlewares:\nmyoidc:\nplugin:\noidcAuth:\nsource: googleSource\nredirectUrl: example.com/callback\nsession:\nsecret: mysupersecret123\n\n\nSecuring a service couldn‚Äôt be easier.\n\nTraefik Enterprise provider\nOne of the main advantages of Traefik Enterprise has always been the dynamic\nconfiguration. Are you a Kubernetes user? Create a CRD, and let the magic\nhappen. Docker user? Add labels to your container‚Ä¶ et voil√†!\n\nBut if you are a bare metal user, so far you have had to share your\nconfiguration file between machines manually. To ease your work, Traefik\nEnterprise 2.2 includes a new internal provider that allows you to set your\nconfiguration using the teectl CLI.\n\nYou need only execute one command and your cluster is automatically updated. The\nconfiguration is still stored in a file for ease of maintenance.\n\nteectl apply dyn-configuration.yaml\n\n\nWhat's Next?\nWith the addition of service mesh support, Traefik Enterprise brings important\nnew functionality on top of its existing high availability, distributed\nservices, and enterprise authentication protocols. We‚Äôll continue to develop\nmore exciting features to benefit customers who choose Traefik Enterprise.\n\nTake a closer look at Traefik Enterprise‚Äôs features\n[https://traefik.io/traefik-enterprise/] to learn more. If you want to test\ndrive this new version, sign up for a free trial of Traefik Enterprise 2.2 today\n[https://info.traefik.io/get-traefik-enterprise-free-for-30-days].","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Enterprise-2.2.jpg\" class=\"kg-image\" alt=\"Announcing Traefik Enterprise 2.2\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Announcing-Traefik-Enterprise-2.2.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Announcing-Traefik-Enterprise-2.2.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Announcing-Traefik-Enterprise-2.2.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Enterprise-2.2.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p><a href=\"https://traefik.io/traefik-enterprise/\">Traefik Enterprise 2.2</a> is here, bringing with it a number of new features and enhancements to our enterprise-grade, cloud-native edge router built on Traefik technology. This latest release includes integrated service mesh capabilities, an improved web UI, support for OpenID Connect authentication, and more.</p><h2 id=\"integrated-service-mesh\"><strong>Integrated Service Mesh</strong></h2><p>Managing a microservice architecture built on Kubernetes requires dealing with external and internal connections (sometimes called north-south and east-west connections, respectively). An ingress controller is the software that routes the north-south connections from the external network, while a service mesh is the increasingly popular choice for managing east-west connections between services on the internal network..</p><p>The usual case is to split the responsibilities between a separate ingress controller and service mesh. But the downside of this architecture is that it means that you have to install, configure, and maintain two different tools, often with very different capabilities and configuration styles.</p><p>That's where Traefik Enterprise 2.2 comes in.</p><p>Traefik Enterprise can now act as both a Kubernetes ingress controller, based on the well-known Traefik edge router, and a service mesh based on Traefik Mesh, the lightweight and simpler service mesh.</p><p>Thus, Traefik Enterprise simplifies your workflow:</p><ul><li>It enables you to install both your ingress controller and your service mesh with a single command</li><li>It requires a single configuration file to manage them together</li><li>It comes with a dashboard to monitor your whole network environment easily</li></ul><p>Traefik Enterprise‚Äôs service mesh is designed to be non-invasive. It requires no sidecar containers and does not modify your Kubernetes objects, and it‚Äôs 100% opt-in.</p><p>Take advantage of this feature by following <a href=\"https://doc.traefik.io/traefik-enterprise/operations/service-mesh/\">the comprehensive guide in the documentation.</a></p><h2 id=\"improved-webui\"><strong>Improved WebUI</strong></h2><p>The key to managing microservices infrastructure is monitoring. You can‚Äôt fix the problems in your infrastructure if you don‚Äôt know what and where they are.</p><p>To this end, we‚Äôve updated the Traefik Enterprise dashboard with features that allow you to monitor your cluster alerts at a glance.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh3.googleusercontent.com/jwBeNWko1GGuIZSIC4yhBQgNXQ4CI6PW2W_61Y25aaHfFTvWrHIzfUydIU-N8freBJ_WvHVvxir6UuEocZqfPzo0STBnEN__bQaa_mP_WpDJASJQ9E_m3vSrBtf97oAs8madpsk\" class=\"kg-image\" alt=\"Traefik Enteprise WebUI Dashboard\"></figure><p>If an error occurs in your cluster, your services, routers, or middlewares configuration, it will be reported on the new welcome page. From there, you will be able to navigate to the error source to fix it.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh3.googleusercontent.com/VCZR58NdsYD1HKVDhIyit9bVcp3CdywV9bpRX9fT1wcij4Qp2-3o_rbesk-Ncu-Yoio3QacblGbXiM2_i-purKbClCJLIBYoaB51iJ55-i6FkIl8ZqYL5hvW5_UoOBj4yWnpUiY\" class=\"kg-image\" alt=\"Traefik Enterprise WebUI Ingress\"></figure><p>Additionally, if you choose to enable the new service mesh option, Traefik Enterprise 2.2‚Äôs enhanced dashboard provides a diagram to monitor your service mesh connections.</p><p>Using it, you won't have to read through all of your Kubernetes configuration files to know why your Kubernetes services don‚Äôt communicate as expected!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh5.googleusercontent.com/1tekIayHmgN5ZA1BjRwvxyPAD8_S684J6Qr-jK4g4-6ANNoo-Rs6k0qA7h0WAgIDEPxq3GOHLw9CfA9iqB5uXV2H7FRVZ2j3uQeiTyl_j4kizrqy50ggZpVW3gL2M6FsEMgjTa4\" class=\"kg-image\" alt=\"Traefik Enteprise WebUI Mesh\"></figure><h2 id=\"openid-connect\"><strong>OpenID Connect</strong></h2><p>Whether you expose one API or hundreds, if you want to sleep well at night, you will have to secure your infrastructure. Authentication is a critical component of this.</p><p>Traefik Enterprise has acknowledged this need. That's why, on top of the existing authentication middlewares (such as LDAP, OAuth 2.0 token introspection, and JWT), v2.2 adds a new <a href=\"https://doc.traefik.io/traefik-enterprise/middlewares/oidc/\">OpenID Connect (OIDC) middleware</a>.</p><!--kg-card-begin: markdown--><p><a href=\"https://openid.net/connect/\" target=\"_blank\" rel=\"nofollow\">OIDC</a> is a very popular framework built on top of OAuth 2.0 to handle authentication workflows.</p>\n<!--kg-card-end: markdown--><p>Using the OIDC middleware, you'll secure your applications by delegating the authentication to an external provider (such as GitHub, Google Accounts, LinkedIn, etc.) with a straightforward configuration. Here‚Äôs an example:</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">http:\nmiddlewares:\nmyoidc:\nplugin:\noidcAuth:\nsource: googleSource\nredirectUrl: example.com/callback\nsession:\nsecret: mysupersecret123\n</code></pre>\n<!--kg-card-end: markdown--><p>Securing a service couldn‚Äôt be easier.</p><h2 id=\"traefik-enterprise-provider\"><strong>Traefik Enterprise provider</strong></h2><p>One of the main advantages of Traefik Enterprise has always been the dynamic configuration. Are you a Kubernetes user? Create a CRD, and let the magic happen. Docker user? Add labels to your container‚Ä¶ et voil√†!</p><p>But if you are a bare metal user, so far you have had to share your configuration file between machines manually. To ease your work, Traefik Enterprise 2.2 includes a new internal provider that allows you to set your configuration using the teectl CLI.</p><p>You need only execute one command and your cluster is automatically updated. The configuration is still stored in a file for ease of maintenance.</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">teectl apply dyn-configuration.yaml\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"what-s-next\"><strong>What's Next?</strong></h2><p>With the addition of service mesh support, Traefik Enterprise brings important new functionality on top of its existing high availability, distributed services, and enterprise authentication protocols. We‚Äôll continue to develop more exciting features to benefit customers who choose Traefik Enterprise.</p><p>Take a closer look at <a href=\"https://traefik.io/traefik-enterprise/\">Traefik Enterprise‚Äôs features</a> to learn more. If you want to test drive this new version, <a href=\"https://info.traefik.io/get-traefik-enterprise-free-for-30-days\">sign up for a free trial of Traefik Enterprise 2.2 today</a>.</p>","url":"https://containous.ghost.io/blog/announcing-traefik-enterprise-2-2-now-an-all-in-one-ingress-api-management-and-service-mesh-solution/","canonical_url":null,"uuid":"e9791a33-78cf-41fb-8f5c-d517fe1dd6f9","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f6531426bd3ed003915e5e9","reading_time":4}},{"node":{"id":"Ghost__Post__5f61ed21a72a090039800f23","title":"Announcing Traefik Mesh 1.4 - New Name, New Features","slug":"announcing-traefik-mesh-1-4-new-name-new-features","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/2bf88b41a1527a3d01d0b0e5af828d57/47498/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg","srcSet":"/static/2bf88b41a1527a3d01d0b0e5af828d57/9dc27/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 300w,\n/static/2bf88b41a1527a3d01d0b0e5af828d57/4fe8c/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 600w,\n/static/2bf88b41a1527a3d01d0b0e5af828d57/47498/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 1200w,\n/static/2bf88b41a1527a3d01d0b0e5af828d57/52258/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 1800w,\n/static/2bf88b41a1527a3d01d0b0e5af828d57/a41d1/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik Mesh 1.4 brings some under-the-hood changes and new features, including support for a new version of the Service Mesh Interface (SMI) specification, enabling filtering by headers and more.","custom_excerpt":"Traefik Mesh 1.4 brings some under-the-hood changes and new features, including support for a new version of the Service Mesh Interface (SMI) specification, enabling filtering by headers and more.","visibility":"public","created_at_pretty":"16 September, 2020","published_at_pretty":"October 1, 2020","updated_at_pretty":"19 October, 2020","created_at":"2020-09-16T10:46:57.000+00:00","published_at":"2020-10-01T14:17:00.000+00:00","updated_at":"2020-10-19T17:22:48.000+00:00","meta_title":"Announcing Traefik Mesh 1.4 - New Name, New Features","meta_description":"Traefik Mesh 1.4 brings some under-the-hood changes, including support for a new version of the SMI specification, enabling filtering by headers and more.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features---Twitter.png","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Today, we're renaming the Maesh project to Traefik Mesh, and this corresponds\nwith the renaming of the company behind the project to Traefik Labs. You can\nlearn more about the company-wide rebranding effort here\n[https://traefik.io/blog/traefik-labs-incubating-the-future-of-cloud-native-networking/]\n.\n\nIn addition to the renaming, Traefik Mesh 1.4 also brings some under-the-hood\nchanges and new features, including support for a new version of the Service\nMesh Interface (SMI) specification, enabling filtering by headers and more.\n\nRenaming of the Project\nAs mentioned, the project is now called Traefik Mesh. The name change includes\nsome changes in the project configuration as well. You'll notice that the\nannotation prefix, the binary name, the prefix for environment variables, and\nthe configuration file's default name have all changed.\n\nMore importantly, we changed the DNS name to opt-in into the mesh usage from \n.maesh to .traefik.mesh. However, we made all of it backward compatible, so you\nshould not encounter problems while transitioning from Maesh to Traefik Mesh.\nMore information about the migration path is available in the documentation\n[https://doc.traefik.io/traefik-mesh/migration/traefik-mesh-v1/#traefik-mesh-v14]\n.\n\nGoing Back to Traefik ... to Traefik\nFor Maesh 1.3, we designed and implemented a custom proxy based on Traefik so we\ncould evolve and iterate on the technology quickly. However, the capabilities we\nneeded for this evolution have since all been introduced upstream into Traefik,\nallowing us to fall back to regular Traefik Proxy nodes for service\ncommunication. With this 1.4 release, Traefik Mesh now uses the standard Traefik\nimage distribution as its service mesh proxy, which means Traefik Proxy features\nwill be available to environments that use Traefik Mesh.\n\nHeader Filtering for Traffic Targets\nWith the release of SMI specification v0.5.0\n[https://github.com/servicemeshinterface/smi-spec/releases/tag/v0.5.0],\nfiltering based on headers introduced in the Traffic Specs API v1alpha3\n[https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md] \nenables routing of requests based on arbitrary parameters such as browser types,\nand cookies. In addition to the headers, these are compatible with other\nfilters, including request types (GET, PUT, etc.) and paths. By utilizing these\nnew features, it's now possible to have additional flexibility when routing\nrequests.\n\nYou can read more about this feature's capabilities and find examples in the \nSMI\nspecification\n[https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md#http-header-filters] \ndocuments on Github.\n\nHeader and Path Filtering for Traffic Splits\nThe latest version of the spec empowers Traefik Mesh users to now run canary and\nA/B testing utilizing Headers, cookies, request type, and more. With the\nv1alpha3 release, Header filtering supports utilizing TrafficSplit and the\nmatches attribute linked to an HTTPRouteGroup. A real world example is available\nin the SMI specification document\n[https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-split/v1alpha3/traffic-split.md#specification]\n, covering how this capability allows you to split traffic based on the\naforementioned new filters.\n\nLooking Ahead\nThe team is continuing work implementing mTLS, and the goal is to launch that\nfeature with the next release. With the introduction of mTLS we anticipate some\nsignificant changes. We‚Äôll be discussing those changes on Github and publishing\na Release Candidate, which needs your feedback. In addition to mTLS, we are\ncontinuing to work with the SMI group by incorporating the latest version of the\nspecification and contributing towards the implementation of routing UDP\ntraffic. We expect to have that ready for the next release as well.\n\nWe love hearing from the community on how you‚Äôre using Traefik Mesh today in\nyour environments and what features you‚Äôd like to see in the future. Let us know\nby opening a Feature Request or reaching out to us on our community forums.\n\nUseful links\n * Website [https://traefik.io/traefik-mesh/]\n * Documentation [https://doc.traefik.io/traefik-mesh/]\n * Github [https://traefik.io/traefik-mesh/]\n * Community Forum [https://community.traefik.io/c/traefik-mesh/15]","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg\" class=\"kg-image\" alt=\"Announcing Traefik Mesh 1.4 - New Name, New Features\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><!--kg-card-begin: markdown--><p>Today, we're renaming the Maesh project to Traefik Mesh, and this corresponds with the renaming of the company behind the project to Traefik Labs. You can learn more about the company-wide rebranding effort <a href=\"https://traefik.io/blog/traefik-labs-incubating-the-future-of-cloud-native-networking/\" target=\"_blank\" rel=\"nofollow\">here</a>.</p>\n<!--kg-card-end: markdown--><p>In addition to the renaming, Traefik Mesh 1.4 also brings some under-the-hood changes and new features, including support for a new version of the Service Mesh Interface (SMI) specification, enabling filtering by headers and more.</p><h2 id=\"renaming-of-the-project\">Renaming of the Project</h2><p>As mentioned, the project is now called Traefik Mesh. The name change includes some changes in the project configuration as well. You'll notice that the annotation prefix, the binary name, the prefix for environment variables, and the configuration file's default name have all changed.</p><!--kg-card-begin: markdown--><p>More importantly, we changed the DNS name to opt-in into the mesh usage from <code>.maesh</code> to <code>.traefik.mesh</code>. However, we made all of it backward compatible, so you should not encounter problems while transitioning from Maesh to Traefik Mesh. More information about the migration path is available <a href=\"https://doc.traefik.io/traefik-mesh/migration/traefik-mesh-v1/#traefik-mesh-v14\" target=\"_blank\"  rel=\"nofollow\">in the documentation</a>.</p>\n<!--kg-card-end: markdown--><h2 id=\"going-back-to-traefik-to-traefik\">Going Back to Traefik ... to Traefik</h2><p>For Maesh 1.3, we designed and implemented a custom proxy based on Traefik so we could evolve and iterate on the technology quickly. However, the capabilities we needed for this evolution have since all been introduced upstream into Traefik, allowing us to fall back to regular Traefik Proxy nodes for service communication. With this 1.4 release, Traefik Mesh now uses the standard Traefik image distribution as its service mesh proxy, which means Traefik Proxy features will be available to environments that use Traefik Mesh.</p><h2 id=\"header-filtering-for-traffic-targets\">Header Filtering for Traffic Targets</h2><!--kg-card-begin: markdown--><p>With the release of <a href=\"https://github.com/servicemeshinterface/smi-spec/releases/tag/v0.5.0\" target=\"_blank\" rel=\"nofollow\">SMI specification v0.5.0</a>, filtering based on headers introduced in the <a href=\"https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md\" target=\"_blank\" rel=\"nofollow\">Traffic Specs API v1alpha3</a> enables routing of requests based on arbitrary parameters such as browser types, and cookies. In addition to the headers, these are compatible with other filters, including request types (GET, PUT, etc.) and paths. By utilizing these new features, it's now possible to have additional flexibility when routing requests.</p>\n<p>You can read more about this feature's capabilities and find examples in the <a href=\"https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md#http-header-filters\" target=\"_blank\" rel=\"nofollow\">SMI specification</a> documents on Github.</p>\n<!--kg-card-end: markdown--><h2 id=\"header-and-path-filtering-for-traffic-splits\">Header and Path Filtering for Traffic Splits</h2><!--kg-card-begin: markdown--><p>The latest version of the spec empowers Traefik Mesh users to now run canary and A/B testing utilizing Headers, cookies, request type, and more. With the v1alpha3 release, Header filtering supports utilizing TrafficSplit and the matches attribute linked to an HTTPRouteGroup. A real world example is available in the <a href=\"https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-split/v1alpha3/traffic-split.md#specification\" target=\"_blank\" rel=\"nofollow\">SMI specification document</a>, covering how this capability allows you to split traffic based on the aforementioned new filters.</p>\n<!--kg-card-end: markdown--><h2 id=\"looking-ahead\">Looking Ahead</h2><p>The team is continuing work implementing mTLS, and the goal is to launch that feature with the next release. With the introduction of mTLS we anticipate some significant changes. We‚Äôll be discussing those changes on Github and publishing a Release Candidate, which needs your feedback. In addition to mTLS, we are continuing to work with the SMI group by incorporating the latest version of the specification and contributing towards the implementation of routing UDP traffic. We expect to have that ready for the next release as well.</p><p>We love hearing from the community on how you‚Äôre using Traefik Mesh today in your environments and what features you‚Äôd like to see in the future. Let us know by opening a Feature Request or reaching out to us on our community forums.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://traefik.io/traefik-mesh/\">Website</a></li><li><a href=\"https://doc.traefik.io/traefik-mesh/\">Documentation</a></li><li><a href=\"https://traefik.io/traefik-mesh/\">Github</a></li><li><a href=\"https://community.traefik.io/c/traefik-mesh/15\">Community Forum</a></li></ul>","url":"https://containous.ghost.io/blog/announcing-traefik-mesh-1-4-new-name-new-features/","canonical_url":null,"uuid":"988cdb3a-2da8-45c3-8271-4f8ac1cfe535","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f61ed21a72a090039800f23","reading_time":2}},{"node":{"id":"Ghost__Post__5f5fc262a72a090039800e87","title":"Install And Configure Traefik with Helm","slug":"install-and-configure-traefik-with-helm","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Kubernetes-and-Helm-blog-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/3c8465819333c37d5dc14524c7ba4332/47498/Kubernetes-and-Helm-blog-1.jpg","srcSet":"/static/3c8465819333c37d5dc14524c7ba4332/9dc27/Kubernetes-and-Helm-blog-1.jpg 300w,\n/static/3c8465819333c37d5dc14524c7ba4332/4fe8c/Kubernetes-and-Helm-blog-1.jpg 600w,\n/static/3c8465819333c37d5dc14524c7ba4332/47498/Kubernetes-and-Helm-blog-1.jpg 1200w,\n/static/3c8465819333c37d5dc14524c7ba4332/52258/Kubernetes-and-Helm-blog-1.jpg 1800w,\n/static/3c8465819333c37d5dc14524c7ba4332/a41d1/Kubernetes-and-Helm-blog-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Install And Configure Traefik with Helm by Robin Sherrer and Daniele Di Rosa. Learn how they went from Traefik 1.x to 2.0, installing and configuring Helm. ","custom_excerpt":"Install And Configure Traefik with Helm by Robin Sherrer and Daniele Di Rosa. Learn how they went from Traefik 1.x to 2.0, installing and configuring Helm. ","visibility":"public","created_at_pretty":"14 September, 2020","published_at_pretty":"October 6, 2020","updated_at_pretty":"27 October, 2020","created_at":"2020-09-14T19:20:02.000+00:00","published_at":"2020-10-06T14:00:00.000+00:00","updated_at":"2020-10-27T06:10:33.000+00:00","meta_title":"Install And Configure Traefik with Helm","meta_description":"Learn how to install and configure Traefik using the official Helm chart and how to configure Traefik with Cloudflare.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/09/kubernetes-and-helm-twitter.jpg","twitter_title":null,"authors":[{"name":"containeroo","slug":"containeroo","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/Containeroo.jpg","twitter":"@containeroo","facebook":null,"website":"https://containeroo.ch/"}],"primary_author":{"name":"containeroo","slug":"containeroo","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/Containeroo.jpg","twitter":"@containeroo","facebook":null,"website":"https://containeroo.ch/"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#community-related-resource","slug":"hash-community-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Guest post by Traefik Ambassador, Robin Scherrer and Daniele Di Rosa aka\nContaineroo.\n\nWhen we started our container journey with Docker some years ago, we looked for\nan easy to configure reverse proxy to expose our services to the internet.\nDaniele had seen a video about the best Docker projects where Emile Vauge,\nfounder of Traefik, delivered a presentation about Traefik. And, we decided to\ngive Traefik a shot. We started with using Traefik 1.x, and then moved to\nTraefik 2.0 a couple of years later.\n\nWhen Traefik 2.0 was released, we spent the weekend figuring out how it works,\nand the next week, decided to help others have a tremendous ‚Äúgetting started‚Äù\nexperience by writing a simple step by step guide. And, with our roles on the\nKubernetes team at work, we went on to replace the existing reverse proxy\nAmbassador with Traefik.\n\nThe Tutorial\nIn this tutorial, we will show you how to install and configure Traefik using\nthe official Helm chart. We will also show you how to configure Traefik with\nCloudflare. This makes wildcard Let's Encrypt certificates possible.\nHelm makes it easy to deploy applications onto your Kubernetes cluster. Even\nthough Traefik supports both Ingress as well as Traefik IngressRoute, we prefer\nto use the CRD instead of Ingress which results in a lot of annotations.\n\nPrerequisites\n * Kubernetes Cluster\n * Helm official docs [https://helm.sh]\n * Kubeconfig file for Helm to access your Kubernetes Cluster (~/.kube/config)\n\nPrepare Helm Chart\nFirst, you‚Äôll need to add the official Helm repository to your Helm client. You\ncan do that by issuing the following command:\n\nhelm repo add traefik https://helm.traefik.io/traefik\nhelm repo update\n\n\nIn order to configure the Helm chart, you'll need to specify certain values. You\ncan find all the values possible here\n[https://github.com/traefik/traefik-helm-chart/blob/master/traefik/values.yaml].\nOpen your favourite editor and set the values you want to change. Here is an\nexample traefik-chart-values.yaml file:\n\nadditionalArguments:\n  - --providers.file.filename=/data/traefik-config.yaml\n  - --entrypoints.websecure.http.tls.certresolver=cloudflare\n  - --entrypoints.websecure.http.tls.domains[0].main=example.com\n  - --entrypoints.websecure.http.tls.domains[0].sans=*.example.com\n  - --certificatesresolvers.cloudflare.acme.dnschallenge.provider=cloudflare\n  - --certificatesresolvers.cloudflare.acme.email=mail@example.com\n  - --certificatesresolvers.cloudflare.acme.dnschallenge.resolvers=1.1.1.1\n  - --certificatesresolvers.cloudflare.acme.storage=/certs/acme.json\nports:\n  web:\n    redirectTo: websecure\nenv:\n  - name: CF_API_EMAIL\n    valueFrom:\n      secretKeyRef:\n        key: email\n        name: cloudflare-api-credentials\n  - name: CF_API_KEY\n    valueFrom:\n      secretKeyRef:\n        key: apiKey\n        name: cloudflare-api-credentials\ningressRoute:\n  dashboard:\n    enabled: false\npersistence:\n  enabled: true\n  path: /certs\n  size: 128Mi\nvolumes:\n  - mountPath: /data\n    name: traefik-config\n    type: configMap\n\n\nWith this values file, you are configuring Traefik to:\n\n * use /data/traefik-config.yaml as a static configuration file\n * use Cloudflare as a certificates resolver\n * set the domain example.com as the certificates main domain\n * set *.example.com as the certificates sans\n * store the certificates in /certs/acme.json\n\nInstall Traefik\nAs a first step, you‚Äôll need to create a Kubernetes namespace:\n\nkubectl create namespace traefik\n\n\nBefore you deploy the Helm chart, you‚Äôll need to add the secret containing the\nCloudflare credentials along with the configmap including the static\nconfiguration.\nCreate a traefik-config.yaml file with the following content:\n\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: cloudflare-api-credentials\n  namespace: traefik\ntype: Opaque\nstringData:\n  email: your@cloudflare.email\n  apiKey: YOURCLOUDFLAREAPIKEY\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: traefik-config\n  namespace: traefik\ndata:\n  traefik-config.yaml: |\n    http:\n      middlewares:\n        headers-default:\n          headers:\n            sslRedirect: true\n            browserXssFilter: true\n            contentTypeNosniff: true\n            forceSTSHeader: true\n            stsIncludeSubdomains: true\n            stsPreload: true\n            stsSeconds: 15552000\n            customFrameOptionsValue: SAMEORIGIN\n\n\nAs an example, we've added a headers-default middleware. For the complete static\nconfiguration, please consult the Traefik docs\n[https://docs.traefik.io/reference/static-configuration/file/].\nNext, you can apply the secret and configmap you created above:\n\nkubectl apply -f traefik-config.yaml\n\n\nThis will create the secret and configmap in the traefik namespace.\nNow it's time to deploy Traefik! The following command will install Traefik in\nthe traefik namespace and with the configuration you created above::\n\nhelm install traefik traefik/traefik --namespace=traefik --values=traefik-chart-values.yaml\n\n\nMake the Dashboard Accessible\nIn order to access the Traefik dashboard, you‚Äôll first need to create an HTTP\nbasic auth middleware. This also requires a secret with the htpasswd\ncredentials.\nUse the following command to create a base64 encoded htpasswd file with a \nkangoroo user and the password jack:\n\nhtpasswd -nb kangoroo jack | openssl base64\n\n\nApply the secret and the middleware to your Kubernetes cluster:\n\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: traefik-dashboard-auth\n  namespace: traefik\ndata:\n  users: |2\n    a2FuZ29yb286JGFwcjEkdGlQbFBINXYkYlJrUHBSUlYuYUxUWnhFRzdYbmduMAoK\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: traefik-dashboard-basicauth\n  namespace: traefik\nspec:\n  basicAuth:\n    secret: traefik-dashboard-auth\n\n\nNow you can apply the following traefik-dashboard-ingressroute.yaml file:\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: traefik-dashboard\n  namespace: traefik\nspec:\n  entryPoints:\n    - websecure\n  routes:\n    - match: Host(`traefik.example.com`)\n      kind: Rule\n      middlewares:\n        - name: traefik-dashboard-basicauth\n          namespace: traefik\n      services:\n        - name: api@internal\n          kind: TraefikService\n\n\nPlease change the matching host rule accordingly under the routes section.\nSince Traefik exposes the dashboard in a special way, you‚Äôll need to tell the\nIngressRoute to use the preconfigured service named api@internal with kind \nTraefikService.\n\nThe IngressRoute CRD\nAs we've mentioned above, Traefik both supports Ingress and IngressRoute as a\nconfiguration.\nThe CRD has a few advantages:\n\n * eliminate or reduce the number of annotations on the Ingress controllers\n * abstract commonly used rules and configuration\n * separate concerns across multiple use-cases and configurations\n   To deploy a simple whoami application service, please refer to the appendix.\n   Here is an example IngressRoute for the whoami service:\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: whoami\n  namespace: traefik\nspec:\n  entryPoints:\n    - websecure\n  routes:\n    - match: Host(`whoami.example.com`)\n      kind: Rule\n      middlewares:\n        - name: headers-default@file\n      services:\n        - name: whoami\n          port: 80\n\n\nThis IngressRoute tells Traefik to listen via the websecure entrypoint and\nforward all the traffic matching the host whoami.example.com to the whoami \nKubernetes service. It also configures the route to use the headers-default \nmiddleware you configured in traefik-config.yaml.\n\nConclusion\nAs you can see, getting started with Traefik as an Ingress controller isn't that\nhard :-) Helm makes it really easy to reconfigure or update Traefik.\n\nTraefik documentation has a lot of good information and can be a great resource\nonce you‚Äôve gotten started using this guide. We bet it will answer most of your\nquestions!\n\nYou can find us on Twitter [https://twitter.com/containeroo], Medium\n[https://medium.com/@containeroo] or GitHub [https://github.com/containeroo].\nFeel free to ask any questions regarding Traefik and Kubernetes. We are happy to\nhelp!\n\nAppendix\nWhoami Example Deployment\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: whoami\n  namespace: traefik\n  labels:\n    app: whoami\nspec:\n  containers:\n    - name: whoami\n      image: containous/whoami:latest\n      ports:\n        - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: whoami\n  namespace: traefik\nspec:\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 80\n  selector:\n    app: whoami\n  type: ClusterIP\n\n\nAbout Us\nBecause of our knowledge in Docker, we were able to switch departments at work,\nand are now working in the Kubernetes department. One of the first things we did\nwas eliminate the existing reverse proxy and switch to Traefik :-D\n\nRobin:\nSwiss IT nerd since forever. Interested in open source technologies like\nAnsible, Docker, Kubernetes, Traefik, Python and Golang. Maintainer of several\nGitHub repos and Docker images for containeroo. Addicted to music, tv shows and\nYouTube. Speaking German and English. Twitter [https://twitter.com/rxbn], Reddit\n[https://reddit.com/u/rxbn] or GitHub [https://github.com/rxbn].\n\nDaniele:\nCouch potato, film and series junky, hobby-columnist for Containeroo, likes\nTraefik, Ansible, Docker and K8s. Hates corn and dill. Born and raised in\nSwitzerland. Star me on GitHub [https://github.com/gi8lino].","html":"<p><strong>Guest post by Traefik Ambassador, Robin Scherrer and Daniele Di Rosa aka Containeroo.</strong></p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Kubernetes-and-Helm-blog-2.jpg\" class=\"kg-image\" alt=\"Install and Configure Traefik with Helm\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Kubernetes-and-Helm-blog-2.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Kubernetes-and-Helm-blog-2.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Kubernetes-and-Helm-blog-2.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Kubernetes-and-Helm-blog-2.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><!--kg-card-begin: markdown--><p>When we started our container journey with Docker some years ago, we looked for an easy to configure reverse proxy to expose our services to the internet. Daniele had seen a video about the best Docker projects where Emile Vauge, founder of Traefik, delivered a presentation about Traefik. And, we decided to give Traefik a shot. We started with using Traefik 1.x, and then moved to Traefik 2.0 a couple of years later.</p>\n<p>When Traefik 2.0 was released, we spent the weekend figuring out how it works, and the next week, decided to help others have a tremendous ‚Äúgetting started‚Äù experience by writing a simple step by step guide. And, with our roles on the Kubernetes team at work, we went on to replace the existing reverse proxy Ambassador with Traefik.</p>\n<h2 id=\"thetutorial\">The Tutorial</h2>\n<p>In this tutorial, we will show you how to install and configure Traefik using the official Helm chart. We will also show you how to configure Traefik with Cloudflare. This makes wildcard Let's Encrypt certificates possible.<br>\nHelm makes it easy to deploy applications onto your Kubernetes cluster. Even though Traefik supports both Ingress as well as Traefik IngressRoute, we prefer to use the CRD instead of Ingress which results in a lot of annotations.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<ul>\n<li>Kubernetes Cluster</li>\n<li>Helm <a href=\"https://helm.sh\" target=\"_blank\" rel=\"nofollow\">official docs</a></li>\n<li>Kubeconfig file for Helm to access your Kubernetes Cluster (<code>~/.kube/config</code>)</li>\n</ul>\n<h2 id=\"preparehelmchart\">Prepare Helm Chart</h2>\n<p>First, you‚Äôll need to add the official Helm repository to your Helm client. You can do that by issuing the following command:</p>\n<pre><code class=\"language-bash\">helm repo add traefik https://helm.traefik.io/traefik\nhelm repo update\n</code></pre>\n<p>In order to configure the Helm chart, you'll need to specify certain values. You can find all the values possible <a href=\"https://github.com/traefik/traefik-helm-chart/blob/master/traefik/values.yaml\" target=\"_blank\" rel=\"nofollow\">here</a>.<br>\nOpen your favourite editor and set the values you want to change. Here is an example <code>traefik-chart-values.yaml</code> file:</p>\n<pre><code class=\"language-yaml\">additionalArguments:\n  - --providers.file.filename=/data/traefik-config.yaml\n  - --entrypoints.websecure.http.tls.certresolver=cloudflare\n  - --entrypoints.websecure.http.tls.domains[0].main=example.com\n  - --entrypoints.websecure.http.tls.domains[0].sans=*.example.com\n  - --certificatesresolvers.cloudflare.acme.dnschallenge.provider=cloudflare\n  - --certificatesresolvers.cloudflare.acme.email=mail@example.com\n  - --certificatesresolvers.cloudflare.acme.dnschallenge.resolvers=1.1.1.1\n  - --certificatesresolvers.cloudflare.acme.storage=/certs/acme.json\nports:\n  web:\n    redirectTo: websecure\nenv:\n  - name: CF_API_EMAIL\n    valueFrom:\n      secretKeyRef:\n        key: email\n        name: cloudflare-api-credentials\n  - name: CF_API_KEY\n    valueFrom:\n      secretKeyRef:\n        key: apiKey\n        name: cloudflare-api-credentials\ningressRoute:\n  dashboard:\n    enabled: false\npersistence:\n  enabled: true\n  path: /certs\n  size: 128Mi\nvolumes:\n  - mountPath: /data\n    name: traefik-config\n    type: configMap\n</code></pre>\n<p>With this values file, you are configuring Traefik to:</p>\n<ul>\n<li>use <code>/data/traefik-config.yaml</code> as a static configuration file</li>\n<li>use Cloudflare as a certificates resolver</li>\n<li>set the domain <code>example.com</code> as the certificates main domain</li>\n<li>set <code>*.example.com</code> as the certificates sans</li>\n<li>store the certificates in <code>/certs/acme.json</code></li>\n</ul>\n<h2 id=\"installtraefik\">Install Traefik</h2>\n<p>As a first step, you‚Äôll need to create a Kubernetes namespace:</p>\n<pre><code class=\"language-bash\">kubectl create namespace traefik\n</code></pre>\n<p>Before you deploy the Helm chart, you‚Äôll need to add the secret containing the Cloudflare credentials along with the configmap including the static configuration.<br>\nCreate a <code>traefik-config.yaml</code> file with the following content:</p>\n<pre><code class=\"language-yaml\">---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: cloudflare-api-credentials\n  namespace: traefik\ntype: Opaque\nstringData:\n  email: your@cloudflare.email\n  apiKey: YOURCLOUDFLAREAPIKEY\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: traefik-config\n  namespace: traefik\ndata:\n  traefik-config.yaml: |\n    http:\n      middlewares:\n        headers-default:\n          headers:\n            sslRedirect: true\n            browserXssFilter: true\n            contentTypeNosniff: true\n            forceSTSHeader: true\n            stsIncludeSubdomains: true\n            stsPreload: true\n            stsSeconds: 15552000\n            customFrameOptionsValue: SAMEORIGIN\n</code></pre>\n<p>As an example, we've added a <code>headers-default</code> middleware. For the complete static configuration, please consult the <a href=\"https://docs.traefik.io/reference/static-configuration/file/\">Traefik docs</a>.<br>\nNext, you can apply the secret and configmap you created above:</p>\n<pre><code class=\"language-bash\">kubectl apply -f traefik-config.yaml\n</code></pre>\n<p>This will create the secret and configmap in the <code>traefik</code> namespace.<br>\nNow it's time to deploy Traefik! The following command will install Traefik in the <code>traefik</code> namespace and with the configuration you created above::</p>\n<pre><code class=\"language-bash\">helm install traefik traefik/traefik --namespace=traefik --values=traefik-chart-values.yaml\n</code></pre>\n<h2 id=\"makethedashboardaccessible\">Make the Dashboard Accessible</h2>\n<p>In order to access the Traefik dashboard, you‚Äôll first need to create an HTTP basic auth middleware. This also requires a secret with the htpasswd credentials.<br>\nUse the following command to create a base64 encoded htpasswd file with a <code>kangoroo</code> user and the password <code>jack</code>:</p>\n<pre><code class=\"language-bash\">htpasswd -nb kangoroo jack | openssl base64\n</code></pre>\n<p>Apply the secret and the middleware to your Kubernetes cluster:</p>\n<pre><code class=\"language-yaml\">---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: traefik-dashboard-auth\n  namespace: traefik\ndata:\n  users: |2\n    a2FuZ29yb286JGFwcjEkdGlQbFBINXYkYlJrUHBSUlYuYUxUWnhFRzdYbmduMAoK\n---\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: traefik-dashboard-basicauth\n  namespace: traefik\nspec:\n  basicAuth:\n    secret: traefik-dashboard-auth\n</code></pre>\n<p>Now you can apply the following <code>traefik-dashboard-ingressroute.yaml</code> file:</p>\n<pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: traefik-dashboard\n  namespace: traefik\nspec:\n  entryPoints:\n    - websecure\n  routes:\n    - match: Host(`traefik.example.com`)\n      kind: Rule\n      middlewares:\n        - name: traefik-dashboard-basicauth\n          namespace: traefik\n      services:\n        - name: api@internal\n          kind: TraefikService\n</code></pre>\n<p>Please change the matching host rule accordingly under the <code>routes</code> section.<br>\nSince Traefik exposes the dashboard in a special way, you‚Äôll need to tell the IngressRoute to use the preconfigured service named <code>api@internal</code> with kind <code>TraefikService</code>.</p>\n<h2 id=\"theingressroutecrd\">The IngressRoute CRD</h2>\n<p>As we've mentioned above, Traefik both supports Ingress and IngressRoute as a configuration.<br>\nThe CRD has a few advantages:</p>\n<ul>\n<li>eliminate or reduce the number of annotations on the Ingress controllers</li>\n<li>abstract commonly used rules and configuration</li>\n<li>separate concerns across multiple use-cases and configurations<br>\nTo deploy a simple <code>whoami</code> application service, please refer to the appendix.<br>\nHere is an example IngressRoute for the <code>whoami</code> service:</li>\n</ul>\n<pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: whoami\n  namespace: traefik\nspec:\n  entryPoints:\n    - websecure\n  routes:\n    - match: Host(`whoami.example.com`)\n      kind: Rule\n      middlewares:\n        - name: headers-default@file\n      services:\n        - name: whoami\n          port: 80\n</code></pre>\n<p>This IngressRoute tells Traefik to listen via the <code>websecure</code> entrypoint and forward all the traffic matching the host <code>whoami.example.com</code> to the <code>whoami</code> Kubernetes service. It also configures the route to use the <code>headers-default</code> middleware you configured in <code>traefik-config.yaml</code>.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>As you can see, getting started with Traefik as an Ingress controller isn't that hard :-)  Helm makes it really easy to reconfigure or update Traefik.</p>\n<p>Traefik documentation has a lot of good information and can be a great resource once you‚Äôve gotten started using this guide. We bet it will answer most of your questions!</p>\n<p>You can find us on <a href=\"https://twitter.com/containeroo\" target=\"_blank\" rel=\"nofollow\">Twitter</a>, <a href=\"https://medium.com/@containeroo\" target=\"_blank\" rel=\"nofollow\">Medium</a> or <a href=\"https://github.com/containeroo\" target=\"_blank\" rel=\"nofollow\">GitHub</a>. Feel free to ask any questions regarding Traefik and Kubernetes. We are happy to help!</p>\n<h2 id=\"appendix\">Appendix</h2>\n<h3 id=\"whoamiexampledeployment\">Whoami Example Deployment</h3>\n<pre><code class=\"language-yaml\">---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: whoami\n  namespace: traefik\n  labels:\n    app: whoami\nspec:\n  containers:\n    - name: whoami\n      image: containous/whoami:latest\n      ports:\n        - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: whoami\n  namespace: traefik\nspec:\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 80\n  selector:\n    app: whoami\n  type: ClusterIP\n</code></pre>\n<h2 id=\"aboutus\">About Us</h2>\n<p>Because of our knowledge in Docker, we were able to switch departments at work, and are now working in the Kubernetes department. One of the first things we did was eliminate the existing reverse proxy and switch to Traefik :-D</p>\n<p>Robin:<br>\nSwiss IT nerd since forever. Interested in open source technologies like Ansible, Docker, Kubernetes, Traefik, Python and Golang. Maintainer of several GitHub repos and Docker images for containeroo. Addicted to music, tv shows and YouTube. Speaking German and English. <a href=\"https://twitter.com/rxbn\" target=\"_blank\" rel=\"nofollow\">Twitter</a>, <a href=\"https://reddit.com/u/rxbn\" target=\"_blank\" rel=\"nofollow\">Reddit</a> or <a href=\"https://github.com/rxbn\" target=\"_blank\" rel=\"nofollow\">GitHub</a>.</p>\n<p>Daniele:<br>\nCouch potato, film and series junky, hobby-columnist for Containeroo, likes Traefik, Ansible, Docker and K8s. Hates corn and dill. Born and raised in Switzerland. Star me on <a href=\"https://github.com/gi8lino\" target=\"_blank\" rel=\"nofollow\">GitHub</a>.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/install-and-configure-traefik-with-helm/","canonical_url":null,"uuid":"67cb07b2-be3a-461e-979b-92dcdab2d516","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f5fc262a72a090039800e87","reading_time":5}},{"node":{"id":"Ghost__Post__5f7f0f1a9ccef80039928d25","title":"Traefik Hackaethon 2020: Middleware Plugins Brain Dump","slug":"traefik-hackaethon-2020-middleware-plugins-brain-dump","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/979b7c781828b335e54a8c988b9c18c8/47498/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump-1.jpg","srcSet":"/static/979b7c781828b335e54a8c988b9c18c8/9dc27/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump-1.jpg 300w,\n/static/979b7c781828b335e54a8c988b9c18c8/4fe8c/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump-1.jpg 600w,\n/static/979b7c781828b335e54a8c988b9c18c8/47498/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump-1.jpg 1200w,\n/static/979b7c781828b335e54a8c988b9c18c8/52258/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump-1.jpg 1800w,\n/static/979b7c781828b335e54a8c988b9c18c8/a41d1/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"The team at Traefik Labs will be hosting a Hackathon next week, and plugins are a significant theme. Awards, bounties, and prizes are available for those who participate. ","custom_excerpt":"The team at Traefik Labs will be hosting a Hackathon next week, and plugins are a significant theme. Awards, bounties, and prizes are available for those who participate. ","visibility":"public","created_at_pretty":"08 October, 2020","published_at_pretty":"October 12, 2020","updated_at_pretty":"03 November, 2020","created_at":"2020-10-08T13:07:38.000+00:00","published_at":"2020-10-12T23:04:00.000+00:00","updated_at":"2020-11-03T17:21:07.000+00:00","meta_title":"Traefik Hackaethon 2020: Middleware Plugins Brain Dump","meta_description":"The team at Traefik Labs will be hosting a Hackathon next week, and plugins are a significant theme. ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump---Twitter.png","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"One of the most powerful features of the Traefik software-based load balancer is\nits support for middlewares\n[https://doc.traefik.io/traefik/middlewares/overview/]. These packages are\nresponsible for applying transformations, validations, redirections, omissions,\nand additions to requests before passing them on, either to another middleware\npackage or to their final destination.\n\nOver the past several years, Traefik has received dozens of ideas and concepts\nfor middlewares through feature and pull requests. Some of these proposals\nsuggested additional functionality for existing middlewares. Others introduced\nbespoke middleware for specific use cases.\n\nWhen these proposals weren't aligned to the vision of the Traefik community they\nlanguished on the Traefik issue board. There they lay dormant, waiting for the\nday that users could easily build custom plugins for Traefik\n[https://traefik.io/blog/unleash-custom-networking-logic-with-traefik-plugins/].\nThat day is here, and this post will provide an outline for those interested in\nbuilding and extending the capabilities of Traefik with their own middlewares.\n\nThe team at Traefik Labs will be hosting a Hackathon next week, and plugins are\na significant theme. Awards, bounties, and prizes are available for those who\nparticipate. You can learn more and sign up here\n[https://info.traefik.io/traefik-hackaethon-2020]. In the meantime, here are\nsome great ideas for middleware plugins that drew from issues on the Traefik\nrepository.\n\nOct 20-22nd: Traefik's Inaugeral Hackaethon - Sign Up Today\n[https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/]\nPopular Middleware Ideas\nForward-Auth with Selective Headers\nhttps://github.com/containous/traefik/issues/6493\n\nThe forward auth middleware included with Traefik will forward all headers\nincluded in the original request. But in some cases, users may want to exclude\nspecific headers from the forwarded request. Instead, they would rather the\nheaders are forwarded only in the response from the auth server.\n\nQuery Parameter Modification\nhttps://github.com/containous/traefik/issues/6276\n\nIn some cases, operators may want to modify the request's query keys or convert\nquery parameters into a path. In either scenario, this can be useful for several\nuse cases. But along with the usefulness comes additional complexity in test\nscenarios and implementations. These constraints make it a prime candidate for\nadoption as a custom plugin.\n\nHeader Transformation\nhttps://github.com/traefik/traefik/issues/6047\n\nThe scope of the Header middleware's current implementation is limited to adding\nor removing headers (which is only available through a file type provider).\nUsers may want to perform more complex operations on headers, such as renaming a\nkey or transforming a value. These operations could be achievable through regex\nor simple pattern matching.\n\nEnhanced Retry and Backoff\nhttps://github.com/traefik/traefik/issues/5282\nhttps://github.com/traefik/traefik/issues/4578\n\nCases exist where operators may want to retry on certain conditions, such as a\n5xx error or connection refused. Without exponential backoff or retries based on\nresponse code, retrying on those parameters isn't feasible. For additional\ninspiration, Spring Cloud Gateway\n[https://cloud.spring.io/spring-cloud-gateway/reference/html/#the-retry-gatewayfilter-factory] \nhas a design that handles both cases.\n\nCustom Response Code Overrides\nhttps://github.com/traefik/traefik/issues/2039\n\nWhen users receive an error message, this can sometimes indicate a particular\nresource's presence or absence. Also, when it‚Äôs impossible to modify the\nclient‚Äôs behavior this can be worked-around by intercepting an erroneous\nresponse and handling it by return a different error response or page. This\nplugin would effectively intercept the service's error response and map an\nalternative response, such as a 200 response instead of a 501 response, or a 404\nrather than a 401 or 403.\n\nCDN AllowList\nhttps://github.com/traefik/traefik/issues/4145\n\nCDNs publish their IP addresses from consumable public resources. When hosting a\nparticular resource that should only be accessible from the CDN (for\ncache-fronting reasons), it‚Äôs logical that users want to block any request that\ndoes not originate from an IP address published on that list.\n\nBasicAuth Overrides\nhttps://github.com/traefik/traefik/issues/4429\n\nIn some instances, users have asked to allow Basic Auth to allow programmatic\noverrides by either a custom header or originating from a specific IP address\n(or set of IP addresses). Both options could be implemented into a custom\nauthentication plugin, with support for IP ranges as well.\n\nRate Limiting Enhancements\nhttps://github.com/traefik/traefik/issues/4548\nhttps://github.com/traefik/traefik/issues/6042\n\nUsers have requested the ability to incorporate multiple rate limiting\nstrategies concurrently; for example, combining client.ip and request.host on a\nsingle frontend. Users have also asked to store rate limiting data external to\nTraefik, enabling more extended duration limits to survive restarts and share\nlimits across multiple instances. These would likely be two separate plugins as\nthey‚Äôre two distinctly different features.\n\nResponse Header Redirect\nhttps://github.com/traefik/traefik/issues/5154\n\nThere is a request to allow a service to command Traefik to internally redirect\nto another service provider through a custom header. This capability could be\nuseful when the client doesn't require exposure to an internal redirect's\ndetails.\n\nBrotli Compression\nhttps://github.com/traefik/traefik/issues/4202\n\nThis plugin has already been implemented as a PR to Traefik. However, the\nlicensing model on one of the dependencies prevented it from being merged as-is.\nThis compression middleware would be relatively straightforward to implement as\na plugin.\n\nAdditional Plugin Ideas\nThere are other plugin ideas out there. We don't want to limit your creativity,\neither, so plugin bounties are not limited to this list. As long as the plugin\nisn't trivial and is deemed functionality by the judges, it is eligible for the\nprize. Here are a few more issues if you're not interested in the ideas listed\nabove.\n\n * HTTP Cache Backends - https://github.com/traefik/traefik/issues/878\n * Containers on Demand - https://github.com/traefik/traefik/issues/6993\n * Open Policy Agent - https://github.com/traefik/traefik/issues/4894\n\nWrapping Up\nSign up for the Hackaethon today\n[https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/] \nand receive a t-shirt and sticker for participating!In addition to the plugin\nideas curated above, we are working on putting together a list of issues that\ncontributors can work on if they're not interested in building a plugin. We want\nto ensure that anyone can participate in the Hackaethon, including features,\nbugs, and documentation tasks that anyone can pick up and start working on.\n\nFor those interested in building custom plugins, we have a meetup scheduled next\nweek before the Hackaethon to demonstrate how easy they are to develop. You can \nsign up for the plugin meetup\n[https://us02web.zoom.us/webinar/register/WN_9LpcglyRSJy89iEYN0ZsbQ] and receive\nthe link today. We‚Äôre looking forward to seeing everyone at the meetup and the\nHackaethon next week and look forward to seeing what you build.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg\" class=\"kg-image\" alt=\"Traefik Hackaethon 2020: Middleware Plugins Brain Dump\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg 1600w, https://containous.ghost.io/content/images/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><!--kg-card-begin: markdown--><p>One of the most powerful features of the Traefik software-based load balancer is its support for <a href=\"https://doc.traefik.io/traefik/middlewares/overview/\">middlewares</a>. These packages are responsible for applying transformations, validations, redirections, omissions, and additions to requests before passing them on, either to another middleware package or to their final destination.</p>\n<!--kg-card-end: markdown--><p>Over the past several years, Traefik has received dozens of ideas and concepts for middlewares through feature and pull requests. Some of these proposals suggested additional functionality for existing middlewares. Others introduced bespoke middleware for specific use cases.</p><!--kg-card-begin: markdown--><p>When these proposals weren't aligned to the vision of the Traefik community they languished on the Traefik issue board. There they lay dormant, waiting for the day that users could easily build <a href=\"https://traefik.io/blog/unleash-custom-networking-logic-with-traefik-plugins/\">custom plugins for Traefik</a>. That day is here, and this post will provide an outline for those interested in building and extending the capabilities of Traefik with their own middlewares.</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>The team at Traefik Labs will be hosting a Hackathon next week, and plugins are a significant theme. Awards, bounties, and prizes are available for those who participate. You can learn more and <a href=\"https://info.traefik.io/traefik-hackaethon-2020\">sign up here</a>. In the meantime, here are some great ideas for middleware plugins that drew from issues on the Traefik repository.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/10/Haekaton-scene.svg\" class=\"kg-image\" alt=\"Oct 20-22nd: Traefik's Inaugeral Hackaethon\"><figcaption>Oct 20-22nd: Traefik's Inaugeral Hackaethon - <a href=\"https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/\">Sign Up Today</a></figcaption></figure><!--kg-card-begin: markdown--><h2 id=\"popularmiddlewareideas\">Popular Middleware Ideas</h2>\n<h3 id=\"forwardauthwithselectiveheaders\">Forward-Auth with Selective Headers</h3>\n<p><a href=\"https://github.com/containous/traefik/issues/6493\">https://github.com/containous/traefik/issues/6493</a></p>\n<p>The forward auth middleware included with Traefik will forward all headers included in the original request. But in some cases, users may want to exclude specific headers from the forwarded request. Instead, they would rather the headers are forwarded only in the response from the auth server.</p>\n<h3 id=\"queryparametermodification\">Query Parameter Modification</h3>\n<p><a href=\"https://github.com/containous/traefik/issues/6276\">https://github.com/containous/traefik/issues/6276</a></p>\n<p>In some cases, operators may want to modify the request's query keys or convert query parameters into a path. In either scenario, this can be useful for several use cases. But along with the usefulness comes additional complexity in test scenarios and implementations. These constraints make it a prime candidate for adoption as a custom plugin.</p>\n<h3 id=\"headertransformation\">Header Transformation</h3>\n<p><a href=\"https://github.com/traefik/traefik/issues/6047\">https://github.com/traefik/traefik/issues/6047</a></p>\n<p>The scope of the Header middleware's current implementation is limited to adding or removing headers (which is only available through a file type provider). Users may want to perform more complex operations on headers, such as renaming a key or transforming a value. These operations could be achievable through regex or simple pattern matching.</p>\n<h3 id=\"enhancedretryandbackoff\">Enhanced Retry and Backoff</h3>\n<p><a href=\"https://github.com/traefik/traefik/issues/5282\">https://github.com/traefik/traefik/issues/5282</a><br>\n<a href=\"https://github.com/traefik/traefik/issues/4578\">https://github.com/traefik/traefik/issues/4578</a></p>\n<p>Cases exist where operators may want to retry on certain conditions, such as a 5xx error or connection refused. Without exponential backoff or retries based on response code, retrying on those parameters isn't feasible. For additional inspiration, <a href=\"https://cloud.spring.io/spring-cloud-gateway/reference/html/#the-retry-gatewayfilter-factory\" target=\"_blank\" rel=\"nofollow\">Spring Cloud Gateway</a> has a design that handles both cases.</p>\n<h3 id=\"customresponsecodeoverrides\">Custom Response Code Overrides</h3>\n<p><a href=\"https://github.com/traefik/traefik/issues/2039\">https://github.com/traefik/traefik/issues/2039</a></p>\n<p>When users receive an error message, this can sometimes indicate a particular resource's presence or absence. Also, when it‚Äôs impossible to modify the client‚Äôs behavior this can be worked-around by intercepting an erroneous response and handling it by return a different error response or page. This plugin would effectively intercept the service's error response and map an alternative response, such as a 200 response instead of a 501 response, or a 404 rather than a 401 or 403.</p>\n<h3 id=\"cdnallowlist\">CDN AllowList</h3>\n<p><a href=\"https://github.com/traefik/traefik/issues/4145\">https://github.com/traefik/traefik/issues/4145</a></p>\n<p>CDNs publish their IP addresses from consumable public resources. When hosting a particular resource that should only be accessible from the CDN (for cache-fronting reasons), it‚Äôs logical that users want to block any request that does not originate from an IP address published on that list.</p>\n<h3 id=\"basicauthoverrides\">BasicAuth Overrides</h3>\n<p><a href=\"https://github.com/traefik/traefik/issues/4429\">https://github.com/traefik/traefik/issues/4429</a></p>\n<p>In some instances, users have asked to allow Basic Auth to allow programmatic overrides by either a custom header or originating from a specific IP address (or set of IP addresses). Both options could be implemented into a custom authentication plugin, with support for IP ranges as well.</p>\n<h3 id=\"ratelimitingenhancements\">Rate Limiting Enhancements</h3>\n<p><a href=\"https://github.com/traefik/traefik/issues/4548\">https://github.com/traefik/traefik/issues/4548</a><br>\n<a href=\"https://github.com/traefik/traefik/issues/6042\">https://github.com/traefik/traefik/issues/6042</a></p>\n<p>Users have requested the ability to incorporate multiple rate limiting strategies concurrently; for example, combining client.ip and request.host on a single frontend. Users have also asked to store rate limiting data external to Traefik, enabling more extended duration limits to survive restarts and share limits across multiple instances. These would likely be two separate plugins as they‚Äôre two distinctly different features.</p>\n<h3 id=\"responseheaderredirect\">Response Header Redirect</h3>\n<p><a href=\"https://github.com/traefik/traefik/issues/5154\">https://github.com/traefik/traefik/issues/5154</a></p>\n<p>There is a request to allow a service to command Traefik to internally redirect to another service provider through a custom header. This capability could be useful when the client doesn't require exposure to an internal redirect's details.</p>\n<h3 id=\"brotlicompression\">Brotli Compression</h3>\n<p><a href=\"https://github.com/traefik/traefik/issues/4202\">https://github.com/traefik/traefik/issues/4202</a></p>\n<p>This plugin has already been implemented as a PR to Traefik. However, the licensing model on one of the dependencies prevented it from being merged as-is. This compression middleware would be relatively straightforward to implement as a plugin.</p>\n<h3 id=\"additionalpluginideas\">Additional Plugin Ideas</h3>\n<p>There are other plugin ideas out there. We don't want to limit your creativity, either, so plugin bounties are not limited to this list. As long as the plugin isn't trivial and is deemed functionality by the judges, it is eligible for the prize. Here are a few more issues if you're not interested in the ideas listed above.</p>\n<ul>\n<li>HTTP Cache Backends - <a href=\"https://github.com/traefik/traefik/issues/878\">https://github.com/traefik/traefik/issues/878</a></li>\n<li>Containers on Demand - <a href=\"https://github.com/traefik/traefik/issues/6993\">https://github.com/traefik/traefik/issues/6993</a></li>\n<li>Open Policy Agent - <a href=\"https://github.com/traefik/traefik/issues/4894\">https://github.com/traefik/traefik/issues/4894</a></li>\n</ul>\n<h2 id=\"wrappingup\">Wrapping Up</h2>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/10/Twitter.jpg\" class=\"kg-image\" alt=\"Sign up for the Hackaethon today and receive a t-shirt and sticker for participating!\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/10/Twitter.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Twitter.jpg 1000w, https://containous.ghost.io/content/images/2020/10/Twitter.jpg 1024w\" sizes=\"(min-width: 720px) 720px\"><figcaption><a href=\"https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/\">Sign up for the Hackaethon today</a> and receive a t-shirt and sticker for participating!</figcaption></figure><!--kg-card-begin: markdown--><p>In addition to the plugin ideas curated above, we are working on putting together a list of issues that contributors can work on if they're not interested in building a plugin. We want to ensure that anyone can participate in the Hackaethon, including features, bugs, and documentation tasks that anyone can pick up and start working on.</p>\n<p>For those interested in building custom plugins, we have a meetup scheduled next week before the Hackaethon to demonstrate how easy they are to develop. You can <a href=\"https://us02web.zoom.us/webinar/register/WN_9LpcglyRSJy89iEYN0ZsbQ\" rel=\"nofollow\" target=\"_blank\">sign up for the plugin meetup</a> and receive the link today. We‚Äôre looking forward to seeing everyone at the meetup and the Hackaethon next week and look forward to seeing what you build.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/traefik-hackaethon-2020-middleware-plugins-brain-dump/","canonical_url":null,"uuid":"c570517f-07fb-4aea-94f4-cc5d9c2ef32f","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f7f0f1a9ccef80039928d25","reading_time":5}},{"node":{"id":"Ghost__Post__5f88c505c254310039a24349","title":"Traefik Enterprise 2.3 Arrives with Vault Support, GitOps Compliance, and More","slug":"traefik-enterprise-2-3-arrives-with-vault-support-gitops-compliance-and-more","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/10/Traefik-Enterprise-2.3.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/59ddc15501f1c991b47879ced7ae3491/47498/Traefik-Enterprise-2.3.jpg","srcSet":"/static/59ddc15501f1c991b47879ced7ae3491/9dc27/Traefik-Enterprise-2.3.jpg 300w,\n/static/59ddc15501f1c991b47879ced7ae3491/4fe8c/Traefik-Enterprise-2.3.jpg 600w,\n/static/59ddc15501f1c991b47879ced7ae3491/47498/Traefik-Enterprise-2.3.jpg 1200w,\n/static/59ddc15501f1c991b47879ced7ae3491/52258/Traefik-Enterprise-2.3.jpg 1800w,\n/static/59ddc15501f1c991b47879ced7ae3491/a41d1/Traefik-Enterprise-2.3.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik Enterprise 2.3 has arrived. Now, with Vault support, GitOps Compliance, support for HTTP caching, and an API portal. ","custom_excerpt":"Traefik Enterprise 2.3 has arrived. Now, with Vault support, GitOps Compliance, support for HTTP caching, and an API portal. ","visibility":"public","created_at_pretty":"15 October, 2020","published_at_pretty":"October 19, 2020","updated_at_pretty":"24 November, 2020","created_at":"2020-10-15T21:54:13.000+00:00","published_at":"2020-10-19T17:21:00.000+00:00","updated_at":"2020-11-24T05:43:10.000+00:00","meta_title":"Traefik Enterprise 2.3 Arrives with Vault support & GitOps Compliance","meta_description":"Traefik Enterprise 2.3 is here. Now, with Vault support, GitOps Compliance, support for HTTP caching, a new way to automate installation and an API portal.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/10/Twitter@2x.png","twitter_title":null,"authors":[{"name":"Nicolas Mengin","slug":"nicolas","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/02/wam.jpeg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Nicolas Mengin","slug":"nicolas","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/02/wam.jpeg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"We are pleased to announce that a new version of Traefik Enterprise is here,\nbringing with it an array of new capabilities. Among the new features in this\nlatest release are integration with Vault, a new way to automate Traefik\nEnterprise installation, support for HTTP caching, and an API portal.\n\nSecure Your Infrastructure in a Vault\nThe more APIs your infrastructure contains, the more complicated TLS certificate\nmanagement becomes.\n\nTo solve this problem, many companies have used Vault\n[https://www.vaultproject.io/] to manage their certificates securely. Customers\nhave asked us to help them easily serve these certificates using Traefik\nEnterprise, and this is now possible with Traefik Enterprise 2.3.\n\nVault as a Provider\nTraefik Enterprise has always been able to read certificates from key-value\nstores such as Consul or etcd. It‚Äôs now possible to use Vault in the same way\n[https://doc.traefik.io/traefik-enterprise/v2.3/providers/vault-kv/], thanks for\nthe new Vault provider in Traefik Enterprise 2.3.\n\nConfigure your Traefik Enterprise cluster to reach your Vault server and it will\ndetect the certificates to serve them:\n\n# Static Configuration\nproviders:\n  plugin:\n    vault:\n      url: \"http://127.0.0.1:8200\" # Vault server URL\n      token: \"s.CUDDqqjiIFXF60KVSeJOxeb5\" # Vault Authentication Token\n\n\nAs usual with Traefik Enterprise, the configuration will be refreshed\nautomatically each time you insert or delete certificates in your Vault server.\n\nVault PKI Support\nMany organizations use Vault to generate TLS certificates on the fly using its\npublic key infrastructure (PKI) feature. Now you can take advantage of this\ncapability with Traefik Enterprise.\n\nBased on our experience with Let‚Äôs Encrypt, we created a new certificate\nresolver [https://doc.traefik.io/traefik-enterprise/v2.3/tls/vault-pki/] to\nintegrate Traefik Enterprise with Vault PKI.\n\n# Static Configuration\ncertificatesResolvers:\n  vaultResolver:\n    vault:\n      url: \"http://127.0.0.1:8200\" # Vault server URL\n      token: \"s.CUDDqqjiIFXF60KVSeJOxeb5\" # Vault Authentication Token\n      role: \"vault-role\" # Role to use to generate certificates\n\n\nOnce this feature is enabled, Traefik Enterprise can use Vault to create and\nrenew all your TLS certificates, which in turn helps to ease management of your\nAPIs.\n\nDon‚Äôt hesitate to take a look at our documentation\n[https://doc.traefik.io/traefik-enterprise/v2.3/operations/vault-pki-guide/] for\nmore information about this feature.\n\nGitOps Automation\nMore and more organizations use GitOps tools to automate their deployments.\nCustomers have asked us for better integration of Traefik Enterprise with these\ntools, and with this release, we‚Äôve delivered.\n\nTraefik Enterprise 2.3 brings a couple of features to improve our compliance\nwith popular GitOps tools (such as Argo CD [https://argoproj.github.io/argo-cd/]\n).\n\nYou can now download a customized Traefik Enterprise manifest to install a\ncluster in Kubernetes from a web service\n[https://doc.traefik.io/traefik-enterprise/v2.3/installing/kubernetes/gitops/#custom-installation-parameters]\n. Additionally, you can provide your static configuration in a Kubernetes\nConfigMap\n[https://doc.traefik.io/traefik-enterprise/v2.3/installing/kubernetes/gitops/#installation]\n, so the configuration can be discovered and automatically reloaded by Traefik\nEnterprise.\n\nIf you‚Äôre interested in the feature, follow our step by step installation\ndocumentation\n[https://doc.traefik.io/traefik-enterprise/v2.3/installing/kubernetes/gitops/] \nand try it out for yourself.\n\nSpeed Up Your Traffic with HTTP Caching\nHaving an infrastructure that can manage all of your traffic is a good thing.\nBut having this infrastructure optimized for your needs is even better.\n\nWith this in mind, Traefik Enterprise 2.3 introduces a new HTTP Cache middleware\n[https://doc.traefik.io/traefik-enterprise/v2.3/middlewares/http-cache/] based\non RFC 7234 [https://tools.ietf.org/html/rfc7234]. It speeds up your external\ntraffic and optimizes your internal traffic by caching HTTP responses in Traefik\nEnterprise proxies. Thus, you can reduce the workload on your services for most\nHTTP requests.\n\nYou just have to set this middleware on your router and Traefik Enterprise will\nstart improving your response times automatically:\n\n# Dynamic Configuration\nhttp:\n  middlewares:\n    test-http-cache:\n      plugin:\n        httpCache:\n          maxTtl: 600\n          memory:\n            limit: \"3Gi\"\n\n\nAPI Portal for Developers\nDeploying a microservice architecture means managing infrastructure with many\nAPIs. These APIs are typically provided by multiple teams in the organization\nand they are often exposed to external partners.\n\nBut how to share the APIs information with all the involved parties? That's\nwhere Traefik Enterprise 2.3 comes in. \n\nWith this new release, you need only describe your APIs‚Äô specifications in the\npopular OpenAPI [https://www.openapis.org/] format and expose them using Traefik\nEnterprise‚Äôs new API portal feature:\n\n# Static Configuration\napiportal:\n  url: spec.json\n\n\nWith just a few lines of configuration, your API specification is reachable from\nyour service.\n\nNeed to monitor all your APIs at a glance? No worries, Traefik Enterprise\nprovides you a dedicated web UI.\n\n\nWhat's Next?\nWith the addition of Vault support, Traefik Enterprise adds support for\nenterprise authentication protocols and Let‚Äôs Encrypt to its portfolio of\nsecurity capabilities.\n\nIn future releases, we‚Äôll continue to develop enterprise-specific features to\nsolve networking issues for companies who choose Traefik Enterprise.\n\nTake a closer look at Traefik Enterprise‚Äôs features to learn more\n[https://traefik.io/traefik-enterprise/]. If you want to test drive this new\nversion, sign up for a free trial of Traefik Enterprise 2.3 today\n[https://info.traefik.io/get-traefik-enterprise-free-for-30-days].","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/10/Blog@2x.jpg\" class=\"kg-image\" alt=\"Traefik Enterprise 2.3 Arrives with Vault Support, GitOps Compliance, and More\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/10/Blog@2x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Blog@2x.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/10/Blog@2x.jpg 1600w, https://containous.ghost.io/content/images/2020/10/Blog@2x.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>We are pleased to announce that a new version of Traefik Enterprise is here, bringing with it an array of new capabilities. Among the new features in this latest release are integration with Vault, a new way to automate Traefik Enterprise installation, support for HTTP caching, and an API portal.</p><h2 id=\"secure-your-infrastructure-in-a-vault\">Secure Your Infrastructure in a Vault</h2><p>The more APIs your infrastructure contains, the more complicated TLS certificate management becomes.</p><!--kg-card-begin: markdown--><p>To solve this problem, many companies have used <a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"nofollow\">Vault</a> to manage their certificates securely. Customers have asked us to help them easily serve these certificates using Traefik Enterprise, and this is now possible with Traefik Enterprise 2.3.</p>\n<!--kg-card-end: markdown--><h3 id=\"vault-as-a-provider\">Vault as a Provider</h3><p>Traefik Enterprise has always been able to read certificates from key-value stores such as Consul or etcd. It‚Äôs now possible to use <a href=\"https://doc.traefik.io/traefik-enterprise/v2.3/providers/vault-kv/\">Vault in the same way</a>, thanks for the new Vault provider in Traefik Enterprise 2.3.</p><p>Configure your Traefik Enterprise cluster to reach your Vault server and it will detect the certificates to serve them:</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\"># Static Configuration\nproviders:\n  plugin:\n    vault:\n      url: &quot;http://127.0.0.1:8200&quot; # Vault server URL\n      token: &quot;s.CUDDqqjiIFXF60KVSeJOxeb5&quot; # Vault Authentication Token\n</code></pre>\n<!--kg-card-end: markdown--><p>As usual with Traefik Enterprise, the configuration will be refreshed automatically each time you insert or delete certificates in your Vault server.</p><h3 id=\"vault-pki-support\">Vault PKI Support</h3><p>Many organizations use Vault to generate TLS certificates on the fly using its public key infrastructure (PKI) feature. Now you can take advantage of this capability with Traefik Enterprise.</p><p>Based on our experience with Let‚Äôs Encrypt, we created a new <a href=\"https://doc.traefik.io/traefik-enterprise/v2.3/tls/vault-pki/\">certificate resolver</a> to integrate Traefik Enterprise with Vault PKI.</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\"># Static Configuration\ncertificatesResolvers:\n  vaultResolver:\n    vault:\n      url: &quot;http://127.0.0.1:8200&quot; # Vault server URL\n      token: &quot;s.CUDDqqjiIFXF60KVSeJOxeb5&quot; # Vault Authentication Token\n      role: &quot;vault-role&quot; # Role to use to generate certificates\n</code></pre>\n<!--kg-card-end: markdown--><p>Once this feature is enabled, Traefik Enterprise can use Vault to create and renew all your TLS certificates, which in turn helps to ease management of your APIs.</p><p>Don‚Äôt hesitate to take a look at our <a href=\"https://doc.traefik.io/traefik-enterprise/v2.3/operations/vault-pki-guide/\">documentation</a> for more information about this feature.</p><h2 id=\"gitops-automation\">GitOps Automation</h2><p>More and more organizations use GitOps tools to automate their deployments. Customers have asked us for better integration of Traefik Enterprise with these tools, and with this release, we‚Äôve delivered.</p><!--kg-card-begin: markdown--><p>Traefik Enterprise 2.3 brings a couple of features to improve our compliance with popular GitOps tools (such as <a href=\"https://argoproj.github.io/argo-cd/\" target=\"_blank\" rel=\"nofollow\">Argo CD</a>).</p>\n<!--kg-card-end: markdown--><p>You can now download a customized Traefik Enterprise manifest to install a cluster in Kubernetes from <a href=\"https://doc.traefik.io/traefik-enterprise/v2.3/installing/kubernetes/gitops/#custom-installation-parameters\">a web service</a>. Additionally, you can provide your <a href=\"https://doc.traefik.io/traefik-enterprise/v2.3/installing/kubernetes/gitops/#installation\">static configuration in a Kubernetes ConfigMap</a>, so the configuration can be discovered and automatically reloaded by Traefik Enterprise.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh4.googleusercontent.com/-Pa5DLSEh9dMm66du3HKBOh0T7XCGlLlE8qkUAMB1HzQSN5zcl4o2swUFEEgHHH_e7T6S1XsoIhA8akMiUmPM0mbb35uqpokH2Ysp9x1HKqtU8-escEqiRqNrxte3tcuzCZzjG7o\" class=\"kg-image\" alt=\"Traefik Enterprise as viewed in Argo CD\"></figure><p>If you‚Äôre interested in the feature, <a href=\"https://doc.traefik.io/traefik-enterprise/v2.3/installing/kubernetes/gitops/\">follow our step by step installation documentation</a> and try it out for yourself.</p><h2 id=\"speed-up-your-traffic-with-http-caching\">Speed Up Your Traffic with HTTP Caching</h2><p>Having an infrastructure that can manage all of your traffic is a good thing. But having this infrastructure optimized for your needs is even better.</p><!--kg-card-begin: markdown--><p>With this in mind, Traefik Enterprise 2.3 introduces a new <a href=\"https://doc.traefik.io/traefik-enterprise/v2.3/middlewares/http-cache/\">HTTP Cache middleware</a> based on <a href=\"https://tools.ietf.org/html/rfc7234\" target=\"_blank\" rel=\"nofollow\">RFC 7234</a>. It speeds up your external traffic and optimizes your internal traffic by caching HTTP responses in Traefik Enterprise proxies. Thus, you can reduce the workload on your services for most HTTP requests.</p>\n<!--kg-card-end: markdown--><p>You just have to set this middleware on your router and Traefik Enterprise will start improving your response times automatically:</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\"># Dynamic Configuration\nhttp:\n  middlewares:\n    test-http-cache:\n      plugin:\n        httpCache:\n          maxTtl: 600\n          memory:\n            limit: &quot;3Gi&quot;\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"api-portal-for-developers\">API Portal for Developers</h2><p>Deploying a microservice architecture means managing infrastructure with many APIs. These APIs are typically provided by multiple teams in the organization and they are often exposed to external partners.</p><p>But how to share the APIs information with all the involved parties? That's where Traefik Enterprise 2.3 comes in. </p><!--kg-card-begin: markdown--><p>With this new release, you need only describe your APIs‚Äô specifications in the popular <a href=\"https://www.openapis.org/\" target=\"_blank\" rel=\"nofollow\">OpenAPI</a> format and expose them using Traefik Enterprise‚Äôs new API portal feature:</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\"># Static Configuration\napiportal:\n  url: spec.json\n</code></pre>\n<!--kg-card-end: markdown--><p>With just a few lines of configuration, your API specification is reachable from your service.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh5.googleusercontent.com/PyheB6IehP5nZYC1A-g8MPqFir_xQDUAeeQQg22FnVo4jgzizDsq82Soy4ZRnu7TyNV3RlrsCJ3gWbfqtwn1BYOySEjLvvWkAiyNn-naYo0aRRJ5Hs0zWgh9d0_rEyOCKy22NCNp\" class=\"kg-image\" alt=\"API specification as seen from the Traefik Enterprise API portal\"></figure><p>Need to monitor all your APIs at a glance? No worries, Traefik Enterprise provides you a dedicated web UI.<br></p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh3.googleusercontent.com/qjEqe2DVQD_pfr8V3ls4bLffXgwKtcX-J_ZnS_UO4V3plp8mrUzLzjDoUoVYm7i3aI_OvPzx7p5pYE9-Z8Ap8aWPIuSvUYVJHrh72HuHSzPTwhUQBMVQCQWXxZz5nK5u-ksffUwM\" class=\"kg-image\" alt=\"Traefik Enterprise API portal dashboard\"></figure><h2 id=\"what-s-next\">What's Next?</h2><p>With the addition of Vault support, Traefik Enterprise adds support for enterprise authentication protocols and Let‚Äôs Encrypt to its portfolio of security capabilities.</p><p>In future releases, we‚Äôll continue to develop enterprise-specific features to solve networking issues for companies who choose Traefik Enterprise.</p><p>Take a closer look at <a href=\"https://traefik.io/traefik-enterprise/\">Traefik Enterprise‚Äôs features to learn more</a>. If you want to test drive this new version, <a href=\"https://info.traefik.io/get-traefik-enterprise-free-for-30-days\">sign up for a free trial of Traefik Enterprise 2.3 today</a>.</p>","url":"https://containous.ghost.io/blog/traefik-enterprise-2-3-arrives-with-vault-support-gitops-compliance-and-more/","canonical_url":null,"uuid":"a8bb7241-7ef4-4fdb-af13-5f2493b42fbf","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f88c505c254310039a24349","reading_time":4}},{"node":{"id":"Ghost__Post__5f97b3e69895340039a5049a","title":"How Vaudoise Insurance Deployed Traefik Enterprise to Successfully Modernize with Microservices","slug":"how-vaudoise-insurance-deployed-traefik-enterprise-to-successfully-modernize-with-microservices","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/2a1ae030bfab70f582e8aa01d0400eb8/f3583/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise.png","srcSet":"/static/2a1ae030bfab70f582e8aa01d0400eb8/630fb/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise.png 300w,\n/static/2a1ae030bfab70f582e8aa01d0400eb8/2a4de/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise.png 600w,\n/static/2a1ae030bfab70f582e8aa01d0400eb8/f3583/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise.png 1200w,\n/static/2a1ae030bfab70f582e8aa01d0400eb8/bbee5/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise.png 1800w,\n/static/2a1ae030bfab70f582e8aa01d0400eb8/0ef64/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise.png 2400w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"As an insurance company, security and service uptime are two of Vaudoise's highest requirements. Traefik Enterprise provides high availability and encryption capabilities necessary for Vaudoise, in a single, easy-to-use solution.","custom_excerpt":"As an insurance company, security and service uptime are two of Vaudoise's highest requirements. Traefik Enterprise provides high availability and encryption capabilities necessary for Vaudoise, in a single, easy-to-use solution.","visibility":"public","created_at_pretty":"27 October, 2020","published_at_pretty":"October 27, 2020","updated_at_pretty":"17 November, 2020","created_at":"2020-10-27T05:45:10.000+00:00","published_at":"2020-10-27T06:05:22.000+00:00","updated_at":"2020-11-17T05:26:20.000+00:00","meta_title":"How Vaudoise Deployed Traefik Enterprise to Modernize w/ Microservices","meta_description":"Traefik Enterprise provides high availability and encryption capabilities necessary for Vaudoise, in a single, easy-to-use solution.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise---Twitter.png","twitter_title":"How Vaudoise Insurance Deployed Traefik Enterprise to Successfully Modernize with Microservices","authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Case Studies","slug":"case-studies","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":"Learn from our users and customers why they choose Traefik and TraefikEE as a modern load balancer to manage network traffic.","meta_title":"Case studies | Containous","visibility":"public"}],"plaintext":"About Vaudoise Insurance\nVaudoise Insurance [https://www.vaudoise.ch] is the only independent private\ninsurance company with a decision-making center in French-speaking Switzerland.\nFounded in 1895, it is one of the ten largest private insurers in the Swiss\nmarket. Vaudoise provides individuals and SMEs with high-level advice and\nsolutions in all areas of insurance and pension provision. Through its network\nof around 100 branches across Switzerland, it offers its customers local\nservice, in terms of both advice and claims settlement. The Group employs\nroughly 1,550 people, including around 100 apprentices.\n\nOverview\nHow do you modernize a company with 125 years of history? Vaudoise Insurance\nentered the digital age decades ago, yet the technical debt incurred by years of\nlegacy computing was becoming too much to manage. Its monolithic systems were\nburdensome to upgrade and rolling out new features required coordination from\nmultiple teams. The pace of change was too slow.\n\nVaudoise‚Äôs technical teams needed to become more agile to match the pace of\ntoday‚Äôs business environment. Its 150-200 IT staffers shared the task of\nmanaging some 300 applications, and too many of these were silos. What the\ncompany‚Äôs development teams wanted was to expose more of its internal data via\nAPIs, making it easier to build new, lightweight applications based on\nmicroservices.\n\nComplicating matters was the fact that insurance is a highly regulated industry,\nparticularly when it comes to data privacy. That meant Vaudoise would need to\ncontinue to host and manage some of its applications on premises, and any new\ntechnologies introduced could not significantly add to the existing management\nburden.\n\nChallenge\nVaudoise‚Äôs strategy was to begin developing new applications as Docker\ncontainers, while simultaneously modernizing its monolithic, legacy applications\nby decomposing them into containerized services. The intent was that this would\nnot only speed time-to-delivery for new applications, but it would also allow\ndevelopment teams to experiment with new technologies (such as NoSQL databases)\nthat simply weren‚Äôt available to their legacy systems.\n\nDamien Desvignes and Patrick Monbaron, application lifecycle management (ALM)\nengineer and system engineer at Vaudoise, belong to the multidisciplinary team\nresponsible for the Docker platform. The company chose Docker Enterprise as its\ncontainer platform, both because of its proven technology and because its Docker\nSwarm mode orchestration layer was significantly less complicated to deploy than\nalternatives (such as Kubernetes).\n\nStill this left Damien and Patrick‚Äôs team with another problem. Now that it had\ndecided how it would host its containers and services, how would it publish\nthem?\n\n> \"We needed a tool that would allow us to dynamically publish new services, or\nchange the configuration of existing services, that was simple to handle and\nthat did not need a restart, unlike the usual nginx-based tools.‚Äù Patrick\nMonbaron, system engineer at Vaudoise\n> ‚ÄúAs an insurance company, security and service uptime are two of our highest\nrequirements. Traefik Enterprise provides high availability and encryption\ncapabilities necessary for Vaudoise, in a single, easy-to-use solution.‚Äù Patrick\nMonbaron, system engineer at Vaudoise\nSolution\nPrior to the company initiative, Damien had successfully used Traefik for over 3\nyears and was confident that its ease-of-use, versatile feature set, and broad\necosystem made it the right choice for application networking with containers.\n\nAs Vaudoise started this new containerized application strategy, Damien\nimmediately sought out Traefik Enterprise\n[https://traefik.io/traefik-enterprise/] to help satisfy the company‚Äôs\nproduction networking requirements. Traefik Enterprise provides out-of-the-box\nhigh availability (HA) and security features that are essential for a business\noperating in the insurance industry. For example, Traefik Enterprise can\ninterface with the Docker Universal Control Plane (UCP) to enable role-based\naccess control (RBAC) on the cluster. Additionally, Traefik Enterprise includes\nfast, responsive enterprise support from Traefik Labs, giving Vaudoise the peace\nof mind of having a partner to rely on.\n\nFrom an operations perspective, Patrick and his infrastructure team benefited\nfrom using Traefik Enterprise by securing and managing Docker Swarm ingress\ntraffic, making it faster and easier to deploy new services. Even HTTPS\nencryption is now centrally managed by the infrastructure team, leaving\ndevelopers free to concentrate on software delivery, without a lot of cross-team\ncoordination.\n\n> ‚ÄúDevelopers are a lot more autonomous than before. Dev teams can manage the\nrewrite rules on their own, for example, which was not possible before.‚Äù Patrick\nMonbaron, system engineer at Vaudoise\nBottom Line\nVaudoise Insurance is only at the beginning of its journey with containers and\nTraefik Enterprise. Damien and Patrick are looking forward to working with\nfeatures introduced in recent versions of Traefik, including the ability to\nsupport applications that use the TCP and UDP protocols, in addition to HTTP.\nEmerging technologies such as service mesh ‚Äì a feature offered by Traefik\nEnterprise 2.2 ‚Äì are also under consideration.\n\nDown the road, Vaudoise may even consider moving from Docker Swarm to a more\nfull-featured container orchestrator, such as Kubernetes, confident that Traefik\nEnterprise will continue to support that new environment.\n\nAlready, however, the features of Traefik Enterprise ‚Äì including enterprise\nsupport from Containous ‚Äì have been instrumental in Vaudoise‚Äôs IT modernization\njourney. Traefik‚Äôs vibrant and active ecosystem, coupled with the enterprise\nfeatures and evolving technology roadmap of Traefik Enterprise, allow Vaudoise\nto proceed with confidence, knowing it will be well-positioned for continued\nsuccess as it moves into the next phase of its long history\n\nWhat‚Äôs Next?\n * Discover Traefik Enterprise [https://traefik.io/traefik-enterprise/], and \n   request your demo\n   [https://info.traefik.io/en/request-demo-traefik-enterprise].","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg\" class=\"kg-image\" alt=\"How Vaudoise Insurance Deployed Traefik Enterprise to Successfully Modernize with Microservices\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg 1600w, https://containous.ghost.io/content/images/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><h2 id=\"about-vaudoise-insurance\"><strong>About Vaudoise Insurance</strong></h2><!--kg-card-begin: markdown--><p><a href=\"https://www.vaudoise.ch\" target=\"_blank\" rel=\"nofollow\">Vaudoise Insurance</a> is the only independent private insurance company with a decision-making center in French-speaking Switzerland. Founded in 1895, it is one of the ten largest private insurers in the Swiss market. Vaudoise provides individuals and SMEs with high-level advice and solutions in all areas of insurance and pension provision. Through its network of around 100 branches across Switzerland, it offers its customers local service, in terms of both advice and claims settlement. The Group employs roughly 1,550 people, including around 100 apprentices.</p>\n<!--kg-card-end: markdown--><h2 id=\"overview\"><strong>Overview</strong></h2><p>How do you modernize a company with 125 years of history? Vaudoise Insurance entered the digital age decades ago, yet the technical debt incurred by years of legacy computing was becoming too much to manage. Its monolithic systems were burdensome to upgrade and rolling out new features required coordination from multiple teams. The pace of change was too slow.</p><p>Vaudoise‚Äôs technical teams needed to become more agile to match the pace of today‚Äôs business environment. Its 150-200 IT staffers shared the task of managing some 300 applications, and too many of these were silos. What the company‚Äôs development teams wanted was to expose more of its internal data via APIs, making it easier to build new, lightweight applications based on microservices.</p><p>Complicating matters was the fact that insurance is a highly regulated industry, particularly when it comes to data privacy. That meant Vaudoise would need to continue to host and manage some of its applications on premises, and any new technologies introduced could not significantly add to the existing management burden.</p><h2 id=\"challenge\"><strong>Challenge</strong></h2><p>Vaudoise‚Äôs strategy was to begin developing new applications as Docker containers, while simultaneously modernizing its monolithic, legacy applications by decomposing them into containerized services. The intent was that this would not only speed time-to-delivery for new applications, but it would also allow development teams to experiment with new technologies (such as NoSQL databases) that simply weren‚Äôt available to their legacy systems.</p><p>Damien Desvignes and Patrick Monbaron, application lifecycle management (ALM) engineer and system engineer at Vaudoise, belong to the multidisciplinary team responsible for the Docker platform. The company chose Docker Enterprise as its container platform, both because of its proven technology and because its Docker Swarm mode orchestration layer was significantly less complicated to deploy than alternatives (such as Kubernetes).</p><p>Still this left Damien and Patrick‚Äôs team with another problem. Now that it had decided how it would host its containers and services, how would it publish them?</p><blockquote>\"We needed a tool that would allow us to dynamically publish new services, or change the configuration of existing services, that was simple to handle and that did not need a restart, unlike the usual nginx-based tools.‚Äù<strong> </strong>Patrick Monbaron, system engineer at Vaudoise</blockquote><blockquote>‚ÄúAs an insurance company, security and service uptime are two of our highest requirements. Traefik Enterprise provides high availability and encryption capabilities necessary for Vaudoise, in a single, easy-to-use solution.‚Äù<strong> </strong>Patrick Monbaron, system engineer at Vaudoise</blockquote><h2 id=\"solution\"><strong>Solution</strong></h2><p>Prior to the company initiative, Damien had successfully used Traefik for over 3 years and was confident that its ease-of-use, versatile feature set, and broad ecosystem made it the right choice for application networking with containers.</p><p>As Vaudoise started this new containerized application strategy, Damien immediately sought out <a href=\"https://traefik.io/traefik-enterprise/\">Traefik Enterprise</a> to help satisfy the company‚Äôs production networking requirements. Traefik Enterprise provides out-of-the-box high availability (HA) and security features that are essential for a business operating in the insurance industry. For example, Traefik Enterprise can interface with the Docker Universal Control Plane (UCP) to enable role-based access control (RBAC) on the cluster. Additionally, Traefik Enterprise includes fast, responsive enterprise support from Traefik Labs, giving Vaudoise the peace of mind of having a partner to rely on.</p><p>From an operations perspective, Patrick and his infrastructure team benefited from using Traefik Enterprise by securing and managing Docker Swarm ingress traffic, making it faster and easier to deploy new services. Even HTTPS encryption is now centrally managed by the infrastructure team, leaving developers free to concentrate on software delivery, without a lot of cross-team coordination.</p><blockquote>‚ÄúDevelopers are a lot more autonomous than before. Dev teams can manage the rewrite rules on their own, for example, which was not possible before.‚Äù Patrick Monbaron, system engineer at Vaudoise</blockquote><h2 id=\"bottom-line\"><strong>Bottom Line</strong></h2><p>Vaudoise Insurance is only at the beginning of its journey with containers and Traefik Enterprise. Damien and Patrick are looking forward to working with features introduced in recent versions of Traefik, including the ability to support applications that use the TCP and UDP protocols, in addition to HTTP. Emerging technologies such as service mesh ‚Äì a feature offered by Traefik Enterprise 2.2 ‚Äì are also under consideration.</p><p>Down the road, Vaudoise may even consider moving from Docker Swarm to a more full-featured container orchestrator, such as Kubernetes, confident that Traefik Enterprise will continue to support that new environment.</p><p>Already, however, the features of Traefik Enterprise ‚Äì including enterprise support from Containous ‚Äì have been instrumental in Vaudoise‚Äôs IT modernization journey. Traefik‚Äôs vibrant and active ecosystem, coupled with the enterprise features and evolving technology roadmap of Traefik Enterprise, allow Vaudoise to proceed with confidence, knowing it will be well-positioned for continued success as it moves into the next phase of its long history</p><h2 id=\"what-s-next\">What‚Äôs Next?</h2><ul><li>Discover <a href=\"https://traefik.io/traefik-enterprise/\">Traefik Enterprise</a>, and <a href=\"https://info.traefik.io/en/request-demo-traefik-enterprise\">request your demo</a>.</li></ul>","url":"https://containous.ghost.io/blog/how-vaudoise-insurance-deployed-traefik-enterprise-to-successfully-modernize-with-microservices/","canonical_url":null,"uuid":"0d4cadb3-fdb1-455e-bb85-9e0f8e4cb840","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f97b3e69895340039a5049a","reading_time":4}},{"node":{"id":"Ghost__Post__5f9c81f69895340039a505c9","title":"The Complete Traefik Training  Course","slug":"the-complete-traefik-training-course","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/10/Blog--1-.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/6278206c4bc85e9f7fc3f65ba177ac00/f3583/Blog--1-.png","srcSet":"/static/6278206c4bc85e9f7fc3f65ba177ac00/630fb/Blog--1-.png 300w,\n/static/6278206c4bc85e9f7fc3f65ba177ac00/2a4de/Blog--1-.png 600w,\n/static/6278206c4bc85e9f7fc3f65ba177ac00/f3583/Blog--1-.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"The Complete Traefik Training Course  course by Brian Christner of The Byte provides real-world examples, hands-on labs and guided lessons on the features available with Traefik Proxy. ","custom_excerpt":"The Complete Traefik Training Course  course by Brian Christner of The Byte provides real-world examples, hands-on labs and guided lessons on the features available with Traefik Proxy. ","visibility":"public","created_at_pretty":"30 October, 2020","published_at_pretty":"November 3, 2020","updated_at_pretty":"21 December, 2020","created_at":"2020-10-30T21:13:26.000+00:00","published_at":"2020-11-03T14:30:00.000+00:00","updated_at":"2020-12-21T22:39:58.000+00:00","meta_title":"The Complete Traefik Training Course by Brian Christner of The Byte","meta_description":"The Complete Traefik Training Course  course provides real-world examples, hands-on labs and guided lessons on the features available with Traefik Proxy. ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/10/Twitter@2x-2.png","twitter_title":null,"authors":[{"name":"Brian Christner","slug":"brianchristner","bio":"Brian is a nominated member of the Docker Captain‚Äôs program and Traefik Ambassador programs. He is also a cloud subject matter expert in the topics of Docker, Cloud Native, DevOps, & crashing his MTB","profile_image":"https://containous.ghost.io/content/images/2020/10/89CC1AD5-4315-4775-8CB2-1851F66E5FF7.jpeg","twitter":"@idomyowntricks","facebook":null,"website":"https://thebyte.io"}],"primary_author":{"name":"Brian Christner","slug":"brianchristner","bio":"Brian is a nominated member of the Docker Captain‚Äôs program and Traefik Ambassador programs. He is also a cloud subject matter expert in the topics of Docker, Cloud Native, DevOps, & crashing his MTB","profile_image":"https://containous.ghost.io/content/images/2020/10/89CC1AD5-4315-4775-8CB2-1851F66E5FF7.jpeg","twitter":"@idomyowntricks","facebook":null,"website":"https://thebyte.io"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Partners","slug":"partners","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#community-related-resource","slug":"hash-community-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Hi! My name is Brian Christner‚ÄîDocker Captain, Traefik Ambassador, DevOps\nprofessional, and the creator of the Complete Traefik Training Course. I‚Äôm happy\nto announce that theByte, in collaboration with Traefik Labs, has created a full\nin-depth Traefik Training course. \n\nWe created this course to help you get up to speed quickly configuring and\ndeploying Traefik. This course provides real-world examples, hands-on labs, and\nguided lessons in order for you to fully immerse yourself with all the features\navailable with the Traefik Proxy. The aim of the course is to help you get up\nand running with Traefik.\n\nMaybe you are already familiar with Traefik or just getting started. The Traefik\nTraining course guides you through a tour of the available features, use cases,\nand answers a lot of the \"Why?\" questions you may have.\n\nWhy Traefik Training?\nTraefik is an amazing tool. I‚Äôve been using it for over three years now and\nimmersed myself in the project as a contributor‚Äîusing it both for personal and\ncustomer projects. However, I have received consistent feedback from customers\nand users requesting a Traefik Training course to walk through configuration,\ndeployment, and operating Traefik and an explanation of why certain things\nbehave and configured. ¬†Based on the feedback we created the Traefik Training\ncourse.\n\nThe Traefik documentation is a great place to start. The Traefik Training course\nextends the documentation with a guided tour on how best to use Traefik to fully\nunderstand the potential for your use case. \n\nWhat will you learn?\nThe Traefik Training course contains over 5 hours of lessons, 20+ hands-on labs,\nand a ton of real-world experience from deploying the Traefik Proxy for\nreal-world projects built into the course. The course covers the background of\nTraefik, ¬†getting started with Traefik, configuration, deployment, and Day 2\noperations. \n\nWhat you'll get:\n‚úÖ ¬†A robust course RECOMMENDED by Traefik Labs!\n\nüìπ ¬†Videos: Over 5 hours of course material\n\nü•º ¬†LABS: More than 20+ Hands-on Labs with access to code examples and templates\n\nüö¶ COLLAB: A course built in cooperation with the Traefik Labs team\n\nüéØ LEARN: A thorough understanding of Reverse Proxies, Load Balancers, and the\nTraefik Architecture\n\nüí° EXAMPLES: Deploy a Monitoring stack of Prometheus, Grafana, and Traefik\n\nüë®‚Äçüè´ Instructor: Learn from the Pro, Brian Christner Docker Captain & Traefik\nAmbassador.\n\nüîë ACCESS: to a Private Slack Channel with engineers, professionals, and fellow\nstudents.\n\nüìä UPDATES: Lifetime free course updates\n\nüèÜ CERTIFICATE: Certificate of completion\n\nCourse Syllabus\n * Course introduction\n * Getting Started with Traefik\n * Configure Traefik\n * Routers & Services\n * HTTPS / TLS / Let's Encrypt\n * Middlewares\n * Observability\n * Operations\n * Advanced Tips\n * Course Wrap and Next Steps\n\nStart Learning Traefik Today\nIt has never been easier to learn Traefik. The Complete Traefik Training course\nis the perfect course to configure, deploy, and manage Traefik helping you get\nstarted, and experiencing the benefits of Traefik very quickly. The course will\nenable you to start connecting your workload to Traefik today.\n\nFor any questions you may have during, or after the course, please ping me on \nTwitter [https://twitter.com/idomyowntricks].\n\nüëâ Get Started Learning Traefik Today. Sign up here!\n[https://www.thebyte.io/traefik-training]","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/11/Blog@2x.png\" class=\"kg-image\" alt srcset=\"https://containous.ghost.io/content/images/size/w600/2020/11/Blog@2x.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/11/Blog@2x.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/11/Blog@2x.png 1600w, https://containous.ghost.io/content/images/2020/11/Blog@2x.png 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Hi! My name is Brian Christner‚ÄîDocker Captain, Traefik Ambassador, DevOps professional, and the creator of the Complete Traefik Training Course. I‚Äôm happy to announce that theByte, in collaboration with Traefik Labs, has created a full in-depth Traefik Training course. </p><p>We created this course to help you get up to speed quickly configuring and deploying Traefik. This course provides real-world examples, hands-on labs, and guided lessons in order for you to fully immerse yourself with all the features available with the Traefik Proxy. The aim of the course is to help you get up and running with Traefik.</p><p>Maybe you are already familiar with Traefik or just getting started. The Traefik Training course guides you through a tour of the available features, use cases, and answers a lot of the \"<strong>Why?\"</strong> questions you may have.</p><h2 id=\"why-traefik-training\">Why Traefik Training?</h2><p>Traefik is an amazing tool. I‚Äôve been using it for over three years now and immersed myself in the project as a contributor‚Äîusing it both for personal and customer projects. However, I have received consistent feedback from customers and users requesting a Traefik Training course to walk through <em>configuration, deployment, and operating Traefik and an explanation of why certain things behave and configured</em>. ¬†Based on the feedback we created the Traefik Training course. ¬†</p><p>The Traefik documentation is a great place to start. The Traefik Training course extends the documentation with a guided tour on how best to use Traefik to fully understand the potential for your use case. </p><h3 id=\"what-will-you-learn\">What will you learn?</h3><p>The Traefik Training course contains over 5 hours of lessons, 20+ hands-on labs, and a ton of real-world experience from deploying the Traefik Proxy for real-world projects built into the course. The course covers the background of Traefik, ¬†getting started with Traefik, configuration, deployment, and Day 2 operations. </p><h3 id=\"what-you-ll-get-\">What you'll get:</h3><p><strong>‚úÖ ¬†A robust course RECOMMENDED by Traefik Labs!</strong></p><p><strong>üìπ ¬†Videos:</strong> Over 5 hours of course material</p><p><strong>ü•º ¬†LABS: </strong>More than 20+ Hands-on Labs with access to code examples and templates</p><p><strong>üö¶ COLLAB:</strong> A course built in cooperation with the Traefik Labs team</p><p><strong>üéØ LEARN: </strong>A thorough understanding of Reverse Proxies, Load Balancers, and the Traefik Architecture</p><p><strong>üí° EXAMPLES: </strong>Deploy a Monitoring stack of Prometheus, Grafana, and Traefik</p><p><strong>üë®‚Äçüè´ Instructor: </strong>Learn from the Pro, Brian Christner Docker Captain &amp; Traefik Ambassador.</p><p><strong>üîë ACCESS: </strong>to a Private Slack Channel with engineers, professionals, and fellow students.</p><p><strong>üìä UPDATES: </strong>Lifetime free course updates</p><p><strong>üèÜ CERTIFICATE: </strong>Certificate of completion</p><h2 id=\"course-syllabus\">Course Syllabus</h2><ul><li>Course introduction</li><li>Getting Started with Traefik</li><li>Configure Traefik</li><li>Routers &amp; Services</li><li>HTTPS / TLS / Let's Encrypt</li><li>Middlewares</li><li>Observability</li><li>Operations</li><li>Advanced Tips</li><li>Course Wrap and Next Steps</li></ul><h3 id=\"start-learning-traefik-today\">Start Learning Traefik Today</h3><p>It has never been easier to learn Traefik. The Complete Traefik Training course is the perfect course to configure, deploy, and manage Traefik helping you get started, and experiencing the benefits of Traefik very quickly. The course will enable you to start connecting your workload to Traefik today.</p><!--kg-card-begin: markdown--><p>For any questions you may have during, or after the course, please ping me on <a href=\"https://twitter.com/idomyowntricks\" target=\"_blank\" rel=\"nofollow\">Twitter</a>.</p>\n<p>üëâ Get Started Learning Traefik Today. <a href=\"https://www.thebyte.io/traefik-training\" target=\"_blank\">Sign up here!</a></p>\n<!--kg-card-end: markdown--><p></p>","url":"https://containous.ghost.io/blog/the-complete-traefik-training-course/","canonical_url":null,"uuid":"71862601-84d1-462e-9d30-1d7444664b2d","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f9c81f69895340039a505c9","reading_time":2}},{"node":{"id":"Ghost__Post__5f7f21459ccef80039928ddc","title":"Leveraging your Ingress Controller to easily migrate to Kubernetes","slug":"leveraging-your-ingress-controller-to-easily-migrate-to-kubernetes","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/ea29e913bf4a4db59cb25046b9525998/47498/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes-1.jpg","srcSet":"/static/ea29e913bf4a4db59cb25046b9525998/9dc27/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes-1.jpg 300w,\n/static/ea29e913bf4a4db59cb25046b9525998/4fe8c/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes-1.jpg 600w,\n/static/ea29e913bf4a4db59cb25046b9525998/47498/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes-1.jpg 1200w,\n/static/ea29e913bf4a4db59cb25046b9525998/52258/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes-1.jpg 1800w,\n/static/ea29e913bf4a4db59cb25046b9525998/a41d1/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"In this article, we‚Äôll delve into the question of migrating legacy applications by discussing the specific challenges these workloads pose and outlining a strategy to overcome them.","custom_excerpt":"In this article, we‚Äôll delve into the question of migrating legacy applications by discussing the specific challenges these workloads pose and outlining a strategy to overcome them.","visibility":"public","created_at_pretty":"08 October, 2020","published_at_pretty":"November 10, 2020","updated_at_pretty":"03 December, 2020","created_at":"2020-10-08T14:25:09.000+00:00","published_at":"2020-11-10T01:46:18.000+00:00","updated_at":"2020-12-03T02:14:07.000+00:00","meta_title":"Leveraging your Ingress Controller to easily migrate to Kubernetes","meta_description":"This article delves into migrating legacy applications by discussing the specific challenges these workloads pose and outlining a strategy to overcome them.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes---Twitter.png","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Many enterprise organizations choose Kubernetes (k8s) [https://kubernetes.io] as\nthe foundation of their IT modernization efforts due to its alignment with cloud\nnative practices. However, a question naturally arises during the adoption\nprocess: How should existing legacy applications be handled as part of a broader\nKubernetes migration? As it turns out, the answer ties to the Ingress\nController, one of the core components in a Kubernetes cluster. In this article,\nwe‚Äôll delve into the question of migrating legacy applications by discussing the\nspecific challenges these workloads pose and outlining a strategy to overcome\nthem.\n\nLegacy applications and Kubernetes\nThe functionality provided by legacy workloads typically encapsulates\nsignificant business value for organizations. Having been designed and\nimplemented in an earlier era, they also tend to gravitate towards monolithic\narchitectures powered by older programming languages and toolchains. For these\nreasons, they're often stagnant with little ongoing development other than to\naddress high priority bugs or significant security vulnerabilities.\n\nHere lies the dilemma: on the one hand, these legacy workloads are highly\nvaluable. Modifying them in any way, including their operating environment,\ncreates risks associated with the business's daily operation. On the other hand,\nleaving them out of a Kubernetes migration means maintaining older operating\nenvironments and preventing teams from reaping the benefits provided by\nKubernetes with these critical applications. What's needed is a way for IT\nleaders to mitigate the migration risks associated with legacy applications.\n\nDiscussions around Ingress Controllers often arise as part of networking and\nrouting in Kubernetes, particularly in connecting external users to applications\n[https://traefik.io/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/]\n. Due to their strategic placement in the overall architecture, in practice,\ntheir capabilities can extend benefits to use cases well beyond just\nconnectivity. As we'll discuss in more detail, used effectively, Ingress\nControllers can help ease the process of migrating and running legacy\napplications on Kubernetes by reducing or mitigating many of the risks that may\notherwise prevent IT from making the transition process. To illustrate where\nIngress Controllers fit into the overall migration picture, consider a\nhigh-level outline of a general migration strategy (we'll dive into each area\nnext):\n\nMigrating your Legacy Applications using Kubernetes Ingress * Deploy legacy\n   workloads on Kubernetes - Get legacy applications running on k8s as simply\n   and quickly as possible\n * Select an option\n   for ongoing development / maintenance: * Build around a legacy application -\n      Use Ingress Controller functionality to route traffic in a manner which\n      allows for building on top of legacy without modifying it\n    * Build your way out of a legacy\n      application - Use Ingress Controller functionality to enable iterative\n      refactoring of legacy\n   \n   \n\nLift and Shift: Deploy legacy workloads on Kubernetes\nThe first step of our migration strategy entails establishing a baseline for\ndeploying legacy codebase running on Kubernetes. The goal is to help achieve a\nstandardizing operating environment for all workloads and serve as a starting\npoint for further improvements. To accomplish this, one must containerize the\nmonolithic codebase and its associated dependencies. While there is no single\nrecipe for containerization that will work across all applications, there are\nwell-known items that need addressing as part of a \"lift and shift\" operation.\n\nFirst, an appropriate Docker base image should be selected or defined for the\nlegacy application. Depending upon the language and technology stack used in its\nimplementation, there may be viable candidates available on Docker Hub\n[https://hub.docker.com/]. Otherwise, DevOps engineers will need to craft a\ncustom image. Once the team establishes a base image, they leverage it to\niterate on the monolithic application's candidate release images. In some cases,\nengineers will augment base images by injecting build artifacts. In others, it\nmay be necessary to generate artifacts using the base image itself through\nmulti-stage build processes. Once the containerized image is available, it can\nbe deployed onto a Kubernetes cluster and validated.\n\nBuild around legacy applications with Ingress Controllers\nOnce the team establishes a baseline deployment, they have options for managing\nthe future legacy workload. There will inevitably be a need to extend the\nmonolith functionally, and this is where Ingress Controllers can help reduce\ncomplexity and risk. Specifically, instead of taking an approach where\ndevelopers must modify or refactor the legacy applications, the core application\ncan be left intact while using Ingress Controllers. This approach permits\nadditional functionality by injecting new services that logically sit between\nend users and the monolith. Since developers are empowered to build these\nservices from scratch, they are implementable using cloud native best practices.\nTraffic from external users routes to the intervening service layer by\nconfiguring the Ingress Controller for the cluster. When requests are received,\nthe containerized legacy application operates as needed for specific\nfunctionality.\n\nBuild away from legacy applications with Ingress Controllers\nAn alternative approach towards realizing additional functionality around a\nlegacy application once deployed on Kubernetes is to employ the so-called\nStrangler pattern. As may be apparent from the name, this strategy consists of\nreplacing legacy codebases gradually by migrating features to new microservice\nimplementations, which may also incorporate additional capabilities. Compared to\na wholesale reimplementation, the overall risk spreads over time. In addition,\nif needed, teams can always fall back to the original implementation since it is\nleft intact. The Ingress Controller is the key to enabling this strategy on\nKubernetes as it allows operators to route traffic from external users to the\nrefactored microservices versus the legacy application. As functionality\ncontinues to shift away from the monolith, it is \"strangled\" out, and\neventually, the legacy application is ready to be removed from the cluster\naltogether.\n\nConclusion\nFor many enterprise organizations, legacy applications continue to support\ncritical processes that form the business's backbone. Therefore, IT leaders need\nto understand potential strategies for handling these workloads during a\nKubernetes migration.\n\nIn this article, we've reviewed how Ingress Controllers can significantly reduce\nthe risk of legacy migrations while also enabling continued development around\nlegacy implementations. While the directions outlined are available today with\navailable Ingress Controllers, this area is also rapidly evolving within the\nKubernetes ecosystem, as evidenced by its Service API evolution\n[https://traefik.io/blog/kubernetes-ingress-service-api-demystified/].\nEnterprises can safely assume that the ability to leverage resources such as\nIngress Controllers to help ease migration challenges is only going to improve\nin the future.\n\nLearn more about Traefik Enterprise\n[https://info.traefik.io/en/request-demo-traefik-enterprise] today and learn how\nbusinesses are leveraging the power of enterprise-grade Kubernetes Ingress to\nsolve their most demanding challenges.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg\" class=\"kg-image\" alt=\"Leveraging your Ingress Controller to easily migrate to Kubernetes\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg 1600w, https://containous.ghost.io/content/images/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><!--kg-card-begin: markdown--><p>Many enterprise organizations choose <a href=\"https://kubernetes.io\" target=\"_blank\" rel=\"nofollow\">Kubernetes (k8s)</a> as the foundation of their IT modernization efforts due to its alignment with cloud native practices. However, a question naturally arises during the adoption process: How should existing legacy applications be handled as part of a broader Kubernetes migration? As it turns out, the answer ties to the Ingress Controller, one of the core components in a Kubernetes cluster. In this article, we‚Äôll delve into the question of migrating legacy applications by discussing the specific challenges these workloads pose and outlining a strategy to overcome them.</p>\n<h2 id=\"legacyapplicationsandkubernetes\">Legacy applications and Kubernetes</h2>\n<p>The functionality provided by legacy workloads typically encapsulates significant business value for organizations. Having been designed and implemented in an earlier era, they also tend to gravitate towards monolithic architectures powered by older programming languages and toolchains. For these reasons, they're often stagnant with little ongoing development other than to address high priority bugs or significant security vulnerabilities.</p>\n<p>Here lies the dilemma: on the one hand, these legacy workloads are highly valuable. Modifying them in any way, including their operating environment, creates risks associated with the business's daily operation. On the other hand, leaving them out of a Kubernetes migration means maintaining older operating environments and preventing teams from reaping the benefits provided by Kubernetes with these critical applications. What's needed is a way for IT leaders to mitigate the migration risks associated with legacy applications.</p>\n<p>Discussions around Ingress Controllers often arise as part of networking and routing in Kubernetes, particularly in <a href=\"https://traefik.io/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/\">connecting external users to applications</a>. Due to their strategic placement in the overall architecture, in practice, their capabilities can extend benefits to use cases well beyond just connectivity. As we'll discuss in more detail, used effectively, Ingress Controllers can help ease the process of migrating and running legacy applications on Kubernetes by reducing or mitigating many of the risks that may otherwise prevent IT from making the transition process. To illustrate where Ingress Controllers fit into the overall migration picture, consider a high-level outline of a general migration strategy (we'll dive into each area next):</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/10/Strangler_Pattern_Blog_Image.svg\" class=\"kg-image\" alt=\"Migrating your Legacy Applications using Kubernetes Ingress\"><figcaption>Migrating your Legacy Applications using Kubernetes Ingress</figcaption></figure><!--kg-card-begin: markdown--><ul>\n<li>Deploy legacy workloads on Kubernetes - Get legacy applications running on k8s as simply and quickly as possible</li>\n<li>Select an option for ongoing development / maintenance:\n<ul>\n<li>Build around a legacy application - Use Ingress Controller functionality to route traffic in a manner which allows for building on top of legacy without modifying it</li>\n<li>Build your way out of a legacy application - Use Ingress Controller functionality to enable iterative refactoring of legacy</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"liftandshiftdeploylegacyworkloadsonkubernetes\">Lift and Shift: Deploy legacy workloads on Kubernetes</h2>\n<p>The first step of our migration strategy entails establishing a baseline for deploying legacy codebase running on Kubernetes. The goal is to help achieve a standardizing operating environment for all workloads and serve as a starting point for further improvements. To accomplish this, one must containerize the monolithic codebase and its associated dependencies. While there is no single recipe for containerization that will work across all applications, there are well-known items that need addressing as part of a &quot;lift and shift&quot; operation.</p>\n<p>First, an appropriate Docker base image should be selected or defined for the legacy application. Depending upon the language and technology stack used in its implementation, there may be viable candidates available on <a href=\"https://hub.docker.com/\" rel=\"nofollow\" target=\"_blank\">Docker Hub</a>. Otherwise, DevOps engineers will need to craft a custom image. Once the team establishes a base image, they leverage it to iterate on the monolithic application's candidate release images. In some cases, engineers will augment base images by injecting build artifacts. In others, it may be necessary to generate artifacts using the base image itself through multi-stage build processes. Once the containerized image is available, it can be deployed onto a Kubernetes cluster and validated.</p>\n<h2 id=\"buildaroundlegacyapplicationswithingresscontrollers\">Build around legacy applications with Ingress Controllers</h2>\n<p>Once the team establishes a baseline deployment, they have options for managing the future legacy workload. There will inevitably be a need to extend the monolith functionally, and this is where Ingress Controllers can help reduce complexity and risk. Specifically, instead of taking an approach where developers must modify or refactor the legacy applications, the core application can be left intact while using Ingress Controllers. This approach permits additional functionality by injecting new services that logically sit between end users and the monolith. Since developers are empowered to build these services from scratch, they are implementable using cloud native best practices. Traffic from external users routes to the intervening service layer by configuring the Ingress Controller for the cluster. When requests are received, the containerized legacy application operates as needed for specific functionality.</p>\n<h2 id=\"buildawayfromlegacyapplicationswithingresscontrollers\">Build away from legacy applications with Ingress Controllers</h2>\n<p>An alternative approach towards realizing additional functionality around a legacy application once deployed on Kubernetes is to employ the so-called Strangler pattern. As may be apparent from the name, this strategy consists of replacing legacy codebases gradually by migrating features to new microservice implementations, which may also incorporate additional capabilities. Compared to a wholesale reimplementation, the overall risk spreads over time. In addition, if needed, teams can always fall back to the original implementation since it is left intact. The Ingress Controller is the key to enabling this strategy on Kubernetes as it allows operators to route traffic from external users to the refactored microservices versus the legacy application. As functionality continues to shift away from the monolith, it is &quot;strangled&quot; out, and eventually, the legacy application is ready to be removed from the cluster altogether.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>For many enterprise organizations, legacy applications continue to support critical processes that form the business's backbone. Therefore, IT leaders need to understand potential strategies for handling these workloads during a Kubernetes migration.</p>\n<p>In this article, we've reviewed how Ingress Controllers can significantly reduce the risk of legacy migrations while also enabling continued development around legacy implementations. While the directions outlined are available today with available Ingress Controllers, this area is also rapidly evolving within the Kubernetes ecosystem, as evidenced by its <a href=\"https://traefik.io/blog/kubernetes-ingress-service-api-demystified/\">Service API evolution</a>. Enterprises can safely assume that the ability to leverage resources such as Ingress Controllers to help ease migration challenges is only going to improve in the future.</p>\n<p><a href=\"https://info.traefik.io/en/request-demo-traefik-enterprise\">Learn more about Traefik Enterprise</a> today and learn how businesses are leveraging the power of enterprise-grade Kubernetes Ingress to solve their most demanding challenges.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/leveraging-your-ingress-controller-to-easily-migrate-to-kubernetes/","canonical_url":null,"uuid":"0428ce65-eac9-4f98-9d45-20c721ff9acb","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f7f21459ccef80039928ddc","reading_time":4}},{"node":{"id":"Ghost__Post__5fb312644a99b50039ce6d0d","title":"Lock Down Your Network with Traefik Enterprise and Vault","slug":"lock-down-your-network-with-traefik-enterprise-and-vault","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/467c1cae57eb781022dd88370e8e23bb/47498/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.jpg","srcSet":"/static/467c1cae57eb781022dd88370e8e23bb/9dc27/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.jpg 300w,\n/static/467c1cae57eb781022dd88370e8e23bb/4fe8c/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.jpg 600w,\n/static/467c1cae57eb781022dd88370e8e23bb/47498/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.jpg 1200w,\n/static/467c1cae57eb781022dd88370e8e23bb/52258/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.jpg 1800w,\n/static/467c1cae57eb781022dd88370e8e23bb/a41d1/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik Enterprise 2.3 now supports Vault for certificate management in two ways: as a key-value store for certificates, and as a certificate resolver.","custom_excerpt":"Traefik Enterprise 2.3 now supports Vault for certificate management in two ways: as a key-value store for certificates, and as a certificate resolver.","visibility":"public","created_at_pretty":"16 November, 2020","published_at_pretty":"November 17, 2020","updated_at_pretty":"08 December, 2020","created_at":"2020-11-16T23:59:32.000+00:00","published_at":"2020-11-17T05:26:08.000+00:00","updated_at":"2020-12-08T16:11:14.000+00:00","meta_title":"Lock Down Your Network with Traefik Enterprise and Vault","meta_description":"Traefik Enterprise 2.3 now supports Vault for certificate management in two ways: as a key-value store for certificates, and as a certificate resolver.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.png","twitter_title":null,"authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#api-gateway-related-resource","slug":"hash-api-gateway-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Every organization has secrets. Likewise, every application and service must\nmanage sensitive information ‚Äì such as usernames and passwords, license keys,\ndatabase credentials, and so on ‚Äì that should be kept away from prying eyes.\n\nAmong the most important secrets that modern apps must maintain are the TLS\ncertificates [https://en.wikipedia.org/wiki/Transport_Layer_Security] that make\nencrypted HTTPS communications possible. The good news for Traefik Enterprise\nusers is that handling these secrets is now easier than ever, thanks to support\nfor Vault in Traefik Enterprise 2.3.\n\nVault [https://www.vaultproject.io/] is an open source\n[https://github.com/hashicorp/vault] tool developed and maintained by HashiCorp\nthat provides a secure and encrypted central data store for secrets. Traefik\nEnterprise 2.3 can use Vault for certificate management in two ways. First, it\ncan use Vault as a key-value store for certificates. Second, it can enlist Vault\nas a certificate resolver, allowing it to dynamically generate certificates on\nthe fly. Let‚Äôs examine both use cases.\n\nUsing Vault as a Key-Value Store for Certificates\nTraefik has long been able to discover and connect with a variety of key-value\nstores, such as Consul, etcd, and ZooKeeper. The Vault provider for Traefik\nEnterprise 2.3 and later can connect to Vault in a similar way, using it as a\nkey-value store for storing and retrieving TLS certificates.\n\nThe first step is to setup the Vault secrets engine for use with Traefik\nEnterprise. As of now, Traefik Enterprise supports the KV Secrets Engine ‚Äì\nVersion 2 [https://www.vaultproject.io/docs/secrets/kv/kv-v2], which is\ncurrently the default and is easily enabled from the command line. It‚Äôs a good\nidea to use a dedicated KV store for TLS certificates, and bear in mind that all\ncertificates must be base64-encoded and stored in the root of the KV secrets\nengine.\n\nFrom there, it‚Äôs a straightforward matter of enabling the Vault Provider in\nTraefik Enterprise‚Äôs static configuration. This takes just a few lines of code,\nand a typical example (in YAML) might look like this:\n\nproviders:\n  plugin:\n    vault:\n      url: \"http://127.0.0.1:8200\"\n      token: \"s.CUDDqqjiIFXF60KVSeJOxeb5\"\n      enginePath: \"secret\"\n      syncInterval: \"5s\"\n      rescanInterval: \"60s\"\n\n\nThis snippet points to the URL of the Vault server and supplies the token that‚Äôs\nneeded to authenticate with it. (The Vault Provider only supports token\nauthentication at this time.) It also specifies how often the provider will pull\ndata from the Vault KV store.\n\nThat‚Äôs it! Once configured, Traefik Enterprise will detect certificates in the\nstore to serve them. And, as usual for Traefik Enterprise, the configuration\nrefreshes automatically whenever you insert or delete certificates from the\nVault store.\n\nIf you‚Äôd like to learn more about how to setup and configure the Vault Provider\nfor Traefik Enterprise, check out the documentation\n[https://doc.traefik.io/traefik-enterprise/providers/vault-kv/].\n\nUsing Vault as a Certificate Resolver for PKI\nExperienced Traefik users will be familiar with its support for automatic\ncertificate generation using the ACME protocol and compatible service providers,\nsuch as Let‚Äôs Encrypt [https://doc.traefik.io/traefik-enterprise/tls/acme/].\nTraefik Enterprise 2.3 adds a new, additional means of automating certificate\ngeneration in the form of support for Vault Public Key Infrastructure (PKI)\n[https://www.hashicorp.com/products/vault/pki-with-vault].\n\nThe Vault PKI secrets engine includes built-in authentication and authorization\nfunctions that make it possible to generate certificates on the fly, without\ngetting bogged down in the traditional, manual process of generating keys and\nsubmitting to a certificate authority (CA).\n\nThis automation is especially valuable in dynamic, microservices-based\nenvironments, where services tend to be short-lived and container instances are\nrapidly created and destroyed, according to demand.\n\nSetting up Vault as a certificate resolver\n[https://doc.traefik.io/traefik/https/acme/#certificate-resolvers] is almost as\neasy as configuring the Vault Provider, as discussed earlier. Once Vault is\ninstalled with the PKI secrets engine enabled, configuring the feature requires\nadding just a few lines to Traefik Enterprise‚Äôs static configuration. For\nexample:\n\ncertificatesResolvers:\n  resolverName:\n\tvault:\n  \turl: \"http://127.0.0.1:8200\"\n  \ttoken: \"s.CUDDqqjiIFXF60KVSeJOxeb5\" # Your Vault auth token goes here\n  \tenginePath: \"pki\"\n  \trole: \"vault-role\"\n\n\nOnce the certificate resolver is configured, assigning it to routes in Traefik\nEnterprise will trigger Vault to generate certificates for requests that match\nthe appropriate patterns. To read more about how this works, consult the \ndocumentation [https://doc.traefik.io/traefik-enterprise/tls/vault-pki/].\nThere‚Äôs also a handy user guide\n[https://doc.traefik.io/traefik-enterprise/operations/vault-pki-guide/] \navailable that walks through the process of deploying a simple TLS-enabled\nservice with Vault on Kubernetes.\n\nGet Secure with Traefik Enterprise\nTraefik Labs is pleased to offer support for Vault in Traefik Enterprise as\nfurther proof of our commitment to provide best-of-breed features that\nsecurity-conscious enterprises demand. Using Vault to manage secrets is a step\nforward in securing your network; using Vault with Traefik Enterprise makes\ntaking that step even easier. If you‚Äôd like to learn more about these and other\nadvanced features of Traefik Enterprise, the best way is to try them out for\nyourself. Sign up for a 30-day free trial\n[https://info.traefik.io/get-traefik-enterprise-free-for-30-days] and explore\nhow Traefik Enterprise can help make your infrastructure more nimble, reliable,\nand secure.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg\" class=\"kg-image\" alt=\"Lock Down Your Network with Traefik Enterprise and Vault\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg 1600w, https://containous.ghost.io/content/images/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Every organization has secrets. Likewise, every application and service must manage sensitive information ‚Äì such as usernames and passwords, license keys, database credentials, and so on ‚Äì that should be kept away from prying eyes.</p><!--kg-card-begin: markdown--><p>Among the most important secrets that modern apps must maintain are the <a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\" target=\"_blank\" rel=\"nofollow\">TLS certificates</a> that make encrypted HTTPS communications possible. The good news for Traefik Enterprise users is that handling these secrets is now easier than ever, thanks to support for Vault in Traefik Enterprise 2.3.</p>\n<p><a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"nofollow\">Vault</a> is an <a href=\"https://github.com/hashicorp/vault\" target=\"_blank\" rel=\"nofollow\">open source</a> tool developed and maintained by HashiCorp that provides a secure and encrypted central data store for secrets. Traefik Enterprise 2.3 can use Vault for certificate management in two ways. First, it can use Vault as a key-value store for certificates. Second, it can enlist Vault as a certificate resolver, allowing it to dynamically generate certificates on the fly. Let‚Äôs examine both use cases.</p>\n<!--kg-card-end: markdown--><h2 id=\"using-vault-as-a-key-value-store-for-certificates\"><strong>Using Vault as a Key-Value Store for Certificates</strong></h2><p>Traefik has long been able to discover and connect with a variety of key-value stores, such as Consul, etcd, and ZooKeeper. The Vault provider for Traefik Enterprise 2.3 and later can connect to Vault in a similar way, using it as a key-value store for storing and retrieving TLS certificates.</p><!--kg-card-begin: markdown--><p>The first step is to setup the Vault secrets engine for use with Traefik Enterprise. As of now, Traefik Enterprise supports the <a href=\"https://www.vaultproject.io/docs/secrets/kv/kv-v2\" target=\"_blank\" rel=\"nofollow\">KV Secrets Engine ‚Äì Version 2</a>, which is currently the default and is easily enabled from the command line. It‚Äôs a good idea to use a dedicated KV store for TLS certificates, and bear in mind that all certificates must be base64-encoded and stored in the root of the KV secrets engine.</p>\n<!--kg-card-end: markdown--><p>From there, it‚Äôs a straightforward matter of enabling the Vault Provider in Traefik Enterprise‚Äôs static configuration. This takes just a few lines of code, and a typical example (in YAML) might look like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-yaml\">providers:\n  plugin:\n    vault:\n      url: &quot;http://127.0.0.1:8200&quot;\n      token: &quot;s.CUDDqqjiIFXF60KVSeJOxeb5&quot;\n      enginePath: &quot;secret&quot;\n      syncInterval: &quot;5s&quot;\n      rescanInterval: &quot;60s&quot;\n</code></pre>\n<!--kg-card-end: markdown--><p>This snippet points to the URL of the Vault server and supplies the token that‚Äôs needed to authenticate with it. (The Vault Provider only supports token authentication at this time.) It also specifies how often the provider will pull data from the Vault KV store.</p><p>That‚Äôs it! Once configured, Traefik Enterprise will detect certificates in the store to serve them. And, as usual for Traefik Enterprise, the configuration refreshes automatically whenever you insert or delete certificates from the Vault store.</p><p>If you‚Äôd like to learn more about how to setup and configure the Vault Provider for Traefik Enterprise, check out the <a href=\"https://doc.traefik.io/traefik-enterprise/providers/vault-kv/\">documentation</a>.</p><h2 id=\"using-vault-as-a-certificate-resolver-for-pki\"><strong>Using Vault as a Certificate Resolver for PKI</strong></h2><!--kg-card-begin: markdown--><p>Experienced Traefik users will be familiar with its support for automatic certificate generation using the ACME protocol and compatible service providers, such as <a href=\"https://doc.traefik.io/traefik-enterprise/tls/acme/\">Let‚Äôs Encrypt</a>. Traefik Enterprise 2.3 adds a new, additional means of automating certificate generation in the form of support for <a href=\"https://www.hashicorp.com/products/vault/pki-with-vault\" target=\"_blank\" rel=\"nofollow\">Vault Public Key Infrastructure (PKI)</a>.</p>\n<!--kg-card-end: markdown--><p>The Vault PKI secrets engine includes built-in authentication and authorization functions that make it possible to generate certificates on the fly, without getting bogged down in the traditional, manual process of generating keys and submitting to a certificate authority (CA).</p><p>This automation is especially valuable in dynamic, microservices-based environments, where services tend to be short-lived and container instances are rapidly created and destroyed, according to demand.</p><p>Setting up Vault as a <a href=\"https://doc.traefik.io/traefik/https/acme/#certificate-resolvers\">certificate resolver</a> is almost as easy as configuring the Vault Provider, as discussed earlier. Once Vault is installed with the PKI secrets engine enabled, configuring the feature requires adding just a few lines to Traefik Enterprise‚Äôs static configuration. For example:</p><!--kg-card-begin: markdown--><pre><code>certificatesResolvers:\n  resolverName:\n\tvault:\n  \turl: &quot;http://127.0.0.1:8200&quot;\n  \ttoken: &quot;s.CUDDqqjiIFXF60KVSeJOxeb5&quot; # Your Vault auth token goes here\n  \tenginePath: &quot;pki&quot;\n  \trole: &quot;vault-role&quot;\n</code></pre>\n<!--kg-card-end: markdown--><p>Once the certificate resolver is configured, assigning it to routes in Traefik Enterprise will trigger Vault to generate certificates for requests that match the appropriate patterns. To read more about how this works, consult the <a href=\"https://doc.traefik.io/traefik-enterprise/tls/vault-pki/\">documentation</a>. There‚Äôs also a handy <a href=\"https://doc.traefik.io/traefik-enterprise/operations/vault-pki-guide/\">user guide</a> available that walks through the process of deploying a simple TLS-enabled service with Vault on Kubernetes.</p><h2 id=\"get-secure-with-traefik-enterprise\"><strong>Get Secure with Traefik Enterprise</strong></h2><p>Traefik Labs is pleased to offer support for Vault in Traefik Enterprise as further proof of our commitment to provide best-of-breed features that security-conscious enterprises demand. Using Vault to manage secrets is a step forward in securing your network; using Vault with Traefik Enterprise makes taking that step even easier. If you‚Äôd like to learn more about these and other advanced features of Traefik Enterprise, the best way is to try them out for yourself. Sign up for a <a href=\"https://info.traefik.io/get-traefik-enterprise-free-for-30-days\">30-day free trial</a> and explore how Traefik Enterprise can help make your infrastructure more nimble, reliable, and secure.</p>","url":"https://containous.ghost.io/blog/lock-down-your-network-with-traefik-enterprise-and-vault/","canonical_url":null,"uuid":"5d85e5ae-9959-4084-b85e-794ac0801881","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5fb312644a99b50039ce6d0d","reading_time":3}},{"node":{"id":"Ghost__Post__5fb434904a99b50039ce6d86","title":"Traefik Hackaethon Is a Wrap","slug":"traefik-hackaethon-is-a-wrap","featured":true,"feature_image":"https://containous.ghost.io/content/images/2020/11/Traefik-Hackaethon-Is-a-Wrap.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/bf1fb8321e805e8c0f912464d2deed79/47498/Traefik-Hackaethon-Is-a-Wrap.jpg","srcSet":"/static/bf1fb8321e805e8c0f912464d2deed79/9dc27/Traefik-Hackaethon-Is-a-Wrap.jpg 300w,\n/static/bf1fb8321e805e8c0f912464d2deed79/4fe8c/Traefik-Hackaethon-Is-a-Wrap.jpg 600w,\n/static/bf1fb8321e805e8c0f912464d2deed79/47498/Traefik-Hackaethon-Is-a-Wrap.jpg 1200w,\n/static/bf1fb8321e805e8c0f912464d2deed79/52258/Traefik-Hackaethon-Is-a-Wrap.jpg 1800w,\n/static/bf1fb8321e805e8c0f912464d2deed79/a41d1/Traefik-Hackaethon-Is-a-Wrap.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik Labs inaugural Traefik Hackaethon is a wrap. The event took place over three days and included multiple contributors from around the world. ","custom_excerpt":"Traefik Labs inaugural Traefik Hackaethon is a wrap. The event took place over three days and included multiple contributors from around the world. ","visibility":"public","created_at_pretty":"17 November, 2020","published_at_pretty":"November 24, 2020","updated_at_pretty":"24 November, 2020","created_at":"2020-11-17T20:37:36.000+00:00","published_at":"2020-11-24T05:42:29.000+00:00","updated_at":"2020-11-24T15:56:04.000+00:00","meta_title":"Traefik Hackaethon is a Wrap","meta_description":"Traefik Labs inaugural Traefik Hackaethon is a wrap. The event took place over three days and included multiple contributors from around the world. ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/11/Traefik-Hackaethon-Is-a-Wrap---Twitter.png","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Community","slug":"community","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Traefik Labs inaugural Traefik Hackaethon\n[https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/] \nis a wrap. The event took place over three days on a Discord server that\nincluded contributors from around the world. Over 50 individuals joined the\nevent and contributed several new plugins for Traefik, multiple bug fixes for\nYaegi, and new features and capabilities for Traefik itself. This event was the\nfirst time Traefik Labs officially organized a hackathon. We couldn‚Äôt be more\npleased with the collaboration between first-time contributors and long-time\nmaintainers within our community.\n\nContributions Are Welcome Here\nThere are two distinct categories of contributions for this event: new plugins\nfor Traefik Pilot [https://pilot.traefik.io/] and pull requests for our open\nsource projects Traefik [https://github.com/traefik/traefik] and Yaegi\n[https://github.com/traefik/yaegi]. Over a dozen individual contributors created\nnew plugins, and we were pleasantly surprised by contributions to our open\nsource projects in the form of new features, bug reports, and other\nimprovements.\n\nIn this post, I‚Äôll cover the contributions that the team was most impressed with\nand which were awarded the grand prizes. In addition to the grand prizes,\nseveral others deserve mention for their collective efforts, and I‚Äôll cover\nthose too! I want to give a special thanks to the engineering team at Traefik\nfor engaging with the community and working with them to bring their ideas to\nlife.\n\nThe entire team is looking forward to the next time we do this, and I‚Äôll talk a\nlittle bit about that at the end of this post.\n\nThe Grand Prizes\nOne of the newest features of Traefik is support for adding customized\nfunctionality to the processing of requests handled by the Traefik Proxy. These\nare called Traefik Plugins, and nearly all ten bounties were claimed by our\ncontributors! Each of the grand prizes went to a team or individual who\ncontributed a plugin. The second prize has a bit of a caveat attached to it, but\nmore on that later.\n\nFirst Prize - Team Fail2Ban\nhttps://pilot.traefik.io/plugins/280093067746214409/fail2-ban\n\n [https://pilot.traefik.io/plugins/280093067746214409/fail2-ban]\n\nThe first prize went to a team that was formed by a few contributors who had\nearlier worked on another plugin named Header Transformation\n[https://pilot.traefik.io/plugins/279923829278507529/header-transformation] \n(more about that below). One of the contributors not only produced a great blog\npost [https://blog.moulard.org/traefik-hackaethon/] about their experience with\nthe event, but they came together to create a handy plugin that will block\nrequests originating from a source that fails to authenticate after a specific\nnumber of times. While the concept of Fail2ban\n[https://en.wikipedia.org/wiki/Fail2ban] isn‚Äôt necessarily new, nor is the\nimplementation of it within a reverse proxy, this is the first time it‚Äôs become\naccessible without the use of external dependencies, complex iptables\n[https://en.wikipedia.org/wiki/Iptables], or integrations with commercial\npackages. The implementation is complete and functionality impressive, given the\ntight deadlines and scope of the plugin. Thank you to Tom and the team for\nputting together two great plugins.\n\nSecond Prize - Team Brotli\nhttps://github.com/traefik/yaegi/pulls?q=is%3Apr+author%3Arsteube\n\n [https://github.com/traefik/yaegi/pulls?q=is%3Apr+author%3Arsteube]\n\nThis plugin (that is still in progress) gets the second place award after the\ncreator worked to implement a compression algorithm ported entirely over to Go,\nwhich coincidentally helped us bring even more compatibility to our runtime Go\ninterpreter Yaegi [https://github.com/traefik/yaegi]. When we kicked off this\nHackathon, we knew that the underlying engine that interprets code in real time,\nusually compiled, is still considered experimental. That didn‚Äôt stop this\ncontributor. He worked all three days with Marc, the Yaegi project lead, to\nidentify and fix numerous issues they found while incorporating the ported\ncompression algorithm. This work led to several PRs and improvements made by the\nauthor and the Yaegi team. While the plugin wasn‚Äôt eligible for the plugin\nbounty, we felt his contributions to the Yaegi project were so impactful that\nthis contributor deserved the second grand prize.\n\nThird Prize - Team Containers On-Demand\nhttps://pilot.traefik.io/plugins/280027003970650633/containers-on-demand\n\n\n\nImagine being able to scale up services from zero with Traefik when the load\nbalancer receives a request. Two developers on this team hatched this idea\ntogether after discussing the concept and built a service that integrates with\nDocker Swarm to interact with the Docker API. The judges felt this plugin\ndeserved the grand prize for two distinct reasons: First, developers‚Äô\npersistence in finding a solution that works given the design constraints; and\nsecond, their creativity in deciding what to build. The plugin engine was\ncreated for users to be creative and bend Traefik in ways the developers at\nTraefik Labs might never have considered. This team‚Äôs contribution fits nicely\ninto the vision the team had.\n\nPlugin Bounties\nEach of the above plugins was awarded a bounty (except for Brotli, since it‚Äôs\ntechnically still a WIP), but there are a few plugins that deserve mention.\n\nTraefik Fault Injection\nhttps://pilot.traefik.io/plugins/279918789803378185/fault-injection\n\nPurposely introducing faults and errors into an environment is a practice known\nas chaos engineering. This plugin allows for failures to be induced\nprogrammatically via the load balancer. It can be used to purposely inject\nfailures of a specific type and rate to any service. Teams that are looking to\nbuild for resilience and solutions engineers who are looking to induce failures\nwithout having to modify application source code may find this plugin useful.\n\nHeader Transformation\nhttps://pilot.traefik.io/plugins/279923829278507529/header-transformation\n\nAuthored by Team Fail2ban, this plugin allows for headers to be modified based\non simple regex-based rulesets: Set, Rename, Del, and Join. Using these rules,\noperators can modify headers sent from the client before they reach their\nservice destination.\n\nDatadog Event\nhttps://pilot.traefik.io/plugins/280005610925195785/datadog-event\n\nOperators who install this plugin may generate an event in Datadog when a\nresponse code or contents matches a regex-based rule.\n\nOpen Source Contributions\nWe saw several PRs opened against Yaegi and Traefik Proxy. These included bug\nfixes, documentation improvements, new features, and capabilities. Below are two\nof the larger pull requests proposed, and while they‚Äôre both incomplete, we want\nto thank the authors for their contribution and hard work.\n\nExponential Backoff for Retry Middleware\nhttps://github.com/traefik/traefik/pull/7460\n\nThe author of this PR initially tried to implement a DynamoDB cache plugin, but\nhe encountered a limitation with the AWS SDK and Yaegi. Instead of giving up, he\njumped right into an open issue and started working with the open source\nengineers at Traefik to develop a solution.\n\nFluentD Log Hook\nhttps://github.com/bearstech/traefik/pull/1\n\nThis work is incomplete, but it seems to be ninety-percent there. This feature,\nwhen merged, would allow operators of Traefik to directly connect access logs to\na log exporter, rather than having to use a log scraping implementation. We‚Äôre\nlooking forward to seeing this feature finished up and opened as a PR.\n\nAnd ... It's A Wrap\n\n\nWe couldn‚Äôt be more excited to see the contributions and collaboration at our\nfirst Traefik Hackaethon. We‚Äôll be doing this again next year and have already\nstarted planning for the spring. In the meantime, our team would love to hear\nfrom you on ideas for themes and bounties. We‚Äôve opened a thread\n[https://community.traefik.io/t/traefik-hackaethon-2-0/8632] on our community\nforums to discuss what you‚Äôd like to see the next time.\n\nThank you to all the participants, and your contributions to the Traefik\necosystem are sincerely appreciated. We can‚Äôt wait to see what you‚Äôre going to\nbuild next.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg\" class=\"kg-image\" alt=\"Traefik Hackaethon Is a Wrap\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg 1600w, https://containous.ghost.io/content/images/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Traefik Labs inaugural <a href=\"https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/\">Traefik Hackaethon</a> is a wrap. The event took place over three days on a Discord server that included contributors from around the world. Over 50 individuals joined the event and contributed several new plugins for Traefik, multiple bug fixes for Yaegi, and new features and capabilities for Traefik itself. This event was the first time Traefik Labs officially organized a hackathon. We couldn‚Äôt be more pleased with the collaboration between first-time contributors and long-time maintainers within our community.</p><!--kg-card-begin: markdown--><h2 id=\"contributionsarewelcomehere\">Contributions Are Welcome Here</h2>\n<!--kg-card-end: markdown--><p>There are two distinct categories of contributions for this event: new plugins for <a href=\"https://pilot.traefik.io/\">Traefik Pilot</a> and pull requests for our open source projects <a href=\"https://github.com/traefik/traefik\">Traefik</a> and <a href=\"https://github.com/traefik/yaegi\">Yaegi</a>. Over a dozen individual contributors created new plugins, and we were pleasantly surprised by contributions to our open source projects in the form of new features, bug reports, and other improvements.</p><p>In this post, I‚Äôll cover the contributions that the team was most impressed with and which were awarded the grand prizes. In addition to the grand prizes, several others deserve mention for their collective efforts, and I‚Äôll cover those too! I want to give a special thanks to the engineering team at Traefik for engaging with the community and working with them to bring their ideas to life.</p><p>The entire team is looking forward to the next time we do this, and I‚Äôll talk a little bit about that at the end of this post.</p><!--kg-card-begin: markdown--><h2 id=\"thegrandprizes\">The Grand Prizes</h2>\n<p>One of the newest features of Traefik is support for adding customized functionality to the processing of requests handled by the Traefik Proxy. These are called Traefik Plugins, and nearly all ten bounties were claimed by our contributors! Each of the grand prizes went to a team or individual who contributed a plugin. The second prize has a bit of a caveat attached to it, but more on that later.</p>\n<h3 id=\"firstprizeteamfail2ban\">First Prize - Team Fail2Ban</h3>\n<p><a href=\"https://pilot.traefik.io/plugins/280093067746214409/fail2-ban\">https://pilot.traefik.io/plugins/280093067746214409/fail2-ban</a></p>\n<p><a href=\"https://pilot.traefik.io/plugins/280093067746214409/fail2-ban\"><img style=\"float: right; margin: 10px; width: 260px;\" src=\"https://containous.ghost.io/content/images/2020/11/fail2ban-snap.png\" alt=\"Fail2Ban Plugin\"></a></p>\n<p>The first prize went to a team that was formed by a few contributors who had earlier worked on another plugin named <a href=\"https://pilot.traefik.io/plugins/279923829278507529/header-transformation\">Header Transformation</a> (more about that below). One of the contributors not only produced a <a href=\"https://blog.moulard.org/traefik-hackaethon/\">great blog post</a> about their experience with the event, but they came together to create a handy plugin that will block requests originating from a source that fails to authenticate after a specific number of times. While the concept of <a href=\"https://en.wikipedia.org/wiki/Fail2ban\" rel=\"nofollow\">Fail2ban</a> isn‚Äôt necessarily new, nor is the implementation of it within a reverse proxy, this is the first time it‚Äôs become accessible without the use of external dependencies, complex <a href=\"https://en.wikipedia.org/wiki/Iptables\" rel=\"nofollow\">iptables</a>, or integrations with commercial packages. The implementation is complete and functionality impressive, given the tight deadlines and scope of the plugin. Thank you to Tom and the team for putting together two great plugins.</p>\n<h3 id=\"secondprizeteambrotli\">Second Prize - Team Brotli</h3>\n<p><a href=\"https://github.com/traefik/yaegi/pulls?q=is%3Apr+author%3Arsteube\">https://github.com/traefik/yaegi/pulls?q=is%3Apr+author%3Arsteube</a></p>\n<p><a href=\"https://github.com/traefik/yaegi/pulls?q=is%3Apr+author%3Arsteube\"><img style=\"float: right; margin: 10px; width: 260px\" src=\"https://containous.ghost.io/content/images/2020/11/brotli-snap.png\" alt=\"Team Brotli Contributions\"></a></p>\n<p>This plugin (that is still in progress) gets the second place award after the creator worked to implement a compression algorithm ported entirely over to Go, which coincidentally helped us bring even more compatibility to our <a href=\"https://github.com/traefik/yaegi\">runtime Go interpreter Yaegi</a>. When we kicked off this Hackathon, we knew that the underlying engine that interprets code in real time, usually compiled, is still considered experimental. That didn‚Äôt stop this contributor. He worked all three days with Marc, the Yaegi project lead, to identify and fix numerous issues they found while incorporating the ported compression algorithm. This work led to several PRs and improvements made by the author and the Yaegi team. While the plugin wasn‚Äôt eligible for the plugin bounty, we felt his contributions to the Yaegi project were so impactful that this contributor deserved the second grand prize.</p>\n<h3 id=\"thirdprizeteamcontainersondemand\">Third Prize - Team Containers On-Demand</h3>\n<p><a href=\"https://pilot.traefik.io/plugins/280027003970650633/containers-on-demand\">https://pilot.traefik.io/plugins/280027003970650633/containers-on-demand</a></p>\n<p><a https://containous.ghost.io/blog/traefik-hackaethon-is-a-wrap/href=\"\"><img style=\"float: right; margin: 10px; width: 260px;\" src=\"https://containous.ghost.io/content/images/2020/11/cod-snap.png\" alt=\"Containers On-Demand Plugin\"></a></p>\n<p>Imagine being able to scale up services from zero with Traefik when the load balancer receives a request. Two developers on this team hatched this idea together after discussing the concept and built a service that integrates with Docker Swarm to interact with the Docker API. The judges felt this plugin deserved the grand prize for two distinct reasons: First, developers‚Äô persistence in finding a solution that works given the design constraints; and second, their creativity in deciding what to build. The plugin engine was created for users to be creative and bend Traefik in ways the developers at Traefik Labs might never have considered. This team‚Äôs contribution fits nicely into the vision the team had.</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id=\"pluginbounties\">Plugin Bounties</h2>\n<p>Each of the above plugins was awarded a bounty (except for Brotli, since it‚Äôs technically still a WIP), but there are a few plugins that deserve mention.</p>\n<h3 id=\"traefikfaultinjection\">Traefik Fault Injection</h3>\n<p><a href=\"https://pilot.traefik.io/plugins/279918789803378185/fault-injection\">https://pilot.traefik.io/plugins/279918789803378185/fault-injection</a></p>\n<p>Purposely introducing faults and errors into an environment is a practice known as chaos engineering. This plugin allows for failures to be induced programmatically via the load balancer. It can be used to purposely inject failures of a specific type and rate to any service. Teams that are looking to build for resilience and solutions engineers who are looking to induce failures without having to modify application source code may find this plugin useful.</p>\n<h3 id=\"headertransformation\">Header Transformation</h3>\n<p><a href=\"https://pilot.traefik.io/plugins/279923829278507529/header-transformation\">https://pilot.traefik.io/plugins/279923829278507529/header-transformation</a></p>\n<p>Authored by Team Fail2ban, this plugin allows for headers to be modified based on simple regex-based rulesets: <code>Set</code>, <code>Rename</code>, <code>Del</code>, and <code>Join</code>. Using these rules, operators can modify headers sent from the client before they reach their service destination.</p>\n<h3 id=\"datadogevent\">Datadog Event</h3>\n<p><a href=\"https://pilot.traefik.io/plugins/280005610925195785/datadog-event\">https://pilot.traefik.io/plugins/280005610925195785/datadog-event</a></p>\n<p>Operators who install this plugin may generate an event in Datadog when a response code or contents matches a regex-based rule.</p>\n<h2 id=\"opensourcecontributions\">Open Source Contributions</h2>\n<p>We saw several PRs opened against Yaegi and Traefik Proxy. These included bug fixes, documentation improvements, new features, and capabilities. Below are two of the larger pull requests proposed, and while they‚Äôre both incomplete, we want to thank the authors for their contribution and hard work.</p>\n<h3 id=\"exponentialbackoffforretrymiddleware\">Exponential Backoff for Retry Middleware</h3>\n<p><a href=\"https://github.com/traefik/traefik/pull/7460\">https://github.com/traefik/traefik/pull/7460</a></p>\n<p>The author of this PR initially tried to implement a DynamoDB cache plugin, but he encountered a limitation with the AWS SDK and Yaegi. Instead of giving up, he jumped right into an open issue and started working with the open source engineers at Traefik to develop a solution.</p>\n<h3 id=\"fluentdloghook\">FluentD Log Hook</h3>\n<p><a href=\"https://github.com/bearstech/traefik/pull/1\">https://github.com/bearstech/traefik/pull/1</a></p>\n<p>This work is incomplete, but it seems to be ninety-percent there. This feature, when merged, would allow operators of Traefik to directly connect access logs to a log exporter, rather than having to use a log scraping implementation. We‚Äôre looking forward to seeing this feature finished up and opened as a PR.</p>\n<h2 id=\"anditsawrap\">And ... It's A Wrap</h2>\n<p><img src=\"https://containous.ghost.io/content/images/2020/11/Haekaton-scene.png\" alt=\"Haekaton-scene\"></p>\n<p>We couldn‚Äôt be more excited to see the contributions and collaboration at our first Traefik Hackaethon. We‚Äôll be doing this again next year and have already started planning for the spring. In the meantime, our team would love to hear from you on ideas for themes and bounties. We‚Äôve <a href=\"https://community.traefik.io/t/traefik-hackaethon-2-0/8632\">opened a thread</a> on our community forums to discuss what you‚Äôd like to see the next time.</p>\n<p>Thank you to all the participants, and your contributions to the Traefik ecosystem are sincerely appreciated. We can‚Äôt wait to see what you‚Äôre going to build next.</p>\n<!--kg-card-end: markdown--><p></p>","url":"https://containous.ghost.io/blog/traefik-hackaethon-is-a-wrap/","canonical_url":null,"uuid":"cd60da37-1574-4e2d-8dc8-5f6b1a207c8b","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5fb434904a99b50039ce6d86","reading_time":5}},{"node":{"id":"Ghost__Post__5fc64b2616db8f0039b432b7","title":"Observing Kubernetes Ingress Traffic using Metrics","slug":"observing-kubernetes-ingress-traffic-using-metrics","featured":true,"feature_image":"https://containous.ghost.io/content/images/2020/12/Blog@2x-2.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/e1059f243239fbb89e6142ce8204cd42/f3583/Blog%402x-2.png","srcSet":"/static/e1059f243239fbb89e6142ce8204cd42/630fb/Blog%402x-2.png 300w,\n/static/e1059f243239fbb89e6142ce8204cd42/2a4de/Blog%402x-2.png 600w,\n/static/e1059f243239fbb89e6142ce8204cd42/f3583/Blog%402x-2.png 1200w,\n/static/e1059f243239fbb89e6142ce8204cd42/bbee5/Blog%402x-2.png 1800w,\n/static/e1059f243239fbb89e6142ce8204cd42/0ef64/Blog%402x-2.png 2400w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Monitoring Kubernetes ingress traffic is a critical part of an effective strategy for detecting and managing potential issues in real-time.","custom_excerpt":"Monitoring Kubernetes ingress traffic is a critical part of an effective strategy for detecting and managing potential issues in real-time.","visibility":"public","created_at_pretty":"01 December, 2020","published_at_pretty":"December 3, 2020","updated_at_pretty":"08 December, 2020","created_at":"2020-12-01T13:54:46.000+00:00","published_at":"2020-12-03T02:13:39.000+00:00","updated_at":"2020-12-08T03:16:46.000+00:00","meta_title":"Observing Kubernetes Ingress Traffic using Metrics","meta_description":"Monitoring Kubernetes ingress traffic is a critical part of an effective strategy for detecting and managing potential issues in real-time.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/12/Twitter@2x-1.png","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Enterprise engineering teams are continuously striving to deliver the best user\nfacing experience possible for the applications they manage. Adopting Kubernetes\n(k8s) is helping in this regard by allowing organizations to easily manage\nlifecycle operations for workloads in a repeatable manner. Because of this,\nKubernetes has been a key enabler towards accelerating implementation of\npurpose-specific services to meet business requirements. While k8s provides a\nstrong foundation for stable operations, proactive measures must still be taken\nto avoid negative impacts including performance or functional issues. Monitoring\nKubernetes ingress traffic is a critical part of an effective strategy for\ndetecting and managing potential issues in real-time. In this article, we‚Äôll\ndiscuss this topic including:\n\n * Where to integrate in a Kubernetes system to obtain metrics\n * How monitoring data can be stored effectively\n * What visualization tools can be used to understand metrics data\n\nObtaining ingress traffic metrics\nWhere and how ingress traffic network statistics can be collected depends upon\nthe adopted approach\n[https://traefik.io/blog/combining-ingress-controllers-and-external-load-balancers-with-kubernetes/] \nfor exposing services. Let‚Äôs dive into the two strategies often used with\nKubernetes:\n\n 1. External Load Balancers\n 2. Ingress Controllers\n\nMetrics with External Load Balancers\nWhen service configurations are defined appropriately by operators, Kubernetes\ncan automate the deployment of managed load balancers. For example, when\nlaunched within AWS, a Kubernetes Service can instantiate a cloud load balancer\ninstance without any out-of-band provisioning steps required by developers. The\nimplementations of these load balancers are black boxes, but they all expose\nmechanisms for monitoring and tracing. In the case of AWS, time-series data and\nrequest logs can be collected and accessed using accompanying integrated\nservices such as CloudWatch and CloudTrail. One potential drawback of these\ntightly integrated proprietary services is that these systems often do not\nintegrate easily with external data storage and visualization tools.\n\nCapturing Metrics from Load Balancers and Ingress ControllersMetrics with\nIngress Controllers\nWhen thinking about monitoring Ingress Controllers, it‚Äôs useful to keep in mind\nthat they are implemented as standard Kubernetes applications. This means that\nany monitoring approaches adopted by organizations to track the health and\nliveliness of k8s workloads can be applied to Ingress Controllers. Tracking\nnetwork traffic statistics in particular, however, requires taking advantage of\ncontroller-specific mechanisms. Similar to external load balancers, the specific\nmetrics exposed vary depending on the controller, but any production quality\nimplementation will provide built-in metric collection capabilities that can be\nintegrated with an external data storage system.\n\nData storage for Ingress Monitoring\nSelecting a data storage solution is an important part of defining a traffic\nmonitoring architecture for Ingress Controllers. There are two general\ncategories of implementations that one can choose between: \n\n 1. Self-managed (typically open source) database systems\n 2. Managed SaaS database systems.\n\nWhile applications often use general-purpose SQL databases for their structured\ndata, with monitoring data it‚Äôs advantageous to utilize a system optimized for\nstoring and querying time-series data. There are multiple open source options\nfor time-series databases, including InfluxDB [https://www.influxdata.com/] and \nPrometheus [https://prometheus.io/], either is typically deployed in the same\nk8s cluster as the Ingress controller. Once these systems are provisioned, it‚Äôs\njust a matter of configuring settings for the Ingress controller to enable\nautomated metric data collection in the database.\n\nSome teams may prefer to take the route of a fully managed data provider to\navoid the overheads of maintaining a database. There are options such as DataDog\n[https://datadoghq.com] or Elasticsearch [https://www.elastic.co/elastic-stack] \navailable that meet this demand in the form of a cloud-based SaaS monitoring\nplatform. The providers are well supported by controller implementations due to\ntheir popularity, and Ingress controllers such as Traefik are designed to easily\nintegrate with it.\n\nVisualizing Ingress Traffic Metrics\nGetting metrics into a database is a first step towards effective ingress\nmonitoring, but providing engineering teams with actionable information in\nreal-time requires being able to easily interpret the information. Visualizing\ntime-series data is the most effective way to convert raw metrics into\nhuman-digestible form. For example, visualizations are often combined into\ndashboards and used by Site Reliability Engineers to track the status of\nservices and as an information source when live-site issues occur. Grafana\n[https://grafana.com/] is a widely adopted open source software for data\nvisualization which works well with databases such as InfluxDB and Prometheus.\nAlternatively, the managed solutions mentioned earlier, such as DataDog, provide\nbuilt-in visualization capabilities as part of their holistic platforms.\n\n\n\n\n\nSummary\nMonitoring ingress traffic is an important part of managing the health of\nexternal-facing services. As outlined in this article, best-of-breed metric\nstorage and visualization technologies can be adopted for Kubernetes monitoring\nby virtue of capabilities provided by Ingress Controller implementations such as\nTraefik. This means organizations can easily rollout effective monitoring for\nk8s clusters providing peace of mind for engineering teams and end-users.\n\nFurthermore, Traefik metrics and reporting are available through Traefik\nEnterprise and Traefik Pilot. You can sign up for a demo\n[https://info.traefik.io/en/request-demo-traefik-enterprise] of Traefik\nEnterprise today, and Traefik Pilot [https://traefik.io/traefik-pilot/] is\nalready available for users of the popular open source Traefik Proxy project.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/12/Blog@2x.png\" class=\"kg-image\" alt=\"Observing Kubernetes Ingress Traffic using Metrics\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/12/Blog@2x.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Blog@2x.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Blog@2x.png 1600w, https://containous.ghost.io/content/images/2020/12/Blog@2x.png 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Enterprise engineering teams are continuously striving to deliver the best user facing experience possible for the applications they manage. Adopting Kubernetes (k8s) is helping in this regard by allowing organizations to easily manage lifecycle operations for workloads in a repeatable manner. Because of this, Kubernetes has been a key enabler towards accelerating implementation of purpose-specific services to meet business requirements. While k8s provides a strong foundation for stable operations, proactive measures must still be taken to avoid negative impacts including performance or functional issues. Monitoring Kubernetes ingress traffic is a critical part of an effective strategy for detecting and managing potential issues in real-time. In this article, we‚Äôll discuss this topic including:</p><ul><li>Where to integrate in a Kubernetes system to obtain metrics</li><li>How monitoring data can be stored effectively</li><li>What visualization tools can be used to understand metrics data</li></ul><h3 id=\"obtaining-ingress-traffic-metrics\">Obtaining ingress traffic metrics</h3><p>Where and how ingress traffic network statistics can be collected depends upon the <a href=\"https://traefik.io/blog/combining-ingress-controllers-and-external-load-balancers-with-kubernetes/\">adopted approach</a> for exposing services. Let‚Äôs dive into the two strategies often used with Kubernetes:</p><ol><li>External Load Balancers</li><li>Ingress Controllers</li></ol><!--kg-card-begin: markdown--><h3 id=\"metricswithexternalloadbalancers\">Metrics with External Load Balancers</h3>\n<p>When service configurations are defined appropriately by operators, Kubernetes can automate the deployment of managed load balancers. For example, when launched within AWS, a Kubernetes Service can instantiate a cloud load balancer instance without any out-of-band provisioning steps required by developers. The implementations of these load balancers are black boxes, but they all expose mechanisms for monitoring and tracing. In the case of AWS, time-series data and request logs can be collected and accessed using accompanying integrated services such as CloudWatch and CloudTrail. One potential drawback of these tightly integrated proprietary services is that these systems often do not integrate easily with external data storage and visualization tools.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png\" class=\"kg-image\" alt=\"Capturing Metrics from Load Balancers and Ingress Controllers\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png 1600w, https://containous.ghost.io/content/images/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png 2310w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Capturing Metrics from Load Balancers and Ingress Controllers</figcaption></figure><!--kg-card-begin: markdown--><h3 id=\"metricswithingresscontrollers\">Metrics with Ingress Controllers</h3>\n<p>When thinking about monitoring Ingress Controllers, it‚Äôs useful to keep in mind that they are implemented as standard Kubernetes applications. This means that any monitoring approaches adopted by organizations to track the health and liveliness of k8s workloads can be applied to Ingress Controllers. Tracking network traffic statistics in particular, however, requires taking advantage of controller-specific mechanisms. Similar to external load balancers, the specific metrics exposed vary depending on the controller, but any production quality implementation will provide built-in metric collection capabilities that can be integrated with an external data storage system.</p>\n<!--kg-card-end: markdown--><h3 id=\"data-storage-for-ingress-monitoring\">Data storage for Ingress Monitoring</h3><p>Selecting a data storage solution is an important part of defining a traffic monitoring architecture for Ingress Controllers. There are two general categories of implementations that one can choose between: </p><ol><li>Self-managed (typically open source) database systems</li><li>Managed SaaS database systems.</li></ol><!--kg-card-begin: markdown--><p>While applications often use general-purpose SQL databases for their structured data, with monitoring data it‚Äôs advantageous to utilize a system optimized for storing and querying time-series data. There are multiple open source options for time-series databases, including <a href=\"https://www.influxdata.com/\" rel=\"nofollow\">InfluxDB</a> and <a href=\"https://prometheus.io/\" rel=\"nofollow\">Prometheus</a>, either is typically deployed in the same k8s cluster as the Ingress controller. Once these systems are provisioned, it‚Äôs just a matter of configuring settings for the Ingress controller to enable automated metric data collection in the database.</p>\n<p>Some teams may prefer to take the route of a fully managed data provider to avoid the overheads of maintaining a database. There are options such as <a href=\"https://datadoghq.com\" rel=\"nofollow\">DataDog</a> or <a href=\"https://www.elastic.co/elastic-stack\" rel=\"nofollow\">Elasticsearch</a> available that meet this demand in the form of a cloud-based SaaS monitoring platform. The providers are well supported by controller implementations due to their popularity, and Ingress controllers such as Traefik are designed to easily integrate with it.</p>\n<h2 id=\"visualizingingresstrafficmetrics\">Visualizing Ingress Traffic Metrics</h2>\n<p>Getting metrics into a database is a first step towards effective ingress monitoring, but providing engineering teams with actionable information in real-time requires being able to easily interpret the information. Visualizing time-series data is the most effective way to convert raw metrics into human-digestible form. For example, visualizations are often combined into dashboards and used by Site Reliability Engineers to track the status of services and as an information source when live-site issues occur. <a href=\"https://grafana.com/\" rel=\"nofollow\">Grafana</a> is a widely adopted open source software for data visualization which works well with databases such as InfluxDB and Prometheus. Alternatively, the managed solutions mentioned earlier, such as DataDog, provide built-in visualization capabilities as part of their holistic platforms.</p>\n<p><img src=\"https://containous.ghost.io/content/images/2020/12/2020-12-01_8-53-38.png\" alt=\"Traefik Metrics\"></p>\n<p><img src=\"https://containous.ghost.io/content/images/2020/12/2020-12-01_8-16-14.png\" alt=\"Load Balancer Metrics\"></p>\n<h2 id=\"summary\">Summary</h2>\n<p>Monitoring ingress traffic is an important part of managing the health of external-facing services. As outlined in this article, best-of-breed metric storage and visualization technologies can be adopted for Kubernetes monitoring by virtue of capabilities provided by Ingress Controller implementations such as Traefik. This means organizations can easily rollout effective monitoring for k8s clusters providing peace of mind for engineering teams and end-users.</p>\n<p>Furthermore, Traefik metrics and reporting are available through Traefik Enterprise and Traefik Pilot. You can <a href=\"https://info.traefik.io/en/request-demo-traefik-enterprise\">sign up for a demo</a> of Traefik Enterprise today, and <a href=\"https://traefik.io/traefik-pilot/\">Traefik Pilot</a> is already available for users of the popular open source Traefik Proxy project.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/observing-kubernetes-ingress-traffic-using-metrics/","canonical_url":null,"uuid":"90c78d85-ea40-4c48-b992-5eb268482ba7","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5fc64b2616db8f0039b432b7","reading_time":4}},{"node":{"id":"Ghost__Post__5fce60e016db8f0039b4334b","title":"From Zero to Hero: Getting Started with k0s and Traefik","slug":"from-zero-to-hero-getting-started-with-k0s-and-traefik","featured":true,"feature_image":"https://containous.ghost.io/content/images/2020/12/Getting-Started-with-k0s-and-Traefik-2.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/e5e000f515b518b83b527146af938a46/f3583/Getting-Started-with-k0s-and-Traefik-2.png","srcSet":"/static/e5e000f515b518b83b527146af938a46/630fb/Getting-Started-with-k0s-and-Traefik-2.png 300w,\n/static/e5e000f515b518b83b527146af938a46/2a4de/Getting-Started-with-k0s-and-Traefik-2.png 600w,\n/static/e5e000f515b518b83b527146af938a46/f3583/Getting-Started-with-k0s-and-Traefik-2.png 1200w,\n/static/e5e000f515b518b83b527146af938a46/bbee5/Getting-Started-with-k0s-and-Traefik-2.png 1800w,\n/static/e5e000f515b518b83b527146af938a46/0ef64/Getting-Started-with-k0s-and-Traefik-2.png 2400w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"K0s is a new Kubernetes distribution from Mirantis. It's similar to Rancher Labs' K3s, yet it ships only the bare minimum of extensions. K0s is a new Kubernetes distribution from Mirantis. This post covers how to configure k0s to include Traefik and begin routing your applications with CRDs.","custom_excerpt":"K0s is a new Kubernetes distribution from Mirantis. It's similar to Rancher Labs' K3s, yet it ships only the bare minimum of extensions. K0s is a new Kubernetes distribution from Mirantis. This post covers how to configure k0s to include Traefik and begin routing your applications with CRDs.","visibility":"public","created_at_pretty":"07 December, 2020","published_at_pretty":"December 8, 2020","updated_at_pretty":"09 December, 2020","created_at":"2020-12-07T17:05:36.000+00:00","published_at":"2020-12-08T16:10:36.000+00:00","updated_at":"2020-12-09T14:14:33.000+00:00","meta_title":"From Zero to Hero: Getting Started with k0s and Traefik","meta_description":"K0s is a new Kubernetes distribution from Mirantis. This post covers how to configure k0s to include Traefik and begin routing your applications with CRDs.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/12/Getting-Started-with-k0s-and-Traefik---Twitter.png","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#homepage-featured-post-1","slug":"hash-homepage-featured-post-1","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"K0s [https://k0sproject.io/] is a new Kubernetes distribution from Mirantis.\nIt's similar to Rancher Labs' K3s, yet it ships with only the bare minimum of\nextensions. This allows flexibility for users who want to customize it to their\nneeds by defining their own ingress, storage, and other controllers in the CRD\nmanifest, configuring the cluster during bootstrap.\n\nIn the examples below, I‚Äôll guide you through how to accomplish getting a\nfunctioning Kubernetes cluster by:\n\n 1. Installing k0s on a clean Linux VM\n 2. Configuring Traefik and MetalLB as an extension\n 3. Starting k0s\n 4. Deploying the Traefik Dashboard IngressRoute and an example service\n\nStep 1\nBefore we start, you should plan to do this on a clean install of Linux,\nprobably in a VM. You will be running k0s as a server/worker, and the worker\ninstalls components into the /var/lib filesystem as root (so root access is a\nrequirement). My understanding is there are plans to allow non-root workers in\nthe future. Hopefully, in addition to non-root, the k0s binary will allow worker\ninstallations in a configurable location.\n\n> Note: Cleanly shutting down and wiping the cluster is not a feature yet in the\nk0s binary. For now, rebooting the system and wiping /var/lib/k0s is the easiest\noption.\nOnce you have a clean Linux VM (I‚Äôm using Ubuntu 20.04.1), you‚Äôll want to\ninstall the Helm and kubectl binaries.\n\ncurl -O https://get.helm.sh/helm-v3.4.1-linux-amd64.tar.gz\ntar xvzf helm-v3.4.1-linux-amd64.tar.gz\nsudo mv linux-amd64/helm /usr/local/bin\n\ncurl -LO \"https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl\"\nchmod +x kubectl\nsudo mv kubectl /usr/local/bin\n\nOnce those are installed, install the k0s binary, create the working directory\nfor k0s, and create a default config.\n\n> Note: The installer and running k0s itself both require root\n# make sure you're running as root\ncurl -sSLf get.k0s.sh | sh\n# create the working directory and set the permissions\nmkdir -p /var/lib/k0s && chmod 755 /var/lib/k0s\n# create the default config\nk0s default-config > /var/lib/k0s/k0s.yaml\n\nStep 2\nIn this step, you‚Äôll configure Traefik and MetalLB\n[https://metallb.universe.tf/] as extensions that will be installed during the\ncluster's bootstrap. Traefik will function as an ingress controller and MetalLB\nwill allow you to access services from a logical IP address deployed as a \nservice load balancer\n[https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer].\nYou will want to have a small range of IP addresses that are addressable on your\nnetwork, preferably outside the range of your DHCP server.\n\nModify the newly created k0s.yaml file in /var/lib/k0s/k0s.yaml:\n\napiVersion: k0s.k0sproject.io/v1beta1\nkind: Cluster\nmetadata:\n  name: k0s\n...\nextensions:\n  helm:\n    repositories:\n    - name: traefik\n      url: https://helm.traefik.io/traefik\n    - name: bitnami\n      url: https://charts.bitnami.com/bitnami\n    charts:\n    - name: traefik\n      chartname: traefik/traefik\n      version: \"9.11.0\"\n      namespace: default\n    - name: metallb\n      chartname: bitnami/metallb\n      version: \"1.0.1\"\n      namespace: default\n      values: |2\n        configInline:\n          address-pools:\n          - name: generic-cluster-pool\n            protocol: layer2\n            addresses:\n            - 172.16.100.215-172.16.100.220\n\nAgain, be sure to provide a range of IPs for MetalLB that are addressable on\nyour network if you want to access the LoadBalancer and Ingress services from\noutside this machine.\n\nStep 3\nNow it's time to run k0s and let it automatically set up the server and worker,\nand deploy and configure Traefik and MetalLB:\n\ncd /var/lib/k0s\nk0s server --enable-worker </dev/null &>/dev/null &\n\nAfter a minute or two, you should be able to access the cluster using the\ncertificate generated by k0s, located in /var/lib/k0s/pki/admin.conf, and see\nthat MetalLB was deployed along with the Traefik Ingress Controller.\n\nroot@k0s-host ‚ûú export KUBECONFIG=/var/lib/k0s/pki/admin.conf\nroot@k0s-host ‚ûú kubectl get all\nNAME                                                 READY   STATUS    RESTARTS   AGE\npod/metallb-1607085578-controller-864c9757f6-bpx6r   1/1     Running   0          81s\npod/metallb-1607085578-speaker-245c2                 1/1     Running   0          60s\npod/traefik-1607085579-77bbc57699-b2f2t              1/1     Running   0          81s\n\nNAME                         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE\nservice/kubernetes           ClusterIP      10.96.0.1        <none>           443/TCP                      96s\nservice/traefik-1607085579   LoadBalancer   10.105.119.102   172.16.100.215   80:32153/TCP,443:30791/TCP   84s\n\nNAME                                        DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE\ndaemonset.apps/metallb-1607085578-speaker   1         1         1       1            1           kubernetes.io/os=linux   87s\n\nNAME                                            READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/metallb-1607085578-controller   1/1     1            1           87s\ndeployment.apps/traefik-1607085579              1/1     1            1           84s\n\nNAME                                                       DESIRED   CURRENT   READY   AGE\nreplicaset.apps/metallb-1607085578-controller-864c9757f6   1         1         1       81s\nreplicaset.apps/traefik-1607085579-77bbc57699              1         1         1       81s\n\nTake note of the IP address assigned to the Traefik Load Balancer here:\n\nNAME                         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE\nservice/traefik-1607085579   LoadBalancer   10.105.119.102   172.16.100.215   80:32153/TCP,443:30791/TCP   84s\n\nYou will need the EXTERNAL-IP (in this case, 172.16.100.215) later, when\naccessing Ingress resources on your cluster.\n\nStep 4\n * Deploy the Traefik dashboard\n * Deploy the sample ‚Äúwhoami‚Äù service\n\nNow that you have a functional and addressable load balancer on your cluster,\nyou can easily deploy the Traefik dashboard and access it from anywhere on your\nlocal network (provided that you configured MetalLB with an addressable range).\n\nCreate the Traefik Dashboard IngressRoute\n[https://doc.traefik.io/traefik/providers/kubernetes-crd/] in a YAML file:\n\napiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: dashboard\nspec:\n  entryPoints:\n    - web\n  routes:\n    - match: PathPrefix(`/dashboard`) || PathPrefix(`/api`)\n      kind: Rule\n      services:\n        - name: api@internal\n          kind: TraefikService\n\nAnd deploy it:\n\nroot@k0s-host ‚ûú kubectl apply -f traefik-dashboard.yaml\ningressroute.traefik.containo.us/dashboard created\n\nYou can now access it from your browser by visiting \nhttp://172.16.100.215/dashboard/:\n\nGreat, now let‚Äôs deploy a simple ‚Äúwhoami‚Äù service.\n\nCreate the whoami Deployment, Service, and Kubernetes Ingress\n[https://kubernetes.io/docs/concepts/services-networking/ingress/] manifest:\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: whoami-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: whoami\n  template:\n    metadata:\n      labels:\n        app: whoami\n    spec:\n      containers:\n      - name: whoami-container\n        image: containous/whoami\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: whoami-service\nspec:\n  ports:\n  - name: http\n    targetPort: 80\n    port: 80\n  selector:\n    app: whoami\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: whoami-ingress\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /whoami\n        pathType: Exact\n        backend:\n          service:\n            name: whoami-service\n            port:\n              number: 80\n\nAnd now, deploy and test it‚Ä¶\n\nroot@k0s-host ‚ûú kubectl apply -f whoami.yaml\ndeployment.apps/whoami-deployment created\nservice/whoami-service created\ningress.networking.k8s.io/whoami-ingress created\n# test the route\nroot@k0s-host ‚ûú curl http://172.16.100.215/whoami\nHostname: whoami-deployment-85bfbd48f-7l77c\nIP: 127.0.0.1\nIP: ::1\nIP: 10.244.214.198\nIP: fe80::b049:f8ff:fe77:3e64\nRemoteAddr: 10.244.214.196:34858\nGET /whoami HTTP/1.1\nHost: 172.16.100.215\nUser-Agent: curl/7.68.0\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 172.16.100.77\nX-Forwarded-Host: 172.16.100.215\nX-Forwarded-Port: 80\nX-Forwarded-Proto: http\nX-Forwarded-Server: traefik-1607085579-77bbc57699-b2f2t\nX-Real-Ip: 172.16.100.77\n\nSummary\nThis post covered installing k0s, setting up a fully functional Load Balancer\nand Ingress controller for use in your local environment. From here, you could\nuse a tool such as ngrok [https://ngrok.io] to expose your Load Balancer to the\nworld and set up Let‚Äôs Encrypt\n[https://doc.traefik.io/traefik/v2.0/user-guides/crd-acme/] so you can provision\nyour own SSL certificates.\n\nThe design of k0s as a single binary installer that allows modular\ncustomizability makes it a unique offering in the Kubernetes community. You can\nlearn more about how to leverage Kubernetes Ingress with Traefik on our site. In\naddition, you can learn more about installing k0s on Mirantis' blog\n[https://www.mirantis.com/blog/how-to-set-up-k0s-kubernetes-a-quick-and-dirty-guide/]\n. While k0s is still relatively new to the scene, I hope this post gives you an\nidea of what it‚Äôs capable of and how you can start experimenting with your own\ncustomized Kubernetes setup.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/12/Getting-Started-with-k0s-and-Traefik-1.png\" class=\"kg-image\" alt=\"Getting Started with k0s and Traefik\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/12/Getting-Started-with-k0s-and-Traefik-1.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Getting-Started-with-k0s-and-Traefik-1.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Getting-Started-with-k0s-and-Traefik-1.png 1600w, https://containous.ghost.io/content/images/2020/12/Getting-Started-with-k0s-and-Traefik-1.png 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><!--kg-card-begin: markdown--><p><a href=\"https://k0sproject.io/\" target=\"_blank\" rel=\"nofollow\">K0s</a> is a new Kubernetes distribution from Mirantis. It's similar to Rancher Labs' K3s, yet it ships with only the bare minimum of extensions. This allows flexibility for users who want to customize it to their needs by defining their own ingress, storage, and other controllers in the CRD manifest, configuring the cluster during bootstrap.</p>\n<!--kg-card-end: markdown--><p>In the examples below, I‚Äôll guide you through how to accomplish getting a functioning Kubernetes cluster by:</p><ol><li>Installing k0s on a clean Linux VM</li><li>Configuring Traefik and MetalLB as an extension</li><li>Starting k0s</li><li>Deploying the Traefik Dashboard IngressRoute and an example service</li></ol><h2 id=\"step-1\">Step 1</h2><p>Before we start, you should plan to do this on a clean install of Linux, probably in a VM. You will be running k0s as a server/worker, and the worker installs components into the <code>/var/lib</code> filesystem as root (so root access is a requirement). My understanding is there are plans to allow non-root workers in the future. Hopefully, in addition to non-root, the k0s binary will allow worker installations in a configurable location.</p><blockquote>Note: Cleanly shutting down and wiping the cluster is not a feature yet in the k0s binary. For now, rebooting the system and wiping <code>/var/lib/k0s</code> is the easiest option.</blockquote><p>Once you have a clean Linux VM (I‚Äôm using Ubuntu 20.04.1), you‚Äôll want to install the Helm and <code>kubectl</code> binaries.</p><pre><code class=\"language-bash\">curl -O https://get.helm.sh/helm-v3.4.1-linux-amd64.tar.gz\ntar xvzf helm-v3.4.1-linux-amd64.tar.gz\nsudo mv linux-amd64/helm /usr/local/bin\n\ncurl -LO \"https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl\"\nchmod +x kubectl\nsudo mv kubectl /usr/local/bin</code></pre><p>Once those are installed, install the k0s binary, create the working directory for k0s, and create a default config.</p><blockquote>Note: The installer and running k0s itself both require root</blockquote><pre><code class=\"language-bash\"># make sure you're running as root\ncurl -sSLf get.k0s.sh | sh\n# create the working directory and set the permissions\nmkdir -p /var/lib/k0s &amp;&amp; chmod 755 /var/lib/k0s\n# create the default config\nk0s default-config &gt; /var/lib/k0s/k0s.yaml</code></pre><h2 id=\"step-2\">Step 2</h2><!--kg-card-begin: markdown--><p>In this step, you‚Äôll configure Traefik and <a href=\"https://metallb.universe.tf/\" rel=\"nofollow\">MetalLB</a> as extensions that will be installed during the cluster's bootstrap. Traefik will function as an ingress controller and MetalLB will allow you to access services from a logical IP address deployed as a <a href=\"https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer\" rel=\"nofollow\">service load balancer</a>. You will want to have a small range of IP addresses that are addressable on your network, preferably outside the range of your DHCP server.</p>\n<!--kg-card-end: markdown--><p>Modify the newly created k0s.yaml file in <code>/var/lib/k0s/k0s.yaml</code>:</p><pre><code class=\"language-yaml\">apiVersion: k0s.k0sproject.io/v1beta1\nkind: Cluster\nmetadata:\n  name: k0s\n...\nextensions:\n  helm:\n    repositories:\n    - name: traefik\n      url: https://helm.traefik.io/traefik\n    - name: bitnami\n      url: https://charts.bitnami.com/bitnami\n    charts:\n    - name: traefik\n      chartname: traefik/traefik\n      version: \"9.11.0\"\n      namespace: default\n    - name: metallb\n      chartname: bitnami/metallb\n      version: \"1.0.1\"\n      namespace: default\n      values: |2\n        configInline:\n          address-pools:\n          - name: generic-cluster-pool\n            protocol: layer2\n            addresses:\n            - 172.16.100.215-172.16.100.220</code></pre><p>Again, be sure to provide a range of IPs for MetalLB that are addressable on your network if you want to access the LoadBalancer and Ingress services from outside this machine.</p><h2 id=\"step-3\">Step 3</h2><p>Now it's time to run k0s and let it automatically set up the server and worker, and deploy and configure Traefik and MetalLB:</p><pre><code class=\"language-bash\">cd /var/lib/k0s\nk0s server --enable-worker &lt;/dev/null &amp;&gt;/dev/null &amp;</code></pre><p>After a minute or two, you should be able to access the cluster using the certificate generated by k0s, located in <code>/var/lib/k0s/pki/admin.conf</code>, and see that MetalLB was deployed along with the Traefik Ingress Controller.</p><pre><code class=\"language-bash\">root@k0s-host ‚ûú export KUBECONFIG=/var/lib/k0s/pki/admin.conf\nroot@k0s-host ‚ûú kubectl get all\nNAME                                                 READY   STATUS    RESTARTS   AGE\npod/metallb-1607085578-controller-864c9757f6-bpx6r   1/1     Running   0          81s\npod/metallb-1607085578-speaker-245c2                 1/1     Running   0          60s\npod/traefik-1607085579-77bbc57699-b2f2t              1/1     Running   0          81s\n\nNAME                         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE\nservice/kubernetes           ClusterIP      10.96.0.1        &lt;none&gt;           443/TCP                      96s\nservice/traefik-1607085579   LoadBalancer   10.105.119.102   172.16.100.215   80:32153/TCP,443:30791/TCP   84s\n\nNAME                                        DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE\ndaemonset.apps/metallb-1607085578-speaker   1         1         1       1            1           kubernetes.io/os=linux   87s\n\nNAME                                            READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/metallb-1607085578-controller   1/1     1            1           87s\ndeployment.apps/traefik-1607085579              1/1     1            1           84s\n\nNAME                                                       DESIRED   CURRENT   READY   AGE\nreplicaset.apps/metallb-1607085578-controller-864c9757f6   1         1         1       81s\nreplicaset.apps/traefik-1607085579-77bbc57699              1         1         1       81s</code></pre><p>Take note of the IP address assigned to the Traefik Load Balancer here:</p><pre><code>NAME                         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE\nservice/traefik-1607085579   LoadBalancer   10.105.119.102   172.16.100.215   80:32153/TCP,443:30791/TCP   84s</code></pre><p>You will need the <code>EXTERNAL-IP</code> (in this case, <code>172.16.100.215</code>) later, when accessing Ingress resources on your cluster.</p><h2 id=\"step-4\">Step 4</h2><ul><li>Deploy the Traefik dashboard</li><li>Deploy the sample ‚Äúwhoami‚Äù service</li></ul><p>Now that you have a functional and addressable load balancer on your cluster, you can easily deploy the Traefik dashboard and access it from anywhere on your local network (provided that you configured MetalLB with an addressable range).</p><p>Create the Traefik Dashboard <a href=\"https://doc.traefik.io/traefik/providers/kubernetes-crd/\">IngressRoute</a> in a YAML file:</p><pre><code class=\"language-yaml\">apiVersion: traefik.containo.us/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: dashboard\nspec:\n  entryPoints:\n    - web\n  routes:\n    - match: PathPrefix(`/dashboard`) || PathPrefix(`/api`)\n      kind: Rule\n      services:\n        - name: api@internal\n          kind: TraefikService</code></pre><p>And deploy it:</p><pre><code class=\"language-bash\">root@k0s-host ‚ûú kubectl apply -f traefik-dashboard.yaml\ningressroute.traefik.containo.us/dashboard created</code></pre><p>You can now access it from your browser by visiting <code>http://172.16.100.215/dashboard/</code>:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/12/image.png\" class=\"kg-image\" alt srcset=\"https://containous.ghost.io/content/images/size/w600/2020/12/image.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/image.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/image.png 1600w, https://containous.ghost.io/content/images/2020/12/image.png 1743w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Great, now let‚Äôs deploy a simple ‚Äúwhoami‚Äù service.</p><!--kg-card-begin: markdown--><p>Create the <code>whoami</code> Deployment, Service, and <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress/\" rel=\"nofollow\">Kubernetes Ingress</a> manifest:</p>\n<!--kg-card-end: markdown--><pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: whoami-deployment\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: whoami\n  template:\n    metadata:\n      labels:\n        app: whoami\n    spec:\n      containers:\n      - name: whoami-container\n        image: containous/whoami\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: whoami-service\nspec:\n  ports:\n  - name: http\n    targetPort: 80\n    port: 80\n  selector:\n    app: whoami\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: whoami-ingress\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /whoami\n        pathType: Exact\n        backend:\n          service:\n            name: whoami-service\n            port:\n              number: 80</code></pre><p>And now, deploy and test it‚Ä¶</p><pre><code class=\"language-bash\">root@k0s-host ‚ûú kubectl apply -f whoami.yaml\ndeployment.apps/whoami-deployment created\nservice/whoami-service created\ningress.networking.k8s.io/whoami-ingress created\n# test the route\nroot@k0s-host ‚ûú curl http://172.16.100.215/whoami\nHostname: whoami-deployment-85bfbd48f-7l77c\nIP: 127.0.0.1\nIP: ::1\nIP: 10.244.214.198\nIP: fe80::b049:f8ff:fe77:3e64\nRemoteAddr: 10.244.214.196:34858\nGET /whoami HTTP/1.1\nHost: 172.16.100.215\nUser-Agent: curl/7.68.0\nAccept: */*\nAccept-Encoding: gzip\nX-Forwarded-For: 172.16.100.77\nX-Forwarded-Host: 172.16.100.215\nX-Forwarded-Port: 80\nX-Forwarded-Proto: http\nX-Forwarded-Server: traefik-1607085579-77bbc57699-b2f2t\nX-Real-Ip: 172.16.100.77</code></pre><h2 id=\"summary\">Summary</h2><!--kg-card-begin: markdown--><p>This post covered installing k0s, setting up a fully functional Load Balancer and Ingress controller for use in your local environment. From here, you could use a tool such as <a href=\"https://ngrok.io\" target=\"_blank\" rel=\"nofollow\">ngrok</a> to expose your Load Balancer to the world and <a href=\"https://doc.traefik.io/traefik/v2.0/user-guides/crd-acme/\">set up Let‚Äôs Encrypt</a> so you can provision your own SSL certificates.</p>\n<p>The design of k0s as a single binary installer that allows modular customizability makes it a unique offering in the Kubernetes community. You can learn more about how to leverage Kubernetes Ingress with Traefik on <a h ref=\"https://traefik.io/solutions/kubernetes-ingress/\">our site</a>. In addition, you can learn more about installing k0s on <a href=\"https://www.mirantis.com/blog/how-to-set-up-k0s-kubernetes-a-quick-and-dirty-guide/\" rel=\"nofollow\">Mirantis' blog</a>. While k0s is still relatively new to the scene, I hope this post gives you an idea of what it‚Äôs capable of and how you can start experimenting with your own customized Kubernetes setup.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/from-zero-to-hero-getting-started-with-k0s-and-traefik/","canonical_url":null,"uuid":"52748163-308e-42aa-8993-8a805ee3500e","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5fce60e016db8f0039b4334b","reading_time":5}},{"node":{"id":"Ghost__Post__5fd818d9255eda00390e23b8","title":"Unleash the Power of Traefik for High Availability Load Balancing","slug":"unleash-the-power-of-traefik-for-high-availability-load-balancing","featured":true,"feature_image":"https://containous.ghost.io/content/images/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/fd6eab4e395f0b7b79b73f0551450d37/47498/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing-1.jpg","srcSet":"/static/fd6eab4e395f0b7b79b73f0551450d37/9dc27/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing-1.jpg 300w,\n/static/fd6eab4e395f0b7b79b73f0551450d37/4fe8c/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing-1.jpg 600w,\n/static/fd6eab4e395f0b7b79b73f0551450d37/47498/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing-1.jpg 1200w,\n/static/fd6eab4e395f0b7b79b73f0551450d37/52258/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing-1.jpg 1800w,\n/static/fd6eab4e395f0b7b79b73f0551450d37/a41d1/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"What if it was possible to achieve true high availability using only Traefik Proxy, Traefik Enterprise, and a few other, easy-to-deploy open-source networking tools?","custom_excerpt":"What if it was possible to achieve true high availability using only Traefik Proxy, Traefik Enterprise, and a few other, easy-to-deploy open-source networking tools?","visibility":"public","created_at_pretty":"15 December, 2020","published_at_pretty":"December 15, 2020","updated_at_pretty":"15 December, 2020","created_at":"2020-12-15T02:00:57.000+00:00","published_at":"2020-12-15T06:42:35.000+00:00","updated_at":"2020-12-15T06:42:35.000+00:00","meta_title":"Unleash the Power of Traefik for High Availability Load Balancing","meta_description":"What if it was possible to achieve true high availability using only Traefik and a few other, easy-to-deploy open-source networking tools?","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing---Twitter.png","twitter_title":null,"authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Every Traefik user knows that it makes the job of application networking easier.\nAt Traefik Labs, we like to say Traefik ‚Äúmakes networking boring.‚Äù And yet,\nbecause Traefik is so easy to use, it‚Äôs also easy to overlook how powerful it\nis.\n\nTraefik has earned a strong following among organizations that develop\ncloud-native applications, due to how effortlessly it integrates with\ntechnologies like Docker and Kubernetes. But the same capabilities that allow it\nto network containers can also help solve bigger networking challenges.\n\nOne use case for which there is growing demand is high availability (HA). With\nthe proliferation of the managed SaaS application delivery model, ensuring\nmaximum uptime and consistent quality of service is more important than ever.\nAchieving this for a global market remains a challenge.\n\nHome-Grown HA\nFor organizations that want to achieve true cloud-scale high availability, the\nsolution is often to turn to proprietary cloud-based solutions or to deploy\ndedicated hardware load balancers. Yet these approaches don't mesh well with\nmodern, cloud-native application development methods. Not only does it increase\ncosts and time-to-delivery, but it takes network configuration out of the hands\nof developers, making it harder to employ practices like agile development,\nDevOps, and site reliability engineering (SRE).\n\nBut what if there was a different approach? What if it was possible to achieve\ntrue high availability using only Traefik Proxy, Traefik Enterprise, and a few\nother, easy-to-deploy open-source networking tools? We recently published a new \nExpert Guide [https://info.traefik.io/request-technical-paper-traefik-ha] that\nexplains how to do just that.\n\nIn the paper, you‚Äôll explore three scenarios designed to increase total traffic\ncapacity and uptime without resorting to complex or proprietary systems:\n\nCase 1: Active/Passive Nodes\nIn this first case, you‚Äôll learn how to set up a two-node cluster of Traefik\ninstances, where one of them is active at any given time. Should the active\ninstance fail, the other instance automatically takes over.\n\nCase 2: Kubernetes Ingress\nBuilding on the first case, you‚Äôll see how to use Traefik Enterprise as a\nmulti-node Kubernetes Ingress controller, complete with SSL termination and a\nrate-limiting feature to prevent network congestion from excessive requests.\n\nCase 3: Cloud-Scale Load Balancing\nFinally, you‚Äôll use Traefik Enterprise and additional open source tools to build\na truly enterprise-grade network environment that‚Äôs capable of scaling to handle\nmassive amounts of requests.\n\nSounds interesting, how can I learn more?\nIf any of this sounds like an itch you‚Äôve been eager to scratch within your own\norganization, download the paper\n[https://info.traefik.io/request-technical-paper-traefik-ha] and dive right in.\nYou‚Äôll receive a link to the Expert Guide, which includes instructions on how to\ndownload the accompanying configuration files for the walk-through.Also, if you\nwant to begin building hands-on experience with Traefik Enterprise, there are\ntwo great ways to explore the high availability features it has to offer. The\nfirst is to contact Traefik Labs and request a guided demo\n[https://info.traefik.io/en/request-demo-traefik-enterprise] that will help you\nunderstand how Traefik Enterprise can benefit your organization. Or, if you‚Äôre\nready to roll up your sleeves, sign up for a 30-day free trial\n[https://info.traefik.io/get-traefik-enterprise-free-for-30-days] and see for\nyourself how easy it is to get started.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg\" class=\"kg-image\" alt=\"Unleash the Power of Traefik for High Availability Load Balancing\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg 1600w, https://containous.ghost.io/content/images/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Every Traefik user knows that it makes the job of application networking easier. At Traefik Labs, we like to say Traefik ‚Äúmakes networking boring.‚Äù And yet, because Traefik is so easy to use, it‚Äôs also easy to overlook how powerful it is.</p><p>Traefik has earned a strong following among organizations that develop cloud-native applications, due to how effortlessly it integrates with technologies like Docker and Kubernetes. But the same capabilities that allow it to network containers can also help solve bigger networking challenges.</p><p>One use case for which there is growing demand is high availability (HA). With the proliferation of the managed SaaS application delivery model, ensuring maximum uptime and consistent quality of service is more important than ever. Achieving this for a global market remains a challenge.</p><h2 id=\"home-grown-ha\"><strong>Home-Grown HA</strong></h2><p>For organizations that want to achieve true cloud-scale high availability, the solution is often to turn to proprietary cloud-based solutions or to deploy dedicated hardware load balancers. Yet these approaches don't mesh well with modern, cloud-native application development methods. Not only does it increase costs and time-to-delivery, but it takes network configuration out of the hands of developers, making it harder to employ practices like agile development, DevOps, and site reliability engineering (SRE).</p><p>But what if there was a different approach? What if it was possible to achieve true high availability using only Traefik Proxy, Traefik Enterprise, and a few other, easy-to-deploy open-source networking tools? We recently published a new <a href=\"https://info.traefik.io/request-technical-paper-traefik-ha\">Expert Guide</a> that explains how to do just that.</p><p>In the paper, you‚Äôll explore three scenarios designed to increase total traffic capacity and uptime without resorting to complex or proprietary systems:</p><h2 id=\"case-1-active-passive-nodes\"><strong>Case 1: Active/Passive Nodes</strong></h2><p>In this first case, you‚Äôll learn how to set up a two-node cluster of Traefik instances, where one of them is active at any given time. Should the active instance fail, the other instance automatically takes over.</p><h2 id=\"case-2-kubernetes-ingress\"><strong>Case 2: Kubernetes Ingress</strong></h2><p>Building on the first case, you‚Äôll see how to use Traefik Enterprise as a multi-node Kubernetes Ingress controller, complete with SSL termination and a rate-limiting feature to prevent network congestion from excessive requests.</p><h2 id=\"case-3-cloud-scale-load-balancing\"><strong>Case 3: Cloud-Scale Load Balancing</strong></h2><p>Finally, you‚Äôll use Traefik Enterprise and additional open source tools to build a truly enterprise-grade network environment that‚Äôs capable of scaling to handle massive amounts of requests.</p><h2 id=\"sounds-interesting-how-can-i-learn-more\">Sounds interesting, how can I learn more?</h2><p>If any of this sounds like an itch you‚Äôve been eager to scratch within your own organization, <a href=\"https://info.traefik.io/request-technical-paper-traefik-ha\">download the paper</a> and dive right in. You‚Äôll receive a link to the Expert Guide, which includes instructions on how to download the accompanying configuration files for the walk-through.Also, if you want to begin building hands-on experience with Traefik Enterprise, there are two great ways to explore the high availability features it has to offer. The first is to contact Traefik Labs and<a href=\"https://info.traefik.io/en/request-demo-traefik-enterprise\"> request a guided demo</a> that will help you understand how Traefik Enterprise can benefit your organization. Or, if you‚Äôre ready to roll up your sleeves, sign up for a<a href=\"https://info.traefik.io/get-traefik-enterprise-free-for-30-days\"> 30-day free trial</a> and see for yourself how easy it is to get started.</p>","url":"https://containous.ghost.io/blog/unleash-the-power-of-traefik-for-high-availability-load-balancing/","canonical_url":null,"uuid":"fabc68fa-2cb9-48c4-a81e-09eca13390ff","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5fd818d9255eda00390e23b8","reading_time":2}},{"node":{"id":"Ghost__Post__5fd92aa6255eda00390e23da","title":"For Developers, Traefik Enterprise 2.3 Adds Support for GitOps and OpenAPI","slug":"traefik-enterprise-adds-support-for-gitops-and-openapi","featured":true,"feature_image":"https://containous.ghost.io/content/images/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/9137a8a7798710019629587d41c5d119/47498/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI-1.jpg","srcSet":"/static/9137a8a7798710019629587d41c5d119/9dc27/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI-1.jpg 300w,\n/static/9137a8a7798710019629587d41c5d119/4fe8c/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI-1.jpg 600w,\n/static/9137a8a7798710019629587d41c5d119/47498/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI-1.jpg 1200w,\n/static/9137a8a7798710019629587d41c5d119/52258/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI-1.jpg 1800w,\n/static/9137a8a7798710019629587d41c5d119/a41d1/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik Enterprise 2.3 introduces new features for developers and DevOps engineers, including support for GitOps practices and OpenAPI.","custom_excerpt":"Traefik Enterprise 2.3 introduces new features for developers and DevOps engineers, including support for GitOps practices and OpenAPI.","visibility":"public","created_at_pretty":"15 December, 2020","published_at_pretty":"December 22, 2020","updated_at_pretty":"22 December, 2020","created_at":"2020-12-15T21:29:10.000+00:00","published_at":"2020-12-22T13:00:00.000+00:00","updated_at":"2020-12-22T12:59:59.000+00:00","meta_title":"Traefik Enterprise 2.3 Adds Support for GitOps and OpenAPI","meta_description":"Traefik Enterprise 2.3 introduces new features for developers and DevOps engineers, including support for GitOps practices and OpenAPI.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI---Twitter.png","twitter_title":null,"authors":[{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Neil McAllister","slug":"neil","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/05/Neil_McAllister_GPS_sm.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"IT operations teams aren‚Äôt the only ones who need an efficient, secure,\neasy-to-use application networking layer. Developers, architects, and DevOps\npros number among Traefik‚Äôs most enthusiastic users.\n\nCloud-native methods ‚Äì including containerization, REST APIs, and microservices\n‚Äì have brought networking front and center in modern software delivery. As a\nresult, application developers need tools that give them greater control over\nnetwork infrastructure, and the team at Traefik Labs is always working to see\nthat their needs are met.\n\nTraefik Enterprise 2.3, the latest version of the commercially supported,\nproduction-grade edition of Traefik, includes two new features aimed squarely at\ndevelopers and DevOps engineers. The first is support for GitOps practices when\ndeploying Traefik, while the second leverages the OpenAPI standard to make\nservice discovery and integration easier. Let‚Äôs take a look at each.\n\nInfrastructure Automation with GitOps\nBriefly, GitOps [https://www.gitops.tech/] is a method of implementing\ncontinuous delivery (CD) for cloud-native applications that uses Git\nrepositories as the source of truth. The technique was originally developed at\nWeaveworks for use with Kubernetes but has since been adapted to other\nenvironments. The central idea is to make developers comfortable when operating\ninfrastructure by allowing them to do it using tools with which they are already\nfamiliar.\n\nIn the past, much of infrastructure configuration relied on command-line tools,\nand this was true of Traefik Enterprise, as well. It supplied the teectl tool,\nwhich eliminates some of the drudgework of configuration and installation, but\nthis approach isn‚Äôt well-suited to CD pipelines.\n\nTraefik Enterprise 2.3 introduces a new internal service to further streamline\nthe process for a GitOps flow for Kubernetes. The procedure is as simple as\nspecifying your Traefik Enterprise license in a Kubernetes Secret, creating a\nConfigMap with your static configuration, and querying the service via HTTP to\ngenerate your installation manifest, like so:\n\ncurl \"https://install.enterprise.traefik.io/v2.3\" --output manifest.yaml\n\nOnce you‚Äôve reviewed the manifest and made any necessary modifications, you can\nstore it in a Git repository in the appropriate directory structure, and then\nintegrate it with GitOps tools such as Argo CD\n[https://argoproj.github.io/argo-cd/].\n\nThe advantages of this approach are several. For one thing, Git automatically\nkeeps a version history of your config files, so you can easily roll back to an\nearlier version if necessary. Also, Traefik Enterprise‚Äôs ability to update the\nstatic configuration without a restart means you can apply updates with minimal\ninterruption of service. To learn more about GitOps-style installation, consult\nthe documentation\n[https://doc.traefik.io/traefik-enterprise/installing/kubernetes/gitops/].\n\nService Visibility with OpenAPI\nAs services proliferate on the network, so do the connections between them. That\nmeans APIs, and lots of them. Staying on top of them all can be challenging for\nany developer, which is why Traefik Enterprise 2.3 incorporates a new API Portal\nbuilt around the OpenAPI specification [https://www.openapis.org/].\n\nOpenAPI (initially known as Swagger) is a language-agnostic interface\ndescription language for REST APIs. The API descriptions themselves are defined\nin JSON files. The idea is to make it easier to auto-generate consistent\nreference documentation for service APIs, no matter who designed and implemented\nthem.\n\nTo use OpenAPI descriptions with Traefik Enterprise, simply enable the new API\nPortal feature by editing the static configuration to include a path (for\nexample, spec.json) to where the JSON files can be found on each service\nentrypoint. From there, anyone with access can browse the catalog of the\nservices and their accompanying APIs from Traefik Enterprise‚Äôs internal web UI:\n\nWhat‚Äôs more, because the API Portal is just another service managed by Traefik,\nadministrators can choose from the full range of access controls provided by\nTraefik Middlewares, including Traefik Enterprise‚Äôs exclusive, enterprise-grade\nauthentication methods.\n\nTo view some examples of how to write API descriptions using OpenAPI, consult\nthe project‚Äôs public specification repository\n[https://github.com/OAI/OpenAPI-Specification/tree/master/examples]. More\ninformation on how to use OpenAPI with Traefik Enterprise is available in the \ndocumentation [https://doc.traefik.io/traefik-enterprise/operations/apiportal/].\n\nEmpowering Developers\nThese latest features are just two examples of the ways in which Traefik\nEnterprise helps give developers greater control over the environments where\ntheir apps and services run. As cloud-native architectures continue to encourage\norganizations to adopt methods like DevOps and site reliability engineering\n(SRE), you can expect Traefik Labs to continue to deliver features that support\nthis new model.\n\nOther examples of developer-centric technologies that are baked into Traefik\nEnterprise include support for certificate management using HashiCorp Vault\n[https://traefik.io/blog/lock-down-your-network-with-traefik-enterprise-and-vault/]\n; authentication tools including JWT, LDAP, and OpenID Connect\n[https://traefik.io/blog/unlock-the-potential-of-data-apis-with-strong-authentication-and-traefik-enterprise/]\n; and a service mesh\n[https://doc.traefik.io/traefik-enterprise/features/#service-mesh] layer that\nenables fine-grained control over inter-service communication. \n\nTo learn more about how Traefik Enterprise can help your organization boost\ndeveloper productivity and reduce time-to-delivery, contact Traefik Labs to \nrequest a demo [https://info.traefik.io/en/request-demo-traefik-enterprise]. Or\nbetter yet, sign up for a 30-day free trial\n[https://info.traefik.io/get-traefik-enterprise-free-for-30-days] and explore\nthe features of Traefik Enterprise for yourself.","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg\" class=\"kg-image\" alt=\"Traefik Enterprise 2.3 Adds Support for GitOps and OpenAPI\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg 1600w, https://containous.ghost.io/content/images/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p>IT operations teams aren‚Äôt the only ones who need an efficient, secure, easy-to-use application networking layer. Developers, architects, and DevOps pros number among Traefik‚Äôs most enthusiastic users.</p><p>Cloud-native methods ‚Äì including containerization, REST APIs, and microservices ‚Äì have brought networking front and center in modern software delivery. As a result, application developers need tools that give them greater control over network infrastructure, and the team at Traefik Labs is always working to see that their needs are met.</p><p>Traefik Enterprise 2.3, the latest version of the commercially supported, production-grade edition of Traefik, includes two new features aimed squarely at developers and DevOps engineers. The first is support for GitOps practices when deploying Traefik, while the second leverages the OpenAPI standard to make service discovery and integration easier. Let‚Äôs take a look at each.</p><h2 id=\"infrastructure-automation-with-gitops\"><strong>Infrastructure Automation with GitOps</strong></h2><!--kg-card-begin: markdown--><p>Briefly, <a href=\"https://www.gitops.tech/\" target=\"_blank\" rel=\"nofollow\">GitOps</a> is a method of implementing continuous delivery (CD) for cloud-native applications that uses Git repositories as the source of truth. The technique was originally developed at Weaveworks for use with Kubernetes but has since been adapted to other environments. The central idea is to make developers comfortable when operating infrastructure by allowing them to do it using tools with which they are already familiar.</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>In the past, much of infrastructure configuration relied on command-line tools, and this was true of Traefik Enterprise, as well. It supplied the <code>teectl</code> tool, which eliminates some of the drudgework of configuration and installation, but this approach isn‚Äôt well-suited to CD pipelines.</p>\n<!--kg-card-end: markdown--><p>Traefik Enterprise 2.3 introduces a new internal service to further streamline the process for a GitOps flow for Kubernetes. The procedure is as simple as specifying your Traefik Enterprise license in a Kubernetes Secret, creating a ConfigMap with your static configuration, and querying the service via HTTP to generate your installation manifest, like so:</p><!--kg-card-begin: markdown--><p><code>curl &quot;https://install.enterprise.traefik.io/v2.3&quot; --output manifest.yaml</code></p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Once you‚Äôve reviewed the manifest and made any necessary modifications, you can store it in a Git repository in the appropriate directory structure, and then integrate it with GitOps tools such as <a href=\"https://argoproj.github.io/argo-cd/\" target=\"_blank\" rel=\"nofollow\">Argo CD</a>.</p>\n<!--kg-card-end: markdown--><p>The advantages of this approach are several. For one thing, Git automatically keeps a version history of your config files, so you can easily roll back to an earlier version if necessary. Also, Traefik Enterprise‚Äôs ability to update the static configuration without a restart means you can apply updates with minimal interruption of service. To learn more about GitOps-style installation, <a href=\"https://doc.traefik.io/traefik-enterprise/installing/kubernetes/gitops/\">consult the documentation</a>.</p><h2 id=\"service-visibility-with-openapi\"><strong>Service Visibility with OpenAPI</strong></h2><!--kg-card-begin: markdown--><p>As services proliferate on the network, so do the connections between them. That means APIs, and lots of them. Staying on top of them all can be challenging for any developer, which is why Traefik Enterprise 2.3 incorporates a new API Portal built around the <a href=\"https://www.openapis.org/\" target=\"_blank\" rel=\"nofollow\">OpenAPI specification</a>.</p>\n<!--kg-card-end: markdown--><p>OpenAPI (initially known as Swagger) is a language-agnostic interface description language for REST APIs. The API descriptions themselves are defined in JSON files. The idea is to make it easier to auto-generate consistent reference documentation for service APIs, no matter who designed and implemented them.</p><!--kg-card-begin: markdown--><p>To use OpenAPI descriptions with Traefik Enterprise, simply enable the new API Portal feature by editing the static configuration to include a path (for example, <code>spec.json</code>) to where the JSON files can be found on each service entrypoint. From there, anyone with access can browse the catalog of the services and their accompanying APIs from Traefik Enterprise‚Äôs internal web UI:</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card\"><img src=\"https://lh6.googleusercontent.com/9GR3S1hfXIGNjLLMwppW07wlFXhiFFxkcS-QffLpLO2UHNnoTSufM1Czo8fpseTBFc8UsxnjD88_fAH0hZ4-ltylQRSDgCZJ4BrnK_m6P61aVlol2m_R2Pak4jZIYbU1GGZHr8tU\" class=\"kg-image\" alt=\"API Portal page\"></figure><p>What‚Äôs more, because the API Portal is just another service managed by Traefik, administrators can choose from the full range of access controls provided by Traefik Middlewares, including Traefik Enterprise‚Äôs exclusive, enterprise-grade authentication methods.</p><!--kg-card-begin: markdown--><p>To view some examples of how to write API descriptions using OpenAPI, consult the project‚Äôs <a href=\"https://github.com/OAI/OpenAPI-Specification/tree/master/examples\" target=\"_blank\" rel=\"nofollow\">public specification repository</a>. More information on how to use OpenAPI with Traefik Enterprise is available in the <a href=\"https://doc.traefik.io/traefik-enterprise/operations/apiportal/\">documentation</a>.</p>\n<!--kg-card-end: markdown--><h2 id=\"empowering-developers\"><strong>Empowering Developers</strong></h2><p>These latest features are just two examples of the ways in which Traefik Enterprise helps give developers greater control over the environments where their apps and services run. As cloud-native architectures continue to encourage organizations to adopt methods like DevOps and site reliability engineering (SRE), you can expect Traefik Labs to continue to deliver features that support this new model.</p><p>Other examples of developer-centric technologies that are baked into Traefik Enterprise include support for <a href=\"https://traefik.io/blog/lock-down-your-network-with-traefik-enterprise-and-vault/\">certificate management using HashiCorp Vault</a>; authentication tools including JWT, LDAP, and <a href=\"https://traefik.io/blog/unlock-the-potential-of-data-apis-with-strong-authentication-and-traefik-enterprise/\">OpenID Connect</a>; and a <a href=\"https://doc.traefik.io/traefik-enterprise/features/#service-mesh\">service mesh</a> layer that enables fine-grained control over inter-service communication. </p><p>To learn more about how Traefik Enterprise can help your organization boost developer productivity and reduce time-to-delivery, contact Traefik Labs to <a href=\"https://info.traefik.io/en/request-demo-traefik-enterprise\">request a demo</a>. Or better yet, sign up for a <a href=\"https://info.traefik.io/get-traefik-enterprise-free-for-30-days\">30-day free trial</a> ¬†and explore the features of Traefik Enterprise for yourself.</p>","url":"https://containous.ghost.io/blog/traefik-enterprise-adds-support-for-gitops-and-openapi/","canonical_url":null,"uuid":"94d5a7d5-71c0-4669-8fa2-bd171b77bb02","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5fd92aa6255eda00390e23da","reading_time":3}}]}},"pageContext":{"slug":"traefik-1-6-get-our-latest-tetedemoine-1859164bf521"}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}