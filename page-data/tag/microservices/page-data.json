{"componentChunkName":"component---src-templates-tag-tsx","path":"/tag/microservices/","result":{"data":{"ghostTag":{"slug":"microservices","name":"Microservices","visibility":"public","feature_image":null,"featureImageSharp":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5e9116ed1afff4004456e002","title":"The Importance of Distributed Tracing and Monitoring in a Microservice Architecture","slug":"the-importance-of-distributed-tracing-and-monitoring-in-a-microservice-architecture","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/05/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/bc214844165f4ac2399fc1548c498842/47498/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg","srcSet":"/static/bc214844165f4ac2399fc1548c498842/9dc27/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg 300w,\n/static/bc214844165f4ac2399fc1548c498842/4fe8c/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg 600w,\n/static/bc214844165f4ac2399fc1548c498842/47498/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"How do teams diagnose latency between microservices or collate logs from dozens of loosely coupled services, while also ensuring that any logging overhead is kept to a minimum?","custom_excerpt":"How do teams diagnose latency between microservices or collate logs from dozens of loosely coupled services, while also ensuring that any logging overhead is kept to a minimum?","visibility":"public","created_at_pretty":"11 April, 2020","published_at_pretty":"May 5, 2020","updated_at_pretty":"22 May, 2020","created_at":"2020-04-11T01:01:33.000+00:00","published_at":"2020-05-05T14:40:44.000+00:00","updated_at":"2020-05-22T00:25:50.000+00:00","meta_title":"Distributed Tracing & Monitoring in a Microservice Architecture","meta_description":"Often microservices can be thought of as a single application, even though internally there may be several services involved in fulfilling requests.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/05/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Twitter.jpg","twitter_title":null,"authors":[{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"}],"primary_author":{"name":"Kevin Crawley","slug":"kevincrawley","bio":"Kevin is a Developer Advocate at Containous, where he contributes to the team by bringing his passion and experience for developer productivity and automation.","profile_image":"https://containous.ghost.io/content/images/2020/04/2020-03-24_14-04-57.png","twitter":"@notsureifkevin","facebook":null,"website":"https://containo.us"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Microservices","slug":"microservices","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Microservices have many advantages, such as the ability to independently deploy\ndecoupled services instead of having to deploy an entire monolithic application\nor scaling out components independently. However, for all their advantages,\nmicroservices also introduce complexities that should be understood by teams\nthat choose to implement them. One of those challenges is monitoring application\nhealth and tracing traffic flows through a distributed system.\n\nOften microservices can logically be thought of as a single application, even\nthough internally there may be several services involved in fulfilling requests\nto the end-user. If each request is routed through a series of services, how do\nteams trace and troubleshoot issues? Even if the system as a whole is working \nfunctionally, perhaps your overall transaction time is unacceptable. How do\nteams diagnose latency between microservices or collate logs from dozens of\nloosely coupled services, while also ensuring that any logging overhead is kept\nto a minimum?\n\nLogging, Monitoring, and Tracing\nBefore we continue, let us disambiguate logging, monitoring, and tracing. These\nterms are often used interchangeably, but there are some subtle differences.\n\nTypically, logging is focused on diagnosing errors or providing auditing\ncapabilities at the component (or microservice) level. Logging is also usually\nreactive in nature and is often the first tool that operators use when\ntroubleshooting service errors or investigating security incidents.\n\nMonitoring is focused on proactive metrics and thresholds that let operators\nknow how a service is handling its requests. These metrics are usually focused\non the underlying infrastructure, such as CPU, Memory, and I/O in addition to\nthe runtime metrics generated by the application itself. These include\nstatistics like heap size, thread count, and memory management (garbage\ncollection).\n\nTracing is typically focused on optimization and performance across multiple\nservices. It includes correlating a single “logical request” to multiple\nphysical requests as they propagate through multiple services. While tracing is\nconcerned with each service in a chain, it is usually focused at the application\nlevel. There are additional benefits to tracing as a troubleshooting tool since\nany exception or error is usually captured along with the entire context of a\nrequest.\n\nWhile logging is important, in this article we will focus on monitoring and\ntracing since they span multiple services.\n\nMonitoring\nMonitoring is the process of recording information, or predefined metrics,\nallowing operators to achieve visibility into their applications state. These\nmetrics help answer questions around resource allocation or to determine if\nrequests are going where they should. This becomes increasingly important when\ntraffic shifting and other advanced routing mechanisms like throttling or\ncircuit breakers are used within microservice applications. Knowing when a\nrequest hit a service is important but knowing why it was forwarded to that\nservice can be just as important. Monitoring can also help operators determine\nwhen circuit breakers are triggered on or off or which traffic shifting rule was\ninvoked in routing the request. Traefik generates metrics around these types of\nKey Performance Indicators (KPIs) and exposes that data through various\nimplementations such as Prometheus.\n\nTracing\nTracing starts at the entry-point of a request into an application. A trace is\nstarted for the request and will have a unique identifier\n[https://www.w3.org/TR/trace-context/] generated for that request. As traffic\nflows from service to service, each service adds some information to the trace,\nlike the time the request arrived at the service as well as how long it took to\nprocess. This allows open source tools such as Jaeger\n[https://www.jaegertracing.io/] and Elastic APM [https://www.elastic.co/apm] to\nvisualize the entire call flow.\n\nHow is tracing implemented in a microservices application? In most cases, there\nare libraries and tools to help instrument the most popular application runtimes\nand frameworks. You could also code it yourself, intercepting calls and adding\nheaders to downstream requests or using some other mechanism to add metadata to\ntraffic. In addition to these techniques, you can utilize tracing with Traefik\n[/traefik/] and Maesh [/maesh/] to gain additional observability within your\napplication environments.\n\nTraefik supports tracing via OpenTracing [https://opentracing.io/], an open\nstandard designed for distributed tracing. You enable tracing via configuration\nand can also specify which backend you want to utilize: Jaeger\n[https://www.jaegertracing.io/], Zipkin [https://zipkin.io/], or DataDog\n[https://www.datadoghq.com/].\n\nTracing or Monitoring, or Both?\nThe distinction between monitoring and tracing is often academic. Some teams\nutilize monitoring and metrics alongside distributed tracing, while other teams\nprefer to keep tracing and monitoring as separate but complementary concerns. In\nmany cases, the aggregate data provided by tracing generates the information\nthey need to determine when and where to scale out their services.\n\nMonitoring is typically easier to implement, so teams usually start their\ndiagnostic journey with metrics. Tracing allows a deeper (or wider) view but\ntypically requires more effort to implement because of the requirements in\ncollecting, storing, and analyzing the vast amounts of telemetry which is\ngenerated by tracing. Of course, there are vendors such as DataDog\n[https://www.datadoghq.com/] and Instana [https://www.instana.com/] which can\noffload most of that work, but those solutions are costly and hard to justify\nwhen first starting out.\n\nBoth monitoring and tracing can be used to help detect when individual services\nare not behaving as they should. Tracing, when properly implemented, will help\nyou not only detect anomalies but give you the information needed to understand\nwhat may be causing them. Ultimately, when you are to the point where you need\nto focus on optimization and improve end-to-end performance, then you’re going\nto have no choice but to utilize tracing. Tools such as Traefik [/traefik/] and \nMaesh [/maesh/] can be used to introduce distributed tracing without the\nsignificant overhead involved with instrumenting every service with open source\ntools and having to manage all that additional telemetry.\n\nConclusion\nBoth monitoring and tracing are important to creating stable, reliable, and\nperformant microservice-based applications. Monitoring provides health checks on\nplatform services and critical infrastructure, while tracing allows you to\ndiagnose end-to-end traffic for requests. As applications mature, they typically\nrequire both monitoring and tracing for efficient and optimal service\nmanagement.\n\nWant to learn more about microservice architecture best practices? Check out\nthis white paper\n[https://info.containo.us/request-white-paper-routing-in-the-cloud] that\naddresses production challenges (including tracing and monitoring) related to\nadopting microservices with a cloud-native mindset.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/05/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog.jpg\" class=\"kg-image\"></figure><p>Microservices have many advantages, such as the ability to independently deploy decoupled services instead of having to deploy an entire monolithic application or scaling out components independently. However, for all their advantages, microservices also introduce complexities that should be understood by teams that choose to implement them. One of those challenges is monitoring application health and tracing traffic flows through a distributed system.</p><p>Often microservices can <em>logically</em> be thought of as a single application, even though internally there may be several services involved in fulfilling requests to the end-user. If each request is routed through a series of services, how do teams trace and troubleshoot issues? Even if the system as a whole is working <em>functionally</em>, perhaps your overall transaction time is unacceptable. How do teams diagnose latency between microservices or collate logs from dozens of loosely coupled services, while also ensuring that any logging overhead is kept to a minimum?</p><h2 id=\"logging-monitoring-and-tracing\">Logging, Monitoring, and Tracing</h2><p>Before we continue, let us disambiguate logging, monitoring, and tracing. These terms are often used interchangeably, but there are some subtle differences.</p><p>Typically, logging is focused on diagnosing errors or providing auditing capabilities at the component (or microservice) level. Logging is also usually reactive in nature and is often the first tool that operators use when troubleshooting service errors or investigating security incidents.</p><p>Monitoring is focused on proactive metrics and thresholds that let operators know how a service is handling its requests. These metrics are usually focused on the underlying infrastructure, such as CPU, Memory, and I/O in addition to the runtime metrics generated by the application itself. These include statistics like heap size, thread count, and memory management (garbage collection).</p><p>Tracing is typically focused on optimization and performance across multiple services. It includes correlating a single “logical request” to multiple physical requests as they propagate through multiple services. While tracing is concerned with each service in a chain, it is usually focused at the application level. There are additional benefits to tracing as a troubleshooting tool since any exception or error is usually captured along with the entire context of a request.</p><p>While logging is important, in this article we will focus on monitoring and tracing since they span multiple services.</p><h2 id=\"monitoring\">Monitoring</h2><p>Monitoring is the process of recording information, or predefined metrics, allowing operators to achieve visibility into their applications state. These metrics help answer questions around resource allocation or to determine if requests are going where they should. This becomes increasingly important when traffic shifting and other advanced routing mechanisms like throttling or circuit breakers are used within microservice applications. Knowing when a request hit a service is important but knowing why it was forwarded to that service can be just as important. Monitoring can also help operators determine when circuit breakers are triggered on or off or which traffic shifting rule was invoked in routing the request. Traefik generates metrics around these types of Key Performance Indicators (KPIs) and exposes that data through various implementations such as Prometheus.</p><h2 id=\"tracing\">Tracing</h2><p>Tracing starts at the entry-point of a request into an application. A trace is started for the request and will have a <a href=\"https://www.w3.org/TR/trace-context/\">unique identifier</a> generated for that request. As traffic flows from service to service, each service adds some information to the trace, like the time the request arrived at the service as well as how long it took to process. This allows open source tools such as <a href=\"https://www.jaegertracing.io/\">Jaeger</a> and <a href=\"https://www.elastic.co/apm\">Elastic APM</a> to visualize the entire call flow.</p><p>How is tracing implemented in a microservices application? In most cases, there are libraries and tools to help instrument the most popular application runtimes and frameworks. You could also code it yourself, intercepting calls and adding headers to downstream requests or using some other mechanism to add metadata to traffic. In addition to these techniques, you can utilize tracing with <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> and <a href=\"https://containous.ghost.io/maesh/\">Maesh</a> to gain additional observability within your application environments.</p><p>Traefik supports tracing via <a href=\"https://opentracing.io/\">OpenTracing</a>, an open standard designed for distributed tracing. You enable tracing via configuration and can also specify which backend you want to utilize: <a href=\"https://www.jaegertracing.io/\">Jaeger</a>, <a href=\"https://zipkin.io/\">Zipkin</a>, or <a href=\"https://www.datadoghq.com/\">DataDog</a>.</p><h2 id=\"tracing-or-monitoring-or-both\">Tracing or Monitoring, or Both?</h2><p>The distinction between monitoring and tracing is often academic. Some teams utilize monitoring and metrics alongside distributed tracing, while other teams prefer to keep tracing and monitoring as separate but complementary concerns. In many cases, the aggregate data provided by tracing generates the information they need to determine when and where to scale out their services.</p><p>Monitoring is typically easier to implement, so teams usually start their diagnostic journey with metrics. Tracing allows a deeper (or wider) view but typically requires more effort to implement because of the requirements in collecting, storing, and analyzing the vast amounts of telemetry which is generated by tracing. Of course, there are vendors such as <a href=\"https://www.datadoghq.com/\">DataDog</a> and <a href=\"https://www.instana.com/\">Instana</a> which can offload most of that work, but those solutions are costly and hard to justify when first starting out.</p><p>Both monitoring and tracing can be used to help detect when individual services are not behaving as they should. Tracing, when properly implemented, will help you not only detect anomalies but give you the information needed to understand what may be causing them. Ultimately, when you are to the point where you need to focus on optimization and improve end-to-end performance, then you’re going to have no choice but to utilize tracing. Tools such as <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> and <a href=\"https://containous.ghost.io/maesh/\">Maesh</a> can be used to introduce distributed tracing without the significant overhead involved with instrumenting every service with open source tools and having to manage all that additional telemetry.</p><h2 id=\"conclusion\">Conclusion</h2><p>Both monitoring and tracing are important to creating stable, reliable, and performant microservice-based applications. Monitoring provides health checks on platform services and critical infrastructure, while tracing allows you to diagnose end-to-end traffic for requests. As applications mature, they typically require both monitoring and tracing for efficient and optimal service management.</p><p>Want to learn more about <strong>microservice architecture best practices</strong>? <a href=\"https://info.containo.us/request-white-paper-routing-in-the-cloud\">Check out this white paper</a> that addresses<strong> production challenges </strong>(including tracing and monitoring) <strong>related to adopting microservices with a cloud-native mindset</strong>.</p>","url":"https://containous.ghost.io/blog/the-importance-of-distributed-tracing-and-monitoring-in-a-microservice-architecture/","canonical_url":null,"uuid":"abf91c0f-1147-4f72-be6e-11329e668272","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e9116ed1afff4004456e002","reading_time":4}}]}},"pageContext":{"slug":"microservices","limit":9,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}