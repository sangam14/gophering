{"componentChunkName":"component---src-templates-tag-tsx","path":"/tag/kubernetes/page/2/","result":{"data":{"ghostTag":{"slug":"kubernetes","name":"Kubernetes","visibility":"public","feature_image":null,"featureImageSharp":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5e9890445df7fe004475aa62","title":"Connecting Users to Applications with Kubernetes Ingress Controllers","slug":"connecting-users-to-applications-with-kubernetes-ingress-controllers","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/1caf24ae2a6677b201631dedaab14f3e/47498/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg","srcSet":"/static/1caf24ae2a6677b201631dedaab14f3e/9dc27/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg 300w,\n/static/1caf24ae2a6677b201631dedaab14f3e/4fe8c/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg 600w,\n/static/1caf24ae2a6677b201631dedaab14f3e/47498/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Kubernetes is the de facto standard for teams developing cloud-native applications. In this article, we’ll review one of the most critical aspects of Kubernetes networking: The Ingress Controller.","custom_excerpt":"Kubernetes is the de facto standard for teams developing cloud-native applications. In this article, we’ll review one of the most critical aspects of Kubernetes networking: The Ingress Controller.","visibility":"public","created_at_pretty":"16 April, 2020","published_at_pretty":"April 21, 2020","updated_at_pretty":"12 October, 2020","created_at":"2020-04-16T17:05:08.000+00:00","published_at":"2020-04-21T13:30:00.000+00:00","updated_at":"2020-10-12T17:54:08.000+00:00","meta_title":"Connecting Users to Apps with Kubernetes Ingress Controllers","meta_description":"In this article, we’ll briefly review one of the most critical but perhaps confusing aspects of Kubernetes networking: The Ingress Controller.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Containerization technologies such as Docker [https://www.docker.com/] have been\nrapidly adopted by software teams, and the ensuing ability to easily package\napplication components into reusable parts has given rise to the widespread use\nof microservices. However, these benefits have come with a price tag as\ndevelopers are faced with challenges around orchestrating and managing\nconnectivity to the underlying containers in a datacenter. Kubernetes\n[https://kubernetes.io/] (k8s) is the de facto standard for teams developing\ncloud-native applications and directly addresses these issues. In this article,\nwe’ll briefly review one of the most critical but perhaps confusing aspects of\nKubernetes networking: The Ingress Controller.\n\nFrom Pods to Production\nLet’s start with a typical scenario: A development team is tasked with writing a\nbackend API service for external applications/users. In the early phases of\ndevelopment, an engineer may instantiate a local instance of the containerized\nimplementation on development machines using direct docker invocations or even\ndocker-compose. At some point, though, they’ll want to deploy a version of the\nservice to a shared development or staging cluster in the same manner as the\nfinal production configuration. Pods, the fundamental deployable units defined\nby k8s, and higher-level abstractions such as Deployment resources can help\nautomate lifecycle management of containers during this step, but they don’t\naddress how applications are accessed over the network. Kubernetes provides a\ndedicated resource abstraction for this purpose.\n\nExposing applications as k8s services\nWhen deployed within Pods, containers are assigned IP addresses that may change\nover time due to a variety of lifecycle operations. This immediately poses\nchallenges when other components need to find and establish network connections\nwith them. The Service resource defined as part of Kubernetes networking manages\nthese aspects automatically. Users can define Services that get associated with\nunderlying Pods through selectors and allows them to be accessed through a\nuser-specified service name. Where connections can be established from and how\nthey’re implemented depends upon the Service type configured. The most commonly\nused service types offered by k8s are:\n\n * ClusterIP\n * NodePort\n * LoadBalancer\n\nClusterIP service type\nThe ClusterIP is enabled by default if no type is defined in the Service\nresource definition. When invoked, k8s creates a virtual cluster IP address that\ncan be used to connect to the underlying Pods. The caveat, though, is that this\nIP address is routable only within the cluster itself. ClusterIP services are\noften used for exposing internal-only application endpoints to each other.\n\nNodePort service type\nThe NodePort type provides the simplest mechanism for external access to\nservices. Specifically, it opens a specific port (within a k8s configured port\nrange) on every node in the cluster. Underneath, a ClusterIP service is created,\nand clients that attempt to connect to an exposed NodePort are routed through.\nWhile the NodePort service type extends a method to access services from outside\nof the cluster, it has some drawbacks including:\n\n * Services can only be exposed on ports from a range (30000-32767 by default)\n * One port can only be mapped to a single service\n * Clients connect through a node and if the corresponding IP of the underlying\n   host / VM changes, they need to be updated accordingly\n\nLoadBalancer service type\nThe LoadBalancer type is often used in cloud environments in order to automate\nthe provisioning of external load balancers outside of the underlying k8s\ncluster. While this enables external network access and avoids the problem of IP\naddresses shifting out from underneath clients, the use of LoadBalancer Service\ntypes can quickly lead to high costs from the underlying cloud (e.g. GCE or\nAWS).\n\nWhile the three Service types above are viable alternatives for some use cases,\nwhen application developers want to expose their services externally without the\nlimitations of NodePort and LoadBalancer types, there’s a better alternative\nextended by Kubernetes networking.\n\nK8s networking and the Ingress resource abstraction\nKubernetes defines a native Ingress resource abstraction that exposes HTTP and\nHTTPS endpoints and routes traffic based upon rules defined by the user. The\nIngress resource is a natural fit when developers and devops engineers want to\nexpose multiple underlying services through a single external endpoint and/or\nload balancer. The Ingress resource definition allows them to route traffic to\ndefined Service resources based upon, for example, host and/or prefix rules.\nTherefore, it complements the Service resource capabilities to provide a\nflexible method for enabling external access. However, defining an Ingress\nresource on its own doesn’t actually expose services outside Kubernetes since it\nsimply conveys a request for networking configuration.\n\nThe wizard behind the curtain: Ingress Controllers\nOur discussion thus far has helped highlight the need for ingress resources, but\nit leaves open the question of how corresponding requests are acted upon. The\nanswer comes in the form of Ingress Controllers which are responsible for\nconsuming inbound requests and creating the corresponding routing specifications\nin a technology-specific manner. Typically, the specific controller installed in\na k8s cluster is selected and deployed by operators. There are many potential\noptions available, but a few illustrative examples include:\n\n * AWS ALB - An instance of an Ingress Controller tied to a specific public\n   cloud, it satisfies inbound Ingress resource requests using AWS Application\n   Load Balancers\n   [https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html]\n * NGINX - Implements Ingress resources using the NGINX open source software\n * Traefik - A leading open source Kubernetes Ingress Controller [/traefik/] \n   that makes setting up routes between Kubernetes services and the outside\n   world simple and reliable\n\nThere need not be a strict either / or decision when it comes to choosing\nIngress Controllers\n[/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/]\n, and k8s operators can elect to deploy multiple controllers if desired. The\nselection process should take into consideration the benefits specific\ncontrollers like Traefik [/traefik/] may provide such as:\n\n * Lets Encrypt support for automated certificate management\n * Traffic splitting based upon custom weight definitions\n * Flexibly route definitions including support for name and path based routing\n   as well as route prioritization\n * Custom resource definitions that provide additional controller-specific\n   enhancements\n\nBy integrating controllers that align with their use cases, development teams\ncan enjoy a variety of capabilities provided by Kubernetes for external access\nwithout having to become networking experts.\n\nWant to learn more about Kubernetes Ingress? Check out this video\n[https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes] \nthat describes the different patterns for deploying external load balancers in\nKubernetes.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg\" class=\"kg-image\" alt=\"Connecting Users to Applications with Kubernetes Ingress Controllers\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 1000w, https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Containerization technologies such as <a href=\"https://www.docker.com/\">Docker</a> have been rapidly adopted by software teams, and the ensuing ability to easily package application components into reusable parts has given rise to the widespread use of microservices. However, these benefits have come with a price tag as developers are faced with challenges around orchestrating and managing connectivity to the underlying containers in a datacenter. <a href=\"https://kubernetes.io/\">Kubernetes</a> (k8s) is the de facto standard for teams developing cloud-native applications and directly addresses these issues. In this article, we’ll briefly review one of the most critical but perhaps confusing aspects of Kubernetes networking: The Ingress Controller.</p><h2 id=\"from-pods-to-production\">From Pods to Production</h2><p>Let’s start with a typical scenario: A development team is tasked with writing a backend API service for external applications/users. In the early phases of development, an engineer may instantiate a local instance of the containerized implementation on development machines using direct docker invocations or even docker-compose. At some point, though, they’ll want to deploy a version of the service to a shared development or staging cluster in the same manner as the final production configuration. Pods, the fundamental deployable units defined by k8s, and higher-level abstractions such as Deployment resources can help automate lifecycle management of containers during this step, but they don’t address how applications are accessed over the network. Kubernetes provides a dedicated resource abstraction for this purpose.</p><h2 id=\"exposing-applications-as-k8s-services\">Exposing applications as k8s services</h2><p>When deployed within Pods, containers are assigned IP addresses that may change over time due to a variety of lifecycle operations. This immediately poses challenges when other components need to find and establish network connections with them. The Service resource defined as part of Kubernetes networking manages these aspects automatically. Users can define Services that get associated with underlying Pods through selectors and allows them to be accessed through a user-specified service name. Where connections can be established from and how they’re implemented depends upon the Service type configured. The most commonly used service types offered by k8s are:</p><ul><li>ClusterIP</li><li>NodePort</li><li>LoadBalancer</li></ul><h3 id=\"clusterip-service-type\">ClusterIP service type</h3><p>The ClusterIP is enabled by default if no type is defined in the Service resource definition. When invoked, k8s creates a virtual cluster IP address that can be used to connect to the underlying Pods. The caveat, though, is that this IP address is routable only within the cluster itself. ClusterIP services are often used for exposing internal-only application endpoints to each other.</p><h3 id=\"nodeport-service-type\">NodePort service type</h3><p>The NodePort type provides the simplest mechanism for external access to services. Specifically, it opens a specific port (within a k8s configured port range) on every node in the cluster. Underneath, a ClusterIP service is created, and clients that attempt to connect to an exposed NodePort are routed through. While the NodePort service type extends a method to access services from outside of the cluster, it has some drawbacks including:</p><ul><li>Services can only be exposed on ports from a range (30000-32767 by default)</li><li>One port can only be mapped to a single service</li><li>Clients connect through a node and if the corresponding IP of the underlying host / VM changes, they need to be updated accordingly</li></ul><h3 id=\"loadbalancer-service-type\">LoadBalancer service type</h3><p>The LoadBalancer type is often used in cloud environments in order to automate the provisioning of external load balancers outside of the underlying k8s cluster. While this enables external network access and avoids the problem of IP addresses shifting out from underneath clients, the use of LoadBalancer Service types can quickly lead to high costs from the underlying cloud (e.g. GCE or AWS).</p><p>While the three Service types above are viable alternatives for some use cases, when application developers want to expose their services externally without the limitations of NodePort and LoadBalancer types, there’s a better alternative extended by Kubernetes networking.</p><h2 id=\"k8s-networking-and-the-ingress-resource-abstraction\">K8s networking and the Ingress resource abstraction</h2><p>Kubernetes defines a native Ingress resource abstraction that exposes HTTP and HTTPS endpoints and routes traffic based upon rules defined by the user. The Ingress resource is a natural fit when developers and devops engineers want to expose multiple underlying services through a single external endpoint and/or load balancer. The Ingress resource definition allows them to route traffic to defined Service resources based upon, for example, host and/or prefix rules. Therefore, it complements the Service resource capabilities to provide a flexible method for enabling external access. However, defining an Ingress resource on its own doesn’t actually expose services outside Kubernetes since it simply conveys a request for networking configuration.</p><h2 id=\"the-wizard-behind-the-curtain-ingress-controllers\">The wizard behind the curtain: Ingress Controllers</h2><p>Our discussion thus far has helped highlight the need for ingress resources, but it leaves open the question of how corresponding requests are acted upon. The answer comes in the form of Ingress Controllers which are responsible for consuming inbound requests and creating the corresponding routing specifications in a technology-specific manner. Typically, the specific controller installed in a k8s cluster is selected and deployed by operators. There are many potential options available, but a few illustrative examples include:</p><ul><li>AWS ALB - An instance of an Ingress Controller tied to a specific public cloud, it satisfies inbound Ingress resource requests using <a href=\"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html\">AWS Application Load Balancers</a></li><li>NGINX - Implements Ingress resources using the NGINX open source software</li><li>Traefik - A leading open source <a href=\"https://containous.ghost.io/traefik/\">Kubernetes Ingress Controller</a> that makes setting up routes between Kubernetes services and the outside world simple and reliable</li></ul><p>There need not be a strict either / or decision when it comes to <a href=\"https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/\">choosing Ingress Controllers</a>, and k8s operators can elect to deploy multiple controllers if desired. The selection process should take into consideration the benefits specific controllers like <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> may provide such as:</p><ul><li>Lets Encrypt support for automated certificate management</li><li>Traffic splitting based upon custom weight definitions</li><li>Flexibly route definitions including support for name and path based routing as well as route prioritization</li><li>Custom resource definitions that provide additional controller-specific enhancements</li></ul><p>By integrating controllers that align with their use cases, development teams can enjoy a variety of capabilities provided by Kubernetes for external access without having to become networking experts.</p><p>Want to learn more about <strong>Kubernetes Ingress</strong>? <a href=\"https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes\">Check out this video</a> that describes the <strong>different patterns for deploying external load balancers in Kubernetes.</strong></p>","url":"https://containous.ghost.io/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/","canonical_url":null,"uuid":"f0bf868a-e778-4b14-bfa8-cb19bbf59318","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e9890445df7fe004475aa62","reading_time":4}},{"node":{"id":"Ghost__Post__5dd548aeec5ed3003878884c","title":"13 Key Considerations When Selecting an Ingress Controller for Kubernetes","slug":"13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/13-keys-considerations-ingress.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/c55e2e1f948717dedf6b7ee99f99d704/f3583/13-keys-considerations-ingress.png","srcSet":"/static/c55e2e1f948717dedf6b7ee99f99d704/630fb/13-keys-considerations-ingress.png 300w,\n/static/c55e2e1f948717dedf6b7ee99f99d704/2a4de/13-keys-considerations-ingress.png 600w,\n/static/c55e2e1f948717dedf6b7ee99f99d704/f3583/13-keys-considerations-ingress.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ","custom_excerpt":"Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"October 8, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T14:07:42.000+00:00","published_at":"2019-10-08T14:11:00.000+00:00","updated_at":"2020-05-21T22:06:35.000+00:00","meta_title":"Considerations When Picking an Ingress Controller for Kubernetes","meta_description":"Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#kubernetes-ingress-related-resource","slug":"hash-kubernetes-ingress-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Evaluating Ingress Controllers\nIngresses are critical to any successful Kubernetes (k8s) deployment. Ingresses\nallow you to define how external (and/or internal) traffic is routed to services\nwithin your cluster. The Kubernetes documentation\n[https://kubernetes.io/docs/concepts/services-networking/ingress/] states that:\n\n> “An Ingress can be configured to give Services externally-reachable URLs, load\nbalance traffic, terminate SSL / TLS, and offer name based virtual hosting.”\nHowever, Ingresses themselves don’t do anything — they’re just metadata. The\nheavy lifting is performed by Ingress Controllers. An Ingress without an Ingress\nController won’t do anything. There’s one more catch: while there are a number\nof system controllers (like ReplicaSet Controller, Endpoints Controller,\nNamespace Controller and others) that are managed by the Kubernetes control\nplane, Ingress Controllers are not automatically started with a cluster — you\nhave to install, configure and manage your own Ingress Controllers.\n\nIt’s also possible to have multiple Ingress Controllers in the same cluster. You\ncan divide the “routing space” by using Ingress class annotations, so that each\nIngress knows which Ingress Controller should be handling it. You could end up\nusing a combination of Ingress Controllers for different scenarios within the\nsame cluster. For example, you may have one Ingress Controller for handling\nexternal traffic coming in to the cluster including bindings to SSL\ncertificates, and have another internal Ingress Controller with no SSL binding\nthat handles in-cluster traffic.\n\nThere are scores of Ingress Controllers to choose from. The Kubernetes\ndocumentation has a list of popular Ingress Controllers here\n[https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers]\n.\n\nThese controllers have varied feature sets and varying levels of community or\ncommercial support. Some are “pure” edge routers, while others have features\nmore akin to service meshes.\n\nSelecting the Right Ingress Controller\nSo how do you choose the right Ingress Controller? There are several criteria\nthat are important to consider when doing so. In this post we’re not going to do\na feature comparison between specific Ingress Controllers, since there are many\nhead-to-head comparisons on the internet already, and because there are so many\nIngress Controllers. Rather, we’re going to discuss what features you should be\nweighing when selecting an Ingress Controller.\n\n1/ Traffic Protocol\nAre you just routing HTTP(S), HTTP/2 or websockets? Do you want to route TCP/UDP\nor gRPC? Not all Ingress Controllers support all these protocols, so you’ll have\nto check which protocols an Ingress Controller supports.\n\n2/ Dynamic Configuration Updates\nDo you require zero-downtime configuration changes — often called “hitless\nreloads”? Some Ingress Controllers require downtime in order to update\nconfiguration, while others update dynamically without downtime.\n\n3/ Resiliency\nDo you need rate limiting, retries or circuit breakers at the edge, or have you\nbuilt this functionality into your services yourself? Some Ingress Controllers\nsupport these features, which means you won’t have to code them yourself.\n\n4/ External Load Balancer Integration\nAre you integrating with an external, managed cloud-based load balancer? Make\nsure the Ingress Controller you select integrates well with your external load\nbalancer in order to reduce work and management for your networking team.\n\n5/ Service Mesh\nIngress Controllers can be configured to handle external traffic (traffic\noriginating outside the cluster) or internal traffic or both. If you need to\nobserve or trace internal traffic, you may need a special breed of Ingress\nController — a Service Mesh. Kubernetes provides standards for Service Meshes\nthrough the SMI Specification for interoperability. If you do require a Service\nMesh, make sure you pick the right tool for the right job. Ingress Controllers\nand Service Meshes are not mutually exclusive.\n\n6/ API Gateway\nDo you need an Ingress Controller or an API gateway, or something that does\nboth? Typically API gateways integrate business logic, while edge routers are\ntypically business agnostic. For example, API Gateways let you monitor traffic\nper customer, or measure transactions for billing purposes. If you require\nbusiness logic at the edge, you should probably look at an API gateway instead\nof an Ingress Controller. Just as with Service Meshes, Ingress Controller and\nAPI gateways are not mutually exclusive.\n\n7/ High Availability\nCan you afford downtime when a server restarts for either planned or unplanned\nmaintenance? If so, you need high availability for your Ingress Controller. Not\nall Ingress Controllers support high availability.\n\n8/ Load Balancing Algorithms\nWhat sort of algorithm-based routing do you need? Most Ingress Controllers\nsupport Round Robin, but if you want Least Connection so that the load on your\nservices is taken into account, you’ll need an Ingress Controller that supports\nmore advanced load balancing algorithms.\n\n9/ Advanced Traffic Shifting\nDo you need to perform canary testing (shifting a percentage of traffic to\ndifferent services for progressive exposure)? Load balancing lets you spread the\nload of a service, but not all load balancers can split traffic using more\nsophisticated rules. If you’re testing in production using techniques like\ncanary testing, make sure the Ingress Controller you select supports traffic\nshifting.\n\n10/ Resources Constraints\nAre you cost sensitive as far as resources in your cluster are concerned?\nIngress Controllers can be resource intensive, so if you are cost sensitive,\nyou’re going to be better off with a light-weight Ingress Controller. Some\nIngress Controllers support scaling up and down, while others do not.\n\n11/ Monitoring\nDo you need to integrate with existing metrics and log collection systems? Some\nIngress Controllers offer limited monitoring and logging and may not support\nyour specific monitoring and logging tooling.\n\n12/ Support\nDo you need enterprise support? Open source Ingress Controllers are easy on the\ncheck book, but what happens when you need support in the middle of the night?\nRemember, some open source Ingress Controllers offer enterprise support plans.\n\n13/ Ecosystem\nMake sure the Ingress Controller you are considering has support in the\nKubernetes partner ecosystem.\n\nConclusion\nAs you can see, there are many factors that require thought before you can\nselect the right Ingress Controller for your clusters. Don’t just select a\nhype-driven, popular option — be deliberate about your requirements and then\nevaluate Ingress Controllers according to the criteria we’ve listed. If you do,\nyou’ll have made an informed decision about a very important part of your\ninfrastructure!\n\n [https://info.containo.us/request-white-paper-routing-in-the-cloud]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-106.png\" class=\"kg-image\"></figure><h2 id=\"evaluating-ingress-controllers\">Evaluating Ingress Controllers</h2><p>Ingresses are critical to any successful Kubernetes (k8s) deployment. Ingresses allow you to define how external (and/or internal) traffic is routed to services within your cluster. The Kubernetes <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress/\" rel=\"noopener\">documentation</a> states that:</p><blockquote><em><em>“An Ingress can be configured to give Services externally-reachable URLs, load balance traffic, terminate SSL / TLS, and offer name based virtual hosting.”</em></em></blockquote><p>However, Ingresses themselves don’t do anything — they’re just <em><em>metadata</em></em>. The heavy lifting is performed by <em><em>Ingress Controllers</em></em>. An Ingress without an Ingress Controller won’t do anything. There’s one more catch: while there are a number of system controllers (like ReplicaSet Controller, Endpoints Controller, Namespace Controller and others) that are managed by the Kubernetes control plane, Ingress Controllers are not automatically started with a cluster — you have to install, configure and manage your own Ingress Controllers.</p><p>It’s also possible to have multiple Ingress Controllers in the same cluster. You can divide the “routing space” by using Ingress class annotations, so that each Ingress knows which Ingress Controller should be handling it. You could end up using a combination of Ingress Controllers for different scenarios within the same cluster. For example, you may have one Ingress Controller for handling external traffic coming in to the cluster including bindings to SSL certificates, and have another internal Ingress Controller with no SSL binding that handles in-cluster traffic.</p><p>There are scores of Ingress Controllers to choose from. The Kubernetes documentation has a list of popular Ingress Controllers <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers\" rel=\"noopener\">here</a>.</p><p>These controllers have varied feature sets and varying levels of community or commercial support. Some are “pure” edge routers, while others have features more akin to service meshes.</p><h2 id=\"selecting-the-right-ingress-controller\">Selecting the Right Ingress Controller</h2><p>So how do you choose the right Ingress Controller? There are several criteria that are important to consider when doing so. In this post we’re not going to do a feature comparison between specific Ingress Controllers, since there are many head-to-head comparisons on the internet already, and because there are so many Ingress Controllers. Rather, we’re going to discuss what features you should be weighing when selecting an Ingress Controller.</p><h3 id=\"1-traffic-protocol\">1/ Traffic Protocol</h3><p>Are you just routing HTTP(S), HTTP/2 or websockets? Do you want to route TCP/UDP or gRPC? Not all Ingress Controllers support all these protocols, so you’ll have to check which protocols an Ingress Controller supports.</p><h3 id=\"2-dynamic-configuration-updates\">2/ Dynamic Configuration Updates</h3><p>Do you require zero-downtime configuration changes — often called “hitless reloads”? Some Ingress Controllers require downtime in order to update configuration, while others update dynamically without downtime.</p><h3 id=\"3-resiliency\">3/ Resiliency</h3><p>Do you need rate limiting, retries or circuit breakers at the edge, or have you built this functionality into your services yourself? Some Ingress Controllers support these features, which means you won’t have to code them yourself.</p><h3 id=\"4-external-load-balancer-integration\">4/ External Load Balancer Integration</h3><p>Are you integrating with an external, managed cloud-based load balancer? Make sure the Ingress Controller you select integrates well with your external load balancer in order to reduce work and management for your networking team.</p><h3 id=\"5-service-mesh\">5/ Service Mesh</h3><p>Ingress Controllers can be configured to handle external traffic (traffic originating outside the cluster) or internal traffic or both. If you need to observe or trace internal traffic, you may need a special breed of Ingress Controller — a Service Mesh. Kubernetes provides standards for Service Meshes through the SMI Specification for interoperability. If you do require a Service Mesh, make sure you pick the right tool for the right job. Ingress Controllers and Service Meshes are not mutually exclusive.</p><h3 id=\"6-api-gateway\">6/ API Gateway</h3><p>Do you need an Ingress Controller or an API gateway, or something that does both? Typically API gateways integrate business logic, while edge routers are typically business agnostic. For example, API Gateways let you monitor traffic per customer, or measure transactions for billing purposes. If you require business logic at the edge, you should probably look at an API gateway instead of an Ingress Controller. Just as with Service Meshes, Ingress Controller and API gateways are not mutually exclusive.</p><h3 id=\"7-high-availability\">7/ High Availability</h3><p>Can you afford downtime when a server restarts for either planned or unplanned maintenance? If so, you need high availability for your Ingress Controller. Not all Ingress Controllers support high availability.</p><h3 id=\"8-load-balancing-algorithms\">8/ Load Balancing Algorithms</h3><p>What sort of algorithm-based routing do you need? Most Ingress Controllers support Round Robin, but if you want Least Connection so that the load on your services is taken into account, you’ll need an Ingress Controller that supports more advanced load balancing algorithms.</p><h3 id=\"9-advanced-traffic-shifting\">9/ Advanced Traffic Shifting</h3><p>Do you need to perform canary testing (shifting a percentage of traffic to different services for progressive exposure)? Load balancing lets you spread the load of a service, but not all load balancers can split traffic using more sophisticated rules. If you’re testing in production using techniques like canary testing, make sure the Ingress Controller you select supports traffic shifting.</p><h3 id=\"10-resources-constraints\">10/ Resources Constraints</h3><p>Are you cost sensitive as far as resources in your cluster are concerned? Ingress Controllers can be resource intensive, so if you are cost sensitive, you’re going to be better off with a light-weight Ingress Controller. Some Ingress Controllers support scaling up and down, while others do not.</p><h3 id=\"11-monitoring\">11/ Monitoring</h3><p>Do you need to integrate with existing metrics and log collection systems? Some Ingress Controllers offer limited monitoring and logging and may not support your specific monitoring and logging tooling.</p><h3 id=\"12-support\">12/ Support</h3><p>Do you need enterprise support? Open source Ingress Controllers are easy on the check book, but what happens when you need support in the middle of the night? Remember, some open source Ingress Controllers offer enterprise support plans.</p><h3 id=\"13-ecosystem\">13/ Ecosystem</h3><p>Make sure the Ingress Controller you are considering has support in the Kubernetes partner ecosystem.</p><h2 id=\"conclusion\">Conclusion</h2><p>As you can see, there are many factors that require thought before you can select the right Ingress Controller for your clusters. Don’t just select a hype-driven, popular option — be deliberate about your requirements and then evaluate Ingress Controllers according to the criteria we’ve listed. If you do, you’ll have made an informed decision about a very important part of your infrastructure!</p><!--kg-card-begin: markdown--><p><a href=\"https://info.containo.us/request-white-paper-routing-in-the-cloud\"><img src=\"https://containous.ghost.io/content/images/2019/12/request-white-paper-routing-in-the-cloud.png\" alt=\"request-white-paper-routing-in-the-cloud\"></a></p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/","canonical_url":null,"uuid":"2c5e7ed6-3b40-4690-b39b-772ba9a0f24c","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd548aeec5ed3003878884c","reading_time":4}}]}},"pageContext":{"slug":"kubernetes","limit":9,"skip":9,"numberOfPages":2,"humanPageNumber":2,"prevPageNumber":1,"nextPageNumber":null,"previousPagePath":"/tag/kubernetes/","nextPagePath":null}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}