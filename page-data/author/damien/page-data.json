{"componentChunkName":"component---src-templates-author-tsx","path":"/author/damien/","result":{"data":{"ghostAuthor":{"slug":"damien","name":"Damien Duportal","bio":null,"cover_image":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","location":null,"website":null,"twitter":null,"facebook":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5dce00062345360038abe2aa","title":"Traefik and Docker: A Discussion with Docker Captain, Bret Fisher","slug":"traefik-and-docker-a-discussion-with-docker-captain-bret-fisher-7f0b9a54ff88","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/Traefik-and-Bret-Fisher-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/047a148bb8af5c21fbc2377a71881001/47498/Traefik-and-Bret-Fisher-1.jpg","srcSet":"/static/047a148bb8af5c21fbc2377a71881001/9dc27/Traefik-and-Bret-Fisher-1.jpg 300w,\n/static/047a148bb8af5c21fbc2377a71881001/4fe8c/Traefik-and-Bret-Fisher-1.jpg 600w,\n/static/047a148bb8af5c21fbc2377a71881001/47498/Traefik-and-Bret-Fisher-1.jpg 1200w,\n/static/047a148bb8af5c21fbc2377a71881001/52258/Traefik-and-Bret-Fisher-1.jpg 1800w,\n/static/047a148bb8af5c21fbc2377a71881001/a41d1/Traefik-and-Bret-Fisher-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"During the past summer, we had an interesting discussion about Traefik andDocker with Bret Fisher, the creator of “Docker Mastery” and part of theDocker Captain program.","custom_excerpt":"During the past summer, we had an interesting discussion about Traefik andDocker with Bret Fisher, the creator of “Docker Mastery” and part of theDocker Captain program.","visibility":"public","created_at_pretty":"15 November, 2019","published_at_pretty":"October 22, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-15T01:31:50.000+00:00","published_at":"2019-10-22T08:31:00.000+00:00","updated_at":"2020-05-22T00:45:04.000+00:00","meta_title":"Traefik and Docker: A Discussion with Docker Captain, Bret Fisher","meta_description":"An interesting discussion about Traefik and Docker with Bret Fisher. Read on to learn more about Bret, and his experience using Traefik and Docker.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Community","slug":"community","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Bret Fisher is the creator of “Docker Mastery” and part of the Docker Captain\nprogram.\n\nDuring the past summer, we had an interesting discussion about Traefik\n[/traefik/] and Docker\n[https://events.docker.com/events/details/docker-san-francisco-presents-traefik-v20-in-docker-containerd-updates/] \nwith Bret Fisher, the creator of “Docker Mastery\n[https://www.bretfisher.com/courses/]” and part of the Docker Captain\n[https://www.docker.com/community/captains] program.\n\nWe’d like to share our discussion with you. Read on to learn more about Bret,\nand his experience using Traefik and Docker.\n\n\n--------------------------------------------------------------------------------\n\nContainous: Hi Bret, could you introduce yourself to our community?\n\nBret: Hi, I’m Bret Fisher [https://twitter.com/BretFisher], a freelance DevOps\nand Docker consultant, focused on containers. I’m also a Docker Captain. My time\nis split between teaching, helping students, answering questions.\n\n> I’m driven by having fun while helping people.\nContainous: Could you explain what is a “Docker Captain”?\n\nBret: The “Docker Captain” program is from Docker Inc.. A Docker Captain is like\na Microsoft MVP. You cannot work for Docker Inc., should be an expert on docker\ntools and share your love for containers often. It also gives you access to\npre-release Docker software.\n\nContainous: How did you get into Traefik?\n\nBret: Because of Docker Swarm mode. Even though Kubernetes has become the most\npopular orchestrator, Docker Swarm still solves a lot of problems for many team.\nI was searching for an easy “Ingress” for Docker Swarm and Traefik was\nrecommended by a fellow Docker Captain.\n\n> I liked Traefik because of the Let’s Encrypt support out-of-the box and because\n“It just works”.\nContainous: Where do you use Traefik?\n\nBret: I’m using it on my own website at https://www.bretfisher.com/\n[https://www.bretfisher.com/]. This website runs on Docker Swarm with Traefik. I\nalso recommended Traefik to my customers, and in my talks and workshops. A lot\nof my 120,000 students have ended up using Traefik.\n\nContainous: Let’s talk a bit about container security. Are you running Traefik\nas the user “root”?\n\nBret: Is it the default ? (Laugh). I’m using the official Docker image so I\nguess “yes,” if it is the default user in that container Image.\n\nContainous: Do you see any compensation measure for this?\n\nBret: First of all, I have a list of general container security activities\n[https://github.com/BretFisher/ama/issues/17] that I follow and recommend others\ncheck out. It follows an order of “easiest steps with biggest benefits first” so\nyou don’t spend time on hard security changes that have little overall\nimprovement in your security posture. In addition, consider running Traefik’s\ncontainer in “read-only” mode\n[https://docs.docker.com/engine/reference/commandline/run/#mount-volume--v---read-only]\n. This mode forbids any writing on the filesystem (unless you explicitly define\na volume on an explicit path.). This first step avoids some (but not all!)\ncommon tasks as installing packages or downloading scripts in case of a bad\nactor gaining file system control in the container. Also, you could enable the\nfeature “user namespaces” in the Docker Engine config, to map the root user of\ncontainers to an unprivileged user of the host machines, which I’m a big fan of.\n\nRunning a Traefik container as a non privileged user to avoid being “root” might\ncreate two challenges:\n\n * Listening on ports below 1024: the range of ports [0–1024] are privileged and\n   thus require special capabilities. Either you can bind to port > 1024, or\n   ensure you are able to grant the Linux Capability CAP_NET_BIND_SERVICE to\n   Traefik.\n * Docker socket membership: the socket file in /var/run/docker.sock is owned by\n   the root user, and a group named docker. The unprivileged user of Traefik\n   must be part of the group docker to allow access to the Docker API.\n\nContainous: Speaking about the Docker socket, do you run Traefik on Swarm\nManager Nodes?\n\nBret: It’s not mandatory. The point is — you can always forward the Docker\nsocket through TCP instead of using a bind-mount of /var/run/docker.sock. If you\nforward the socket in TCP inside and encrypted Docker network, then it removes\nthe “run on manager” constraint for Traefik.\n\nPlease note that overlay networks optional encryption is not performed by Docker\nSwarm itself, but rather the Linux kernel (IPSec), ensuring low-level security.\n\nAlso, it’s worthwhile to add an intermediate proxy to control requests through\nthe TCP-forwarded Docker socket, allowing read-only requests to the API.\n\nI have an example Swarm stack YAML of this setup here\n[https://github.com/BretFisher/dogvscat/blob/master/stack-proxy-global.yml].\n\nWith all of these, running Traefik on the host network of worker nodes, with an\noverlay network for backends is totally doable.\n\nContainous: Are you using the Traefik dashboard? If yes, what is your point of\nview on the security of this feature?\n\nTraefik v2 DashboardBret: Yes. I’m using the Traefik dashboard. I tend to configure the dashboard\nwith an IP whitelist, and not exposed on a public network or on the default\nport.\n\nPublicly exposing an admin dashboard keeps happening: just look at situations\nsuch as the Kubernetes dashboard hack at Tesla\n[https://redlock.io/blog/cryptojacking-tesla].\n\nI’m a huge fan of “secure by default” tools, and I wished more tools were like\nDocker and Swarm in this way. Over my 25 years in tech helping many companies\nwith infrastructure, I’ve learned that if authentication and encryption are\noptional, many won’t do it.\n\nContainous: Do you have a recommendation about using the “default” Docker image\nfor Traefik based on “scratch” versus the “Linux Alpine” image? Why?\n\nBret: As a rule of thumb, I would avoid “scratch” (or distroless\n[https://github.com/GoogleContainerTools/distroless]) images until everyone in\nthe pipeline is able to know how to operate it. Size is not important unless\nyou’re operating an IoT business. Compared to the pain and suffering of “no\ntools,” using “scratch” doesn’t feel a good trade-off unless you have\nspecialists on board. The image “scratch” feels like a “Golang developers”\nhabit, but when it comes to the Ops team it’s another topic: What about not\nbeing able to docker exec or kubectl cp?\n\nHopefully, the Kubernetes ephemeral containers\n[https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/] \nfeature will help make this possible for more people.\n\nAs a rule of thumb, for container newcomers, they need to learn by doing. In\nthis case, I wouldn’t use “scratch” here to keep the learning curve smooth.\n\nI also share this opinion about the host OS. Too many people try to use a\n“Container OS” too early in their organisational learning. It tends to add lots\nof risk without a big productivity boost. Stick with your traditional Linux\ndistribution until you’ve had significant production Docker usage.\n\nContainous: What is your recommendation for the load balancer part outside\nSwarm? To create an external load balancer pointing to nodes, using DNS, or\nsomething else? And, why?\n\nBret: The expected answer is “It’s complicated” or ”It depends” (laugh).\n\nMost companies already have their own solution for load balancing, including\ncloud load balancers and datacenter hardware load balancers. Then they point\ntheir load balancer to the Docker Swarm nodes and rely on Traefik for providing\nthe application layer load balancing inside the cluster. Pro Tip: Don’t point\nLB’s to all your Swarm nodes. Pick 2–3 worker nodes and make those the ingress\npoints, which will make troubleshooting and load easier to manage.\n\nHowever, about the “DNS round robin” solution, I refer to it as the “poor\nperson’s LB”, because of the small amount of time required to make it work. It’s\nsimple when the client is a web browser, but as you cannot control the “client”,\nthat’s where the limit is drawn (DNS caching, no retry patterns, etc.). Another\nlimit: as soon as showing HTTP 503 errors is an issue, there is no “retry\npattern” expected from web browsers (even though Traefik could do that). It’s\nthe recommended solution in my course “Solo DevOps” where the context is “only\none person in charge of the DevOps tasks, with so many tools involved”. Once you\nhave an external load balancer solution, it’s likely best to stick with that in\nall but the smallest projects.\n\nAs a general rule, ask yourselves: “During the time it goes down, do you lose\nmoney? If yes, then go for load balancing with health checks.”\n\n> Try both solutions for education purposes. It’s really valuable.\nContainous: Have you tried the new Traefik v2.0\n[/blog/traefik-2-0-6531ec5196c2/]?\n\nBret: Not yet, but it made quite some noise in the Docker Captain channel. It\nmight be the fact that they are “Golang people,” but it looks neat.\n\nContainous: Is there something you would like to tell the Traefik community?\n\nBret: Traefik is a really nice tool because everything is configurable from the\ncommand line when starting in a container (using CMD). TOML files are fine, but\nit’s great to have the option to skip that and configure it dynamically at\nruntime.\n\nAlso, everything is streamlined for the container world, with a linear learning\ncurve: configuration management is not mandatory even for rich features such as\nLet’s Encrypt.\n\nContainous: Thanks a lot for these insights Bret! Happy to have this exchange.\nLet’s meet again for a live session next time!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Bret Fisher is the creator of “Docker Mastery” and part of the Docker Captain program.</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/Traefik-and-Bret-Fisher-1-1.jpg\" class=\"kg-image\"></figure><p>During the past summer, we had an interesting discussion about<a href=\"https://containous.ghost.io/traefik/\"> Traefik</a> and <a href=\"https://events.docker.com/events/details/docker-san-francisco-presents-traefik-v20-in-docker-containerd-updates/\" rel=\"noopener nofollow\">Docker</a> with Bret Fisher, the creator of “<a href=\"https://www.bretfisher.com/courses/\" rel=\"noopener nofollow\">Docker Mastery</a>” and part of the <a href=\"https://www.docker.com/community/captains\" rel=\"noopener nofollow\">Docker Captain</a> program.</p><p>We’d like to share our discussion with you. Read on to learn more about Bret, and his experience using Traefik and Docker.</p><hr><p><strong><strong>Containous: Hi Bret, could you introduce yourself to our community?</strong></strong></p><p><em><em>Bret: </em></em>Hi, I’m<a href=\"https://twitter.com/BretFisher\" rel=\"noopener nofollow\"> Bret Fisher</a>, a freelance DevOps and Docker consultant, focused on containers. I’m also a Docker Captain. My time is split between teaching, helping students, answering questions.</p><blockquote><em>I’m driven by having fun while helping people.</em></blockquote><p><strong><strong>Containous: Could you explain what is a “Docker Captain”?</strong></strong></p><p><em><em>Bret: </em></em>The “Docker Captain” program is from Docker Inc.. A Docker Captain is like a Microsoft MVP. You cannot work for Docker Inc., should be an expert on docker tools and <strong><strong>share</strong></strong> your love for containers often. It also gives you access to pre-release Docker software.</p><p><strong><strong>Containous: How did you get into Traefik?</strong></strong></p><p><em><em>Bret: </em></em>Because of Docker Swarm mode. Even though Kubernetes has become the most popular orchestrator, Docker Swarm still solves a lot of problems for many team. I was searching for an easy “Ingress” for Docker Swarm and Traefik was recommended by a fellow Docker Captain.</p><blockquote><em>I liked Traefik because of the Let’s Encrypt support out-of-the box and because “It just works”.</em></blockquote><p><strong><strong>Containous: Where do you use Traefik?</strong></strong></p><p><em><em>Bret: </em></em>I’m using it on my own website at<a href=\"https://www.bretfisher.com/\" rel=\"noopener nofollow\"> https://www.bretfisher.com/</a>. This website runs on Docker Swarm with Traefik. I also recommended Traefik to my customers, and in my talks and workshops. A lot of my 120,000 students have ended up using Traefik.</p><p><strong><strong>Containous: Let’s talk a bit about container security. Are you running Traefik as the user “root”?</strong></strong></p><p><em><em>Bret: </em></em>Is it the default ? (Laugh). I’m using the official Docker image so I guess “yes,” if it is the default user in that container Image.</p><p><strong><strong>Containous: Do you see any compensation measure for this?</strong></strong></p><p><em><em>Bret: </em></em>First of all, I have a <a href=\"https://github.com/BretFisher/ama/issues/17\" rel=\"noopener nofollow\">list of general container security activities</a> that I follow and recommend others check out. It follows an order of “easiest steps with biggest benefits first” so you don’t spend time on hard security changes that have little overall improvement in your security posture. In addition, consider running Traefik’s container in<a href=\"https://docs.docker.com/engine/reference/commandline/run/#mount-volume--v---read-only\" rel=\"noopener nofollow\"> “read-only” mode</a>. This mode forbids any writing on the filesystem (unless you explicitly define a volume on an explicit path.). This first step avoids some (but not all!) common tasks as installing packages or downloading scripts in case of a bad actor gaining file system control in the container. Also, you could enable the feature “user namespaces” in the Docker Engine config, to map the root user of containers to an unprivileged user of the host machines, which I’m a big fan of.</p><p>Running a Traefik container as a non privileged user to avoid being “root” might create two challenges:</p><ul><li>Listening on ports below 1024: the range of ports [0–1024] are privileged and thus require special capabilities. Either you can bind to port &gt; 1024, or ensure you are able to grant the Linux Capability <code>CAP_NET_BIND_SERVICE </code>to Traefik.</li><li>Docker socket membership: the socket file in /var/run/docker.sock is owned by the root user, and a group named docker. The unprivileged user of Traefik must be part of the group docker to allow access to the Docker API.</li></ul><p><strong><strong>Containous: Speaking about the Docker socket, do you run Traefik on Swarm Manager Nodes?</strong></strong></p><p><em><em>Bret: </em></em>It’s not mandatory. The point is — you can always forward the Docker socket through TCP instead of using a bind-mount of <code>/var/run/docker.sock</code>. If you forward the socket in TCP inside and encrypted Docker network, then it removes the “run on manager” constraint for Traefik.</p><p>Please note that overlay networks optional encryption is not performed by Docker Swarm itself, but rather the Linux kernel (IPSec), ensuring low-level security.</p><p>Also, it’s worthwhile to add an intermediate proxy to control requests through the TCP-forwarded Docker socket, allowing read-only requests to the API.</p><p>I have an <a href=\"https://github.com/BretFisher/dogvscat/blob/master/stack-proxy-global.yml\" rel=\"noopener nofollow\">example Swarm stack YAML of this setup here</a>.</p><p>With all of these, running Traefik on the host network of worker nodes, with an overlay network for backends is totally doable.</p><p><strong><strong>Containous: Are you using the Traefik dashboard? If yes, what is your point of view on the security of this feature?</strong></strong></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/0-kb8q6VKOvrvofb36.png\" class=\"kg-image\" alt=\"Traefik v2 Dashboard\"><figcaption><strong><strong>Traefik v2 Dashboard</strong></strong></figcaption></figure><p><em><em>Bret: </em></em>Yes. I’m using the Traefik dashboard. I tend to configure the dashboard with an IP whitelist, and not exposed on a public network or on the default port.</p><p>Publicly exposing an admin dashboard keeps happening: just look at situations such as the<a href=\"https://redlock.io/blog/cryptojacking-tesla\" rel=\"noopener nofollow\"> Kubernetes dashboard hack at Tesla</a>.</p><p>I’m a huge fan of “secure by default” tools, and I wished more tools were like Docker and Swarm in this way. Over my 25 years in tech helping many companies with infrastructure, I’ve learned that if authentication and encryption are optional, many won’t do it.</p><p><strong><strong>Containous: Do you have a recommendation about using the “default” Docker image for Traefik based on “scratch” versus the “Linux Alpine” image? Why?</strong></strong></p><p><em><em>Bret: </em></em>As a rule of thumb, I would avoid “scratch” (or <a href=\"https://github.com/GoogleContainerTools/distroless\" rel=\"noopener nofollow\">distroless</a>) images until everyone in the pipeline is able to know how to operate it. Size is not important unless you’re operating an IoT business. Compared to the pain and suffering of “no tools,” using “scratch” doesn’t feel a good trade-off unless you have specialists on board. The image “scratch” feels like a “Golang developers” habit, but when it comes to the Ops team it’s another topic: What about not being able to <code>docker exec</code> or <code>kubectl cp</code>?</p><p>Hopefully, the <a href=\"https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/\" rel=\"noopener nofollow\">Kubernetes ephemeral containers</a> feature will help make this possible for more people.</p><p>As a rule of thumb, for container newcomers, they need to learn by doing. In this case, I wouldn’t use “scratch” here to keep the learning curve smooth.</p><p>I also share this opinion about the host OS. Too many people try to use a “Container OS” too early in their organisational learning. It tends to add lots of risk without a big productivity boost. Stick with your traditional Linux distribution until you’ve had significant production Docker usage.</p><p><strong><strong>Containous: What is your recommendation for the load balancer part outside Swarm? To create an external load balancer pointing to nodes, using DNS, or something else? And, why?</strong></strong></p><p><em><em>Bret: </em></em>The expected answer is “It’s complicated” or ”It depends” (laugh).</p><p>Most companies already have their own solution for load balancing, including cloud load balancers and datacenter hardware load balancers. Then they point their load balancer to the Docker Swarm nodes and rely on Traefik for providing the application layer load balancing inside the cluster. Pro Tip: Don’t point LB’s to all your Swarm nodes. Pick 2–3 worker nodes and make those the ingress points, which will make troubleshooting and load easier to manage.</p><p>However, about the “DNS round robin” solution, I refer to it as the “poor person’s LB”, because of the small amount of time required to make it work. It’s simple when the client is a web browser, but as you cannot control the “client”, that’s where the limit is drawn (DNS caching, no retry patterns, etc.). Another limit: as soon as showing HTTP 503 errors is an issue, there is no “retry pattern” expected from web browsers (even though Traefik could do that). It’s the recommended solution in my course “Solo DevOps” where the context is “only one person in charge of the DevOps tasks, with so many tools involved”. Once you have an external load balancer solution, it’s likely best to stick with that in all but the smallest projects.</p><p>As a general rule, ask yourselves: “During the time it goes down, do you lose money? If yes, then go for load balancing with health checks.”</p><blockquote><em>Try both solutions for education purposes. It’s really valuable.</em></blockquote><p><strong><strong>Containous: Have you tried the new<a href=\"https://containous.ghost.io/blog/traefik-2-0-6531ec5196c2/\"> Traefik v2.0</a>?</strong></strong></p><p><em><em>Bret: </em></em>Not yet, but it made quite some noise in the Docker Captain channel. It might be the fact that they are “Golang people,” but it looks neat.</p><p><strong><strong>Containous: Is there something you would like to tell the Traefik community?</strong></strong></p><p><em><em>Bret: </em></em>Traefik is a really nice tool because everything is configurable from the command line when starting in a container (using CMD). TOML files are fine, but it’s great to have the option to skip that and configure it dynamically at runtime.</p><p>Also, everything is streamlined for the container world, with a linear learning curve: configuration management is not mandatory even for rich features such as Let’s Encrypt.</p><p><strong><strong>Containous: Thanks a lot for these insights Bret! Happy to have this exchange. Let’s meet again for a live session next time!</strong></strong></p>","url":"https://containous.ghost.io/blog/traefik-and-docker-a-discussion-with-docker-captain-bret-fisher-7f0b9a54ff88/","canonical_url":null,"uuid":"aa3d6be3-2d32-46bf-961c-0c347dfb8bbc","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dce00062345360038abe2aa","reading_time":6}},{"node":{"id":"Ghost__Post__5dd54eefec5ed30038788910","title":"Announcing Maesh, a Lightweight and Simpler Service Mesh Made by the Traefik Team","slug":"announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/maesh.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/14e5db97752eac82720eec1f0b64d421/f3583/maesh.png","srcSet":"/static/14e5db97752eac82720eec1f0b64d421/630fb/maesh.png 300w,\n/static/14e5db97752eac82720eec1f0b64d421/2a4de/maesh.png 600w,\n/static/14e5db97752eac82720eec1f0b64d421/f3583/maesh.png 1200w,\n/static/14e5db97752eac82720eec1f0b64d421/bbee5/maesh.png 1800w,\n/static/14e5db97752eac82720eec1f0b64d421/0ef64/maesh.png 2400w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"We are proud to introduce Maesh, Containous’ new service mesh designed from the ground up to be straightforward, easy to install and easy to use...","custom_excerpt":"We are proud to introduce Maesh, Containous’ new service mesh designed from the ground up to be straightforward, easy to install and easy to use...","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"September 4, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T14:34:23.000+00:00","published_at":"2019-09-04T14:36:00.000+00:00","updated_at":"2020-05-21T23:51:21.000+00:00","meta_title":"Announcing Maesh, a Lightweight and Simpler Service Mesh","meta_description":"We are proud to introduce Maesh, Containous’ new service mesh designed from the ground up to be straightforward, easy to install and easy to use...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"We are proud to introduce Maesh [/maesh/], Containous’ new service mesh designed\nfrom the ground up to be straightforward, easy to install and easy to use. Maesh\nallows for visibility and management of the traffic that flows inside your\nKubernetes cluster, which is just as important as the ingress and egress\ntraffic.\n\nBuilt on top of Traefik, Maesh is a simple, yet full-featured service mesh. It\nis container-native and fits as your de-facto service mesh in your Kubernetes\ncluster. It supports the latest Service Mesh Interface specification (SMI\n[https://smi-spec.io/]) that facilitates integration with pre-existing\nsolutions. Moreover, Maesh is opt-in by default, which means that your existing\nservices are unaffected until you decide to add them to the mesh.\n\nNon-Invasive Service Mesh\nMaesh does not use any sidecar container but handles routing through proxy\nendpoints running on each node. The mesh controller runs in a dedicated pod and\nhandles all the configuration parsing and deployment to the proxy nodes. Maesh\nsupports multiple configuration options: annotations on user service objects,\nand SMI objects. Not using sidecars means that Maesh does not modify your\nKubernetes objects, and does not modify your traffic without your knowledge.\nUsing the Maesh endpoints is all that is required.\n\nMaesh ArchitectureRelies on Kubernetes DNS\nMaesh leverages the CoreDNS platform installed by default in Kubernetes. It\nallows users to use the Maesh endpoints (instead of the standard Kubernetes\nservice endpoints) to benefit from its feature set — no sidecars! Maesh\nendpoints run side-by-side with user services: you choose whether you use them\nor not (opt-in). This gives more confidence, since users know that they are able\nto test, and revert back to the user services: they should be happy with the\nresult.\n\nAlso, the updates to CoreDNS made during the installation of Maesh is minimal\nand non-invasive, and is easily removable.\n\nMultiple Network Layers\nMaesh can run in both TCP and HTTP mode\n\n * In HTTP mode, Maesh leverages Traefik’s feature set to enable rich routing on\n   virtual-host, path, headers, cookies.\n * Using TCP mode allows a seamless and easy integration with SNI routing\n   support.\n\nUse both modes at the same time within the same cluster, and is configurable via\nannotations on services.\n\nBuilt on Top of Traefik\nMaesh builds on top of Traefik [/traefik/], the leading reverse proxy for\nrouting, and provides every feature users would expect: OpenTracing, load\nbalancing for HTTP, gRPC, WebSocket, TCP, rich routing rules, retries and\nfail-overs, not to mention access controls, rate limits, and circuit breakers.\n\nEasy to Install; Easy to Use\nInstalling Maesh to your cluster is easy: install the Helm chart, as there are\nno helper applications, no CRDs to install, and no new vocabulary for users to\nlearn. If users understand how pods and services work, then Maesh will be easy\nto understand and use.\n\nLet’s get started by installing Maesh using the following commands:\n\nhelm repo add maesh https://containous.github.io/maesh/charts\nhelm repo update\nhelm install --name=maesh --namespace=maesh maesh/maesh\n\nMaesh is now ready to use in your cluster, and you’re one annotation away from\nusing it on any running application:\n\nkubectl annotate service \\\n    web-application maesh.containo.us/traffic-type=http\n\nIs your application using a TCP communication protocol (which is not HTTP)? It\nis also supported:\n\nkubectl annotate service mongo-database \\\n    maesh.containo.us/traffic-type=tcp\n\nThat’s how easy it is to install and use Maesh!\n\nWhat’s Next\nBecause Maesh is open source, we would love the community’s input as to which\nfeatures are important to you, so that we can prioritise the top requests.\n\nWe welcome community contributions and love when they are faster than us to\nprovide additional features! Pull requests are the best way to support the\nproduct and make it your own.\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-110.png\" class=\"kg-image\"></figure><p>We are proud to introduce <a href=\"https://containous.ghost.io/maesh/\">Maesh</a>, Containous’ new service mesh designed from the ground up to be straightforward, easy to install and easy to use. Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic.</p><p>Built on top of Traefik, Maesh is a simple, yet full-featured service mesh. It is container-native and fits as your de-facto service mesh in your Kubernetes cluster. It supports the latest Service Mesh Interface specification (<a href=\"https://smi-spec.io/\" rel=\"noopener\">SMI</a>) that facilitates integration with pre-existing solutions. Moreover, Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.</p><h2 id=\"non-invasive-service-mesh\">Non-Invasive Service Mesh</h2><p>Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Maesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Maesh does not modify your Kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-10.png\" class=\"kg-image\"><figcaption>Maesh Architecture</figcaption></figure><h2 id=\"relies-on-kubernetes-dns\">Relies on Kubernetes DNS</h2><p>Maesh leverages the CoreDNS platform installed by default in Kubernetes. It allows users to use the Maesh endpoints (instead of the standard Kubernetes service endpoints) to benefit from its feature set — no sidecars! Maesh endpoints run side-by-side with user services: you choose whether you use them or not (opt-in). This gives more confidence, since users know that they are able to test, and revert back to the user services: they should be happy with the result.</p><p>Also, the updates to CoreDNS made during the installation of Maesh is minimal and non-invasive, and is easily removable.</p><h2 id=\"multiple-network-layers\">Multiple Network Layers</h2><p>Maesh can run in both TCP and HTTP mode</p><ul><li>In HTTP mode, Maesh leverages Traefik’s feature set to enable rich routing on virtual-host, path, headers, cookies.</li><li>Using TCP mode allows a seamless and easy integration with SNI routing support.</li></ul><p>Use both modes at the same time within the same cluster, and is configurable via annotations on services.</p><h2 id=\"built-on-top-of-traefik\">Built on Top of Traefik</h2><p>Maesh builds on top of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, the leading reverse proxy for routing, and provides every feature users would expect: OpenTracing, load balancing for HTTP, gRPC, WebSocket, TCP, rich routing rules, retries and fail-overs, not to mention access controls, rate limits, and circuit breakers.</p><h2 id=\"easy-to-install-easy-to-use\">Easy to Install; Easy to Use</h2><p>Installing Maesh to your cluster is easy: install the Helm chart, as there are no helper applications, no CRDs to install, and no new vocabulary for users to learn. If users understand how pods and services work, then Maesh will be easy to understand and use.</p><p>Let’s get started by installing Maesh using the following commands:</p><pre><code class=\"language-shell\">helm repo add maesh https://containous.github.io/maesh/charts\nhelm repo update\nhelm install --name=maesh --namespace=maesh maesh/maesh</code></pre><p>Maesh is now ready to use in your cluster, and you’re one annotation away from using it on any running application:</p><pre><code class=\"language-shell\">kubectl annotate service \\\n    web-application maesh.containo.us/traffic-type=http</code></pre><p>Is your application using a TCP communication protocol (which is not HTTP)? It is also supported:</p><pre><code class=\"language-shell\">kubectl annotate service mongo-database \\\n    maesh.containo.us/traffic-type=tcp</code></pre><p>That’s how easy it is to install and use Maesh!</p><h2 id=\"what-s-next\">What’s Next</h2><p>Because Maesh is open source, we would love the community’s input as to which features are important to you, so that we can prioritise the top requests.</p><p>We welcome community contributions and love when they are faster than us to provide additional features! Pull requests are the best way to support the product and make it your own.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\" rel=\"noopener\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\" rel=\"noopener\">Community Forum</a></li></ul>","url":"https://containous.ghost.io/blog/announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29/","canonical_url":null,"uuid":"3100e2c8-491b-40da-a686-6e372e6d1979","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd54eefec5ed30038788910","reading_time":3}},{"node":{"id":"Ghost__Post__5dd553eaec5ed30038788992","title":"From Zero to Hero in Minutes with Konvoy’s Built-In Traefik for Kubernetes","slug":"from-zero-to-hero-in-minutes-with-konvoys-built-in-traefik-for-kubernetes-11577fdeeb14","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/d2iq.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/57b06de950e215169b9335c2c7d6fe56/47498/d2iq.jpg","srcSet":"/static/57b06de950e215169b9335c2c7d6fe56/9dc27/d2iq.jpg 300w,\n/static/57b06de950e215169b9335c2c7d6fe56/4fe8c/d2iq.jpg 600w,\n/static/57b06de950e215169b9335c2c7d6fe56/47498/d2iq.jpg 1200w,\n/static/57b06de950e215169b9335c2c7d6fe56/52258/d2iq.jpg 1800w,\n/static/57b06de950e215169b9335c2c7d6fe56/53d6a/d2iq.jpg 1950w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Konvoy, from D2iQ, provides a complete out-of-the-box experience of production-ready Kubernetes.\nIt is a tool for provisioning pure Kubernetes clusters...","custom_excerpt":"Konvoy, from D2iQ, provides a complete out-of-the-box experience of production-ready Kubernetes.\nIt is a tool for provisioning pure Kubernetes clusters...","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"August 8, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-20T14:55:38.000+00:00","published_at":"2019-08-08T14:55:00.000+00:00","updated_at":"2020-05-22T00:15:26.000+00:00","meta_title":"From Zero to Hero with Konvoy’s Built-In Traefik for Kubernetes","meta_description":"Konvoy provides a complete out-of-the-box experience of production-ready Kubernetes. It is a tool for provisioning pure Kubernetes clusters","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Partners","slug":"partners","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Konvoy [https://d2iq.com/solutions/ksphere/konvoy], from D2iQ, provides a\ncomplete out-of-the-box experience of production-ready Kubernetes.\n\nIt is a tool for provisioning pure Kubernetes clusters, based on a set of Cloud\nNative Computing Foundation (CNCF) and community-contributed components. This\nKubernetes distribution provides a set of pre-installed components to get you\nstarted immediately.\n\nWe’re delighted to announce that Traefik [/traefik/], the popular open source\ncloud native edge router, integrates with Konvoy.\n\nClick to continue reading…\n[https://d2iq.com/blog/from-zero-to-hero-in-minutes-with-konvoy-s-built-in-traefik-for-kubernetes]\n\nWelcome To Konvoy Ops Dashboard: Traefik is already there!","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-111.png\" class=\"kg-image\"></figure><p><a href=\"https://d2iq.com/solutions/ksphere/konvoy\" rel=\"noopener\">Konvoy</a>, from D2iQ, provides a complete out-of-the-box experience of production-ready Kubernetes.</p><p>It is a tool for provisioning pure Kubernetes clusters, based on a set of Cloud Native Computing Foundation (CNCF) and community-contributed components. This Kubernetes distribution provides a set of pre-installed components to get you started immediately.</p><p>We’re delighted to announce that <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, the popular open source cloud native edge router, integrates with Konvoy.</p><p><a href=\"https://d2iq.com/blog/from-zero-to-hero-in-minutes-with-konvoy-s-built-in-traefik-for-kubernetes\" rel=\"noopener\">Click to continue reading…</a></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-13.png\" class=\"kg-image\"><figcaption>Welcome To Konvoy Ops Dashboard: Traefik is already there!</figcaption></figure>","url":"https://containous.ghost.io/blog/from-zero-to-hero-in-minutes-with-konvoys-built-in-traefik-for-kubernetes-11577fdeeb14/","canonical_url":null,"uuid":"168418c1-96a7-4a33-a812-57808b935115","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd553eaec5ed30038788992","reading_time":1}},{"node":{"id":"Ghost__Post__5dd7badbf1db6f0038c74299","title":"The Journey to Traefik Enterprise Edition: Smooth Operations","slug":"the-journey-to-traefik-enterprise-edition-smooth-operations-2591bb7ff1fe","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/smooth-ops.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/3e8dd3b9ae78318437039481a8ed57fb/f3583/smooth-ops.png","srcSet":"/static/3e8dd3b9ae78318437039481a8ed57fb/630fb/smooth-ops.png 300w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/2a4de/smooth-ops.png 600w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/f3583/smooth-ops.png 1200w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/bbee5/smooth-ops.png 1800w,\n/static/3e8dd3b9ae78318437039481a8ed57fb/7b560/smooth-ops.png 1931w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Welcome to the fifth step of our journey towards Traefik Enterprise Edition.\nThis post focuses on the experience of operating TraefikEE...","custom_excerpt":"Welcome to the fifth step of our journey towards Traefik Enterprise Edition.\nThis post focuses on the experience of operating TraefikEE...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"March 18, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T10:39:23.000+00:00","published_at":"2019-03-18T10:39:00.000+00:00","updated_at":"2020-05-21T23:40:43.000+00:00","meta_title":"The Journey to Traefik Enterprise Edition: Smooth Operations","meta_description":"Welcome to the fifth step of our journey towards Traefik Enterprise Edition.\nThis post focuses on the experience of operating TraefikEE...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the fifth step of our journey towards Traefik Enterprise Edition\n[/traefikee/].\n\nThis post focuses on the experience of operating TraefikEE using the \ntraefikeectl command line. You should already feel at ease with TraefikEE’s\none-line installation and concepts. If you are not, then you can check the\nprevious posts of the “Journey to TraefikEE:”\n\n * Join the“Early Access” Program\n   [/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/]\n * Product Evaluation\n   [/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/]\n * High Availability\n   [/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n * HTTPS for Everyone\n   [/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/]\n\nToday, we’ll focus on traefikeectl, the command-line tool used to install,\nconfigure and operate all your TraefikEE installations, in a lean and repeatable\nway, independently of your platform.\n\nOne Command-Line to Rule Them All\n> (A voice in the background): I used Traefik because it’s really simple to use.\nI’m interested by TraefikEE for its high availability features. But distributed\nsystems are really hard. How to deal with this intrinsic complexity?\n> Containous: Let us introduce traefikeectl (also known as “TraefikEE-cuddle”),\nthe command-line tool which abstracts most of this complexity.\nTraefikEE is designed from the ground up to be platform agnostic. From\ninstallation to any operation, the workflow is the same on each platform.\n\nAll the operations are managed by the command line traefikeectl following this\nworkflow, whichever platform you are using:\n\n * Install Phase: Installs a TraefikEE cluster (with traefikeectl install or\n   manually),\n * Connect Phase: Make your local traefikeectl aware of an existing TraefikEE\n   cluster allowing multi-cluster management,\n * Deploy Phase: Deploy a “routing configuration” to this TraefikEE instance.\n\nInstall Phase\nPlatform-Specific\nDo you remember the “One Line Installation for Kubernetes”\n[/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/] \nfrom previous posts (and the related documentation [https://docs.containo.us])?\n\ntraefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n  # ...\n\nWhat if you want to install on a Docker Swarm cluster instead?\n\nWell, the answer is to use the flag —-swarm instead of --kubernetes , as\ndescribed on the “One Line Installation guide for Swarm”:\n\ntraefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --swarm\n  # ...\n\nEach “agnostic” feature is then provided by the commandtraefikeectl when\nrequired, as --kubernetes.namespace or --swarm.networkname .\n\nCustomize Installation\nWe’ll now dig on how to customize installation for Kubernetes.\n\n> (A voice in the background): We are not able to use traefikeectl for\ninstallation in our Kubernetes cluster, because the default configuration does\nnot fit our needs.\n> Containous: The install command of traefikeectl allows you to customize\ninstallation. With Kubernetes, you can provide a YAML file to specify custom\nvalues.\nFollowing the reference values from the documentation, let’s consider that you\nwant to specify the following elements during the installation:\n\n * A custom URL for accessing the dashboard, as \n   http(s)://private.mycompany.org/traefikee,\n * Limiting the resources used for each node to 2Gb of memory and 2 CPUs (See\n   the article “Managing Compute Resources for Containers\n   [https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/]\n   ” Kubernetes Documentation for reference).\n\nBefore installation, create the following YAML file to specify these values:\n\n## File \"traefikee-values.yaml\"\n\n# Expose dashboard at http(s)://private.mycompany.org/traefikee\ndashboard:\n  host: \"private.mycompany.org\"\n  path: \"/traefikee\"\n\n# Restrict resources usage for each TraefikEE node\nresources:\n  cpus: \"2\"\n  memory: \"2G\"\n\nYou can now proceed to the “One Line Installation”, by adding the flag \n--kubernetes.helmvaluespath to use the YAML value file:\n\ntraefikeectl install --kubernetes \\\n  --licensekey=XXXXXXX \\\n  --dashboard \\\n  --kubernetes.helmvaluespath=./traefikee-values.yaml\n\nAs no one is perfect, traefikeectl might not provide some specific settings\nrequired for your platform to work correctly. In this case, you still can “patch\n[https://kubernetes.io/docs/reference/kubectl/cheatsheet/#patching-resources]” , \n“edit”\n[https://kubernetes.io/docs/reference/kubectl/cheatsheet/#editing-resources] or\neven “annotate”\n[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#annotate] \nthe Kubernetes resources created by traefikee install.\n\nConnect Phase\nThe next step is to ensure that your traefikeectl command has knowledge of the\ncluster you want to operate.\n\n> Please note that this step is not required if you used a “One Line Installation”\nwith traefikeectl install, as it is automatically done.\nThe scenario is the following:\n\n * A TraefikEE cluster, designated astraefikee-staging, is running on your\n   remote Kubernetes platform, in the namespace traefikee-ingress,\n * You want to set up an administration machine (your computer, a freshly\n   onboarded team member, etc.) to operate this cluster,\n * This machine is already configured to reach the Kubernetes cluster.\n\nThe connect phase is easy:\n\ntraefikeectl connect --clustername=traefikee-staging \\\n  --kubernetes \\\n  --kubernetes.namespace=traefikee-ingress\n\nThat’s all: traefikeectl is now aware of this cluster and can operate it:\n\n\ntraefikeectl list-nodes\n\ntraefikeectl logs\n\n# ...\n\nUnder the hood, traefikeectl stored the cluster connection information in a TOML\nfile named after the cluster name. These files are located in ${TRAEFIKEE_HOME},\nwhich defaults to the directory ${HOME}/.config/traefikee (XDG_CONFIG folder\n[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html]).\n\n> Please note that if you do not provide the option --clustername , the default\nvalue traefikee is used.\nIt means that you can manage multiple TraefikEE clusters from the same \ntraefikeectl, so you are free to split per environment (staging/production, or\nevent external/internal, etc.).\n\nDeploy Phase\nThe last step of the workflow is to deploy a “routing configuration”.\n\n> (A voice in the background): We followed the previous blog post, and we were\nable to install TraefikEE on our platform. Now, we want to enable HTTPS and\nMetrics collection with Prometheus [https://prometheus.io/]. Do we have to\ninstall the cluster again to update the configuration as we did for Traefik?\n> Containous: Fortunately, you don’t have to reinstall the cluster. Unlike\nTraefik, TraefikEE lets you update the configuration at runtime.\nLet’s say that you want to set up TraefikEE with the following routing\nconfiguration:\n\n * Enable TLS termination on the port 443 (defining a new “entrypoint” named \n   https),\n * Auto-generate TLS certificates using Let’s Encrypt for this new https \n   “entrypoint” . The host names for these certificates are determined from the\n   backend applications (either Ingresses on Kubernetes or labels on Docker\n   Swarm),\n * Enable the Prometheus metric exporter,\n * Enable redirection from http to https for any incoming request.\n\nWith Traefik, you would have passed the following options (and restarted Traefik\nto apply the configuration):\n\n## Traefik Configuration References:\n# Entrypoints: https://docs.traefik.io/configuration/entrypoints/\n# Metrics: https://docs.traefik.io/configuration/metrics/\n# ACME/Let's Encrypt: https://docs.traefik.io/configuration/acme/\n\ntraefik --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true \\\n  --metrics.prometheus\n\nWith TraefikEE, the same configuration is passed to the traefikeectl deploy \ncommand. It’s sent to the TraefikEE control plane through the traefikeectl API,\nstored on the TraefikEE Control Plane and then applied to all the TraefikEE Data\nNodes (which are hot-reloaded).\n\ntraefikeectl deploy --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true \\\n  --metrics.prometheus\n\nIf you prefer using TOML file instead of command-line flags:\n\n# File \"traefik.toml\"\n\ndefaultEntryPoints = [\"https\",\"http\"]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \":80\"\n    [entryPoints.http.redirect]\n    entryPoint = \"https\"\n  [entryPoints.https]\n  address = \":443\"\n  [entryPoints.https.tls]\n\n[kubernetes]\n\n[acme]\nemail = \"damien@containo.us\"\nstorage = \"acme.json\"\nentryPoint = \"https\"\nonHostRule = true\n[acme.tlsChallenge]\n\ntraefikeectl deploy --configfile=./traefik.toml\n\n\n--------------------------------------------------------------------------------\n\nThat’s all for today: we installed a customized cluster, connected a remote\nmachine to operate with traefikeectl, and deployed the same configuration as the\none you could have used for Traefik, but without taking down the cluster, and\nwithout loosing any requests!\n\nYou can learn more about the traefikeectl command line on the reference\ndocumentation [https://docs.containo.us/installing/teectl-cli/].","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-7.png\" class=\"kg-image\"></figure><p>Welcome to the fifth step of our journey towards <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition</a>.</p><p>This post focuses on the experience of operating TraefikEE using the <code>traefikeectl</code> command line. You should already feel at ease with TraefikEE’s one-line installation and concepts. If you are not, then you can check the previous posts of the “Journey to TraefikEE:”</p><ul><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/\">Join the“Early Access” Program</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">Product Evaluation</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">High Availability</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/\">HTTPS for Everyone</a></em></em></li></ul><p>Today, we’ll focus on <code>traefikeectl</code>, the command-line tool used to install, configure and operate all your TraefikEE installations, in a lean and repeatable way, independently of your platform.</p><h2 id=\"one-command-line-to-rule-them-all\">One Command-Line to Rule Them All</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-38.png\" class=\"kg-image\"></figure><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I used Traefik because it’s really simple to use. I’m interested by TraefikEE for its high availability features. But distributed systems are really hard. How to deal with this intrinsic complexity?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Let us introduce <code><em>traefikeectl</em></code> (also known as “TraefikEE-cuddle”), the command-line tool which abstracts most of this complexity.</em></em></blockquote><p>TraefikEE is designed from the ground up to be platform agnostic. From installation to any operation, the workflow is the same on each platform.</p><p>All the operations are managed by the command line <code>traefikeectl</code> following this workflow, whichever platform you are using:</p><ul><li><strong><strong>Install Phase:</strong></strong> Installs a TraefikEE cluster (with <code>traefikeectl install</code> or manually),</li><li><strong><strong>Connect Phase: </strong></strong>Make your local <code>traefikeectl</code> aware of an existing TraefikEE cluster allowing multi-cluster management,</li><li><strong><strong>Deploy Phase:</strong></strong> Deploy a “routing configuration” to this TraefikEE instance.</li></ul><h2 id=\"install-phase\">Install Phase</h2><h3 id=\"platform-specific\">Platform-Specific</h3><p>Do you remember the <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">“One Line Installation for Kubernetes”</a> from previous posts (and the <a href=\"https://docs.containo.us\">related documentation</a>)?</p><pre><code class=\"language-shell\">traefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n  # ...</code></pre><p>What if you want to install on a Docker Swarm cluster instead?</p><p>Well, the answer is to use the flag <code>—-swarm</code> instead of <code>--kubernetes</code> , as described on the “One Line Installation guide for Swarm”:</p><pre><code class=\"language-shell\">traefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --swarm\n  # ...</code></pre><p>Each “agnostic” feature is then provided by the command<code>traefikeectl</code> when required, as <code>--kubernetes.namespace</code> or <code>--swarm.networkname</code> .</p><h3 id=\"customize-installation\">Customize Installation</h3><p>We’ll now dig on how to customize installation for Kubernetes.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> We are not able to use <code><em>traefikeectl</em></code> for installation in our Kubernetes cluster, because the default configuration does not fit our needs.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> The <code><em>install</em></code> command of <code><em>traefikeectl</em></code> allows you to customize installation. With Kubernetes, you can provide a YAML file to specify custom values.</em></em></blockquote><p>Following the reference values from the documentation, let’s consider that you want to specify the following elements during the installation:</p><ul><li>A custom URL for accessing the dashboard, as <code>http(s)://private.mycompany.org/traefikee</code>,</li><li>Limiting the resources used for each node to <code>2Gb</code> of memory and <code>2 CPUs</code> (See the article “<a href=\"https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/\" rel=\"noopener\">Managing Compute Resources for Containers</a>” Kubernetes Documentation for reference).</li></ul><p>Before installation, create the following YAML file to specify these values:</p><pre><code class=\"language-yaml\">## File \"traefikee-values.yaml\"\n\n# Expose dashboard at http(s)://private.mycompany.org/traefikee\ndashboard:\n  host: \"private.mycompany.org\"\n  path: \"/traefikee\"\n\n# Restrict resources usage for each TraefikEE node\nresources:\n  cpus: \"2\"\n  memory: \"2G\"</code></pre><p>You can now proceed to the “One Line Installation”, by adding the flag <code>--kubernetes.helmvaluespath</code> to use the YAML value file:</p><pre><code class=\"language-shell\">traefikeectl install --kubernetes \\\n  --licensekey=XXXXXXX \\\n  --dashboard \\\n  --kubernetes.helmvaluespath=./traefikee-values.yaml</code></pre><p>As no one is perfect, <code>traefikeectl</code> might not provide some specific settings required for your platform to work correctly. In this case, you still can “<a href=\"https://kubernetes.io/docs/reference/kubectl/cheatsheet/#patching-resources\" rel=\"noopener\">patch</a>” , <a href=\"https://kubernetes.io/docs/reference/kubectl/cheatsheet/#editing-resources\" rel=\"noopener\">“edit”</a> or even <a href=\"https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#annotate\" rel=\"noopener\">“annotate”</a> the Kubernetes resources created by <code>traefikee install</code>.</p><h2 id=\"connect-phase\">Connect Phase</h2><p>The next step is to ensure that your <code>traefikeectl</code> command has knowledge of the cluster you want to operate.</p><blockquote><em><em>Please note that this step is not required if you used a “One Line Installation” with <code>traefikeectl install</code>, as it is automatically done.</em></em></blockquote><p>The scenario is the following:</p><ul><li>A TraefikEE cluster, designated as<code>traefikee-staging</code>, is running on your remote Kubernetes platform, in the namespace <code>traefikee-ingress</code>,</li><li>You want to set up an administration machine (your computer, a freshly onboarded team member, etc.) to operate this cluster,</li><li>This machine is already configured to reach the Kubernetes cluster.</li></ul><p>The connect phase is easy:</p><pre><code class=\"language-shell\">traefikeectl connect --clustername=traefikee-staging \\\n  --kubernetes \\\n  --kubernetes.namespace=traefikee-ingress</code></pre><p>That’s all: <code>traefikeectl</code> is now aware of this cluster and can operate it:</p><pre><code class=\"language-shell\">\ntraefikeectl list-nodes\n\ntraefikeectl logs\n\n# ...</code></pre><p>Under the hood, <code>traefikeectl</code> stored the cluster connection information in a TOML file named after the cluster name. These files are located in <code>${TRAEFIKEE_HOME}</code>, which defaults to the directory <code>${HOME}/.config/traefikee</code> (<a href=\"https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\" rel=\"noopener\">XDG_CONFIG folder</a>).</p><blockquote><em><em>Please note that if you do not provide the option <code>--clustername</code> , the default value <code>traefikee</code> is used.</em></em></blockquote><p>It means that you can manage multiple TraefikEE clusters from the same <code>traefikeectl</code>, so you are free to split per environment (staging/production, or event external/internal, etc.).</p><h2 id=\"deploy-phase\">Deploy Phase</h2><p>The last step of the workflow is to deploy a “routing configuration”.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> We followed the previous blog post, and we were able to install TraefikEE on our platform. Now, we want to enable HTTPS and Metrics collection with <a href=\"https://prometheus.io/\" rel=\"noopener\">Prometheus</a>. Do we have to install the cluster again to update the configuration as we did for Traefik?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Fortunately, you don’t have to reinstall the cluster. Unlike Traefik, TraefikEE lets you update the configuration at runtime.</em></em></blockquote><p>Let’s say that you want to set up TraefikEE with the following routing configuration:</p><ul><li>Enable TLS termination on the port 443 (defining a new “entrypoint” named <code>https</code>),</li><li>Auto-generate TLS certificates using Let’s Encrypt for this new <code>https</code> “entrypoint” . The host names for these certificates are determined from the backend applications (either Ingresses on Kubernetes or labels on Docker Swarm),</li><li>Enable the Prometheus metric exporter,</li><li>Enable redirection from <code>http</code> to <code>https</code> for any incoming request.</li></ul><p>With Traefik, you would have passed the following options (and restarted Traefik to apply the configuration):</p><pre><code class=\"language-shell\">## Traefik Configuration References:\n# Entrypoints: https://docs.traefik.io/configuration/entrypoints/\n# Metrics: https://docs.traefik.io/configuration/metrics/\n# ACME/Let's Encrypt: https://docs.traefik.io/configuration/acme/\n\ntraefik --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true \\\n  --metrics.prometheus</code></pre><p>With TraefikEE, the same configuration is passed to the <code>traefikeectl deploy</code> command. It’s sent to the TraefikEE control plane through the traefikeectl API, stored on the TraefikEE Control Plane and then applied to <strong><strong>all</strong></strong> the TraefikEE Data Nodes (which are hot-reloaded).</p><pre><code class=\"language-shell\">traefikeectl deploy --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true \\\n  --metrics.prometheus</code></pre><p>If you prefer using TOML file instead of command-line flags:</p><pre><code class=\"language-toml\"># File \"traefik.toml\"\n\ndefaultEntryPoints = [\"https\",\"http\"]\n\n[entryPoints]\n  [entryPoints.http]\n  address = \":80\"\n    [entryPoints.http.redirect]\n    entryPoint = \"https\"\n  [entryPoints.https]\n  address = \":443\"\n  [entryPoints.https.tls]\n\n[kubernetes]\n\n[acme]\nemail = \"damien@containo.us\"\nstorage = \"acme.json\"\nentryPoint = \"https\"\nonHostRule = true\n[acme.tlsChallenge]</code></pre><pre><code class=\"language-shell\">traefikeectl deploy --configfile=./traefik.toml</code></pre><hr><p>That’s all for today: we installed a customized cluster, connected a remote machine to operate with <code>traefikeectl</code>, and deployed the same configuration as the one you could have used for Traefik, but without taking down the cluster, and without loosing any requests!</p><p>You can learn more about the <code>traefikeectl</code> command line on <a href=\"https://docs.containo.us/installing/teectl-cli/\">the reference documentation</a>.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-smooth-operations-2591bb7ff1fe/","canonical_url":null,"uuid":"34907a2a-bbdd-4139-84dd-26a5ca4ad805","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7badbf1db6f0038c74299","reading_time":5}},{"node":{"id":"Ghost__Post__5dd7bc8af1db6f0038c742d5","title":"The Journey to Traefik Enterprise Edition: HTTPS for Everyone","slug":"the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/ee-tls-le.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/27079133642b20968c4b4d4fe242c032/ee604/ee-tls-le.png","srcSet":"/static/27079133642b20968c4b4d4fe242c032/630fb/ee-tls-le.png 300w,\n/static/27079133642b20968c4b4d4fe242c032/2a4de/ee-tls-le.png 600w,\n/static/27079133642b20968c4b4d4fe242c032/ee604/ee-tls-le.png 800w","sizes":"(max-width: 800px) 100vw, 800px"}}},"excerpt":"Welcome to the fourth step of our journey towards Traefik Enterprise Edition.\nToday, we’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS by default...","custom_excerpt":"Welcome to the fourth step of our journey towards Traefik Enterprise Edition.\nToday, we’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS by default...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"February 25, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T10:46:34.000+00:00","published_at":"2019-02-25T10:45:00.000+00:00","updated_at":"2020-05-21T23:28:53.000+00:00","meta_title":"The Journey to Traefik Enterprise Edition: HTTPS for Everyone","meta_description":"Welcome to the 4th step of our journey towards Traefik Enterprise. We’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS for everyone.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the fourth step of our journey towards Traefik Enterprise Edition\n[/traefikee/].\n\nBefore jumping in, you should check the previous posts:\n\n * Join the“Early Access” Program\n   [/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/]\n * Product Evaluation\n   [/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/]\n * High Availability\n   [/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n\nToday, we’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS by\ndefault, for your application.\n\nCreate a Kubernetes Cluster with kops\nFollowing the same steps as the previous blog post (“Create a cluster with\nkops”)\n[/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n, start a kops cluster with one Kubernetes manager and three Kubernetes nodes:\n\n$ export NAME=traefikee-demo.containous.cloud\n$ export KOPS_STATE_STORE=s3://<YOUR BUCKET>\n$ export ROUTE53_ZONE_ID=<ROUTE53_ZONE_ID>\n$ export NB_MASTER_NODE=1\n$ export NB_WORKER_NODE=3\n\n$ kops create cluster \\\n    --zones us-east-1a \\\n    --dns-zone=\"${ROUTE53_ZONE_ID}\" \\\n    --node-size=\"t2.large\" \\\n    --master-count=\"${NB_MASTER_NODE}\" \\\n    --node-count=\"${NB_WORKER_NODE}\" \\\n    --yes \\\n    \"${NAME}\"\n\nAfter a few minutes, your cluster is started with four Kubernetes nodes:\n\n$ kubectl get nodes\nNAME                            STATUS   ROLES    AGE   VERSION\nip-172-20-34-251.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-49-209.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-53-165.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-56-217.ec2.internal   Ready    master   3m    v1.11.6\n\nPick a Public Domain Name\nIn the previous blog post, we used a domain name generated by Amazon Web\nServices\n[/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/] \nas the main entry point to reach our platform.\n\nYou cannot use this “generated” public hostname, because Let’s Encrypt has a\n“forbidden domains list.” Some domains are considered too risky, and any request\nfor issuing certificates under these domains is automatically refused. It’s the\ncase with domains in\n[https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2]\n*.amazonaws.com\n[https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2]\n.\n\nTo solve this challenge, let’s pick a custom public domain name. Any domain or\nsub-domain (like test.company.org ) can be used. You have to be able to create\nDNS records of type CNAME on this domain.\n\n> (A voice in the background): I don’t want to pay for a domain used for\nevaluating a product. Maybe later if it goes further, but not now.\n> Containous: You can get free DNS using Dot-T-K\n[http://www.dot.tk/en/index.html?lang=en], or even cheap ones using NameCheap\n[https://www.namecheap.com/].\nFor the next steps, we’ll pick the domain demo.containo.us .\n\nInstall TraefikEE\nThen, install a simple TraefikEE cluster, without dashboard, as we did on the\nprevious blog post\n[/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n:\n\n$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/…/traefikee-license)\" \\\n  --kubernetes\n...\n\n✔ Installation successful\n\nOnce the installation succeeded, verify that the TraefikEE cluster is composed\nof six nodes, three control nodes and three data nodes, as expected:\n\n$ traefikeectl list-nodes\n...\nName                                 Role\n----                                 ----\ntraefikee-control-node-0             CONTROL NODE\ndata-node-traefikee-data-node-9ndbp  DATA NODE\ndata-node-traefikee-data-node-vqgzr  DATA NODE\ntraefikee-control-node-1             CONTROL NODE\ntraefikee-control-node-2             CONTROL NODE (Current Leader)\ndata-node-traefikee-data-node-5w66x  DATA NODE\n\nConfigure the Domain DNS Records\nThe next step is to create a CNAME DNS record, on the public domain name,\npointing to the Load Balancer’s hostname, created during TraefikEE’s\ninstallation.\n\nGet the load balancer’s public hostname with the following command (field\nEXTERNAL-IP):\n\n$ kubectl get svc -n traefikee traefikee-lb\nNAME          TYPE         EXTERNAL-IP\ntraefikee-lb  LoadBalancer a16ff-456.us-east-1.elb.amazonaws.com\n\nThen, create the DNS CNAME record to this hostname (choose a short TTL):\n\nIN  CNAME  demo.containo.us a16ff-456.us-east-1.elb.amazonaws.com\n\nThe DNS propagation takes some time, due to the “TTL”. Verify that your computer\ncan resolve the DNS name with tools asdig , drillor nslookup :\n\n$ dig CNAME demo.containo.us\n...\n;; QUESTION SECTION:\n;demo.containo.us.       IN      CNAME\n\n;; ANSWER SECTION:\ndemo.containo.us. 60     IN      CNAME   a16ff-456.us-east-1.elb.amazonaws.com.\n\n;; Query time: 38 msec\n;; SERVER: 212.224.255.252#53(212.224.255.252)\n;; WHEN: Wed Feb 06 11:21:25 CET 2019\n;; MSG SIZE  rcvd: 136\n\nConfigure TraefikEE for HTTPS\nThen, we configure TraefikEE to enable HTTPS and Let’s Encrypt for certificate\non HTTPS. The configuration is the same as Traefik’s (check Traefik's\ndocumentation [https://docs.traefik.io] for more details):\n\n### Configure 2 entrypoints for https and https\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  \n### Enable ACME protocol for the HTTPS entry point\n  --acme.entryPoint=https \\\n  \n### Set up ACME protocol for Let's Encrypt TLS-APLN-01 Challenge\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  \n### Tell Traefik to get certificate's hostname from backend's rules\n  --acme.onHostRule=true\n\n> (A voice in the background): When using Traefik with Let’s Encrypt, I often get\ncertificates requests failures because of the rate limit on Let’s Encrypt side\n[https://letsencrypt.org/docs/rate-limits/].\n> Containous: Traefik allows to test your HTTPS configuration with the “staging”\nenvironment [https://letsencrypt.org/docs/staging-environment/], without rate\nlimiting, but with untrusted certificates . It’s useful to validate\nconfiguration before switching to “production” certificates. Add the flag \n--acme.caServer='https://acme-staging-v02.api.letsencrypt.org/directory' to the\nconfiguration.\nBe careful! You cannot change the caServer unless you reinstall TraefikEE.\nThe main difference from using Traefik here, is that TraefikEE is a distributed\nsystem, so you need to specify the configuration after TraefikEE’s installation.\n\nThe traefikeectl tool provides a command named deploy to send any routing\nconfiguration to the TraefikEE cluster. You can read more on this topic on the \nreference documentation for routing configurations [https://docs.containo.us].\n\nNow, let’s deploy the following configuration to the TraefikEE cluster and\nthat’s all!\n\ntraefikeectl deploy --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true\n\n> (A voice in the background): Why is there a —-kubernetes flag in this\nconfiguration?\n> Containous: This flag tells TraefikEE to watch for any Kubernetes Ingress. It’s\nthe same directive as the one in Traefik.\nDeploy an Application\nAs we previously did on the post, “A Tour of TraefikEE”, we deploy a test\napplication based on https://github.com/containous/whoami.\n\nYou can reuse the same YAML file, but you have to change the directive host in\nthe ingress, and map it to your public domain name. I’m using the following\none-line shell command for this:\n\n$ curl --location --silent --show-error https://bit.ly/2WE5XFk \\\n  | sed 's/localhost/demo.damienduportal.org/g' \\\n  | kubectl apply -f -\n\ndeployment.extensions/whoami created\ningress.extensions/whoami created\nservice/whoami created\n\nYou can check that Kubernetes is using the right domain name by checking the\ningress “whoami”:\n\n$ kubectl get ingress whoami --namespace=traefikee\nNAME     HOSTS                     ADDRESS   PORTS   AGE\nwhoami   demo.damienduportal.org             80      9m\n\nThe page https://demo.damienduportal.org/whoami is now, (after a few seconds,\nrequired for issuing certificates), securely served over HTTPS, with a valid\ncertificate, issued by Let’s Encrypt:\n\nGreen Lock for Everyone> If you try to access\nhttp://demo.damienduportal.org/whoami, then you are redirected to\nhttps://demo.damienduportal.org/whoami as expected.\nThat’s all for today, you are ready to use HTTPS on your applications!\nYou can now clean your kops cluster with:\n\nkops delete cluster --name=\"${NAME}\"\n\n\n--------------------------------------------------------------------------------\n\nOn the next post, “The Journey to Traefik Enterprise Edition: Smooth\nOperations,” we’ll focus on how to configure and operate TraefikEE remotely with\nthe traefikeectl command line.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-8.png\" class=\"kg-image\"></figure><p>Welcome to the fourth step of our journey towards <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition</a>.</p><p>Before jumping in, you should check the previous posts:</p><ul><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/\">Join the“Early Access” Program</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">Product Evaluation</a></em></em></li><li><em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">High Availability</a></em></em></li></ul><p>Today, we’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS by default, for your application.</p><h2 id=\"create-a-kubernetes-cluster-with-kops\">Create a Kubernetes Cluster with kops</h2><p>Following the same steps as <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">the previous blog post (“Create a cluster with kops”)</a>, start a kops cluster with one Kubernetes manager and three Kubernetes nodes:</p><pre><code class=\"language-shell\">$ export NAME=traefikee-demo.containous.cloud\n$ export KOPS_STATE_STORE=s3://&lt;YOUR BUCKET&gt;\n$ export ROUTE53_ZONE_ID=&lt;ROUTE53_ZONE_ID&gt;\n$ export NB_MASTER_NODE=1\n$ export NB_WORKER_NODE=3\n\n$ kops create cluster \\\n    --zones us-east-1a \\\n    --dns-zone=\"${ROUTE53_ZONE_ID}\" \\\n    --node-size=\"t2.large\" \\\n    --master-count=\"${NB_MASTER_NODE}\" \\\n    --node-count=\"${NB_WORKER_NODE}\" \\\n    --yes \\\n    \"${NAME}\"</code></pre><p>After a few minutes, your cluster is started with four Kubernetes nodes:</p><pre><code class=\"language-shell\">$ kubectl get nodes\nNAME                            STATUS   ROLES    AGE   VERSION\nip-172-20-34-251.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-49-209.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-53-165.ec2.internal   Ready    node     2m    v1.11.6\nip-172-20-56-217.ec2.internal   Ready    master   3m    v1.11.6</code></pre><h2 id=\"pick-a-public-domain-name\">Pick a Public Domain Name</h2><p>In the previous blog post, we used <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">a domain name generated by Amazon Web Services</a> as the main entry point to reach our platform.</p><p>You cannot use this “generated” public hostname, because Let’s Encrypt has a “forbidden domains list.” Some domains are considered too risky, and any request for issuing certificates under these domains is automatically refused. <a href=\"https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2\" rel=\"noopener\">It’s the case with domains in </a><code><a href=\"https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2\" rel=\"noopener\">*.amazonaws.com</a>.</code></p><p>To solve this challenge, let’s pick a custom public domain name. Any domain or sub-domain (like <code>test.company.org</code> ) can be used. You have to be able to create DNS records of type <code>CNAME</code> on this domain.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I don’t want to pay for a domain used for evaluating a product. Maybe later if it goes further, but not now.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> You can get free DNS using <a href=\"http://www.dot.tk/en/index.html?lang=en\" rel=\"noopener\">Dot-T-K</a>, or even cheap ones using <a href=\"https://www.namecheap.com/\" rel=\"noopener\">NameCheap</a>.</em></em></blockquote><p>For the next steps, we’ll pick the domain <code>demo.containo.us</code> .</p><h2 id=\"install-traefikee\">Install TraefikEE</h2><p>Then, install a simple TraefikEE cluster, without dashboard, as we did on <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">the previous blog post</a>:</p><pre><code class=\"language-shell\">$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/…/traefikee-license)\" \\\n  --kubernetes\n...\n\n✔ Installation successful</code></pre><p>Once the installation succeeded, verify that the TraefikEE cluster is composed of six nodes, three control nodes and three data nodes, as expected:</p><pre><code class=\"language-shell\">$ traefikeectl list-nodes\n...\nName                                 Role\n----                                 ----\ntraefikee-control-node-0             CONTROL NODE\ndata-node-traefikee-data-node-9ndbp  DATA NODE\ndata-node-traefikee-data-node-vqgzr  DATA NODE\ntraefikee-control-node-1             CONTROL NODE\ntraefikee-control-node-2             CONTROL NODE (Current Leader)\ndata-node-traefikee-data-node-5w66x  DATA NODE</code></pre><h2 id=\"configure-the-domain-dns-records\">Configure the Domain DNS Records</h2><p>The next step is to create a <code>CNAME</code> DNS record, on the public domain name, pointing to the Load Balancer’s hostname, created during TraefikEE’s installation.</p><p>Get the load balancer’s public hostname with the following command (field EXTERNAL-IP):</p><pre><code class=\"language-shell\">$ kubectl get svc -n traefikee traefikee-lb\nNAME          TYPE         EXTERNAL-IP\ntraefikee-lb  LoadBalancer a16ff-456.us-east-1.elb.amazonaws.com</code></pre><p>Then, create the DNS CNAME record to this hostname (choose a short TTL):</p><pre><code class=\"language-shell\">IN  CNAME  demo.containo.us a16ff-456.us-east-1.elb.amazonaws.com</code></pre><p>The DNS propagation takes some time, due to the “TTL”. Verify that your computer can resolve the DNS name with tools as<code>dig</code> , <code>drill</code>or <code>nslookup</code> :</p><pre><code class=\"language-shell\">$ dig CNAME demo.containo.us\n...\n;; QUESTION SECTION:\n;demo.containo.us.       IN      CNAME\n\n;; ANSWER SECTION:\ndemo.containo.us. 60     IN      CNAME   a16ff-456.us-east-1.elb.amazonaws.com.\n\n;; Query time: 38 msec\n;; SERVER: 212.224.255.252#53(212.224.255.252)\n;; WHEN: Wed Feb 06 11:21:25 CET 2019\n;; MSG SIZE  rcvd: 136</code></pre><h2 id=\"configure-traefikee-for-https\">Configure TraefikEE for HTTPS</h2><p>Then, we configure TraefikEE to enable HTTPS and Let’s Encrypt for certificate on HTTPS. The configuration is the same as Traefik’s (check <a href=\"https://docs.traefik.io\">Traefik's documentation</a> for more details):</p><pre><code class=\"language-shell\">### Configure 2 entrypoints for https and https\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  \n### Enable ACME protocol for the HTTPS entry point\n  --acme.entryPoint=https \\\n  \n### Set up ACME protocol for Let's Encrypt TLS-APLN-01 Challenge\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  \n### Tell Traefik to get certificate's hostname from backend's rules\n  --acme.onHostRule=true</code></pre><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> When using Traefik with Let’s Encrypt, I often get certificates requests failures because of <a href=\"https://letsencrypt.org/docs/rate-limits/\" rel=\"noopener\">the rate limit on Let’s Encrypt side</a>.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Traefik allows to test your HTTPS configuration with <a href=\"https://letsencrypt.org/docs/staging-environment/\" rel=\"noopener\">the “staging” environment</a>, without rate limiting, but with untrusted certificates . It’s useful to validate configuration before switching to “production” certificates. Add the flag <code>--acme.caServer='https://acme-staging-v02.api.letsencrypt.org/directory<em>'</em></code><em> to the configuration.</em></em></em><br><em><em><em>Be careful! You cannot change the caServer unless you reinstall TraefikEE.</em></em></em></blockquote><p>The main difference from using Traefik here, is that TraefikEE is a distributed system, so you need to specify the configuration <strong><strong>after</strong></strong> TraefikEE’s installation.</p><p>The <code>traefikeectl</code> tool provides a command named <code>deploy</code> to send any routing configuration to the TraefikEE cluster. You can read more on this topic on the <a href=\"https://docs.containo.us\">reference documentation for routing configurations</a>.</p><p>Now, let’s deploy the following configuration to the TraefikEE cluster and that’s all!</p><pre><code class=\"language-shell\">traefikeectl deploy --kubernetes \\\n  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \\\n  --entryPoints='Name:https Address::443 TLS' \\\n  --defaultentrypoints=https,http \\\n  --acme.entryPoint=https \\\n  --acme.email=damien@containo.us \\\n  --acme.tlsChallenge \\\n  --acme.onHostRule=true</code></pre><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Why is there a <code>—-kubernetes</code> flag in this configuration?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> This flag tells TraefikEE to watch for any Kubernetes Ingress. It’s the same directive as the one in Traefik.</em></em></blockquote><h2 id=\"deploy-an-application\">Deploy an Application</h2><p>As we previously did on the post, “A Tour of TraefikEE”, we deploy a test application based on <a href=\"https://github.com/containous/whoami\" rel=\"noopener\">https://github.com/containous/whoami</a>.</p><p>You can reuse the same YAML file, but you have to change the directive <code>host</code> in the ingress, and map it to your public domain name. I’m using the following one-line shell command for this:</p><pre><code class=\"language-shell\">$ curl --location --silent --show-error https://bit.ly/2WE5XFk \\\n  | sed 's/localhost/demo.damienduportal.org/g' \\\n  | kubectl apply -f -\n\ndeployment.extensions/whoami created\ningress.extensions/whoami created\nservice/whoami created</code></pre><p>You can check that Kubernetes is using the right domain name by checking the ingress “whoami”:</p><pre><code class=\"language-shell\">$ kubectl get ingress whoami --namespace=traefikee\nNAME     HOSTS                     ADDRESS   PORTS   AGE\nwhoami   demo.damienduportal.org             80      9m</code></pre><p>The page https://demo.damienduportal.org/whoami is now, (after a few seconds, required for issuing certificates), securely served over HTTPS, with a valid certificate, issued by Let’s Encrypt:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-39.png\" class=\"kg-image\"><figcaption>Green Lock for Everyone</figcaption></figure><blockquote><em><em>If you try to access http://demo.damienduportal.org/whoami, then you are redirected to https://demo.damienduportal.org/whoami as expected.</em></em></blockquote><p>That’s all for today, you are ready to use HTTPS on your applications!<br>You can now clean your kops cluster with:</p><pre><code class=\"language-shell\">kops delete cluster --name=\"${NAME}\"</code></pre><hr><p>On the next post, “The Journey to Traefik Enterprise Edition: Smooth Operations,” we’ll focus on how to configure and operate TraefikEE remotely with the <code>traefikeectl</code> command line.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/","canonical_url":null,"uuid":"f89e17d3-fb94-408b-a240-ff3f036d382b","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7bc8af1db6f0038c742d5","reading_time":5}},{"node":{"id":"Ghost__Post__5dd7c361f1db6f0038c74326","title":"The Journey to Traefik Enterprise Edition: High Availability","slug":"the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/ee-ha.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/9c0b9ef78b45492064f94ebc3a717c59/a8378/ee-ha.png","srcSet":"/static/9c0b9ef78b45492064f94ebc3a717c59/630fb/ee-ha.png 300w,\n/static/9c0b9ef78b45492064f94ebc3a717c59/2a4de/ee-ha.png 600w,\n/static/9c0b9ef78b45492064f94ebc3a717c59/a8378/ee-ha.png 1024w","sizes":"(max-width: 1024px) 100vw, 1024px"}}},"excerpt":"Welcome to the third step of our journey towards Traefik Enterprise Edition . Let’s evaluate TraefikEE’s high availability feature with...","custom_excerpt":"Welcome to the third step of our journey towards Traefik Enterprise Edition . Let’s evaluate TraefikEE’s high availability feature with...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"January 28, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T11:15:45.000+00:00","published_at":"2019-01-28T11:15:00.000+00:00","updated_at":"2020-05-21T23:37:43.000+00:00","meta_title":"The Journey to Traefik Enterprise Edition: High Availability","meta_description":"Welcome to the third step of our journey towards Traefik Enterprise Edition . Let’s evaluate TraefikEE’s high availability feature.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the third step of our journey towards Traefik Enterprise Edition\n[/traefikee/] .\n\nAfter the two first posts Join the“Early Access” Program\n[/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/https://containo.us/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/]\n, and Product Evaluation\n[/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/]\n), let’s get real and evaluate TraefikEE’s high availability feature.\n\nThe previous post described how to install TraefikEE on a local machine, which\nis not a realistic environment. Today, we’ll use a Kubernetes multi-node cluster\ndeployed in Amazon EC2 as a more realistic platform for running TraefikEE.\n\nCreating a Kubernetes Cluster with kops\nThe first step is to get a multi-node Kubernetes cluster up and running\nsomewhere in the cloud.\n\nkops (aka. “Kubernetes Operations”) is a tool provided by the Kubernetes\ncommunity. It provides a command line to create and manage Kubernetes clusters\non cloud infrastructures as Amazon EC2 [https://aws.amazon.com/ec2/], Google\nCompute Engine [https://cloud.google.com/compute/?hl=fr] or Digital Ocean\n[https://www.digitalocean.com/].\n\nUsing the kops tutorial for AWS, we have the following requirements set up:\n\n * The aws command line tool installed\n * AWS API access credentials loaded (check this project\n   [https://github.com/mmatur/aws-mfa] from Michael MATUR\n   [https://medium.com/u/c01753d22e74?source=post_page-----7421718be2d8----------------------] \n   if you need MFA)\n * The kops command line tool installed\n * One of the 3 DNS scenarios configured\n * An AWS S3 bucket created to store kops configuration\n\nWe can create a Kubernetes cluster with 3 masters and 6 worker nodes. The worker\nnodes are a t2.large [https://aws.amazon.com/ec2/instance-types/t2/] types, with\n2 CPUs and 8 Gb memory each:\n\n$ export NAME=traefikee-demo.containous.cloud\n$ export KOPS_STATE_STORE=s3://<YOUR BUCKET>\n$ export ROUTE53_ZONE_ID=<ROUTE53_ZONE_ID>\n\n$ kops create cluster \\\n  --zones us-east-1a \\\n  --dns-zone=\"${ROUTE53_ZONE_ID}\" \\\n  --node-size=\"t2.large\" \\\n  --master-count=3 \\\n  --node-count=6 \\\n\"${NAME}\"\n\nOnce the cluster is created, validate its state with kops, and verify the access\nto the Kubernetes API with the kubectl:\n\n$ kops validate cluster --name=\"${NAME}\"\nValidating cluster traefikee-demo.containous.cloud\n...\n\nYour cluster traefikee-demo.containous.cloud is ready\n\n$ kubectl get nodes\nNAME STATUS ROLES AGE VERSION\nip-172–20–33–152.ec2.internal Ready node 1d v1.11.6\nip-172–20–37–195.ec2.internal Ready master 1d v1.11.6\nip-172–20–38–193.ec2.internal Ready node 1d v1.11.6\nip-172–20–42–46.ec2.internal Ready master 1d v1.11.6\nip-172–20–44–104.ec2.internal Ready node 1d v1.11.6\nip-172–20–52–184.ec2.internal Ready node 1d v1.11.6\nip-172–20–60–90.ec2.internal Ready node 1d v1.11.6\nip-172–20–61–254.ec2.internal Ready node 1d v1.11.6\nip-172–20–62–134.ec2.internal Ready master 1d v1.11.6\n\nWe can now proceed to install TraefikEE on this cluster.\n\nTraefikEE Installation\nWe expect that the command line traefikeectl command is already installed on\nyour machine. If you haven’t done it yet, check the \"Install traefikeectl\"\nsection of the Installation Guide [https://docs.containo.us].\n\n$ traefikeectl version\nVersion: v1.0.0-beta17\nCodename: Gewurztraminer\nGo version: go1.11.4\nBuilt: 2019-01-22_10:12:50AM\nOS/Arch: darwin/amd64\n\nNext step: installation of TraefikEE in one line, using traefikeectl, as covered\non the previous blog post\n[/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/]\n.\n\n> Don’t forget it takes some time to download all the required resources\n$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/…/traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n\n# ...\n\nYou can access the dashboard with the following credentials:\n\nUsername: admin\nPassword: 384bae9a1fe11670\n\n✔ Installation successful\n\n> Don’t forget to write down the password for later.\nCongratulations, your TraefikEE cluster is installed locally! The last step is\nto check the topology of the TraefikEE cluster:\n\n$ traefikeectl list-nodes\nName                                 Role\n----                                 ----\ndata-node-traefikee-data-node-864tl  DATA NODE\ndata-node-traefikee-data-node-jptsq  DATA NODE\ndata-node-traefikee-data-node-rn4x8  DATA NODE\ntraefikee-control-node-1             CONTROL NODE\ndata-node-traefikee-data-node-l6x2s  DATA NODE\ndata-node-traefikee-data-node-wmm6n  DATA NODE\ndata-node-traefikee-data-node-h2pgb  DATA NODE\ntraefikee-control-node-2             CONTROL NODE (Current Leader)\ntraefikee-control-node-0             CONTROL NODE\n\nAs expected we have:\n\n * A Control Plane composed of 3 nodes, which is the default\n * A Data Plane composed of 6 nodes, which is the default behavior (see the\n   flag\n   “ — datanodes”) [https://docs.containo.us/installing/teectl-cli/] . TraefikEE\n   sets up 1 data node per worker node of the Kubernetes cluster. It uses a \n   Kubernetes Daemon Set\n   [https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/] under\n   the hood.\n\nAccessing the Web Dashboard\nOn the previous post, we used the kubectl port-forward command to access the\ndashboard by forwarding a port locally\n[https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/]\n.\n\nAs this Kubernetes cluster is available from the outside, we want to use a\npublic hostname to access it instead, so the end users can access your\napplications from anywhere.\n\nUsing the command line kubectl, fetch the public hostname of the Amazon Elastic\nLoad-Balancer allocated during the installation (column EXTERNAL-IP):\n\n$ kubectl get svc -n traefikee traefikee-lb\n\nNAME          TYPE         EXTERNAL-IP\ntraefikee-lb  LoadBalancer a277b89-820.us-east-1.elb.amazonaws.com\n\nYou can now access the dashboard on the URL http://<EXTERNAL-IP>/dashboard/ .\n\nAll your nodes are belong to us> (A voice in the background): My Kubernetes Cluster does not show any\nEXTERNAL-IP. How can I reach the dashboard (and applications)?\n> Containous: Most of Kubernetes providers propose out of the box implementation\nfor the Service of type “LoadBalancer”\n[https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer].\nIf it is not your case, take a look at https://metallb.universe.tf/.\nDeploy an Application\nAs we did on the previous post, we deploy an application based on \nhttps://github.com/containous/whoami. \n\n$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/0ff70f9ae50d7930a9fa6c06bdc15253c81b8af4/whoami.yaml\n\nThe dashboard updates itself once the application is deployed:\n\nYou can now reach the application at the URL http://<EXTERNAL-IP>/whoami :\n\nHigh Availability\nWhat happens if one of the 6 worker node goes down by accident or for \nmaintenance\n[https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/]?\n\n * 1 of the 6 data nodes goes down (or is rescheduled). The load balancer\n   forwards the traffic to the 5 remaining nodes: no request are lost!\n * If 1 of the control nodes was running on this worker node, the remaining\n   nodes elect a new leader and take care of the configuration, until the node\n   comes up.\n\n> (A voice in the background): Aren’t the control node part of a Raft cluster? If\nyes, then what happens if only 2 control nodes are up?\n> Containous: The workload handled by the failed node is distributed to the 2\nothers, so the cluster does not loose data and continues to work as expected.\nHowever if the failed node does not comes back, then you are not tolerant to\nanother failure. You can run a TraefikEE of 5 control nodes to be fault tolerant\nto 2 failures. You can get more information on the TraefikEE documentation or\nchek how the Raft consensus work here [http://thesecretlivesofdata.com/raft/].\nTo demonstrate this high-availability behavior, we will:\n\n * Run a load test on the “whoami” application served by TraefikEE\n * Restart 1 of the 6 Kubernetes worker node\n * Verify that no requests are lost\n * Validate that the cluster comes back in an healthy state once the Kubernetes\n   worker node is restarted\n\nLoad Testing the whoami Application\nWe’ll use “slapper” (https://github.com/ikruglov/slapper), a go command line\nproviding a real-time view of the load test in the console.\n\n# You need go - https://golang.org/dl/\n\n$ go get -u github.com/ikruglov/slapper\n...\n\n$ which slapper\n\"${GOPATH}/bin/slapper\"\n\nSlapper requires a “target file\n[https://github.com/ikruglov/slapper#targets-syntax]” which is a text file\ndescribing the load-testing scenario. Our load-testing scenario is simple: we\nwant to emit HTTP GET requests to the URL of the whoami application.\n\n$ cat whoami.target\nGET http://a277bd4f21fde11e9b5150ea2ab8b589-823458350.us-east-1.elb.amazonaws.com/whoami\n\nLet’s start the load testing for 30s, with 50 requests per seconds, and with an\nadapted scale (with an example output):\n\n$ slapper -targets ./whoami.target -minY 100ms -maxY 800ms -timeout 30s -rate 50\n\nsent: 198    in-flight: 6  rate:   50/50 RPS responses: [200]: 192\n\n100-101 ms: [     0/     0]\n101-102 ms: [     0/     0]\n102-103 ms: [     0/     0]\n103-105 ms: [     0/     0]\n105-106 ms: [     0/     0]\n106-108 ms: [    13/     0] **************************\n108-110 ms: [   112/     0] ************************************\n110-113 ms: [    40/     0] ****************************************\n113-115 ms: [    10/     0] ********************\n115-118 ms: [     3/     0] ******\n118-121 ms: [     4/     0] ********\n121-125 ms: [     2/     0] ****\n125-129 ms: [     0/     0]\n129-133 ms: [     0/     0]\n133-138 ms: [     0/     0]\n138-144 ms: [     0/     0]\n144-150 ms: [     0/     0]\n...\n800+ ms: [     0/     0]\n\nReboot a Worker Node\nUsing the aws and kubectlcommand lines, we get the EC2 instance ID of a worker\nnode, and restart it:\n\n# Select one of the 6 Kubernetes nodes\n$ kubectl get nodes\nNAME STATUS ROLES AGE VERSION\n...\nip-172–20–38–193.ec2.internal Ready node 1d v1.11.6\n...\n\n# Get the EC2 instance ID\n$ aws ec2 describe-instances --filters \"Name=private-dns-name,Values=ip-172-20-38-193.ec2.internal\" | grep InstanceId\n\"InstanceId\": \"i-0fdc6a4f95908a2ba\",\n\n# Restart the instance\n$ aws ec2 reboot-instances --instance-ids=i-0fdc6a4f95908a2ba\n\nThe Dashboard immediately reports that a control node and a data node are\nunhealthy ( traefikee-control-node-0 and data-node-traefikee-wmm6n in this\ncase):\n\nValidate High Availability\nIf you check back the load testing, you can see that no requests have been lost\nor in error. You might see, however, a punctual growth on the response time (+-\n100ms):\n\nsent: 25736  in-flight: 2 rate:   50/50 RPS responses: [200]: 25734\n\nAs soon as the EC2 instance has restarted, all the failed nodes (Kubernetes and\nTraefikEE) are going back online:\n\nTraefikEE cluster back to nominal stateCheck this video of a the load test\nrunning with a worker node randomly killed:\n\nThat’s all for today! We demonstrated the high availability feature of\nTraefikEE. Oh, and don’t forget to clean your cluster:\n\nkops delete cluster --name=\"${NAME}\"\n\n\n--------------------------------------------------------------------------------\n\nOn the next post “The Journey to Traefik Enterprise Edition: HTTPS for everyone\n[/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/]\n”, we’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS by\ndefault.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-9.png\" class=\"kg-image\"></figure><p>Welcome to the third step of our journey towards<a href=\"https://containous.ghost.io/traefikee/\"> Traefik Enterprise Edition</a> .</p><p>After the two first posts <em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/https://containo.us/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/\">Join the“Early Access” Program</a></em></em>, and <em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">Product Evaluation</a></em></em>), let’s get real and evaluate TraefikEE’s high availability feature.</p><p>The previous post described how to install TraefikEE on a local machine, which is not a realistic environment. Today, we’ll use a Kubernetes multi-node cluster deployed in Amazon EC2 as a more realistic platform for running TraefikEE.</p><h2 id=\"creating-a-kubernetes-cluster-with-kops\">Creating a Kubernetes Cluster with kops</h2><p>The first step is to get a multi-node Kubernetes cluster up and running somewhere in the cloud.</p><p><code>kops</code> (aka. “Kubernetes Operations”) is a tool provided by the Kubernetes community. It provides a command line to create and manage Kubernetes clusters on cloud infrastructures as <a href=\"https://aws.amazon.com/ec2/\" rel=\"noopener\">Amazon EC2</a>, <a href=\"https://cloud.google.com/compute/?hl=fr\" rel=\"noopener\">Google Compute Engine</a> or <a href=\"https://www.digitalocean.com/\" rel=\"noopener\">Digital Ocean</a>.</p><p>Using the kops tutorial for AWS, we have the following requirements set up:</p><ul><li>The <code>aws</code> command line tool installed</li><li>AWS API access credentials loaded (<a href=\"https://github.com/mmatur/aws-mfa\" rel=\"noopener\">check this project</a> from <a href=\"https://medium.com/u/c01753d22e74?source=post_page-----7421718be2d8----------------------\" rel=\"noopener\">Michael MATUR</a> if you need MFA)</li><li>The <code>kops</code> command line tool installed</li><li>One of the 3 DNS scenarios configured</li><li>An AWS S3 bucket created to store kops configuration</li></ul><p>We can create a Kubernetes cluster with 3 masters and 6 worker nodes. The worker nodes are a <a href=\"https://aws.amazon.com/ec2/instance-types/t2/\" rel=\"noopener\">t2.large</a> types, with 2 CPUs and 8 Gb memory each:</p><pre><code class=\"language-shell\">$ export NAME=traefikee-demo.containous.cloud\n$ export KOPS_STATE_STORE=s3://&lt;YOUR BUCKET&gt;\n$ export ROUTE53_ZONE_ID=&lt;ROUTE53_ZONE_ID&gt;\n\n$ kops create cluster \\\n  --zones us-east-1a \\\n  --dns-zone=\"${ROUTE53_ZONE_ID}\" \\\n  --node-size=\"t2.large\" \\\n  --master-count=3 \\\n  --node-count=6 \\\n\"${NAME}\"</code></pre><p>Once the cluster is created, validate its state with <code>kops</code>, and verify the access to the Kubernetes API with the <code>kubectl</code>:</p><pre><code class=\"language-shell\">$ kops validate cluster --name=\"${NAME}\"\nValidating cluster traefikee-demo.containous.cloud\n...\n\nYour cluster traefikee-demo.containous.cloud is ready\n\n$ kubectl get nodes\nNAME STATUS ROLES AGE VERSION\nip-172–20–33–152.ec2.internal Ready node 1d v1.11.6\nip-172–20–37–195.ec2.internal Ready master 1d v1.11.6\nip-172–20–38–193.ec2.internal Ready node 1d v1.11.6\nip-172–20–42–46.ec2.internal Ready master 1d v1.11.6\nip-172–20–44–104.ec2.internal Ready node 1d v1.11.6\nip-172–20–52–184.ec2.internal Ready node 1d v1.11.6\nip-172–20–60–90.ec2.internal Ready node 1d v1.11.6\nip-172–20–61–254.ec2.internal Ready node 1d v1.11.6\nip-172–20–62–134.ec2.internal Ready master 1d v1.11.6</code></pre><p>We can now proceed to install TraefikEE on this cluster.</p><h2 id=\"traefikee-installation\">TraefikEE Installation</h2><p>We expect that the command line <code>traefikeectl</code> command is already installed on your machine. If you haven’t done it yet, check the \"Install traefikeectl\" section of the <a href=\"https://docs.containo.us\">Installation Guide</a>.</p><pre><code class=\"language-shell\">$ traefikeectl version\nVersion: v1.0.0-beta17\nCodename: Gewurztraminer\nGo version: go1.11.4\nBuilt: 2019-01-22_10:12:50AM\nOS/Arch: darwin/amd64</code></pre><p>Next step: installation of TraefikEE in one line, using <code>traefikeectl</code>, as covered on <a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/\">the previous blog post</a>.</p><blockquote><em><em>Don’t forget it takes some time to download all the required resources</em></em></blockquote><pre><code class=\"language-shell\">$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/…/traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n\n# ...\n\nYou can access the dashboard with the following credentials:\n\nUsername: admin\nPassword: 384bae9a1fe11670\n\n✔ Installation successful</code></pre><blockquote>Don’t forget to write down the password for later.</blockquote><p>Congratulations, your TraefikEE cluster is installed locally! The last step is to check the topology of the TraefikEE cluster:</p><pre><code class=\"language-shell\">$ traefikeectl list-nodes\nName                                 Role\n----                                 ----\ndata-node-traefikee-data-node-864tl  DATA NODE\ndata-node-traefikee-data-node-jptsq  DATA NODE\ndata-node-traefikee-data-node-rn4x8  DATA NODE\ntraefikee-control-node-1             CONTROL NODE\ndata-node-traefikee-data-node-l6x2s  DATA NODE\ndata-node-traefikee-data-node-wmm6n  DATA NODE\ndata-node-traefikee-data-node-h2pgb  DATA NODE\ntraefikee-control-node-2             CONTROL NODE (Current Leader)\ntraefikee-control-node-0             CONTROL NODE</code></pre><p>As expected we have:</p><ul><li>A Control Plane composed of <strong><strong>3</strong></strong> nodes, which is the default</li><li>A Data Plane composed of <strong><strong>6</strong></strong> nodes, which is <a href=\"https://docs.containo.us/installing/teectl-cli/\">the default behavior (see the flag “ — datanodes”)</a> . TraefikEE sets up 1 data node per worker node of the Kubernetes cluster. It uses a <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/\" rel=\"noopener\">Kubernetes Daemon Set</a> under the hood.</li></ul><h2 id=\"accessing-the-web-dashboard\">Accessing the Web Dashboard</h2><p>On the previous post, we used the <code>kubectl port-forward</code> command to access the dashboard by <a href=\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\" rel=\"noopener\">forwarding a port locally</a>.</p><p>As this Kubernetes cluster is available from the outside, we want to use a public hostname to access it instead, so the end users can access your applications from anywhere.</p><p>Using the command line <code>kubectl</code>, fetch the public hostname of the Amazon Elastic Load-Balancer allocated during the installation (column <code>EXTERNAL-IP</code>):</p><pre><code class=\"language-shell\">$ kubectl get svc -n traefikee traefikee-lb\n\nNAME          TYPE         EXTERNAL-IP\ntraefikee-lb  LoadBalancer a277b89-820.us-east-1.elb.amazonaws.com</code></pre><p>You can now access the dashboard on the URL <code>http://&lt;EXTERNAL-IP&gt;/dashboard/</code> .</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-41.png\" class=\"kg-image\"><figcaption>All your nodes are belong to us</figcaption></figure><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> My Kubernetes Cluster does not show any EXTERNAL-IP. How can I reach the dashboard (and applications)?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Most of Kubernetes providers propose out of the box implementation for the <a href=\"https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer\" rel=\"noopener\">Service of type “LoadBalancer”</a>. If it is not your case, take a look at <a href=\"https://metallb.universe.tf/\" rel=\"noopener\">https://metallb.universe.tf/</a>.</em></em></blockquote><h2 id=\"deploy-an-application\">Deploy an Application</h2><p>As we did on the previous post, we deploy an application based on <a href=\"https://github.com/containous/whoami\" rel=\"noopener\">https://github.com/containous/whoami</a>. </p><pre><code class=\"language-shell\">$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/0ff70f9ae50d7930a9fa6c06bdc15253c81b8af4/whoami.yaml</code></pre><p>The dashboard updates itself once the application is deployed:</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-42.png\" class=\"kg-image\"></figure><p>You can now reach the application at the URL <code>http://&lt;EXTERNAL-IP&gt;/whoami</code> :</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-43.png\" class=\"kg-image\"></figure><h2 id=\"high-availability\">High Availability</h2><p>What happens if one of the 6 worker node goes down by accident or for <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/\" rel=\"noopener\">maintenance</a>?</p><ul><li>1 of the 6 data nodes goes down (or is rescheduled). The load balancer forwards the traffic to the 5 remaining nodes: no request are lost!</li><li>If 1 of the control nodes was running on this worker node, the remaining nodes elect a new leader and take care of the configuration, until the node comes up.</li></ul><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Aren’t the control node part of a Raft cluster? If yes, then what happens if only 2 control nodes are up?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> The workload handled by the failed node is distributed to the 2 others, so the cluster does not loose data and continues to work as expected. However if the failed node does not comes back, then you are not tolerant to another failure. You can run a TraefikEE of 5 control nodes to be fault tolerant to 2 failures. You can get more information on the TraefikEE documentation or chek how the Raft consensus work <a href=\"http://thesecretlivesofdata.com/raft/\" rel=\"noopener\">here</a>.</em></em></blockquote><p>To demonstrate this high-availability behavior, we will:</p><ul><li>Run a load test on the “<em><em>whoami</em></em>” application served by TraefikEE</li><li>Restart 1 of the 6 Kubernetes worker node</li><li>Verify that no requests are lost</li><li>Validate that the cluster comes back in an healthy state once the Kubernetes worker node is restarted</li></ul><h2 id=\"load-testing-the-whoami-application\">Load Testing the whoami Application</h2><p>We’ll use “slapper” (<a href=\"https://github.com/ikruglov/slapper\" rel=\"noopener\">https://github.com/ikruglov/slapper</a>), a go command line providing a real-time view of the load test in the console.</p><pre><code class=\"language-shell\"># You need go - https://golang.org/dl/\n\n$ go get -u github.com/ikruglov/slapper\n...\n\n$ which slapper\n\"${GOPATH}/bin/slapper\"</code></pre><p>Slapper requires a “<a href=\"https://github.com/ikruglov/slapper#targets-syntax\" rel=\"noopener\">target file</a>” which is a text file describing the load-testing scenario. Our load-testing scenario is simple: we want to emit HTTP GET requests to the URL of the <em><em>whoami</em></em> application.</p><pre><code class=\"language-shell\">$ cat whoami.target\nGET http://a277bd4f21fde11e9b5150ea2ab8b589-823458350.us-east-1.elb.amazonaws.com/whoami</code></pre><p>Let’s start the load testing for 30s, with 50 requests per seconds, and with an adapted scale (with an example output):</p><pre><code class=\"language-shell\">$ slapper -targets ./whoami.target -minY 100ms -maxY 800ms -timeout 30s -rate 50\n\nsent: 198    in-flight: 6  rate:   50/50 RPS responses: [200]: 192\n\n100-101 ms: [     0/     0]\n101-102 ms: [     0/     0]\n102-103 ms: [     0/     0]\n103-105 ms: [     0/     0]\n105-106 ms: [     0/     0]\n106-108 ms: [    13/     0] **************************\n108-110 ms: [   112/     0] ************************************\n110-113 ms: [    40/     0] ****************************************\n113-115 ms: [    10/     0] ********************\n115-118 ms: [     3/     0] ******\n118-121 ms: [     4/     0] ********\n121-125 ms: [     2/     0] ****\n125-129 ms: [     0/     0]\n129-133 ms: [     0/     0]\n133-138 ms: [     0/     0]\n138-144 ms: [     0/     0]\n144-150 ms: [     0/     0]\n...\n800+ ms: [     0/     0]</code></pre><h2 id=\"reboot-a-worker-node\">Reboot a Worker Node</h2><p>Using the <code>aws</code> and <code>kubectl</code>command lines, we get the EC2 instance ID of a worker node, and restart it:</p><pre><code class=\"language-shell\"># Select one of the 6 Kubernetes nodes\n$ kubectl get nodes\nNAME STATUS ROLES AGE VERSION\n...\nip-172–20–38–193.ec2.internal Ready node 1d v1.11.6\n...\n\n# Get the EC2 instance ID\n$ aws ec2 describe-instances --filters \"Name=private-dns-name,Values=ip-172-20-38-193.ec2.internal\" | grep InstanceId\n\"InstanceId\": \"i-0fdc6a4f95908a2ba\",\n\n# Restart the instance\n$ aws ec2 reboot-instances --instance-ids=i-0fdc6a4f95908a2ba</code></pre><p>The Dashboard immediately reports that a control node and a data node are unhealthy ( <code>traefikee-control-node-0</code> and <code>data-node-traefikee-wmm6n</code> in this case):</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-44.png\" class=\"kg-image\"></figure><h2 id=\"validate-high-availability\">Validate High Availability</h2><p>If you check back the load testing, you can see that no requests have been lost or in error. You might see, however, a punctual growth on the response time (+- 100ms):</p><pre><code class=\"language-shell\">sent: 25736  in-flight: 2 rate:   50/50 RPS responses: [200]: 25734</code></pre><p>As soon as the EC2 instance has restarted, all the failed nodes (Kubernetes and TraefikEE) are going back online:</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-45.png\" class=\"kg-image\"><figcaption>TraefikEE cluster back to nominal state</figcaption></figure><p>Check this video of a the load test running with a worker node randomly killed:</p><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/ghYsR5CuNiQ?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure><p>That’s all for today! We demonstrated the high availability feature of TraefikEE. Oh, and don’t forget to clean your cluster:</p><pre><code class=\"language-shell\">kops delete cluster --name=\"${NAME}\"</code></pre><hr><p>On the next post “<a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/\">The Journey to Traefik Enterprise Edition: HTTPS for everyone</a>”, we’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS by default.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/","canonical_url":null,"uuid":"68a2548b-36b0-4fe7-9993-4eba958e6280","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7c361f1db6f0038c74326","reading_time":7}},{"node":{"id":"Ghost__Post__5dd7e6ebf1db6f0038c7437f","title":"The Journey to Traefik Enterprise Edition: Product Evaluation","slug":"the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/ee-evaluation.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b5028e39443bd90d0ac061a694e3e926/f3583/ee-evaluation.png","srcSet":"/static/b5028e39443bd90d0ac061a694e3e926/630fb/ee-evaluation.png 300w,\n/static/b5028e39443bd90d0ac061a694e3e926/2a4de/ee-evaluation.png 600w,\n/static/b5028e39443bd90d0ac061a694e3e926/f3583/ee-evaluation.png 1200w,\n/static/b5028e39443bd90d0ac061a694e3e926/bbee5/ee-evaluation.png 1800w,\n/static/b5028e39443bd90d0ac061a694e3e926/0ef64/ee-evaluation.png 2400w,\n/static/b5028e39443bd90d0ac061a694e3e926/5363e/ee-evaluation.png 2450w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Welcome to the second post of our journey towards Traefik Enterprise Edition . Let’s continue our journey by quickly evaluating the product on your local machine...","custom_excerpt":"Welcome to the second post of our journey towards Traefik Enterprise Edition . Let’s continue our journey by quickly evaluating the product on your local machine...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"January 22, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T13:47:23.000+00:00","published_at":"2019-01-22T13:47:00.000+00:00","updated_at":"2020-05-21T23:32:20.000+00:00","meta_title":"The Journey to Traefik Enterprise Edition: Product Evaluation","meta_description":"Welcome to the second post of our journey towards Traefik Enterprise Edition . Let’s continue our journey by quickly evaluating the product.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the second post of our journey towards Traefik Enterprise Edition\n[/traefikee/] .\n\nAfter our first step (Join the“Early Access” Program\n[/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/]\n), let’s continue by doing a quick evaluation the product on your local machine.\n\n> (A voice in the background): But, the shiny website says that it is a \ndistributed version. How can we assess this on a single machine?\n> (Another voice in the background): A developer machine is not a production\nenvironment!\n> Containous: These assertions are 100% right dear users! Following the core\nprinciples of Traefik, we want to keep things simple and start by getting\nTraefikEE up and running on a “testing system”. Don’t worry: next steps of the\njourney are coming, to cover other topics from high availability, to\ninstallation on production systems.\nTraefikEE Installation\nThe next step of the journey is to install TraefikEE: Let’s follow the provided \ndocumentation [https://docs.containo.us/]!\n\n“TraefikEE-Cuddle”\n\nThe “Getting Started with Installation\n[https://docs.containo.us/getting-started/]” page recommends to use the command\nline traefikeectl and guides you on installing this command:\n\n$ curl -sSL -o /usr/local/bin/traefikeectl https://get-the-link-for-your-operating-system/traefikeectl\n\n$ shasum -a256 /usr/local/bin/traefikeectl # Check against the SHA256 checksums for your release\n\n$ chmod a+x /usr/local/bin/traefikeectl # Make it executable\n\n$ traefikeectl version\nVersion:      v1.0.0-beta16\nCodename:     Gewurztraminer\nGo version:   go1.11.4\nBuilt:        2019-01-21_06:00:54PM\nOS/Arch:      darwin/amd64\n\nKubernetes Time!\n\nTraefikEE can be installed on different platforms but, this example uses \nKubernetes [https://kubernetes.io/].\n\n> (A voice in the background): I don’t know Kubernetes\nContainous: You don’t have to for this evaluation. But you can learn it from \nhttps://kubernetes.io/docs/tutorials/kubernetes-basics/\nA Kubernetes installation is required. Don’t worry, we are not yak shaving\n[https://en.wiktionary.org/wiki/yak_shaving] to select where and how install\nKubernetes.\n\nInstead we’ll use the awesome “KinD” (Kubernetes inside Docker)\n[https://github.com/kubernetes-sigs/kind] tool providing a disposable Kubernetes\nlocally.\n\n> (From https://github.com/kubernetes-sigs/kind), kind is a tool for running local\nKubernetes clusters using Docker container \"nodes\".\nkind is primarily designed for testing Kubernetes 1.11+, initially targeting the\nconformance tests. If you have Go [https://golang.org/] and Docker\n[https://www.docker.com/] installed go get sigs.k8s.io/kind && kind create\ncluster is all you need\nInstall your Kubernetes cluster for the evaluation:\n\n$ kind create cluster --name=traefikee\nCreating cluster 'kind-traefikee' ...\n✓ Ensuring node image (kindest/node:v1.12.3) 🖼\n✓ [kind-traefikee-control-plane] Creating node container 📦\n✓ [kind-traefikee-control-plane] Fixing mounts 🗻\n✓ [kind-traefikee-control-plane] Starting systemd 🖥\n✓ [kind-traefikee-control-plane] Waiting for docker to be ready 🐋\n✓ [kind-traefikee-control-plane] Starting Kubernetes (this may take a minute) ☸\n\nCluster creation complete. You can now use the cluster with:\nexport KUBECONFIG=\"$(kind get kubeconfig-path --name=\"traefikee\")\"\nkubectl cluster-info\n\n$ export KUBECONFIG=\"$(kind get kubeconfig-path --name=\"traefikee\")\"\n\n$ kubectl cluster-info\nKubernetes master is running at https://localhost:55243\n\n# We have a Kubernetes cluster ready to use!\n\nPlease note that any local Kubernetes installation passing the conformance tests\ncan be used for the evaluation (as Docker4Mac or Docker4Windows).\n\nTrafikEE Installation\n\nFollowing the official documentation [https://docs.containo.us], you may install\nTraefikEE in one line, using traefikeectl . It might take a few minute to\ndownload all the required resources:\n\n$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n...\n\nYou can access the dashboard with the following credentials:\n\nUsername: admin\nPassword: 4087abf2354666d9\n\n✔ Installation successful\n\nCongratulations, your TraefikEE cluster is installed locally!\n\nA Tour of TraefikEE\nTraefikEE is installed, now what?\n\nFirst, we have to open access from your web-browser to the cluster:\n\n# Forward TraefikEE data plane's port 80 to your localhost:8000\nkubectl port-forward -n traefikee \"$(kubectl get pod -n traefikee | awk '{print $1}' | grep data-node)\" 8000:80 &\n\nTraefikEE is now exposed on your machine on the following URL:\nhttp://localhost:8000 .\n\n> On a production-grade Kubernetes installation, you would use your external Load\nBalancer’s public hostname and port.\nWeb Dashboard\n\nLet’s start the tour with the Web Dashboard, which is enabled because we used\nthe flag--dashboard during the installation.\n\nOpen the URL http://localhost:8000 and authenticate with the username and\npassword credentials from the traefikeectl install command’s output from\nearlier.\n\n> In this example, the username is admin and the password is d4087abf2354666d9dsds\n. These credentials are generated automatically during the installation.\nYou can see the default section named “Providers” which shows you the\nTraefikEE’s routing configuration, generated from Kubernetes:\n\nLooks like Traefik’s WebUIUsing the top bar, navigate to the “Metrics” section\nto get an overview of the incoming request’s metrics.\n\n> (A voice in the background): Traefik also provides a “Metrics” page, what is the\nvalue of this one?\nContainous: It’s the same, except that metrics are aggregated from all the data\nplane’s nodes.\nLook, someone forgot its password and got HTTP/401 responsesIt’s time to get an\noverview of the cluster. Browse to the “Cluster” section to check that you have\na Control Plane of 3 nodes, and a Data Plane of 1 node.\n\n> (A voice in the background): Wait, isn’t TraefikEE distributed? Why only 1 node\nin the data plane?\nContainous: By default, there is 1 “TraefikEE Data Node” per Kubernetes node. We\nare using a single-node Kubernetes hence 1 data node. Wait for the next blog to\nlearn more about the distribution.\nIt’s a nice cluster that you have thereOperations with traefikeectl\n\nNext step of this tour is the “Smooth Operations” feature. We know that\nEngineers love automation. So we made a command line, traefikeectlto automate\nall the operations on your TraefikEE clusters.\n\nYou already tasted traefikeectl. Let’s do another example of operation by\nlisting all the cluster’s nodes with traefikeectl:\n\n$ traefikeectl list-nodes\n\nName                                 Role\n----                                 ----\ndata-node-traefikee-data-node-5fplw  DATA NODE\ntraefikee-control-node-0             CONTROL NODE (Current Leader)\ntraefikee-control-node-2             CONTROL NODE\ntraefikee-control-node-1             CONTROL NODE\n\nThe next section shows another example, but you can already check the \ntraefikeectl ‘s Command Line Reference Documentation\n[https://docs.containo.us/installing/teectl-cli/] to learn more about the\noperations features.\n\nDeploy an application\n\nTraefikEE is an edge router, which main goal is to route incoming request into\nyour applications.\n\n> (A voice in the background): Did you just say “applications”? But there are no\napplications deployed into this Kubernetes, only TraefikEE.\nContainous: Patience, there is an example below. But let that sink in: Isn’t the\nDashboard an application with incoming traffic?\nLet’s deploy an example application. It’s an HTTP web service, based on\ngithub.com/containous/whoami, which responds an HTML page with the headers of\nyour request.\n\n$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/8b87143b084c612f86d66f587df7c058c7fa1aa0/whoami.yaml\n\nCheck the dashboard again. After a few seconds, the routing configuration for\nthe application “whoami” is automatically picked by TraefikEE from Kubernetes: a\nfrontend and 2 associated backends (the 2 replicas).\n\nThe application is reachable at the URL localhost:8000/whoami. As the “whoami”\napplication is scaled to 2 instances, try to reload the page multiple time to\nsee the field “Hostname” changing, due to the Load Balancing.\n\nSuch Web, Much Text\n--------------------------------------------------------------------------------\n\nThat’s all for today and this first quick tour. On the next post “The Journey\nto\nTraefik Enterprise Edition: High Availability\n[/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/]\n”, we’ll cover the distributed features of TraefikEE.","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-10.png\" class=\"kg-image\"></figure><p>Welcome to the second post of our journey towards <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition</a> .</p><p>After our first step (<em><em><a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/\">Join the“Early Access” Program</a></em></em>), let’s continue by doing a quick evaluation the product on your local machine.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> But, the shiny website says that it is a <strong><strong>distributed</strong></strong> version. How can we assess this on a single machine?</em></em></blockquote><blockquote><em><em><strong><strong>(Another voice in the background):</strong></strong> A developer machine is <strong><strong>not</strong></strong> a production environment!</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> These assertions are 100% right dear users! Following the core principles of Traefik, we want to keep things simple and start by getting TraefikEE up and running on a “testing system”. Don’t worry: next steps of the journey are coming, to cover other topics from high availability, to installation on production systems.</em></em></blockquote><h2 id=\"traefikee-installation\">TraefikEE Installation</h2><p>The next step of the journey is to install TraefikEE: Let’s follow the provided <a href=\"https://docs.containo.us/\">documentation</a>!</p><p><strong><strong><em><em>“TraefikEE-Cuddle”</em></em></strong></strong></p><p>The “<a href=\"https://docs.containo.us/getting-started/\">Getting Started with Installation</a>” page recommends to use the command line <code>traefikeectl</code> and guides you on installing this command:</p><pre><code class=\"language-shell\">$ curl -sSL -o /usr/local/bin/traefikeectl https://get-the-link-for-your-operating-system/traefikeectl\n\n$ shasum -a256 /usr/local/bin/traefikeectl # Check against the SHA256 checksums for your release\n\n$ chmod a+x /usr/local/bin/traefikeectl # Make it executable\n\n$ traefikeectl version\nVersion:      v1.0.0-beta16\nCodename:     Gewurztraminer\nGo version:   go1.11.4\nBuilt:        2019-01-21_06:00:54PM\nOS/Arch:      darwin/amd64</code></pre><p><strong><strong><em><em>Kubernetes Time!</em></em></strong></strong></p><p>TraefikEE can be installed on different platforms but, this example uses <a href=\"https://kubernetes.io/\" rel=\"noopener\">Kubernetes</a>.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I don’t know Kubernetes</em></em><br><em><em><strong><strong>Containous:</strong></strong> You don’t have to for this evaluation. But you can learn it from <a href=\"https://kubernetes.io/docs/tutorials/kubernetes-basics/\" rel=\"noopener\">https://kubernetes.io/docs/tutorials/kubernetes-basics/</a></em></em></blockquote><p>A Kubernetes installation is required. Don’t worry, we are not <a href=\"https://en.wiktionary.org/wiki/yak_shaving\" rel=\"noopener\">yak shaving</a> to select where and how install Kubernetes.</p><p>Instead we’ll use the awesome <a href=\"https://github.com/kubernetes-sigs/kind\" rel=\"noopener\">“KinD” (Kubernetes inside Docker)</a> tool providing a disposable Kubernetes locally.</p><blockquote><em><em>(From <a href=\"https://github.com/kubernetes-sigs/kind\" rel=\"noopener\">https://github.com/kubernetes-sigs/kind</a></em>), <em><code><em>kind</em></code> is a tool for running local Kubernetes clusters using Docker container \"nodes\".</em></em><br><em><em><code><em>kind</em></code> is primarily designed for testing Kubernetes 1.11+, initially targeting the conformance tests.</em> <em>If you have <a href=\"https://golang.org/\" rel=\"noopener\">Go</a> and <a href=\"https://www.docker.com/\" rel=\"noopener\">Docker</a> installed <code><em>go get sigs.k8s.io/kind &amp;&amp; kind create cluster</em></code> is all you need</em></em></blockquote><p>Install your Kubernetes cluster for the evaluation:</p><pre><code class=\"language-shell\">$ kind create cluster --name=traefikee\nCreating cluster 'kind-traefikee' ...\n✓ Ensuring node image (kindest/node:v1.12.3) 🖼\n✓ [kind-traefikee-control-plane] Creating node container 📦\n✓ [kind-traefikee-control-plane] Fixing mounts 🗻\n✓ [kind-traefikee-control-plane] Starting systemd 🖥\n✓ [kind-traefikee-control-plane] Waiting for docker to be ready 🐋\n✓ [kind-traefikee-control-plane] Starting Kubernetes (this may take a minute) ☸\n\nCluster creation complete. You can now use the cluster with:\nexport KUBECONFIG=\"$(kind get kubeconfig-path --name=\"traefikee\")\"\nkubectl cluster-info\n\n$ export KUBECONFIG=\"$(kind get kubeconfig-path --name=\"traefikee\")\"\n\n$ kubectl cluster-info\nKubernetes master is running at https://localhost:55243\n\n# We have a Kubernetes cluster ready to use!</code></pre><p><em><em>Please note that any local Kubernetes installation passing the conformance tests can be used for the evaluation (as Docker4Mac or Docker4Windows).</em></em></p><p><strong><strong><em><em>TrafikEE Installation</em></em></strong></strong></p><p>Following the <a href=\"https://docs.containo.us\">official documentation</a>, you may install TraefikEE in one line, using <code>traefikeectl</code> . It might take a few minute to download all the required resources:</p><pre><code class=\"language-shell\">$ traefikeectl install \\\n  --licensekey=\"$(cat /keybase/.../traefikee-license)\" \\\n  --dashboard \\\n  --kubernetes\n...\n\nYou can access the dashboard with the following credentials:\n\nUsername: admin\nPassword: 4087abf2354666d9\n\n✔ Installation successful</code></pre><p>Congratulations, your TraefikEE cluster is installed locally!</p><h2 id=\"a-tour-of-traefikee\">A Tour of TraefikEE</h2><p>TraefikEE is installed, now what?</p><p>First, we have to open access from your web-browser to the cluster:</p><pre><code class=\"language-shell\"># Forward TraefikEE data plane's port 80 to your localhost:8000\nkubectl port-forward -n traefikee \"$(kubectl get pod -n traefikee | awk '{print $1}' | grep data-node)\" 8000:80 &amp;</code></pre><p>TraefikEE is now exposed on your machine on the following URL: http://localhost:8000 .</p><blockquote><em><em>On a production-grade Kubernetes installation, you would use your external Load Balancer’s public hostname and port.</em></em></blockquote><p><strong><strong><em><em>Web Dashboard</em></em></strong></strong></p><p>Let’s start the tour with the Web Dashboard, which is enabled because we used the flag<code>--dashboard</code> during the installation.</p><p>Open the URL http://localhost:8000 and authenticate with the username and password credentials from the <code>traefikeectl install</code> command’s output from earlier.</p><blockquote><em><em>In this example, the username is <code><em>admin</em></code> and the password is <code><em>d4087abf2354666d9dsds</em></code>. These credentials are generated automatically during the installation.</em></em></blockquote><p>You can see the default section named “Providers” which shows you the TraefikEE’s routing configuration, generated from Kubernetes:</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-46.png\" class=\"kg-image\"><figcaption>Looks like Traefik’s WebUI</figcaption></figure><p>Using the top bar, navigate to the “Metrics” section to get an overview of the incoming request’s metrics.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Traefik also provides a “Metrics” page, what is the value of this one?</em></em><br><em><em><strong><strong>Containous:</strong></strong> It’s the same, except that metrics are aggregated from all the data plane’s nodes.</em></em></blockquote><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-47.png\" class=\"kg-image\"><figcaption>Look, someone forgot its password and got HTTP/401 responses</figcaption></figure><p>It’s time to get an overview of the cluster. Browse to the “Cluster” section to check that you have a Control Plane of 3 nodes, and a Data Plane of 1 node.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Wait, isn’t TraefikEE distributed? Why only 1 node in the data plane?</em></em><br><em><em><strong><strong>Containous:</strong></strong> By default, there is 1 “TraefikEE Data Node” per Kubernetes node. We are using a single-node Kubernetes hence 1 data node. Wait for the next blog to learn more about the distribution.</em></em></blockquote><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-48.png\" class=\"kg-image\"><figcaption>It’s a nice cluster that you have there</figcaption></figure><p><strong><strong><em><em>Operations with traefikeectl</em></em></strong></strong></p><p>Next step of this tour is the “Smooth Operations” feature. We know that Engineers love automation. So we made a command line, <code>traefikeectl</code>to automate all the operations on your TraefikEE clusters.</p><p>You already tasted <code>traefikeectl</code>. Let’s do another example of operation by listing all the cluster’s nodes with <code>traefikeectl</code>:</p><pre><code class=\"language-shell\">$ traefikeectl list-nodes\n\nName                                 Role\n----                                 ----\ndata-node-traefikee-data-node-5fplw  DATA NODE\ntraefikee-control-node-0             CONTROL NODE (Current Leader)\ntraefikee-control-node-2             CONTROL NODE\ntraefikee-control-node-1             CONTROL NODE</code></pre><p>The next section shows another example, but you can already check the <code>traefikeectl</code> ‘s <a href=\"https://docs.containo.us/installing/teectl-cli/\">Command Line Reference Documentation</a> to learn more about the operations features.</p><p><strong><strong><em><em>Deploy an application</em></em></strong></strong></p><p>TraefikEE is an edge router, which main goal is to route incoming request into your applications.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Did you just say “applications”? But there are no applications deployed into this Kubernetes, only TraefikEE.</em></em><br><em><em><strong><strong>Containous:</strong></strong> Patience, there is an example below. But let that sink in: Isn’t the Dashboard an application with incoming traffic?</em></em></blockquote><p>Let’s deploy an example application. It’s an HTTP web service, based on github.com/containous/whoami, which responds an HTML page with the headers of your request.</p><pre><code class=\"language-shell\">$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/8b87143b084c612f86d66f587df7c058c7fa1aa0/whoami.yaml</code></pre><p>Check the dashboard again. After a few seconds, the routing configuration for the application “whoami” is automatically picked by TraefikEE from Kubernetes: a frontend and 2 associated backends (the 2 replicas).</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-49.png\" class=\"kg-image\"></figure><p>The application is reachable at the URL localhost:8000/whoami. As the “whoami” application is scaled to 2 instances, try to reload the page multiple time to see the field “Hostname” changing, due to the Load Balancing.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-50.png\" class=\"kg-image\"><figcaption>Such Web, Much Text</figcaption></figure><hr><p>That’s all for today and this first quick tour. On the next post “<a href=\"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/\">The Journey to Traefik Enterprise Edition: High Availability</a>”, we’ll cover the distributed features of TraefikEE.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/","canonical_url":null,"uuid":"63024ef7-edc2-4641-ad1c-3774332c9c49","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7e6ebf1db6f0038c7437f","reading_time":5}},{"node":{"id":"Ghost__Post__5dd7e9cff1db6f0038c743f4","title":"The Journey to Traefik Enterprise Edition: Join the Free “Early Access” Program","slug":"the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/ee.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/6a61f59bb594a837dfeec781fa0238ee/fe3a8/ee.png","srcSet":"/static/6a61f59bb594a837dfeec781fa0238ee/630fb/ee.png 300w,\n/static/6a61f59bb594a837dfeec781fa0238ee/2a4de/ee.png 600w,\n/static/6a61f59bb594a837dfeec781fa0238ee/fe3a8/ee.png 1035w","sizes":"(max-width: 1035px) 100vw, 1035px"}}},"excerpt":"Welcome to the first post of our journey with Traefik Enterprise Edition!\nThis post guides you through the first steps of your TraefikEE discovery journey...","custom_excerpt":"Welcome to the first post of our journey with Traefik Enterprise Edition!\nThis post guides you through the first steps of your TraefikEE discovery journey...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"January 14, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-22T13:59:43.000+00:00","published_at":"2019-01-14T13:59:00.000+00:00","updated_at":"2020-05-21T23:47:33.000+00:00","meta_title":"The Journey to TraefikEE: Join the Free “Early Access” Program","meta_description":"Welcome to the first post of our journey with Traefik Enterprise Edition!\nThis post guides you through the first steps of your TraefikEE discovery journey..","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Damien Duportal","slug":"damien","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/dduportal_light.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Welcome to the first post of our journey with Traefik Enterprise Edition\n[/traefikee/]!\n\nTraefikEE (Enterprise Edition) is available here\n[https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days] for\nfree.\n\nThis post guides you through the first steps of your TraefikEE discovery\njourney: From requesting the “early access” to obtaining your license key and\ngetting started.\n\nTraefikEE: Traefik, for the Enterprise World\nIntroduced during KubeCon US 2018 (check out the “Introducing Traefik\nEnterprise\nEdition” blog post [/blog/introducing-traefik-enterprise-edition-83b78d09efeb/]\n), TraefikEE is built on top of Traefik and adds clustering features to satisfy\nthe needs of Enterprise customers. All Traefik concepts apply to TraefikEE, so\nif you already are a Traefik user, you’re in familiar territory.\n\nTraefikEE runs on the edge of your platform to route the traffic to your\napplications.\n\nGlobal Architecture of Traefik Enterprise EditionTraefikEE is composed of two\nplanes:\n\n * The data plane: horizontally scalable nodes, which forward ingress traffic to\n   your services\n * The control plane: distributed nodes, implementing the raft consensus\n   [http://thesecretlivesofdata.com/raft/], which watch your platform and its\n   services, stores topology changes, and reconfigure the data plane to adapt\n   ingress routing dynamically\n\nThis distributed architecture is the cornerstone of TraefikEE’s strengths:\nnatively highly available, scalable, and secure.\n\nSupport Account and License\nThe journey begins by visiting the TraefikEE website at \nhttps://containo.us/traefikee [/traefikee/], and opting in to the program by\nclicking the “Free Trial” form.\n\n> (A voice in the background): I’ve been told it is free. Why should I give you my\npersonal information?\n> Containous: We need a way to communicate together, so the form creates a\n“Support Account” for you in our ticketing system. So you can raise requests if\nyou get any issue with TraefikEE, and we can send you information about update.\nOnce you’ve filled out the form, look for a “Welcome to Containous” e-mail sent\nfrom support@containous.zendesk.com in your mail’s inbox (or, possibly junk\nfolder). Click on the link it contains to validate your account. You will be\nprompted to set a (strong) password: you know the story [https://xkcd.com/936/].\n\nOnce your account is validated with a (strong) password, the system will\ngenerate a TraefikEE license and send you an e-mail entitled “Your license key”\n(it may take a couple minutes) which will contain instructions.\n\nKnock, knock, you got an email!> (A voice in the background): I never received the email. It’s probably tagged as\nspam by my organization’s mail system.\n> Containous: Instead of the email, you can also browse the customer portal at \nhttps://support.containo.us/\n[https://containous.zendesk.com/hc/en-us/restricted?return_to=https%3A%2F%2Fcontainous.zendesk.com%2Fhc%2Fen-us]\n, select the button “Check my existing requests / License” and open the request\nnamed “Your license key”.\nGet your license and put it somewhere “secure” (e.g. an encrypted system). For\nthis post series, we store the license in a file, encrypted into a Keybase.io\n[https://keybase.io/] volume:\n\n$ cat /keybase/private/dduportal/traefikee-license\nxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n\nThat’s all folks, you can get started with the installation from the\ndocumentation [https://docs.containo.us/].\n\nOn the next post “The Journey to Traefik Enterprise Edition: Product\nEvaluation”, we will install TraefikEE on your machine and take a tour of its\nfeatures.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/12/image-11.png\" class=\"kg-image\"></figure><p>Welcome to the first post of our journey with <a href=\"https://containous.ghost.io/traefikee/\">Traefik Enterprise Edition</a>!</p><p>TraefikEE (Enterprise Edition) is available <a href=\"https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days\">here</a> for free.</p><p>This post guides you through the first steps of your TraefikEE discovery journey: From requesting the “early access” to obtaining your license key and getting started.</p><h2 id=\"traefikee-traefik-for-the-enterprise-world\">TraefikEE: Traefik, for the Enterprise World</h2><p>Introduced during KubeCon US 2018 (<a href=\"https://containous.ghost.io/blog/introducing-traefik-enterprise-edition-83b78d09efeb/\">check out the “Introducing Traefik Enterprise Edition” blog post</a>), TraefikEE is built on top of Traefik and adds clustering features to satisfy the needs of Enterprise customers. All Traefik concepts apply to TraefikEE, so if you already are a Traefik user, you’re in familiar territory.</p><p>TraefikEE runs on the edge of your platform to route the traffic to your applications.</p><figure class=\"kg-card kg-image-card kg-width-wide kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-51.png\" class=\"kg-image\"><figcaption>Global Architecture of Traefik Enterprise Edition</figcaption></figure><p>TraefikEE is composed of two planes:</p><ul><li>The <strong><strong>data plane</strong></strong>: horizontally scalable nodes, which forward ingress traffic to your services</li><li>The <strong><strong>control plane</strong></strong>: distributed nodes, implementing <a href=\"http://thesecretlivesofdata.com/raft/\" rel=\"noopener\">the raft consensus</a>, which watch your platform and its services, stores topology changes, and reconfigure the data plane to adapt ingress routing dynamically</li></ul><p>This distributed architecture is the cornerstone of TraefikEE’s strengths: natively <strong><strong>highly available</strong></strong>, <strong><strong>scalable</strong></strong>, and <strong><strong>secure</strong></strong>.</p><h2 id=\"support-account-and-license\">Support Account and License</h2><p>The journey begins by visiting the TraefikEE website at <a href=\"https://containous.ghost.io/traefikee/\">https://containo.us/traefikee</a>, and opting in to the program by clicking the “Free Trial” form.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I’ve been told it is free. Why should I give you my personal information?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> We need a way to communicate together, so the form creates a “Support Account” for you in our ticketing system. So you can raise requests if you get any issue with TraefikEE, and we can send you information about update.</em></em></blockquote><p>Once you’ve filled out the form, look for a “Welcome to Containous” e-mail sent from <a href=\"mailto:support@containous.zendesk.com\" rel=\"noopener\">support@containous.zendesk.com</a> in your mail’s inbox (or, possibly junk folder). Click on the link it contains to validate your account. You will be prompted to set a (strong) password: <a href=\"https://xkcd.com/936/\" rel=\"noopener\">you know the story</a>.</p><p>Once your account is validated with a (strong) password, the system will generate a TraefikEE license and send you an e-mail entitled “Your license key” (it may take a couple minutes) which will contain instructions.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-53.png\" class=\"kg-image\"><figcaption>Knock, knock, you got an email!</figcaption></figure><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I never received the email. It’s probably tagged as spam by my organization’s mail system.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Instead of the email, you can also browse the customer portal at</em> </em><a href=\"https://containous.zendesk.com/hc/en-us/restricted?return_to=https%3A%2F%2Fcontainous.zendesk.com%2Fhc%2Fen-us\">https://support.containo.us/</a><em><em>, select the button “Check my existing requests / License” and open the request named “Your license key”.</em></em></blockquote><p>Get your license and put it somewhere “secure” (e.g. an encrypted system). For this post series, we store the license in a file, encrypted into a <a href=\"https://keybase.io/\" rel=\"noopener\">Keybase.io</a> volume:</p><pre><code class=\"language-shell\">$ cat /keybase/private/dduportal/traefikee-license\nxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></pre><p>That’s all folks, you can <a href=\"https://docs.containo.us/\">get started with the installation from the documentation</a>.</p><p>On the next post “The Journey to Traefik Enterprise Edition: Product Evaluation”, we will install TraefikEE on your machine and take a tour of its features.</p>","url":"https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/","canonical_url":null,"uuid":"ba5a6dc5-e17f-4c5a-ace8-c1c2b1bb61c9","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7e9cff1db6f0038c743f4","reading_time":3}}]}},"pageContext":{"slug":"damien","limit":9,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}