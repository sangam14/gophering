{"componentChunkName":"component---src-templates-author-tsx","path":"/author/greenled/","result":{"data":{"ghostAuthor":{"slug":"greenled","name":"Juan Carlos Mejías Rodríguez","bio":"DevOps engineer and lecturer at the University of Camagüey, Cuba. Specialized on continuous integration, Linux and Docker containers. Developing, deploying and monitoring web applications since 2015.","cover_image":"https://containous.ghost.io/content/images/2020/05/resumen-fotos-093.jpg","profile_image":"//www.gravatar.com/avatar/23f5bab61dffbd57974ca32a6d65dba5?s=250&d=mm&r=x","location":"Camagüey, Cuba","website":"https://greenled.github.io","twitter":"@greenled2013","facebook":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5ec806bb4e2e9a0045ce791f","title":"Gradual Migration from Traefik 1.x to 2.x","slug":"gradual-migration-from-traefik-1-to-2","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/47498/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg","srcSet":"/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/9dc27/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 300w,\n/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/4fe8c/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 600w,\n/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/47498/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 1200w,\n/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/52258/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 1800w,\n/static/e5fd74b8a7a81dde1f452bdfb0e1ed83/a41d1/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"In this post, I will share a migration strategy that helped me move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback.","custom_excerpt":"In this post, I will share a migration strategy that helped me move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback.","visibility":"public","created_at_pretty":"22 May, 2020","published_at_pretty":"June 9, 2020","updated_at_pretty":"25 August, 2020","created_at":"2020-05-22T17:07:07.000+00:00","published_at":"2020-06-09T05:33:17.000+00:00","updated_at":"2020-08-25T22:50:45.000+00:00","meta_title":"Gradual Migration from Traefik 1.x to 2.x","meta_description":"This post shares a migration strategy that helped move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x-Twitter.png","twitter_title":null,"authors":[{"name":"Juan Carlos Mejías Rodríguez","slug":"greenled","bio":"DevOps engineer and lecturer at the University of Camagüey, Cuba. Specialized on continuous integration, Linux and Docker containers. Developing, deploying and monitoring web applications since 2015.","profile_image":"//www.gravatar.com/avatar/23f5bab61dffbd57974ca32a6d65dba5?s=250&d=mm&r=x","twitter":"@greenled2013","facebook":null,"website":"https://greenled.github.io"}],"primary_author":{"name":"Juan Carlos Mejías Rodríguez","slug":"greenled","bio":"DevOps engineer and lecturer at the University of Camagüey, Cuba. Specialized on continuous integration, Linux and Docker containers. Developing, deploying and monitoring web applications since 2015.","profile_image":"//www.gravatar.com/avatar/23f5bab61dffbd57974ca32a6d65dba5?s=250&d=mm&r=x","twitter":"@greenled2013","facebook":null,"website":"https://greenled.github.io"},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"How To","slug":"how-to","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#community-related-resource","slug":"hash-community-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"},{"name":"#traefik-related-resource","slug":"hash-traefik-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Guest post by Juan Carlos Mejías, Traefik Ambassador\n\nAre you a happy Traefik user? Join the club! I use Traefik as a reverse proxy to\nmanage the ingress of several dozen services in a Docker Swarm cluster, and\ncouldn't be happier with it. Since its introduction in early 2015, Traefik has\ngrown in maturity and popularity (don't take my word, look at the project's\nstargazers over time [https://star-history.t9t.io/#containous/traefik]. When\nTraefik v2 was released I couldn't help but think about migrating, but I had one\nmajor concern: downtime.\n\nTraefik's documentation explains how to migrate configurations from 1.x format\nto 2.x format however, as in any system with some degree of complexity,\nmigrating is not just about changing configurations but managing them. You have\nto make sure everything keeps running smoothly and be prepared to rollback in\ncase something goes wrong -have you heard of Murphy's Law? Also, you probably\ndon't want to migrate the whole system at a time, or you could quickly find\nyourself trying to put out more fires than you can handle.\n\nIn this post, I will share a migration strategy that helped me move to Traefik 2\nwith very little downtime, one service at a time, with an easy way to rollback.\nFor the sake of clarity and brevity, I will start from a single Traefik instance\nwith two backend services and will keep everything in a single Docker Swarm\nstack. The same strategy could be used in a clustered Traefik deployment with\nmany more backend services as well. In fact, this scenario is where Traefik\nshines the brightest.\n\nInitial setup\nLet's start from the following setup, with a Traefik 1 instance as a reverse\nproxy and two Nginx services, all running on Docker Swarm:\n\nInitial setup. Traefik 1 handling all routingThis configuration can be deployed\nto the swarm with the following stack definition:\n\n# docker-compose.yaml\n\n# Version >= 3.3 so configs are available\nversion: \"3.4\"\n\nnetworks:\n  traefik-public:\n    external: true\n\nconfigs:\n  index1:\n    # Contains string \"1\"\n    file: ./index1.html\n  index2:\n    # Contains string \"2\"\n    file: ./index2.html\n\nservices:\n  traefik1:\n    image: traefik:v1.7\n    ports:\n      - \"80:80\"\n    volumes:\n      # So that Traefik can listen to the Docker events\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: >\n      --docker\n      --docker.swarmmode\n      --entrypoints='Name:http Address::80'\n    networks:\n      - traefik-public\n\n  web1:\n    image: nginx:1-alpine\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.frontend.rule=Host:web1.docker.local\n        - traefik.port=80\n        - traefik.webservice.frontend.entryPoints=http\n    configs:\n      - source: index1\n        target: /usr/share/nginx/html/index.html\n    networks:\n      - traefik-public\n\n  web2:\n    image: nginx:1-alpine\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.frontend.rule=Host:web2.docker.local\n        - traefik.port=80\n        - traefik.webservice.frontend.entryPoints=http\n    configs:\n      - source: index2\n        target: /usr/share/nginx/html/index.html\n    networks:\n      - traefik-public\n\n\nFiles index1.html and index1.html contain strings 1 and 2 respectively:\n\necho 1 > index1.html\necho 2 > index2.html\n\n\nWith the above configuration, you can now create a Docker Swarm (if you don't\nalready have one), an overlay network for Traefik and deploy the stack:\n\ndocker swarm init\ndocker network create --driver=overlay traefik-public\ndocker stack deploy -c docker-compose.yaml traefik\n\n\nWhen the stack deployment finishes you will be able to query the defined Nginx\nservices as web1.docker.local and web2.docker.local. In the example below I’m\nusing curl:\n\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 2\n\n\nIt may take a few seconds to start the containers so if you get a 404 page not\nfound response just wait and try again.\n\nTraefik 2 with fallback to Traefik 1\nYou now have a working Traefik 1.x reverse proxy and two backend services. Let's\nmigrate it to 2.x! Next you are going to add a Traefik 2 service which will run\nalongside and proxy requests to the existing one. Incoming requests will be\nrouted to the Traefik 2 service and if no routes are matched they will then be\nrouted to the Traefik 1 service.\n\nTraefik 2 routing all requests to Traefik 1Deploy these changes to the stack\ndefinition file:\n\n # docker-compose.yaml\n\n ...\n configs:\n   ...\n+  # Dynamic configuration for Traefik 2 (see below)\n+  traefik2-providers:\n+    file: ./traefik2-providers.yaml\n\n services:\n   traefik1:\n     image: traefik:v1.7\n-    ports:\n-      - \"80:80\"\n   ...\n+  traefik2:\n+    image: traefik:v2.1\n+    ports:\n+      # The HTTP port\n+      - \"80:80\"\n+    volumes:\n+      # So that Traefik can listen to the Docker events\n+      - /var/run/docker.sock:/var/run/docker.sock\n+    command: >\n+      --providers.docker\n+      --providers.docker.swarmMode\n+      --providers.file.directory=/etc/traefik\n+      --providers.file.filename=providers.yaml\n+      --entryPoints.http.address=:80\n+      --api.insecure\n+    configs:\n+      - source: traefik2-providers\n+        target: /etc/traefik/providers.yaml\n+    networks:\n+      - traefik-public\n\n\nThe traefik2-providers.yaml file used in the traefik2-providers config directive\nfor the traefik2 service defines a catch-all route that forwards unmatched\nrequests to the traefik1 service:\n\n# traefik2-providers.yaml\n\nhttp:\n  routers:\n    # Define a catch-all router that forwards requests to legacy Traefik\n    to-traefik1:\n      # Catch all domains (regex matches all strings)\n      # See https://github.com/google/re2/wiki/Syntax\n      rule: \"HostRegexp(`{domain:.+}`)\"\n      # If the rule matches, forward to the traefik1 service (see below)\n      service: traefik1\n      # Set the lowest priority, so this route is only used as a last resort\n      priority: 1\n\n  services:\n    # Define how to reach legacy Traefik\n    traefik1:\n      loadBalancer:\n        servers:\n          # Legacy Traefik is part of the same stack so,\n          # hostname defaults to service name\n          - url: http://traefik1\n\n\nRedeploy the stack and check everything is still working as expected:\n\ndocker stack deploy -c docker-compose.yaml traefik\n# ...\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web2.docker.local http://127.0.0.1\n# 2\n\n\nTraefik 2 replacing Traefik 1\nNext let's set up Traefik 2 to handle requests to web1, as in Image 3:\n\nTraefik 2 handling web1 service's routingThis setup can be achieved by updating web1 service labels to match Traefik 2\nformat as follows:\n\n...\nservices:\n  ...\n  web1:\n    ...\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.http.routers.web1.rule=Host(`web1.docker.local`)\n        - traefik.http.services.web1.loadbalancer.server.port=80\n    ...\n\n\nRedeploy the stack and again check everything is still working as expected:\n\ndocker stack deploy -c docker-compose.yaml traefik\n# ...\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web2.docker.local http://127.0.0.1\n# 2\n\n\nNow repeat the process for web2 service. If something goes wrong, you just need\nto revert to a previous working configuration for the affected service,\nredeploy, and start over. In a real-world scenario with lots of services,\nmigration can take place one service at a time like this, reducing downtime.\nWhen you finish migrating to Traefik 2, take down the Traefik 1 service. You\nwill then end up with this scenario:\n\nTraefik 2 handling all routingWrapping Up\nAnd that's it! You’ve successfully migrated from Traefik [/traefik/] 1.x to 2.x\none service at a time. This step by step migration strategy comes from the\nStranglerFigApplication pattern, as described by Martin Fowler\n[https://martinfowler.com/bliki/StranglerFigApplication.html]. As a final note,\nI would highly recommend putting your configurations under version control as\nthat would make it very easy to roll back changes when needed.\n\nAuthor's Bio\nJuan Carlos is a lecturer at the Informatics and Exact Sciences Faculty of the\nUniversity of Camagüey, Cuba, [https://www.reduc.edu.cu/] and also DevOps\nengineer at the same institution. He has specialized on version control,\ncontinuous integration and deployment, Linux, and Docker containers. Since 2015\nhe has developed, deployed and monitored web applications for the University's\nIT infrastructure.","html":"<p><strong>Guest post by Juan Carlos Mejías, Traefik Ambassador</strong></p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg\" class=\"kg-image\" alt=\"Gradual Migration from Traefik 1.x to 2.x\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 1600w, https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><!--kg-card-begin: markdown--><p>Are you a happy Traefik user? Join the club! I use Traefik as a reverse proxy to manage the ingress of several dozen services in a Docker Swarm cluster, and couldn't be happier with it. Since its introduction in early 2015, Traefik has grown in maturity and popularity (don't take my word, look at <a href=\"https://star-history.t9t.io/#containous/traefik\" target=\"_blank\" rel=\"nofollow\">the project's stargazers over time</a>. When Traefik v2 was released  I couldn't help but think about migrating, but I had one major concern: downtime.</p>\n<p>Traefik's documentation explains how to migrate configurations from 1.x format to 2.x format however, as in any system with some degree of complexity, migrating is not just about changing configurations but managing them. You have to make sure everything keeps running smoothly and be prepared to rollback in case something goes wrong -have you heard of Murphy's Law? Also, you probably don't want to migrate the whole system at a time, or you could quickly find yourself trying to put out more fires than you can handle.</p>\n<p>In this post, I will share a migration strategy that helped me move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback. For the sake of clarity and brevity, I will start from a single Traefik instance with two backend services and will keep everything in a single Docker Swarm stack. The same strategy could be used in a clustered Traefik deployment with many more backend services as well. In fact, this scenario is where Traefik shines the brightest.</p>\n<h2 id=\"initialsetup\">Initial setup</h2>\n<p>Let's start from the following setup, with a Traefik 1 instance as a reverse proxy and two Nginx services, all running on Docker Swarm:</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/06/1-diagram1-traefik1-handling-all-routing.png\" class=\"kg-image\" alt=\"Initial setup. Traefik 1 handling all routing\"><figcaption>Initial setup. Traefik 1 handling all routing</figcaption></figure><!--kg-card-begin: markdown--><p>This configuration can be deployed to the swarm with the following stack definition:</p>\n<pre><code class=\"language-yaml\"># docker-compose.yaml\n\n# Version &gt;= 3.3 so configs are available\nversion: &quot;3.4&quot;\n\nnetworks:\n  traefik-public:\n    external: true\n\nconfigs:\n  index1:\n    # Contains string &quot;1&quot;\n    file: ./index1.html\n  index2:\n    # Contains string &quot;2&quot;\n    file: ./index2.html\n\nservices:\n  traefik1:\n    image: traefik:v1.7\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      # So that Traefik can listen to the Docker events\n      - /var/run/docker.sock:/var/run/docker.sock\n    command: &gt;\n      --docker\n      --docker.swarmmode\n      --entrypoints='Name:http Address::80'\n    networks:\n      - traefik-public\n\n  web1:\n    image: nginx:1-alpine\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.frontend.rule=Host:web1.docker.local\n        - traefik.port=80\n        - traefik.webservice.frontend.entryPoints=http\n    configs:\n      - source: index1\n        target: /usr/share/nginx/html/index.html\n    networks:\n      - traefik-public\n\n  web2:\n    image: nginx:1-alpine\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.frontend.rule=Host:web2.docker.local\n        - traefik.port=80\n        - traefik.webservice.frontend.entryPoints=http\n    configs:\n      - source: index2\n        target: /usr/share/nginx/html/index.html\n    networks:\n      - traefik-public\n</code></pre>\n<p>Files <code>index1.html</code> and <code>index1.html</code> contain strings <code>1</code> and <code>2</code> respectively:</p>\n<pre><code class=\"language-bash\">echo 1 &gt; index1.html\necho 2 &gt; index2.html\n</code></pre>\n<p>With the above configuration, you can now create a Docker Swarm (if you don't already have one), an overlay network for Traefik and deploy the stack:</p>\n<pre><code class=\"language-bash\">docker swarm init\ndocker network create --driver=overlay traefik-public\ndocker stack deploy -c docker-compose.yaml traefik\n</code></pre>\n<p>When the stack deployment finishes you will be able to query the defined Nginx services as <code>web1.docker.local</code> and <code>web2.docker.local</code>. In the example below I’m using curl:</p>\n<pre><code class=\"language-bash\">curl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 2\n</code></pre>\n<p>It may take a few seconds to start the containers so if you get a <code>404 page not found</code> response just wait and try again.</p>\n<h2 id=\"traefik2withfallbacktotraefik1\">Traefik 2 with fallback to Traefik 1</h2>\n<p>You now  have a working Traefik 1.x reverse proxy and two backend services. Let's migrate it to 2.x! Next you are going to add a Traefik 2 service which will run alongside and proxy requests to the existing one. Incoming requests will be routed to the Traefik 2 service and if no routes are matched they will then be routed to the  Traefik 1 service.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/06/2-diagram2-traefik2-routing-requests-to-traefik1.png\" class=\"kg-image\" alt=\"Traefik 2 routing all requests to Traefik 1\"><figcaption>Traefik 2 routing all requests to Traefik 1</figcaption></figure><!--kg-card-begin: markdown--><p>Deploy these changes to the stack definition file:</p>\n<pre><code class=\"language-diff\"> # docker-compose.yaml\n\n ...\n configs:\n   ...\n+  # Dynamic configuration for Traefik 2 (see below)\n+  traefik2-providers:\n+    file: ./traefik2-providers.yaml\n\n services:\n   traefik1:\n     image: traefik:v1.7\n-    ports:\n-      - &quot;80:80&quot;\n   ...\n+  traefik2:\n+    image: traefik:v2.1\n+    ports:\n+      # The HTTP port\n+      - &quot;80:80&quot;\n+    volumes:\n+      # So that Traefik can listen to the Docker events\n+      - /var/run/docker.sock:/var/run/docker.sock\n+    command: &gt;\n+      --providers.docker\n+      --providers.docker.swarmMode\n+      --providers.file.directory=/etc/traefik\n+      --providers.file.filename=providers.yaml\n+      --entryPoints.http.address=:80\n+      --api.insecure\n+    configs:\n+      - source: traefik2-providers\n+        target: /etc/traefik/providers.yaml\n+    networks:\n+      - traefik-public\n</code></pre>\n<p>The <code>traefik2-providers.yaml</code> file used in the <code>traefik2-providers</code> config directive for the <code>traefik2</code> service defines a catch-all route that forwards unmatched requests to the <code>traefik1</code> service:</p>\n<pre><code class=\"language-yaml\"># traefik2-providers.yaml\n\nhttp:\n  routers:\n    # Define a catch-all router that forwards requests to legacy Traefik\n    to-traefik1:\n      # Catch all domains (regex matches all strings)\n      # See https://github.com/google/re2/wiki/Syntax\n      rule: &quot;HostRegexp(`{domain:.+}`)&quot;\n      # If the rule matches, forward to the traefik1 service (see below)\n      service: traefik1\n      # Set the lowest priority, so this route is only used as a last resort\n      priority: 1\n\n  services:\n    # Define how to reach legacy Traefik\n    traefik1:\n      loadBalancer:\n        servers:\n          # Legacy Traefik is part of the same stack so,\n          # hostname defaults to service name\n          - url: http://traefik1\n</code></pre>\n<p>Redeploy the stack and check everything is still  working as expected:</p>\n<pre><code class=\"language-bash\">docker stack deploy -c docker-compose.yaml traefik\n# ...\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web2.docker.local http://127.0.0.1\n# 2\n</code></pre>\n<h2 id=\"traefik2replacingtraefik1\">Traefik 2 replacing Traefik 1</h2>\n<p>Next let's set up Traefik 2 to handle requests to <code>web1</code>, as in Image 3:</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/06/3-diagram3-traefik2-handling-web1-routing.png\" class=\"kg-image\" alt=\"Traefik 2 handling web1 service's routing\"><figcaption>Traefik 2 handling web1 service's routing</figcaption></figure><!--kg-card-begin: markdown--><p>This setup can be achieved by updating <code>web1</code> service labels to match Traefik 2 format as follows:</p>\n<pre><code class=\"language-yaml\">...\nservices:\n  ...\n  web1:\n    ...\n    deploy:\n      labels:\n        - traefik.enable=true\n        - traefik.http.routers.web1.rule=Host(`web1.docker.local`)\n        - traefik.http.services.web1.loadbalancer.server.port=80\n    ...\n</code></pre>\n<p>Redeploy the stack and again check everything is still working as expected:</p>\n<pre><code class=\"language-bash\">docker stack deploy -c docker-compose.yaml traefik\n# ...\ncurl -H Host:web1.docker.local http://127.0.0.1\n# 1\ncurl -H Host:web2.docker.local http://127.0.0.1\n# 2\n</code></pre>\n<p>Now repeat the process for <code>web2</code> service. If something goes wrong, you just need to revert to a previous working configuration for the affected service, redeploy, and start over. In a real-world scenario with lots of services, migration can take place one service at a time like this, reducing downtime.<br>\nWhen you finish migrating to Traefik 2, take down the Traefik 1 service. You will then end up with this scenario:</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/06/4-diagram4-traefik2-handling-all-routing.png\" class=\"kg-image\" alt=\"Traefik 2 handling all routing\"><figcaption>Traefik 2 handling all routing</figcaption></figure><!--kg-card-begin: markdown--><h2 id=\"wrappingup\">Wrapping Up</h2>\n<p>And that's it! You’ve successfully migrated from <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> 1.x to 2.x one service at a time. This step by step migration strategy comes from the StranglerFigApplication pattern, as <a href=\"https://martinfowler.com/bliki/StranglerFigApplication.html\" target=\"_blank\" rel=\"nofollow\">described by Martin Fowler</a>. As a final note, I would highly recommend putting your configurations under version control as that would make it very easy to roll back changes when needed.</p>\n<h3 id=\"authorsbio\">Author's Bio</h3>\n<p>Juan Carlos is a lecturer at the <a href=\"https://www.reduc.edu.cu/\">Informatics and Exact Sciences Faculty of the University of Camagüey, Cuba,</a> and also DevOps engineer at the same institution. He has specialized on version control, continuous integration and deployment, Linux, and Docker containers. Since 2015 he has developed, deployed and monitored web applications for the University's IT infrastructure.</p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/gradual-migration-from-traefik-1-to-2/","canonical_url":null,"uuid":"54e054d8-0db0-4a41-9c09-13d3db8daeb1","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ec806bb4e2e9a0045ce791f","reading_time":6}}]}},"pageContext":{"slug":"greenled","limit":9,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}