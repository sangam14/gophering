{"componentChunkName":"component---src-templates-author-tsx","path":"/author/marc/","result":{"data":{"ghostAuthor":{"slug":"marc","name":"Marc Vertes","bio":null,"cover_image":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/mv2.png","location":null,"website":null,"twitter":"@MarcVertes","facebook":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5dd5560dec5ed300387889f5","title":"Announcing Yaegi","slug":"announcing-yaegi-263a1e2d070a","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/yaegi.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/9c70aec44ba59d7e82b64c010a65a5f2/f3583/yaegi.png","srcSet":"/static/9c70aec44ba59d7e82b64c010a65a5f2/630fb/yaegi.png 300w,\n/static/9c70aec44ba59d7e82b64c010a65a5f2/2a4de/yaegi.png 600w,\n/static/9c70aec44ba59d7e82b64c010a65a5f2/f3583/yaegi.png 1200w,\n/static/9c70aec44ba59d7e82b64c010a65a5f2/bbee5/yaegi.png 1800w,\n/static/9c70aec44ba59d7e82b64c010a65a5f2/ed396/yaegi.png 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Yaegi, Yet Another Go Interpreter, is an open source project to bring executableGo scripts, embedded plugins on top of the Go runtime...","custom_excerpt":"Yaegi, Yet Another Go Interpreter, is an open source project to bring executableGo scripts, embedded plugins on top of the Go runtime...","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"July 24, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T15:04:45.000+00:00","published_at":"2019-07-24T15:04:00.000+00:00","updated_at":"2020-05-21T23:54:41.000+00:00","meta_title":"Announcing Yaegi, Yet Another Go Interpreter","meta_description":"Yaegi is an open source project developed to bring executable Go scripts, embedded plugins, interactive shells, and instant prototyping","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Marc Vertes","slug":"marc","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/mv2.png","twitter":"@MarcVertes","facebook":null,"website":null}],"primary_author":{"name":"Marc Vertes","slug":"marc","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/mv2.png","twitter":"@MarcVertes","facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Yet Another Go Interpreter\n\nIn this post, we present Yaegi [https://github.com/containous/yaegi/], Yet\nAnother Go Interpreter, with the E standing for Elegant, Embedded, Easy, or\nwhatever you prefer.\n\nYaegi is an open source project developed by Containous, (the company behind \nTraefik [/traefik/] and TraefikEE [/traefikee/]), to bring executable Go\n[https://golang.org/] scripts, embedded plugins, interactive shells, and instant\nprototyping on top of the Go runtime. Yaegi project is hosted on GitHub\n[https://github.com/containous/yaegi].\n\nMotivation\nDespite being static and strongly typed, Go feels like a dynamic language. The\nstandard library even provides the Go parser used by the compiler and the\nreflection system to interact dynamically with the runtime. So why not just take\nthe last logical step and finally build a complete Go interpreter?\n\nProgramming languages for high level scripting and for low level implementation\nare usually different. This time, with Go, we have an opportunity to unify both.\nImagine all the C/C++/Java fast libraries for Python being written in Python\ninstead. That’s what Yaegi is for Go (or, the reverse). No burden due to syntax\nswitch, no need to rewrite or modify slow code to make it fast, and full access\nto goroutines, channels, type safety, etc. at script level.\n\nGoals and Priorities\n * Simplicity: New(), Eval() and Use() is the only API. No external dependencies\n   besides the standard Go library.\n * Standard: the interpreter supports 100% of the Go Specification\n   [https://golang.org/ref/spec].\n * Robustness: preserve type safety and runtime integrity: unsafe and syscall\n   packages are not used nor exposed by default. Security over performance.\n * Interoperability: scripts can “import” pre-compiled runtime packages, but\n   also compiled code can “import” script packages during execution. See usage\n   examples below for more details.\n\nUsing Yaegi\nAs a Command-Line Interpreter\nThe Yaegi executable can interpret Go files or run an interactive\nRead-Eval-Print-Loop:\n\n$ yaegi\n> 1 + 2\n3\n> import \"fmt\"\n> fmt.Println(\"Hello World\")\nHello World\n>\n\nYaegi works like go run (but faster). It also enables executable Go scripts\n(starting with #!). Yaegi provides a full Go environment with a complete\nstandard library in a single standalone executable.\n\nAs an Embedded Interpreter\nIn the following example, an interpreter is created with New() and then it\nevaluates Go code using Eval(). Nothing surprising here.\n\npackage main\n\nimport (\n    \"github.com/containous/yaegi/interp\"\n    \"github.com/containous/yaegi/stdlib\"\n)\n\nfunc main() {\n    i := interp.New(interp.Options{})\n    i.Use(stdlib.Symbols)\n    i.Eval(`import \"fmt\"`)\n    i.Eval(`fmt.Println(\"hello\")`)\n}\n\nThis example demonstrates the ability to use executable pre-compiled symbols in\nthe interpreter. Thanks to the statement i.Use(stdlib.Symbols), the interpreted \nimport \"fmt\"will load the fmt package from the executable itself (wrapped in \nreflect.Values) instead of trying to parse source files.\n\nYaegi also provides the goexports command to build the binary wrapper of any\npackage from its source. This is the command we used to generate all stdlib\nwrappers provided by default.\n\nAs a Dynamic Extension Framework\nThe program is compiled ahead of time, except for the function bar() that is\ninterpreted from a script. The import process involves the following steps:\n\n 1. use of i.Eval(src) to internally compile the script package in the context\n    of the interpreter\n 2. use of v,_ := i.Eval(\"foo.Bar\") to get the symbol that we want to use as a \n    reflect.Value (please forgive me for the missing error handling)\n 3. application of Interface()method and type assertion to convert the \n    reflect.Value into a usable Go typed function\n\npackage main\n\nimport \"github.com/containous/yaegi/interp\"\n\nconst src = `package foo\nfunc Bar(s string) string { return s + \"-Foo\" }`\n\nfunc main() {\n    i := interp.New(interp.Options{})\n    i.Eval(src)\n    v, _ := i.Eval(\"foo.Bar\")\n    bar := v.Interface().(func(string) string)\n    \n    r := bar(\"Kung\")\n    println(r)\n    // Output:\n    // Kung-Foo\n}\n\nWhat about Performance?\nInterpreters are quite common in domains like gaming or science. But could Yaegi\nalso be usable as a plugin engine in the context of distributed systems?\n\nTo answer that, we have benchmarked the use of gziphandler\n[https://github.com/nytimes/gziphandler], a middleware for compressing HTTP\nresponses. Gziphandler provides interface methods implementing compression for\nthe HTTP server in the standard library. This demonstrates an interpreted\ndynamic processing inserted into a statically compiled server program, with a\ndirect impact on latency and throughput.\n\nIn one case, gziphandler is compiled and used directly as a callback passed to \nhttp.Handle(). In the other, the interpreted version of gziphandler is used.\n\nBenchmark      old ns/op   new ns/op    delta\nCompress-8     769088      817632       +6.31%\n\nWe measured less than 10% of overhead for the interpreted version of gziphandler\ncompared to the compiled version, which is to us an acceptable cost for to the\nbenefits of dynamically extending foour server.\n\nOne important factor is that the gzip compression itself is provided by the\nstandard lib, already compiled, and exposed to the interpreter by Use().\n\nInterpreters work best at providing the glue language and offloading CPU\nintensive computations to optimized compiled libraries. With Go and Yaegi, this\ncan be achieved simply and almost transparently.\n\nConclusion\nWe are announcing Yaegi, a Go interpreter. It’s a young project and as such, far\nfrom perfect. Yaegi is open source and needs your feedback and contributions. We\nhope to make it as useful as possible for the Go community and beyond. This is\nonly the beginning. At Containous, we are focused on solving practical problems\nthrough innovative solutions. Stay tuned for upcoming announcements about both\nYaegi and Containous.\n\nJoin us at github.com/containous/yaegi [https://github.com/containous/yaegi].\n\nI want to thank Containous [/], Emile Vauge [https://twitter.com/emilevauge], \nLudovic Fernandez [https://twitter.com/ludnadez], Mathieu Lonjaret\n[https://twitter.com/lejatorn] who coined the name, Peka\n[https://www.linkedin.com/in/pierre-keersbulik-198107117] for the awesome logo,\nand many other colleagues for their support.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Yet Another Go Interpreter</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-112.png\" class=\"kg-image\"></figure><p>In this post, we present <a href=\"https://github.com/containous/yaegi/\" rel=\"noopener\">Yaegi</a>, Yet Another Go Interpreter, with the E standing for Elegant, Embedded, Easy, or whatever you prefer.</p><p>Yaegi is an open source project developed by Containous, (the company behind <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> and <a href=\"https://containous.ghost.io/traefikee/\" rel=\"noopener\">TraefikEE</a>), to bring executable <a href=\"https://golang.org/\" rel=\"noopener\">Go</a> scripts, embedded plugins, interactive shells, and instant prototyping on top of the Go runtime. Yaegi project is hosted on <a href=\"https://github.com/containous/yaegi\" rel=\"noopener\">GitHub</a>.</p><h2 id=\"motivation\">Motivation</h2><p>Despite being static and strongly typed, Go feels like a dynamic language. The standard library even provides the Go parser used by the compiler and the reflection system to interact dynamically with the runtime. So why not just take the last logical step and finally build a complete Go interpreter?</p><p>Programming languages for high level scripting and for low level implementation are usually different. This time, with Go, we have an opportunity to unify both. Imagine all the C/C++/Java fast libraries for Python being written in Python instead. That’s what Yaegi is for Go (or, the reverse). No burden due to syntax switch, no need to rewrite or modify slow code to make it fast, and full access to goroutines, channels, type safety, etc. at script level.</p><h2 id=\"goals-and-priorities\">Goals and Priorities</h2><ul><li>Simplicity: <code>New()</code>, <code>Eval()</code> and <code>Use()</code> is the only API. No external dependencies besides the standard Go library.</li><li>Standard: the interpreter supports 100% of the <a href=\"https://golang.org/ref/spec\" rel=\"noopener\">Go Specification</a>.</li><li>Robustness: preserve type safety and runtime integrity: <code>unsafe</code> and <code>syscall</code>packages are not used nor exposed by default. Security over performance.</li><li>Interoperability: scripts can “import” pre-compiled runtime packages, but also compiled code can “import” script packages during execution. See usage examples below for more details.</li></ul><h2 id=\"using-yaegi\">Using Yaegi</h2><h3 id=\"as-a-command-line-interpreter\">As a Command-Line Interpreter</h3><p>The Yaegi executable can interpret Go files or run an interactive Read-Eval-Print-Loop:</p><pre><code class=\"language-shell\">$ yaegi\n&gt; 1 + 2\n3\n&gt; import \"fmt\"\n&gt; fmt.Println(\"Hello World\")\nHello World\n&gt;</code></pre><p>Yaegi works like <code>go run</code> (but faster). It also enables executable Go scripts (starting with <code>#!</code>). Yaegi provides a full Go environment with a complete standard library in a single standalone executable.</p><h3 id=\"as-an-embedded-interpreter\">As an Embedded Interpreter</h3><p>In the following example, an interpreter is created with <code>New()</code> and then it evaluates Go code using <code>Eval()</code>. Nothing surprising here.</p><pre><code class=\"language-go\">package main\n\nimport (\n    \"github.com/containous/yaegi/interp\"\n    \"github.com/containous/yaegi/stdlib\"\n)\n\nfunc main() {\n    i := interp.New(interp.Options{})\n    i.Use(stdlib.Symbols)\n    i.Eval(`import \"fmt\"`)\n    i.Eval(`fmt.Println(\"hello\")`)\n}</code></pre><p>This example demonstrates the ability to use executable pre-compiled symbols in the interpreter. Thanks to the statement <code>i.Use(stdlib.Symbols)</code>, the interpreted <code>import \"fmt\"</code>will load the <code>fmt</code> package from the executable itself (wrapped in <code>reflect.Values</code>) instead of trying to parse source files.</p><p>Yaegi also provides the <code>goexports</code> command to build the binary wrapper of any package from its source. This is the command we used to generate all stdlib wrappers provided by default.</p><h3 id=\"as-a-dynamic-extension-framework\">As a Dynamic Extension Framework</h3><p>The program is compiled ahead of time, except for the function <code>bar()</code> that is interpreted from a script. The import process involves the following steps:</p><ol><li>use of <code>i.Eval(src)</code> to internally compile the script package in the context of the interpreter</li><li>use of <code>v,_ := i.Eval(\"<em><em>foo.Bar</em></em>\")</code> to get the symbol that we want to use as a <code>reflect.Value </code>(please forgive me for the missing error handling)</li><li>application of <code>Interface()</code>method and type assertion to convert the <code>reflect.Value</code> into a usable Go typed function</li></ol><pre><code class=\"language-go\">package main\n\nimport \"github.com/containous/yaegi/interp\"\n\nconst src = `package foo\nfunc Bar(s string) string { return s + \"-Foo\" }`\n\nfunc main() {\n    i := interp.New(interp.Options{})\n    i.Eval(src)\n    v, _ := i.Eval(\"foo.Bar\")\n    bar := v.Interface().(func(string) string)\n    \n    r := bar(\"Kung\")\n    println(r)\n    // Output:\n    // Kung-Foo\n}</code></pre><h2 id=\"what-about-performance\">What about Performance?</h2><p>Interpreters are quite common in domains like gaming or science. But could Yaegi also be usable as a plugin engine in the context of distributed systems?</p><p>To answer that, we have benchmarked the use of <a href=\"https://github.com/nytimes/gziphandler\" rel=\"noopener\">gziphandler</a>, a middleware for compressing HTTP responses. Gziphandler provides interface methods implementing compression for the HTTP server in the standard library. This demonstrates an interpreted dynamic processing inserted into a statically compiled server program, with a direct impact on latency and throughput.</p><p>In one case, gziphandler is compiled and used directly as a callback passed to <code>http.Handle()</code>. In the other, the interpreted version of gziphandler is used.</p><pre><code class=\"language-text\">Benchmark      old ns/op   new ns/op    delta\nCompress-8     769088      817632       +6.31%</code></pre><p>We measured less than 10% of overhead for the interpreted version of gziphandler compared to the compiled version, which is to us an acceptable cost for to the benefits of dynamically extending foour server.</p><p>One important factor is that the gzip compression itself is provided by the standard lib, already compiled, and exposed to the interpreter by <code>Use()</code>.</p><p>Interpreters work best at providing the glue language and offloading CPU intensive computations to optimized compiled libraries. With Go and Yaegi, this can be achieved simply and almost transparently.</p><h2 id=\"conclusion\">Conclusion</h2><p>We are announcing Yaegi, a Go interpreter. It’s a young project and as such, far from perfect. Yaegi is open source and needs your feedback and contributions. We hope to make it as useful as possible for the Go community and beyond. This is only the beginning. At Containous, we are focused on solving practical problems through innovative solutions. Stay tuned for upcoming announcements about both Yaegi and Containous.</p><p>Join us at <a href=\"https://github.com/containous/yaegi\" rel=\"noopener\">github.com/containous/yaegi</a>.</p><p>I want to thank <a href=\"https://containous.ghost.io/\" rel=\"noopener\">Containous</a>, <a href=\"https://twitter.com/emilevauge\" rel=\"noopener\">Emile Vauge</a>, <a href=\"https://twitter.com/ludnadez\" rel=\"noopener\">Ludovic Fernandez</a>, <a href=\"https://twitter.com/lejatorn\" rel=\"noopener\">Mathieu Lonjaret</a> who coined the name, <a href=\"https://www.linkedin.com/in/pierre-keersbulik-198107117\" rel=\"noopener\">Peka</a> for the awesome logo, and many other colleagues for their support.</p>","url":"https://containous.ghost.io/blog/announcing-yaegi-263a1e2d070a/","canonical_url":null,"uuid":"35426a19-ead7-403f-b5c3-69421eb25799","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd5560dec5ed300387889f5","reading_time":4}}]}},"pageContext":{"slug":"marc","limit":9,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}