{"componentChunkName":"component---src-templates-author-tsx","path":"/author/manuel/","result":{"data":{"ghostAuthor":{"slug":"manuel","name":"Manuel Zapf","bio":null,"cover_image":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","location":null,"website":null,"twitter":null,"facebook":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5f61ed21a72a090039800f23","title":"Announcing Traefik Mesh 1.4 - New Name, New Features","slug":"announcing-traefik-mesh-1-4-new-name-new-features","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/2bf88b41a1527a3d01d0b0e5af828d57/47498/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg","srcSet":"/static/2bf88b41a1527a3d01d0b0e5af828d57/9dc27/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 300w,\n/static/2bf88b41a1527a3d01d0b0e5af828d57/4fe8c/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 600w,\n/static/2bf88b41a1527a3d01d0b0e5af828d57/47498/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 1200w,\n/static/2bf88b41a1527a3d01d0b0e5af828d57/52258/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 1800w,\n/static/2bf88b41a1527a3d01d0b0e5af828d57/a41d1/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik Mesh 1.4 brings some under-the-hood changes and new features, including support for a new version of the Service Mesh Interface (SMI) specification, enabling filtering by headers and more.","custom_excerpt":"Traefik Mesh 1.4 brings some under-the-hood changes and new features, including support for a new version of the Service Mesh Interface (SMI) specification, enabling filtering by headers and more.","visibility":"public","created_at_pretty":"16 September, 2020","published_at_pretty":"October 1, 2020","updated_at_pretty":"19 October, 2020","created_at":"2020-09-16T10:46:57.000+00:00","published_at":"2020-10-01T14:17:00.000+00:00","updated_at":"2020-10-19T17:22:48.000+00:00","meta_title":"Announcing Traefik Mesh 1.4 - New Name, New Features","meta_description":"Traefik Mesh 1.4 brings some under-the-hood changes, including support for a new version of the SMI specification, enabling filtering by headers and more.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features---Twitter.png","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Today, we're renaming the Maesh project to Traefik Mesh, and this corresponds\nwith the renaming of the company behind the project to Traefik Labs. You can\nlearn more about the company-wide rebranding effort here\n[https://traefik.io/blog/traefik-labs-incubating-the-future-of-cloud-native-networking/]\n.\n\nIn addition to the renaming, Traefik Mesh 1.4 also brings some under-the-hood\nchanges and new features, including support for a new version of the Service\nMesh Interface (SMI) specification, enabling filtering by headers and more.\n\nRenaming of the Project\nAs mentioned, the project is now called Traefik Mesh. The name change includes\nsome changes in the project configuration as well. You'll notice that the\nannotation prefix, the binary name, the prefix for environment variables, and\nthe configuration file's default name have all changed.\n\nMore importantly, we changed the DNS name to opt-in into the mesh usage from \n.maesh to .traefik.mesh. However, we made all of it backward compatible, so you\nshould not encounter problems while transitioning from Maesh to Traefik Mesh.\nMore information about the migration path is available in the documentation\n[https://doc.traefik.io/traefik-mesh/migration/traefik-mesh-v1/#traefik-mesh-v14]\n.\n\nGoing Back to Traefik ... to Traefik\nFor Maesh 1.3, we designed and implemented a custom proxy based on Traefik so we\ncould evolve and iterate on the technology quickly. However, the capabilities we\nneeded for this evolution have since all been introduced upstream into Traefik,\nallowing us to fall back to regular Traefik Proxy nodes for service\ncommunication. With this 1.4 release, Traefik Mesh now uses the standard Traefik\nimage distribution as its service mesh proxy, which means Traefik Proxy features\nwill be available to environments that use Traefik Mesh.\n\nHeader Filtering for Traffic Targets\nWith the release of SMI specification v0.5.0\n[https://github.com/servicemeshinterface/smi-spec/releases/tag/v0.5.0],\nfiltering based on headers introduced in the Traffic Specs API v1alpha3\n[https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md] \nenables routing of requests based on arbitrary parameters such as browser types,\nand cookies. In addition to the headers, these are compatible with other\nfilters, including request types (GET, PUT, etc.) and paths. By utilizing these\nnew features, it's now possible to have additional flexibility when routing\nrequests.\n\nYou can read more about this feature's capabilities and find examples in the \nSMI\nspecification\n[https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md#http-header-filters] \ndocuments on Github.\n\nHeader and Path Filtering for Traffic Splits\nThe latest version of the spec empowers Traefik Mesh users to now run canary and\nA/B testing utilizing Headers, cookies, request type, and more. With the\nv1alpha3 release, Header filtering supports utilizing TrafficSplit and the\nmatches attribute linked to an HTTPRouteGroup. A real world example is available\nin the SMI specification document\n[https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-split/v1alpha3/traffic-split.md#specification]\n, covering how this capability allows you to split traffic based on the\naforementioned new filters.\n\nLooking Ahead\nThe team is continuing work implementing mTLS, and the goal is to launch that\nfeature with the next release. With the introduction of mTLS we anticipate some\nsignificant changes. We’ll be discussing those changes on Github and publishing\na Release Candidate, which needs your feedback. In addition to mTLS, we are\ncontinuing to work with the SMI group by incorporating the latest version of the\nspecification and contributing towards the implementation of routing UDP\ntraffic. We expect to have that ready for the next release as well.\n\nWe love hearing from the community on how you’re using Traefik Mesh today in\nyour environments and what features you’d like to see in the future. Let us know\nby opening a Feature Request or reaching out to us on our community forums.\n\nUseful links\n * Website [https://traefik.io/traefik-mesh/]\n * Documentation [https://doc.traefik.io/traefik-mesh/]\n * Github [https://traefik.io/traefik-mesh/]\n * Community Forum [https://community.traefik.io/c/traefik-mesh/15]","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg\" class=\"kg-image\" alt=\"Announcing Traefik Mesh 1.4 - New Name, New Features\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><!--kg-card-begin: markdown--><p>Today, we're renaming the Maesh project to Traefik Mesh, and this corresponds with the renaming of the company behind the project to Traefik Labs. You can learn more about the company-wide rebranding effort <a href=\"https://traefik.io/blog/traefik-labs-incubating-the-future-of-cloud-native-networking/\" target=\"_blank\" rel=\"nofollow\">here</a>.</p>\n<!--kg-card-end: markdown--><p>In addition to the renaming, Traefik Mesh 1.4 also brings some under-the-hood changes and new features, including support for a new version of the Service Mesh Interface (SMI) specification, enabling filtering by headers and more.</p><h2 id=\"renaming-of-the-project\">Renaming of the Project</h2><p>As mentioned, the project is now called Traefik Mesh. The name change includes some changes in the project configuration as well. You'll notice that the annotation prefix, the binary name, the prefix for environment variables, and the configuration file's default name have all changed.</p><!--kg-card-begin: markdown--><p>More importantly, we changed the DNS name to opt-in into the mesh usage from <code>.maesh</code> to <code>.traefik.mesh</code>. However, we made all of it backward compatible, so you should not encounter problems while transitioning from Maesh to Traefik Mesh. More information about the migration path is available <a href=\"https://doc.traefik.io/traefik-mesh/migration/traefik-mesh-v1/#traefik-mesh-v14\" target=\"_blank\"  rel=\"nofollow\">in the documentation</a>.</p>\n<!--kg-card-end: markdown--><h2 id=\"going-back-to-traefik-to-traefik\">Going Back to Traefik ... to Traefik</h2><p>For Maesh 1.3, we designed and implemented a custom proxy based on Traefik so we could evolve and iterate on the technology quickly. However, the capabilities we needed for this evolution have since all been introduced upstream into Traefik, allowing us to fall back to regular Traefik Proxy nodes for service communication. With this 1.4 release, Traefik Mesh now uses the standard Traefik image distribution as its service mesh proxy, which means Traefik Proxy features will be available to environments that use Traefik Mesh.</p><h2 id=\"header-filtering-for-traffic-targets\">Header Filtering for Traffic Targets</h2><!--kg-card-begin: markdown--><p>With the release of <a href=\"https://github.com/servicemeshinterface/smi-spec/releases/tag/v0.5.0\" target=\"_blank\" rel=\"nofollow\">SMI specification v0.5.0</a>, filtering based on headers introduced in the <a href=\"https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md\" target=\"_blank\" rel=\"nofollow\">Traffic Specs API v1alpha3</a> enables routing of requests based on arbitrary parameters such as browser types, and cookies. In addition to the headers, these are compatible with other filters, including request types (GET, PUT, etc.) and paths. By utilizing these new features, it's now possible to have additional flexibility when routing requests.</p>\n<p>You can read more about this feature's capabilities and find examples in the <a href=\"https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md#http-header-filters\" target=\"_blank\" rel=\"nofollow\">SMI specification</a> documents on Github.</p>\n<!--kg-card-end: markdown--><h2 id=\"header-and-path-filtering-for-traffic-splits\">Header and Path Filtering for Traffic Splits</h2><!--kg-card-begin: markdown--><p>The latest version of the spec empowers Traefik Mesh users to now run canary and A/B testing utilizing Headers, cookies, request type, and more. With the v1alpha3 release, Header filtering supports utilizing TrafficSplit and the matches attribute linked to an HTTPRouteGroup. A real world example is available in the <a href=\"https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-split/v1alpha3/traffic-split.md#specification\" target=\"_blank\" rel=\"nofollow\">SMI specification document</a>, covering how this capability allows you to split traffic based on the aforementioned new filters.</p>\n<!--kg-card-end: markdown--><h2 id=\"looking-ahead\">Looking Ahead</h2><p>The team is continuing work implementing mTLS, and the goal is to launch that feature with the next release. With the introduction of mTLS we anticipate some significant changes. We’ll be discussing those changes on Github and publishing a Release Candidate, which needs your feedback. In addition to mTLS, we are continuing to work with the SMI group by incorporating the latest version of the specification and contributing towards the implementation of routing UDP traffic. We expect to have that ready for the next release as well.</p><p>We love hearing from the community on how you’re using Traefik Mesh today in your environments and what features you’d like to see in the future. Let us know by opening a Feature Request or reaching out to us on our community forums.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://traefik.io/traefik-mesh/\">Website</a></li><li><a href=\"https://doc.traefik.io/traefik-mesh/\">Documentation</a></li><li><a href=\"https://traefik.io/traefik-mesh/\">Github</a></li><li><a href=\"https://community.traefik.io/c/traefik-mesh/15\">Community Forum</a></li></ul>","url":"https://containous.ghost.io/blog/announcing-traefik-mesh-1-4-new-name-new-features/","canonical_url":null,"uuid":"988cdb3a-2da8-45c3-8271-4f8ac1cfe535","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f61ed21a72a090039800f23","reading_time":2}},{"node":{"id":"Ghost__Post__5f61e3c3a72a090039800ee6","title":"Houston, we have Plugins! Traefik 2.3 Announcement","slug":"houston-we-have-plugins-traefik-2-3-announcement","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/09/Traefik2-3-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/d9c38c8baef3f8781df7d002f1b7005a/47498/Traefik2-3-1.jpg","srcSet":"/static/d9c38c8baef3f8781df7d002f1b7005a/9dc27/Traefik2-3-1.jpg 300w,\n/static/d9c38c8baef3f8781df7d002f1b7005a/4fe8c/Traefik2-3-1.jpg 600w,\n/static/d9c38c8baef3f8781df7d002f1b7005a/47498/Traefik2-3-1.jpg 1200w,\n/static/d9c38c8baef3f8781df7d002f1b7005a/52258/Traefik2-3-1.jpg 1800w,\n/static/d9c38c8baef3f8781df7d002f1b7005a/a41d1/Traefik2-3-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik 2.3, the latest version of the most popular open source cloud native proxy, is now available. With plugins, ECS provider, and more!","custom_excerpt":"Traefik 2.3, the latest version of the most popular open source cloud native proxy, is now available. With plugins, ECS provider, and more!","visibility":"public","created_at_pretty":"16 September, 2020","published_at_pretty":"September 23, 2020","updated_at_pretty":"01 October, 2020","created_at":"2020-09-16T10:06:59.000+00:00","published_at":"2020-09-23T14:30:00.000+00:00","updated_at":"2020-10-01T15:17:34.000+00:00","meta_title":"Houston, we have Plugins! Traefik 2.3 Announcement","meta_description":"Traefik 2.3 brings in new capabilities, including the Traefik Plugin system, support for Amazon ECS and support for the Kubernetes IngressClass API resource","og_description":null,"og_image":null,"og_title":null,"twitter_description":"Traefik 2.3 brings in new capabilities, including the Traefik Plugin system, integration with Traefik Pilot, support for Amazon ECS, and support for the Kubernetes IngressClass API resource launched in Kubernetes 1.18. ","twitter_image":"https://containous.ghost.io/content/images/2020/09/Traefik2-3-Twitter.png","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Today we're proud to announce the latest release of Traefik! Traefik 2.3 brings\nin new capabilities, including the Traefik Plugin system, integration with\nTraefik Pilot, support for Amazon ECS, and support for the Kubernetes\nIngressClass API resource launched in Kubernetes 1.18. Let’s dive in and explore\nwhat these features mean for you, our users.\n\nTraefik Plugins\nWith Go 1.8's release in March 2017, our community's most requested feature\n[https://github.com/traefik/traefik/issues/1336] has been to add middleware\nplugin support to Traefik. Well, it's here. Traefik now supports the ability to\nadd custom middleware functionality to your environment easily. Today, several\nuseful plugins in the marketplace are waiting for you to use, such as BlockPath\n[https://pilot.traefik.io/plugins/276809782519661056/block-path] and Deny Ip\n[https://pilot.traefik.io/plugins/276812076107694611/deny-ip-plugin]. Plugins\nare designed to function and operate just like any other native middlewares\n[https://docs.traefik.io/middlewares/overview/] already distributed with\nTraefik.\n\nThe plugin system operates in conjunction with Traefik Pilot, which maintains a\ncatalog of community created plugins and a hash for each version published by\nthe author. For security, Pilot ensures that you are running the actual code\ncommitted and tagged on GitHub every time Traefik launches.\n\nCustom middleware plugins for the community, by the communityYou can either get started\n[https://doc.traefik.io/traefik/v2.3/plugins/using-plugins/] using the existing\nplugins marketplace [https://pilot.traefik.io/plugins] or create your own plugin\n[https://github.com/traefik/plugindemo]. We can't wait to see what the community\nis going to build!\n\nTraefik Pilot Integration\nTraefik Pilot is a managed SaaS application offered by Traefik Labs that helps\noperators of Traefik ensure their environments are operating efficiently and\nsecurely. This new integration brings users not only the plugins mentioned above\nbut a centralized platform that provides performance metrics, security, and\nupdate notifications in real time. You can get started with Traefik Pilot today\nby signing up and configuring your Traefik instances with a uniquely generated\nkey.\n\nTraefik Pilot automatically collects performance metrics from your Traefik\ninstancesOnce registered and activated, your Traefik instance will periodically\nsend information to Traefik Pilot, providing you with insight into the\nperformance, security, and availability of your Traefik instances.\n\nTraefik Pilot will monitor the following data points on every Traefik instance\nyou register:\n\n * Health Status and Availability Alerts\n * Version Information and Security Alerts\n * Performance Metrics * Requests per second\n    * Total requests\n    * Request duration\n   \n   \n\nFor additional details about Traefik Pilot and the features available upon\nregistration of your Traefik instance, please check out the product announcement\nfor Pilot.\n\nAmazon ECS Provider\nAmazon ECS is a managed orchestration service that can be used either on its own\nor in conjunction with Fargate, the AWS serverless compute engine for\ncontainers. The ECS provider for Traefik allows for the dynamic configuration of\nthe provider using labels attached to your ECS containers.\n\nThis feature was contributed by alekitto [https://github.com/alekitto], a\ncommunity member, who refactored code from v1.x to support ECS by implementing\nthe provider for the latest versions of Traefik. Thanks to his time and effort,\nthe rest of the Traefik community can benefit while running their ECS workloads.\n\nMore information on how to activate or configure the provider is available here: \nhttps://doc.traefik.io/v2.3/providers/ecs/\n[https://doc.traefik.io/traefik/v2.3/providers/ecs/]\n\nKubernetes IngressClass\nWith the release of Kubernetes 1.18, improvements made to the Ingress API\n[https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/] \nhave made possible new capabilities in Traefik 2.3. This release includes the\nability to specify how Ingress paths should match, and features a new\nIngressClass resource that allows users to specify how controllers should\nimplement Ingress resources. You can use these new APIs in Traefik with this\nrelease, which means better interoperability and vendor neutrality.\n\nAlso, Ingress resources utilizing the new pathType field will be supported\naccordingly. More information on how to utilize the support for the new\nIngressClass resource can be found both in our documentation\n[https://doc.traefik.io/traefik/providers/kubernetes-ingress/#ingressclass] and\nthe Kubernetes official docs\n[https://v1-18.docs.kubernetes.io/docs/concepts/services-networking/ingress/].\n\nThe Road Ahead\nWe're excited about the work we have ahead of us for the next release, Traefik\n2.4. We are planning to revamp the Getting Started guides for 2.x, and with that\nwill include common use case examples with introductions to more complex topics\nfor popular platforms such as Kubernetes and Docker Swarm. This work comes after\nhearing from the community how we could improve the documentation and begin with\nmore transparent explanations on the new configuration approaches and how to get\nstarted with it.\n\nAlso, we're looking at the configuration of Traefik itself and how we can\nabstract everyday use cases into a simpler and easy to use format. You'll be\nhearing more about this and other enhancements to Traefik, including support for\nthe latest Kubernetes Service API that the team at Google has been working on,\nand features to support the inclusion of mTLS in Traefik Mesh.\n\nWe love hearing from the community on how you're using Traefik and what features\nyou'd like to see in the future. Let us know by opening a Feature Request\n[https://github.com/traefik/traefik/issues/new?template=Feature_request.md] or\nreaching out to us on our community forums.\n\nUseful links\n * Website [https://traefik.io/traefik/]\n * Documentation [https://doc.traefik.io/traefik/v2.3/]\n * Github [https://github.com/traefik/traefik]\n * Forum [https://community.traefik.io/c/traefik/traefik-v2]","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/09/Traefik2-3.jpg\" class=\"kg-image\" alt=\"Traefik 2.3 features integration with Traefik Pilot, Middleware Plugins, ECS provider, and support for K8S IngressClass\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/Traefik2-3.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Traefik2-3.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Traefik2-3.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Traefik2-3.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Today we're proud to announce the latest release of Traefik! Traefik 2.3 brings in new capabilities, including the Traefik Plugin system, integration with Traefik Pilot, support for Amazon ECS, and support for the Kubernetes IngressClass API resource launched in Kubernetes 1.18. Let’s dive in and explore what these features mean for you, our users.</p><h3 id=\"traefik-plugins\">Traefik Plugins</h3><p>With Go 1.8's release in March 2017, our community's <a href=\"https://github.com/traefik/traefik/issues/1336\">most requested feature</a> has been to add middleware plugin support to Traefik. Well, it's here. Traefik now supports the ability to add custom middleware functionality to your environment easily. Today, several useful plugins in the marketplace are waiting for you to use, such as <a href=\"https://pilot.traefik.io/plugins/276809782519661056/block-path\">BlockPath</a> and <a href=\"https://pilot.traefik.io/plugins/276812076107694611/deny-ip-plugin\">Deny Ip</a>. Plugins are designed to function and operate just like any other native <a href=\"https://docs.traefik.io/middlewares/overview/\">middlewares</a> already distributed with Traefik.</p><p>The plugin system operates in conjunction with Traefik Pilot, which maintains a catalog of community created plugins and a hash for each version published by the author. For security, Pilot ensures that you are running the actual code committed and tagged on GitHub every time Traefik launches.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/09/image-3.png\" class=\"kg-image\" alt=\"Custom middleware plugins for the community, by the community\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/image-3.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/image-3.png 1000w, https://containous.ghost.io/content/images/2020/09/image-3.png 1359w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Custom middleware plugins for the community, by the community</figcaption></figure><p>You can either <a href=\"https://doc.traefik.io/traefik/v2.3/plugins/using-plugins/\">get started</a> using the <a href=\"https://pilot.traefik.io/plugins\">existing plugins marketplace</a> or <a href=\"https://github.com/traefik/plugindemo\">create your own plugin</a>. We can't wait to see what the community is going to build!</p><h3 id=\"traefik-pilot-integration\">Traefik Pilot Integration</h3><p>Traefik Pilot is a managed SaaS application offered by Traefik Labs that helps operators of Traefik ensure their environments are operating efficiently and securely. This new integration brings users not only the plugins mentioned above but a centralized platform that provides performance metrics, security, and update notifications in real time. You can get started with Traefik Pilot today by signing up and configuring your Traefik instances with a uniquely generated key.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://containous.ghost.io/content/images/2020/09/image-2.png\" class=\"kg-image\" alt=\"Traefik Pilot automatically collects performance metrics from your Traefik instances\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/09/image-2.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/image-2.png 1000w, https://containous.ghost.io/content/images/2020/09/image-2.png 1359w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Traefik Pilot automatically collects performance metrics from your Traefik instances</figcaption></figure><p>Once registered and activated, your Traefik instance will periodically send information to Traefik Pilot, providing you with insight into the performance, security, and availability of your Traefik instances.</p><p>Traefik Pilot will monitor the following data points on every Traefik instance you register:</p><!--kg-card-begin: markdown--><ul>\n<li>Health Status and Availability Alerts</li>\n<li>Version Information and Security Alerts</li>\n<li>Performance Metrics\n<ul>\n<li>Requests per second</li>\n<li>Total requests</li>\n<li>Request duration</li>\n</ul>\n</li>\n</ul>\n<!--kg-card-end: markdown--><p>For additional details about Traefik Pilot and the features available upon registration of your Traefik instance, please check out the product announcement for Pilot.</p><h2 id=\"amazon-ecs-provider\"><strong>Amazon ECS Provider</strong></h2><p>Amazon ECS is a managed orchestration service that can be used either on its own or in conjunction with Fargate, the AWS serverless compute engine for containers. The ECS provider for Traefik allows for the dynamic configuration of the provider using labels attached to your ECS containers.</p><!--kg-card-begin: markdown--><p>This feature was contributed by <a href=\"https://github.com/alekitto\" target=\"_blank\" rel=\"nofollow\">alekitto</a>, a community member, who refactored code from v1.x to support ECS by implementing the provider for the latest versions of Traefik. Thanks to his time and effort, the rest of the Traefik community can benefit while running their ECS workloads.</p>\n<!--kg-card-end: markdown--><p>More information on how to activate or configure the provider is available here: <a href=\"https://doc.traefik.io/traefik/v2.3/providers/ecs/\">https://doc.traefik.io/v2.3/providers/ecs/</a></p><h2 id=\"kubernetes-ingressclass\"><strong>Kubernetes IngressClass</strong></h2><!--kg-card-begin: markdown--><p>With the release of Kubernetes 1.18, <a href=\"https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/\" target=\"_blank\" rel=\"nofollow\">improvements made to the Ingress API</a> have made possible new capabilities in Traefik 2.3. This release includes the ability to specify how Ingress paths should match, and features a new IngressClass resource that allows users to specify how controllers should implement Ingress resources. You can use these new APIs in Traefik with this release, which means better interoperability and vendor neutrality.</p>\n<p>Also, Ingress resources utilizing the new <code>pathType</code> field will be supported accordingly. More information on how to utilize the support for the new IngressClass resource can be found both in <a href=\"https://doc.traefik.io/traefik/providers/kubernetes-ingress/#ingressclass\">our documentation</a> and the Kubernetes <a href=\"https://v1-18.docs.kubernetes.io/docs/concepts/services-networking/ingress/\" target=\"_blank\" rel=\"nofollow\">official docs</a>.</p>\n<!--kg-card-end: markdown--><h2 id=\"the-road-ahead\">The Road Ahead</h2><p>We're excited about the work we have ahead of us for the next release, Traefik 2.4. We are planning to revamp the Getting Started guides for 2.x, and with that will include common use case examples with introductions to more complex topics for popular platforms such as Kubernetes and Docker Swarm. This work comes after hearing from the community how we could improve the documentation and begin with more transparent explanations on the new configuration approaches and how to get started with it.</p><p>Also, we're looking at the configuration of Traefik itself and how we can abstract everyday use cases into a simpler and easy to use format. You'll be hearing more about this and other enhancements to Traefik, including support for the latest Kubernetes Service API that the team at Google has been working on, and features to support the inclusion of mTLS in Traefik Mesh.</p><p>We love hearing from the community on how you're using Traefik and what features you'd like to see in the future. Let us know by opening a <a href=\"https://github.com/traefik/traefik/issues/new?template=Feature_request.md\">Feature Request</a> or reaching out to us on our community forums.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://traefik.io/traefik/\">Website</a></li><li><a href=\"https://doc.traefik.io/traefik/v2.3/\">Documentation</a></li><li><a href=\"https://github.com/traefik/traefik\">Github</a></li><li><a href=\"https://community.traefik.io/c/traefik/traefik-v2\">Forum</a></li></ul>","url":"https://containous.ghost.io/blog/houston-we-have-plugins-traefik-2-3-announcement/","canonical_url":null,"uuid":"539200bd-c9d6-473d-b170-daf87e7dfb8f","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f61e3c3a72a090039800ee6","reading_time":4}},{"node":{"id":"Ghost__Post__5efbfbdc1555240039b0bf80","title":"Announcing Maesh 1.3","slug":"announcing-maesh-1-3","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/07/Announcing-Maesh-1.3-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/efb1b1925cac747fc113d310e892bbdd/47498/Announcing-Maesh-1.3-1.jpg","srcSet":"/static/efb1b1925cac747fc113d310e892bbdd/9dc27/Announcing-Maesh-1.3-1.jpg 300w,\n/static/efb1b1925cac747fc113d310e892bbdd/4fe8c/Announcing-Maesh-1.3-1.jpg 600w,\n/static/efb1b1925cac747fc113d310e892bbdd/47498/Announcing-Maesh-1.3-1.jpg 1200w,\n/static/efb1b1925cac747fc113d310e892bbdd/52258/Announcing-Maesh-1.3-1.jpg 1800w,\n/static/efb1b1925cac747fc113d310e892bbdd/a41d1/Announcing-Maesh-1.3-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Maesh 1.3, the latest version of the simpler service mesh, is now even more reliable, flexible, and widely available. ","custom_excerpt":"Maesh 1.3, the latest version of the simpler service mesh, is now even more reliable, flexible, and widely available. ","visibility":"public","created_at_pretty":"01 July, 2020","published_at_pretty":"July 9, 2020","updated_at_pretty":"21 July, 2020","created_at":"2020-07-01T02:58:36.000+00:00","published_at":"2020-07-09T05:45:40.000+00:00","updated_at":"2020-07-21T13:59:12.000+00:00","meta_title":"Announcing Maesh 1.3","meta_description":"Maesh 1.3, the latest version of the simpler service mesh, is now even more reliable, flexible, and widely available. ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/07/Announcing-Maesh-1.3---Twitter@2x.jpg","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"The simpler service mesh, now even more reliable, flexible, and widely\navailable.\n\nMaesh 1.3, the latest version of the simpler service mesh, is available today.\nThis release introduces new configuration options and brings important\nenhancements to the project’s architecture.\n\nNamespace watchlists\nPreviously, it was possible to configure a set of namespaces to be ignored by\nthe Maesh Controller, via the ignoreNamespaces option. Operators of large\nclusters found themselves having to define a large number of exceptions if they\nwere only interested in a small subset of namespaces.\n\nMaesh 1.3 introduces an option that enables operators to specify which\nnamespaces they want to be observed by the Maesh controller called \nwatchNamespaces:\n\nhelm install maesh maesh/maesh --set controller.watchNamespaces={first,second}\n\n\nFor those who rely on ignoreNamespaces, it will still continue to work, we\naren’t planning to remove that configuration option.\n\nSupport for named TargetPort in Service resources\nA typical service definition in Kubernetes might look like this:\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: MyApp\n  ports:\n    - port: 80\n      targetPort: http\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp-deployment\n  labels:\n    app: MyApp\nspec:\n  selector:\n    matchLabels:\n      app: MyApp\n  template:\n    metadata:\n      labels:\n        app: MyApp\n    spec:\n      containers:\n        - name: nginx\n          image: nginx:1.14.2\n          ports:\n            - containerPort: 80\n              name: http\n\n\nKubernetes will look for the corresponding Pod matching the selector and for a\nport on the pod named http. Maesh now supports this and will do the reverse\nlookup of the targetPort as well, greatly enhancing flexibility.\n\nReal-Time In-Memory Port Mapping\nOne of the architectural components of earlier versions of Maesh is a database\nreferred to as StateTable, whose job included keeping track of port allocations\nand holding entries for port mappings. Before Maesh 1.3, port allocations and\nstates were managed inside of a Kubernetes resource called a ConfigMap.\n\nMaintaining that state externally seems reasonable, but there is always a catch.\nWhat if another process or user modifies the table? What if it becomes\nunavailable due to misconfigured permissions, or becomes so large as to\nintroduce performance issues within the Kubernetes database back-end?\n\nBecause of this, starting in Maesh 1.3, ConfigMaps\n[https://kubernetes.io/docs/concepts/configuration/configmap/] that store \nStateTable objects are gone. Instead, the Maesh Controller keeps in-memory state\ntables generated on every initialization and kept in sync with every service\nupdate.\n\nA More Reliable Controller Loop\nAs a consequence of removing the state tables mentioned above, the mechanism\nwith which a controller performs updates in the clusters required a redesign.\nPreviously, it just watched for changes and updated the configuration as they\nhappened. With the state now being stored in memory, that behavior was no longer\nsufficient, colliding events may impact Maesh's proxy nodes' performance.\n\nTo address that issue, Maesh 1.3 now leverages Kubernetes Work Queues\n[https://kubernetes.io/docs/tasks/job/fine-parallel-processing-work-queue/] to\nguarantee the correct processing of events that are responsible for updating the\nin-memory database. The queues help Maesh perform reliably in situations where\nit must process concurrent events.\n\nSupport for CoreDNS on AKS\nAs already mentioned in a previous release [/blog/maesh-1-0-802f4be9a9a7/],\nMaesh relies heavily on CoreDNS for name resolution. Because of this dependency,\nMaesh is designed to patch CoreDNS through its initialization process. On AKS,\nthere is a specific process\n[https://docs.microsoft.com/en-us/azure/aks/coredns-custom] to follow when\ncustomizing CoreDNS and we’ve updated Maesh to conform to that process. As a\nresult of this update, Maesh is now supported on Azure Kubernetes Service.\n\nNext Steps\nThe changes introduced in this release represent the next step in evolving the\nMaesh project into a solution the community has been requesting. Research is\nunderway on how Maesh can implement simple, easy to use, end-to-end encryption.\nDeveloping and shipping this capability will be the next significant milestone\nto hit.\n\nYour participation with the Maesh project is invaluable, and your suggestions\nare responsible for the improvements and direction this project undergoes. We\nwelcome your continued feedback, PRs, and contributions because that is what\nkeeps Maesh going in the right direction.\n\nThank you!\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">The simpler service mesh, now even more reliable, flexible, and widely available.</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/07/Announcing-Maesh-1.3.jpg\" class=\"kg-image\" alt=\"Announcing Maesh 1.3\"></figure><p>Maesh 1.3, the latest version of the simpler service mesh, is available today. This release introduces new configuration options and brings important enhancements to the project’s architecture.</p><h2 id=\"namespace-watchlists\">Namespace watchlists</h2><p>Previously, it was possible to configure a set of namespaces to be ignored by the Maesh Controller, via the <code>ignoreNamespaces</code> option. Operators of large clusters found themselves having to define a large number of exceptions if they were only interested in a small subset of namespaces.</p><p>Maesh 1.3 introduces an option that enables operators to specify which namespaces they want to be observed by the Maesh controller called <code>watchNamespaces</code>:</p><!--kg-card-begin: markdown--><pre><code>helm install maesh maesh/maesh --set controller.watchNamespaces={first,second}\n</code></pre>\n<!--kg-card-end: markdown--><p>For those who rely on <code>ignoreNamespaces</code>, it will still continue to work, we aren’t planning to remove that configuration option.</p><h2 id=\"support-for-named-targetport-in-service-resources\">Support for named TargetPort in Service resources</h2><p>A typical service definition in Kubernetes might look like this:</p><!--kg-card-begin: markdown--><pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: MyApp\n  ports:\n    - port: 80\n      targetPort: http\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp-deployment\n  labels:\n    app: MyApp\nspec:\n  selector:\n    matchLabels:\n      app: MyApp\n  template:\n    metadata:\n      labels:\n        app: MyApp\n    spec:\n      containers:\n        - name: nginx\n          image: nginx:1.14.2\n          ports:\n            - containerPort: 80\n              name: http\n</code></pre>\n<!--kg-card-end: markdown--><p>Kubernetes will look for the corresponding Pod matching the selector and for a port on the pod named <code>http</code>. Maesh now supports this and will do the reverse lookup of the targetPort as well, greatly enhancing flexibility.</p><h2 id=\"real-time-in-memory-port-mapping\">Real-Time In-Memory Port Mapping</h2><p>One of the architectural components of earlier versions of Maesh is a database referred to as <code>StateTable</code>, whose job included keeping track of port allocations and holding entries for port mappings. Before Maesh 1.3, port allocations and states were managed inside of a Kubernetes resource called a ConfigMap.</p><p>Maintaining that state externally seems reasonable, but there is always a catch. What if another process or user modifies the table? What if it becomes unavailable due to misconfigured permissions, or becomes so large as to introduce performance issues within the Kubernetes database back-end?</p><!--kg-card-begin: markdown--><p>Because of this, starting in Maesh 1.3, <a href=\"https://kubernetes.io/docs/concepts/configuration/configmap/\" target=\"_blank\" rel=\"nofollow\">ConfigMaps</a> that store <code>StateTable</code> objects are gone. Instead, the Maesh Controller keeps in-memory state tables generated on every initialization and kept in sync with every service update.</p>\n<!--kg-card-end: markdown--><h2 id=\"a-more-reliable-controller-loop\">A More Reliable Controller Loop</h2><p>As a consequence of removing the state tables mentioned above, the mechanism with which a controller performs updates in the clusters required a redesign. Previously, it just watched for changes and updated the configuration as they happened. With the state now being stored in memory, that behavior was no longer sufficient, colliding events may impact Maesh's proxy nodes' performance.</p><!--kg-card-begin: markdown--><p>To address that issue, Maesh 1.3 now leverages <a href=\"https://kubernetes.io/docs/tasks/job/fine-parallel-processing-work-queue/\" target=\"_blank\" rel=\"nofollow\">Kubernetes Work Queues</a> to guarantee the correct processing of events that are responsible for updating the in-memory database. The queues help Maesh perform reliably in situations where it must process concurrent events.</p>\n<!--kg-card-end: markdown--><h2 id=\"support-for-coredns-on-aks\">Support for CoreDNS on AKS</h2><!--kg-card-begin: markdown--><p>As already mentioned in <a href=\"https://containous.ghost.io/blog/maesh-1-0-802f4be9a9a7/\">a previous release</a>, Maesh relies heavily on CoreDNS for name resolution. Because of this dependency, Maesh is designed to patch CoreDNS through its initialization process. On AKS, there is a <a href=\"https://docs.microsoft.com/en-us/azure/aks/coredns-custom\" target=\"_blank\" rel=\"nofollow\">specific process</a> to follow when customizing CoreDNS and we’ve updated Maesh to conform to that process. As a result of this update, Maesh is now supported on Azure Kubernetes Service.</p>\n<!--kg-card-end: markdown--><h2 id=\"next-steps\">Next Steps</h2><p>The changes introduced in this release represent the next step in evolving the Maesh project into a solution the community has been requesting. Research is underway on how Maesh can implement simple, easy to use, end-to-end encryption. Developing and shipping this capability will be the next significant milestone to hit.</p><p>Your participation with the Maesh project is invaluable, and your suggestions are responsible for the improvements and direction this project undergoes. We welcome your continued feedback, PRs, and contributions because that is what keeps Maesh going in the right direction.</p><p>Thank you!</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\">Community Forum</a><br></li></ul>","url":"https://containous.ghost.io/blog/announcing-maesh-1-3/","canonical_url":null,"uuid":"789a57a8-4c4e-4359-91fb-c3e96dfbb7c5","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5efbfbdc1555240039b0bf80","reading_time":3}},{"node":{"id":"Ghost__Post__5ec2a072c49e39004576b7ad","title":"Kubernetes Ingress & Service API Demystified","slug":"kubernetes-ingress-service-api-demystified","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/d9aac10cdc9e917545bdb3e3680ce4f2/47498/Kubernetes-Ingress---Service-API-Demystified-1.jpg","srcSet":"/static/d9aac10cdc9e917545bdb3e3680ce4f2/9dc27/Kubernetes-Ingress---Service-API-Demystified-1.jpg 300w,\n/static/d9aac10cdc9e917545bdb3e3680ce4f2/4fe8c/Kubernetes-Ingress---Service-API-Demystified-1.jpg 600w,\n/static/d9aac10cdc9e917545bdb3e3680ce4f2/47498/Kubernetes-Ingress---Service-API-Demystified-1.jpg 1200w,\n/static/d9aac10cdc9e917545bdb3e3680ce4f2/52258/Kubernetes-Ingress---Service-API-Demystified-1.jpg 1800w,\n/static/d9aac10cdc9e917545bdb3e3680ce4f2/a41d1/Kubernetes-Ingress---Service-API-Demystified-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"The Ingress Object itself already has a long history with K8s. It is still considered beta, which is kinda surprising for something that has been so long present in K8s. But why is that? And when will that change?","custom_excerpt":"The Ingress Object itself already has a long history with K8s. It is still considered beta, which is kinda surprising for something that has been so long present in K8s. But why is that? And when will that change?","visibility":"public","created_at_pretty":"18 May, 2020","published_at_pretty":"June 2, 2020","updated_at_pretty":"14 October, 2020","created_at":"2020-05-18T14:49:22.000+00:00","published_at":"2020-06-02T14:24:25.000+00:00","updated_at":"2020-10-14T05:00:57.000+00:00","meta_title":"Kubernetes Ingress & Service API Demystified","meta_description":"This blog covers some of the long-standing issues with the current state of Ingress in Kubernetes, as well as the new Service API aimed at solving them.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified-2.jpg","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"The Ingress Object itself already has a long history with K8s. It is still\nconsidered beta, which is kinda surprising for something that has been so long\npresent in K8s. But why is that? And when will that change?\n\nWith the release of Kubernetes 1.18, some improvements\n[https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/] \nhave been made to Ingress, which have been overdue for a long time. However, the\nchanges introduced are minor, and some of the issues we’ll be covering in this\nblog post have gone untackled. In addition to covering the issues mentioned\nabove, we’ll be exploring the new Service API aimed at solving these issues.\n\nIssues\nIn this blog post we’ll cover some of the long-standing issues with the current\nstate of Ingress in Kubernetes, including these topics:\n\n * Inflexible HTTP routing definitions\n * Schema differences across vendors\n * Extensibility of Ingress\n\nInflexible HTTP routing definitions\nA simple Ingress object example is the following:\n\n---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-ingress\nspec:\n  rules:\n  - http:\n      paths:\n      - Host: myhost.com\n  path: /testpath\n        pathType: Prefix\n        backend:\nserviceName: test\n \tservicePort: 80\n\n\nThe above Ingress object will route HTTP requests with the URI  GET \nhttp://myhost.com/testpath and forward the request internally to the service\ncalled test on port 80. So far, so good.\n\nThe primary focus of an ingress resource is on solving simple HTTP routing\ncases, similar to the concept of Virtual Hosts with a Path Based routing\nextension. This leads us to the first issue: How would you configure cases like\na redirect?\n\nSchema differences across vendors\nFurther configuration is usually done through annotations on the Ingress\nresource. Annotations are like key-value pairs stored in the metadata of an\nobject.\n\n---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-ingress\n  nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - http:\n      paths:\n      - Host: myhost.com\n  path: /testpath\n        pathType: Prefix\n        backend:\nserviceName: test\n \tservicePort: 80\n\n\nThe above example shows that the Ingress Controller (nginx) would rewrite all\nrequests to / (slash) before forwarding to the backend.\n\nConsider that the same configuration in Traefik would look like this:\n\n--- \napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata: \n  name: rewrite-slash\nspec: \n  replacePath: \n    path: /\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: whoami-ingress\n  annotations:\n    kubernetes.io/ingress.class: traefik              \n    traefik.ingress.kubernetes.io/router.middlewares: default-rewrite-slash@kubernetescrd\nspec:\n  rules:\n  - host: whoami.localhost\n    http:\n      paths:\n      - path: /foobar\n        backend:\n          serviceName: whoami\n          servicePort: web\n\n\n\nAs you can see, it’s totally different! Which brings us to another issue:\nextensibility. \n\nExtensibility of Ingress\nExtending Ingress Objects is a requirement and the de-facto standard for that is\nusing annotations. However, annotations often differ between the many different\nimplementations of  Ingress Controllers and it's therefore hard to manage for an\nend-user.\n\nThis unmanageability also translates back to the providers who must maintain\ntheir ingress controller implementation, who are often constrained by the\nsimplicity of the key / value pair approach.\n\nService API aka Ingress V2\nAnnounced at Kubecon NA in 2019 by Google there has been substantial effort in\n creating an “Ingress V2” which is now known as the Service API\n[https://github.com/kubernetes-sigs/service-apis].\n\nThis specification aims to solve a few problems:\n\n * Provide clean separation and role-based control\n * Uplevel the Ingress specification\n * Specify standard methods of extending the Ingress specification\n\nTo do so, the specification currently consists of 4 different CRD Ressources:\n\nGatewayclass\nThe GatewayClass is meant to be a Cluster Scoped resource, which is meant to\nrepresent a “category” of gateways. It’s similar to the former `ingress.class`\nannotation or the now included IngressClass resource.\n\nThe expected use-case is to have more than one GatewayClass per Ingress\nController provider. These classes may have a variety of default settings, which\nare inherited by the cluster-level gateway. Also, this can be used to pass\nadditional configuration down to that gateway. Since it is a cluster scoped\nresource, it's expected to be managed by the Infrastructure provider.\n\n---\nkind: GatewayClass\nmetadata:\n  name: cluster-gateway\nspec:\n  controller: \"acme.io/gateway-controller\"\n  parametersRef:\n    apiVersion: core/v1\n    kind: ConfigMap\n    namespace: acme-system\n    name: internet-gateway\n\n\nGateway\nThe gateway has a life-cycle which is tied with the infrastructure. For\ninstance, one Gateway could be running an instance of Traefik or one AWS ELB. As\nalready mentioned, it’s linked to a Gateway class for inferring configuration.\n\nThe gateway sets listener bindings (Address, Ports, TLS…) and the routes served\nby the gateway.\n\n---\nkind: Gateway\nname: my-app-gw\nnamespace: my-app\nspec:\n  class: from-internet\n  listeners:\n  - address:\n      ip: 1.2.3.4\n    protocols: [\"http\"] # implies port 80.\n    routes:\n      ...\n  - address:\n      ip: 1.2.3.4\n    protocols: [\"https\"] # implies port 443\n    certificates:\n    - name: my-secret\n    - apiGroup: certmanager.k8s.io\n      kind: Certificate               \n      name: lets-encrypt-cert\n    routes:\n      - route:\n        name: http-app-1\n        namespace: app-1\n        kind: HTTPRoute\n\n\nIt also has some sane default protocols like: http, https, TCP… which map to\npredefined ports.\n\nRoute\nLast but not least, a route is used to describe a way to handle traffic given\nprotocol level descriptions.\n\nA route can be of a different ressource (HTTPRoute, TLSRoute, TCPRoute…) and can\ntherefore have different protocol level descriptions taken into consideration\nfor routing. Each of these Protocols have different attributes which could be\nused for route matching. It can also be used to delegate to other Route\nResources in a multi-tenant scenario, for example, where  one team offers a\nglobal authentication service where you would want to forward from within your\ncurrent scope.\n\n---\nkind: HTTPRoute\nname: delegate-1\nnamespace: other-team\nrules:\n- match:\n    http:\n      host: bar.com\n      path:\n        prefix: /store\n  action:\n    backend:                           \n      name: delegate-1                  \n      namespace: other-team             \n      kind: HTTPRoute\n      apiGroup: networking.k8s.io\n\n\nIn the above HTTPRoute example it’s listening for traffic with a host of bar.com\nand looking for a Pathprefix of /store, which is close to some of the examples\nwe’ve explored on  traditional Ingress but allows for some additional specifics.\n\nExtensibility\nTaking what we just learned to the next level, the question that arrives now is:\n“How can we extend that, for example, to implement Rewrites?”\n\nFor that purpose, the specification currently offers three different levels of\nsupport:\n\n * Core\n * Extended\n * Custom\n\nCore functionality is guaranteed between all solutions respecting a specific set\nof API’s. Extended is a standardised API, but functionality is not guaranteed\nbetween all solutions.\n\nFor special use-cases, which might be vendor specific, there’s a custom layer\nwhere the implementation can be custom built to meet specific requirements.\nUsually, these will end up in CRD’s or custom annotations.\n\nSumUp\nService API is a new set of forward-looking API’s attempting to solve some\nissues that have become apparent over the evolving usage of Ingress. However, as\nit’s a bit more complex and might not solve all the simple use cases Ingress is\ncapable of solving, it’s not meant to replace Ingress but rather provide an\nalternative for complex use cases.\n\nEventually, Traefik itself will support the new Service API spec. In the\nmeantime, we offer support for both native Kubernetes Ingress and have extended\nsupport for Ingress through the use of CRDs. Learn more about how we do both\nand\nempower developers with flexible and easy to use Kubernetes Ingress\n[/solutions/kubernetes-ingress/].","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg\" class=\"kg-image\" alt=\"Kubernetes Ingress &amp; Service API Demystified\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 1600w, https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 2400w\" sizes=\"(min-width: 720px) 720px\"></figure><p>The Ingress Object itself already has a long history with K8s. It is still considered beta, which is kinda surprising for something that has been so long present in K8s. But why is that? And when will that change?</p><p>With the release of Kubernetes 1.18, some <a href=\"https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/\">improvements</a> have been made to Ingress, which have been overdue for a long time. However, the changes introduced are minor, and some of the issues we’ll be covering in this blog post have gone untackled. In addition to covering the issues mentioned above, we’ll be exploring the new Service API aimed at solving these issues.</p><h2 id=\"issues\">Issues</h2><p>In this blog post we’ll cover some of the long-standing issues with the current state of Ingress in Kubernetes, including these topics:</p><ul><li>Inflexible HTTP routing definitions</li><li>Schema differences across vendors</li><li>Extensibility of Ingress</li></ul><h2 id=\"inflexible-http-routing-definitions\">Inflexible HTTP routing definitions</h2><p>A simple Ingress object example is the following:</p><!--kg-card-begin: markdown--><pre><code>---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-ingress\nspec:\n  rules:\n  - http:\n      paths:\n      - Host: myhost.com\n  path: /testpath\n        pathType: Prefix\n        backend:\nserviceName: test\n \tservicePort: 80\n</code></pre>\n<!--kg-card-end: markdown--><p>The above Ingress object will route HTTP requests with the URI  GET <em>http://myhost.com/testpath</em> and forward the request internally to the service called test on port 80. So far, so good.</p><p>The primary focus of an ingress resource is on solving simple HTTP routing cases, similar to the concept of Virtual Hosts with a Path Based routing extension. This leads us to the first issue: How would you configure cases like a redirect?</p><h2 id=\"schema-differences-across-vendors\">Schema differences across vendors</h2><p>Further configuration is usually done through annotations on the Ingress resource. Annotations are like key-value pairs stored in the metadata of an object.</p><!--kg-card-begin: markdown--><pre><code>---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-ingress\n  nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - http:\n      paths:\n      - Host: myhost.com\n  path: /testpath\n        pathType: Prefix\n        backend:\nserviceName: test\n \tservicePort: 80\n</code></pre>\n<!--kg-card-end: markdown--><p>The above example shows that the Ingress Controller (nginx) would rewrite all requests to / (slash) before forwarding to the backend.</p><p>Consider that the same configuration in Traefik would look like this:</p><!--kg-card-begin: markdown--><pre><code>--- \napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata: \n  name: rewrite-slash\nspec: \n  replacePath: \n    path: /\n---\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: whoami-ingress\n  annotations:\n    kubernetes.io/ingress.class: traefik              \n    traefik.ingress.kubernetes.io/router.middlewares: default-rewrite-slash@kubernetescrd\nspec:\n  rules:\n  - host: whoami.localhost\n    http:\n      paths:\n      - path: /foobar\n        backend:\n          serviceName: whoami\n          servicePort: web\n\n</code></pre>\n<!--kg-card-end: markdown--><p>As you can see, it’s totally different! Which brings us to another issue: extensibility. </p><h2 id=\"extensibility-of-ingress\">Extensibility of Ingress</h2><p>Extending Ingress Objects is a requirement and the de-facto standard for that is using annotations. However, annotations often differ between the many different implementations of  Ingress Controllers and it's therefore hard to manage for an end-user.</p><p>This unmanageability also translates back to the providers who must maintain their ingress controller implementation, who are often constrained by the simplicity of the key / value pair approach.</p><h2 id=\"service-api-aka-ingress-v2\">Service API aka Ingress V2</h2><p>Announced at Kubecon NA in 2019 by Google there has been substantial effort in  creating an “Ingress V2” which is now known as the <a href=\"https://github.com/kubernetes-sigs/service-apis\">Service API</a>.</p><p>This specification aims to solve a few problems:</p><ul><li>Provide clean separation and role-based control</li><li>Uplevel the Ingress specification</li><li>Specify standard methods of extending the Ingress specification</li></ul><p>To do so, the specification currently consists of 4 different CRD Ressources:</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh4.googleusercontent.com/bVzQquzU0GRBFEZBpOLTIniju6zwytLAlLcRP52swLC2GF4Vqw4855Uu-OQFVZdPG5bZ-C8kg9EfLb5L21JpXegV6wwkOJnXDh5EaY2do5--ouHYeDfUbARTSOdWCBhpv2jXVWUM\" class=\"kg-image\" alt></figure><h2 id=\"gatewayclass\">Gatewayclass</h2><p>The GatewayClass is meant to be a Cluster Scoped resource, which is meant to represent a “category” of gateways. It’s similar to the former `ingress.class` annotation or the now included IngressClass resource.</p><p>The expected use-case is to have more than one GatewayClass per Ingress Controller provider. These classes may have a variety of default settings, which are inherited by the cluster-level gateway. Also, this can be used to pass additional configuration down to that gateway. Since it is a cluster scoped resource, it's expected to be managed by the Infrastructure provider.</p><!--kg-card-begin: markdown--><pre><code>---\nkind: GatewayClass\nmetadata:\n  name: cluster-gateway\nspec:\n  controller: &quot;acme.io/gateway-controller&quot;\n  parametersRef:\n    apiVersion: core/v1\n    kind: ConfigMap\n    namespace: acme-system\n    name: internet-gateway\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"gateway\">Gateway</h2><p>The gateway has a life-cycle which is tied with the infrastructure. For instance, one Gateway could be running an instance of Traefik or one AWS ELB. As already mentioned, it’s linked to a Gateway class for inferring configuration.</p><p>The gateway sets listener bindings (Address, Ports, TLS…) and the routes served by the gateway.</p><!--kg-card-begin: markdown--><pre><code>---\nkind: Gateway\nname: my-app-gw\nnamespace: my-app\nspec:\n  class: from-internet\n  listeners:\n  - address:\n      ip: 1.2.3.4\n    protocols: [&quot;http&quot;] # implies port 80.\n    routes:\n      ...\n  - address:\n      ip: 1.2.3.4\n    protocols: [&quot;https&quot;] # implies port 443\n    certificates:\n    - name: my-secret\n    - apiGroup: certmanager.k8s.io\n      kind: Certificate               \n      name: lets-encrypt-cert\n    routes:\n      - route:\n        name: http-app-1\n        namespace: app-1\n        kind: HTTPRoute\n</code></pre>\n<!--kg-card-end: markdown--><p>It also has some sane default protocols like: http, https, TCP… which map to predefined ports.</p><h2 id=\"route\">Route</h2><p>Last but not least, a route is used to describe a way to handle traffic given protocol level descriptions.</p><p>A route can be of a different ressource (HTTPRoute, TLSRoute, TCPRoute…) and can therefore have different protocol level descriptions taken into consideration for routing. Each of these Protocols have different attributes which could be used for route matching. It can also be used to delegate to other Route Resources in a multi-tenant scenario, for example, where  one team offers a global authentication service where you would want to forward from within your current scope.</p><!--kg-card-begin: markdown--><pre><code>---\nkind: HTTPRoute\nname: delegate-1\nnamespace: other-team\nrules:\n- match:\n    http:\n      host: bar.com\n      path:\n        prefix: /store\n  action:\n    backend:                           \n      name: delegate-1                  \n      namespace: other-team             \n      kind: HTTPRoute\n      apiGroup: networking.k8s.io\n</code></pre>\n<!--kg-card-end: markdown--><p>In the above HTTPRoute example it’s listening for traffic with a host of bar.com and looking for a Pathprefix of /store, which is close to some of the examples we’ve explored on  traditional Ingress but allows for some additional specifics.</p><h2 id=\"extensibility\">Extensibility</h2><p>Taking what we just learned to the next level, the question that arrives now is: “How can we extend that, for example, to implement Rewrites?”</p><p>For that purpose, the specification currently offers three different levels of support:</p><ul><li>Core</li><li>Extended</li><li>Custom</li></ul><p>Core functionality is guaranteed between all solutions respecting a specific set of API’s. Extended is a standardised API, but functionality is not guaranteed between all solutions.</p><p>For special use-cases, which might be vendor specific, there’s a custom layer where the implementation can be custom built to meet specific requirements. Usually, these will end up in CRD’s or custom annotations.</p><h2 id=\"sumup\">SumUp</h2><p>Service API is a new set of forward-looking API’s attempting to solve some issues that have become apparent over the evolving usage of Ingress. However, as it’s a bit more complex and might not solve all the simple use cases Ingress is capable of solving, it’s not meant to replace Ingress but rather provide an alternative for complex use cases.</p><p>Eventually, Traefik itself will support the new Service API spec. In the meantime, we offer support for both native Kubernetes Ingress and have extended support for Ingress through the use of CRDs. Learn more about <a href=\"https://containous.ghost.io/solutions/kubernetes-ingress/\">how we do both and empower developers with flexible and easy to use Kubernetes Ingress</a>.<br></p>","url":"https://containous.ghost.io/blog/kubernetes-ingress-service-api-demystified/","canonical_url":null,"uuid":"a1c9986a-1406-40fe-9274-993271aed29f","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ec2a072c49e39004576b7ad","reading_time":5}},{"node":{"id":"Ghost__Post__5eba1e92c49e39004576b665","title":"Announcing Maesh 1.2","slug":"announcing-maesh-1-2","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/05/Announcing-Maesh-1-2-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/eea388d034bc889f2b61ee6aec472465/47498/Announcing-Maesh-1-2-1.jpg","srcSet":"/static/eea388d034bc889f2b61ee6aec472465/9dc27/Announcing-Maesh-1-2-1.jpg 300w,\n/static/eea388d034bc889f2b61ee6aec472465/4fe8c/Announcing-Maesh-1-2-1.jpg 600w,\n/static/eea388d034bc889f2b61ee6aec472465/47498/Announcing-Maesh-1-2-1.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Maesh 1.2 brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.","custom_excerpt":"Maesh 1.2 brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.","visibility":"public","created_at_pretty":"12 May, 2020","published_at_pretty":"May 12, 2020","updated_at_pretty":"02 June, 2020","created_at":"2020-05-12T03:57:06.000+00:00","published_at":"2020-05-12T18:51:37.000+00:00","updated_at":"2020-06-02T14:24:48.000+00:00","meta_title":"Announcing Maesh 1.2 - Now with support for UDP, reworked ACL and more","meta_description":"Maesh 1.2 brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.","og_description":"Now with support for UDP, reworked ACL, and a more efficient installation!","og_image":null,"og_title":"Announcing Maesh 1.2","twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/05/Announcing-Maesh-1-2-Twitter.jpg","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Now with support for UDP, reworked ACL, and a more efficient installation!\n\nIn early March, we proudly announced the general availability of Maesh 1.1\n[/blog/traefik-maesh-1-1/]. Now, less than 3 months later we’re proud to\nintroduce Maesh 1.2, the latest release of our simpler service mesh. This\nrelease brings new additions such as UDP support and enhancing our internal\narchitecture to provide more flexibility and performance in large deployments.\n\nUDP Support\nAs you probably know, Maesh [/blog/maesh-1-0-802f4be9a9a7/] is built on top of \nTraefik [/traefik/], our popular Cloud Native Edge Router. Traefik introduced\nUDP support with the release of version 2.2 [/blog/traefik-2-2-ingress/] in\nearly March, and  as a result, Maesh is now able to handle UDP connections\n[https://en.wikipedia.org/wiki/User_Datagram_Protocol] as well.\n\nThe only thing you need to do is modify your \"maesh.containo.us/traffic-type\"\nannotation and set it to udp.\n\n---\napiVersion: v1\nkind: Service\nmetadata: \n  annotations: \n    maesh.containo.us/traffic-type: udp\n  labels: \n    app: my-udp-service\n  name: udp-service\n  namespace: test\nspec: \n  ports: \n    - port: 8080\n      protocol: UDP\n  selector: \n    app: my-udp-service\n\n\nThat’s it! Maesh will now proxy the UDP protocol to that service.\n\nPull over Push Configuration\nAs a result of the architectural change mentioned above, we were able to improve\nthe way our proxy nodes ingest configuration.\n\nPrior to this release, the Maesh Controller pushed the current dynamic\nconfiguration to the proxy nodes. Of course, this solution was not optimal as it\neventually resulted in longer deployment times and became a bottleneck in large\nclusters.\n\nWe’ve changed the configuration to a pull based system, so instead of waiting\nfor a push, the custom nodes will pull the configuration from the\ncontroller.This change improves both performance along with stability, and makes\nthe deployment of configuration not only more efficient but much easier.\n\nACL as a feature\nMaesh was designed from the ground up to be SMI [https://smi-spec.io/] \ncompliant. Therefore, we initially had a CLI flag to configure Maesh called \n--smi. This would set Maesh into the SMI Mode which made it possible to make use\nof TrafficSplits or ACL.\n\nAs a side-effect you were unable to use the retry annotation together with SMI\nbecause internally the two modes were incompatible.\n\nTo change that, we have reworked how Maesh discovers services. Maesh will now\nbuild an internal topology of every deployed service, including *nested\nTrafficSplits* through the SMI specification.\n\nAdditionally, if you want to use ACL (TrafficTarget in SMI) you may now activate\nthe ACL flag --acl similar to how you could activate the SMI flag before. Doing\nso, will activate the ACL feature on Maesh without impacting the SMI mode.\n\nMultiple Middlewares per service\nLast but not least, we also enhanced the handling of the annotations on your\nservices. It is now possible to combine middlewares, for example the\nretry-attempts with the rate-limiter to better control your services.\n\n---\napiVersion: v1\nkind: Service\nmetadata: \n  annotations:\n    maesh.containo.us/retry-attempts: 2\n    maesh.containo.us/ratelimit-burst: 200\n  labels: \n    app: my-udp-service\n  name: udp-service\n  namespace: test\nspec: \n  ports: \n    - port: 8080\n      protocol: UDP\n  selector: \n    app: my-udp-service\n\n\nThis configuration activates the retry feature and Maesh will simultaneously try\nto proxy the request twice in case of a network error and activate the rate\nlimiting for that service.\n\nNew Helm Major Version\nAs a result of all the architecture changes mentioned above, we needed to\nenhance the Major Version of our chart as we had some helm breaking changes. For\nassistance while upgrading your installation, please see here\n[https://docs.mae.sh/master/migration/helm-chart/].\n\nWhat’s Next\nWe’re just getting started. Work is underway to implement some of the most\nrequested features into Maesh, including End to End encryption. Of course, this\nis only made possible by you, an awesome community, which provides us such\nvaluable feedback that we’re able to define an exciting roadmap for a product\nyou’ve helped us build. \n\nPlease don’t stop contributing, either in PR’s or just raising issues. For us it\nmatters a lot. \n\nThank you!\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Now with support for UDP, reworked ACL, and a more efficient installation!</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/05/Announcing-Maesh-1-2.jpg\" class=\"kg-image\"></figure><p>In early March, we proudly announced the general availability of <a href=\"https://containous.ghost.io/blog/traefik-maesh-1-1/\">Maesh 1.1</a>. Now, less than 3 months later we’re proud to introduce Maesh 1.2, the latest release of our simpler service mesh. This release brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.</p><h2 id=\"udp-support\">UDP Support</h2><p>As you probably know, <a href=\"https://containous.ghost.io/blog/maesh-1-0-802f4be9a9a7/\">Maesh</a> is built on top of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, our popular Cloud Native Edge Router. Traefik introduced UDP support with the <a href=\"https://containous.ghost.io/blog/traefik-2-2-ingress/\">release of version 2.2</a> in early March, and  as a result, Maesh is now able to handle <a href=\"https://en.wikipedia.org/wiki/User_Datagram_Protocol\">UDP connections</a> as well.</p><p>The only thing you need to do is modify your \"maesh.containo.us/traffic-type\" annotation and set it to <strong>udp</strong>.</p><!--kg-card-begin: markdown--><pre><code>---\napiVersion: v1\nkind: Service\nmetadata: \n  annotations: \n    maesh.containo.us/traffic-type: udp\n  labels: \n    app: my-udp-service\n  name: udp-service\n  namespace: test\nspec: \n  ports: \n    - port: 8080\n      protocol: UDP\n  selector: \n    app: my-udp-service\n</code></pre>\n<!--kg-card-end: markdown--><p>That’s it! Maesh will now proxy the UDP protocol to that service.</p><h2 id=\"pull-over-push-configuration\">Pull over Push Configuration</h2><p>As a result of the architectural change mentioned above, we were able to improve the way our proxy nodes ingest configuration.</p><p>Prior to this release, the Maesh Controller pushed the current dynamic configuration to the proxy nodes. Of course, this solution was not optimal as it eventually resulted in longer deployment times and became a bottleneck in large clusters.</p><p>We’ve changed the configuration to a pull based system, so instead of waiting for a push, the custom nodes will pull the configuration from the controller.This change improves both performance along with stability, and makes the deployment of configuration not only more efficient but much easier.</p><h2 id=\"acl-as-a-feature\">ACL as a feature</h2><p>Maesh was designed from the ground up to be <a href=\"https://smi-spec.io/\">SMI</a> compliant. Therefore, we initially had a CLI flag to configure Maesh called <strong>--smi</strong>. This would set Maesh into the SMI Mode which made it possible to make use of TrafficSplits or ACL.</p><p>As a side-effect you were unable to use the retry annotation together with SMI because internally the two modes were incompatible.</p><p>To change that, we have reworked how Maesh discovers services. Maesh will now build an internal topology of every deployed service, including *nested TrafficSplits* through the SMI specification.</p><p>Additionally, if you want to use ACL (TrafficTarget in SMI) you may now activate the ACL flag<strong> --acl</strong> similar to how you could activate the SMI flag before. Doing so, will activate the ACL feature on Maesh without impacting the SMI mode.</p><h2 id=\"multiple-middlewares-per-service\">Multiple Middlewares per service</h2><p>Last but not least, we also enhanced the handling of the annotations on your services. It is now possible to combine middlewares, for example the retry-attempts with the rate-limiter to better control your services.</p><!--kg-card-begin: markdown--><pre><code>---\napiVersion: v1\nkind: Service\nmetadata: \n  annotations:\n    maesh.containo.us/retry-attempts: 2\n    maesh.containo.us/ratelimit-burst: 200\n  labels: \n    app: my-udp-service\n  name: udp-service\n  namespace: test\nspec: \n  ports: \n    - port: 8080\n      protocol: UDP\n  selector: \n    app: my-udp-service\n</code></pre>\n<!--kg-card-end: markdown--><p>This configuration activates the retry feature and Maesh will simultaneously try to proxy the request twice in case of a network error and activate the rate limiting for that service.</p><h2 id=\"new-helm-major-version\">New Helm Major Version</h2><p>As a result of all the architecture changes mentioned above, we needed to enhance the Major Version of our chart as we had some helm breaking changes. For assistance while upgrading your installation, please see <a href=\"https://docs.mae.sh/master/migration/helm-chart/\">here</a>.</p><h2 id=\"what-s-next\">What’s Next</h2><p>We’re just getting started. Work is underway to implement some of the most requested features into Maesh, including End to End encryption. Of course, this is only made possible by you, an awesome community, which provides us such valuable feedback that we’re able to define an exciting roadmap for a product you’ve helped us build. </p><p>Please don’t stop contributing, either in PR’s or just raising issues. For us it matters a lot. </p><p>Thank you!</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\">Community Forum</a><br></li></ul>","url":"https://containous.ghost.io/blog/announcing-maesh-1-2/","canonical_url":null,"uuid":"b766ba7b-fcf3-4d04-aca7-89caea3a0a44","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eba1e92c49e39004576b665","reading_time":3}},{"node":{"id":"Ghost__Post__5e5cd2ba3727400038a2f958","title":"Announcing Traefik 2.2","slug":"traefik-2-2-ingress","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/Traefik2.2Blog.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/45b5b2113a5d238563769f59eb3b6ce2/f3583/Traefik2.2Blog.png","srcSet":"/static/45b5b2113a5d238563769f59eb3b6ce2/630fb/Traefik2.2Blog.png 300w,\n/static/45b5b2113a5d238563769f59eb3b6ce2/2a4de/Traefik2.2Blog.png 600w,\n/static/45b5b2113a5d238563769f59eb3b6ce2/f3583/Traefik2.2Blog.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Traefik 2.1 adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik since the beginning and is utterly important for us, but also for you, our users. ","custom_excerpt":"Traefik 2.1 adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik since the beginning and is utterly important for us, but also for you, our users. ","visibility":"public","created_at_pretty":"02 March, 2020","published_at_pretty":"March 26, 2020","updated_at_pretty":"28 April, 2020","created_at":"2020-03-02T09:32:42.000+00:00","published_at":"2020-03-26T12:58:01.000+00:00","updated_at":"2020-04-28T13:02:41.000+00:00","meta_title":"Announcing Traefik 2.2 - With Enhanced Ingress support and more!","meta_description":"Traefik 2.1 adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":"https://containous.ghost.io/content/images/2020/03/Traefik2.2-Twitter.png","twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#community-related-resource","slug":"hash-community-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"},{"name":"#traefik-related-resource","slug":"hash-traefik-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"With Enhanced Ingress support and more!\n\nAfter releasing 2.1 in December, we are excited to announce a new release. This\none adds couple of long awaited features, but also brings simplicity in certain\nareas. Simplicity has always been a key feature of Traefik since the beginning\nand is utterly important for us, but also for you, our users. Our goal is to\nkeep constantly improving the user experience by making the handling of Traefik\neven more easy, that you can focus on your real issues. \n\nEnhanced Ingress Support\nAs announced with the 2.1 release, this release is focusing on user experience.\nFor that reason, we brought back extended Ingress Support. Prior to Traefik\nv2.2, plain Kubernetes Ingress Objects were only supported without annotations.\nAs our community told us, they have a valuable use-case where they want to run\nTraefik as a simple Ingress Controller, and don't want to fully commit to the\nIngressRoute in order to stay better included with the Kubernetes ecosystem. For\nthat reason, we’re supporting Ingress Objects with a sub-set of annotations\nagain.\n\nkind: Ingress\napiVersion: networking.k8s.io/v1beta1\nmetadata:\n  name: foo\n  namespace: bar\n  annotations:\n    traefik.ingress.kubernetes.io/router.entrypoints: web, websecure\n    traefik.ingress.kubernetes.io/router.middlewares: redirect-http@kuberntes-crd\n    external-dns.alpha.kubernetes.io/hostname: *.mycompany.org\nspec:\n  rules:\n  - host: foo.com\n    http:\n      paths:\n      - path: /bar\n        backend:\n          serviceName: service1\n          servicePort: 80\n\nAdditionally, not all the behavior we want to be configurable for our users fit\ninto the idea of an Ingress, therefore we're also supporting a subset of\nannotations on Service Objects to fill the gap.\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: service1\n  namespace: bar\n  annotations: traefik.ingress.kubernetes.io/service.sticky: \"true\"\nspec:\n  type: ClusterIP\n  ports:\n  - port: 80\n    name: http\n\nA list of all annotations (Ingress and Service) can be found here \nhttps://docs.traefik.io/master/routing/providers/kubernetes-ingress/\n\nEntrypoint Redirection And Default Router Configuration\nTraefik 2.x is really powerful, given the reworked architecture allowing us to\noperate from Layer 4 and above. Additionally, the new concept of routers,\nmiddlewares and services allows for more flexibility. As a result, you told us\nthat the configuration ended up being a bit too verbose, and that you're missing\nsome sort of redirects on Entrypoints, as we had something similar with Traefik\n1.x.\n\nFor that reason, we introduced the concepts of Entrypoint redirects, and default\nrouter configuration.\n\nWith that release, it's possible to configure redirects bound to an Entrypoint\nthrough the static configuration. Additionally, you can also set defaults for\nthe other areas a router can handle.\n\nhttp:\n    redirections:\n        entryPoint:\n          to: foobar\n          scheme: foobar\n    middlewares:\n      - foobar\n      - foobar\n    tls:\n      options: foobar\n      certResolver: foobar\n      domains:\n        - main: foobar\n          sans:\n          - foobar\n          - foobar\n        - main: foobar\n          sans:\n          - foobar\n          - foobar\n\nTraefik will then create a default router, which will handle the configured\nredirects for you. For everything starting with middlewares, the default values\nwill be copied automatically to all the routers you create.\n\nKey Value Stores\nAnother long awaited feature have been the addition of Key Value Stores as a\ndynamic configuration provider in Traefik v2.Not only have former stores are\nre-added again (such as e.g. etcd or Consul), but new ones such as Redis have\nbeen added providing more supported platforms.\n\nUDP\nSupport for TCP is one of the major changes from Traefik Version to Version 2.\nNow, with the new release we're also adding support for UDP! The only\nrequirement is enabling an Entrypoint to be UDP based and that’s it.\n\n[entryPoints]\n  [entryPoints.udp]\n    address = \":8093/udp\"\n  [entryPoints.http]\n    address = \":8093\" # same as \":8093/tcp\"\n\nFor now, we don't have any routing rules, as TLS is not supported currently (so\nthere is no HostSNI), and there is no PathPrefix notion since there are no\nrequests at the transport layer level. However, that’s not preventing you from\nload balancing your UDP services. That only means that you need to have one\ndedicated Entrypoint per UDP service you want to load balance.\n\nElastic APM Tracer\nElastic APM is a well known solution in the ecosystem. It's the APM solution\nprovided by Elastic [https://www.elastic.co/de/apm]. Starting now, it's a\nsupported Tracing backend for Traefik as well thanks to a community\ncontribution. Just configure it, and you'll have your traces transferred to that\nsystem. \n\nWeb UI Enhancement\nLast but not least, there have been a couple of modifications to the Web UI. Now\nnot only will you be able to see your UDP services, but we’ve had a great\ncommunity contribution to add a dark theme also!\n\nWhat's next?\nAs we said with the previous release, focusing on improving the user experience\nis our goal. Implementing advanced Ingress support on Kubernetes and providing a\nway to configure defaults on an Entrypoint was one of our first steps. However,\nthere are still things to be done which will be part of the upcoming release(s).\nNot only on improving the user experience but also on providing additional\nfeatures. For that please keep raising your voice in the issue tracker\n[https://github.com/containous/traefik/issues], on the community forum\n[https://community.containo.us/], or better—pull request\n[https://github.com/containous/traefik/pulls] your way into making Traefik a\nbetter tool for everyone.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">With Enhanced Ingress support and more!</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/03/Traefik2.2-blog.png\" class=\"kg-image\"></figure><p>After releasing 2.1 in December, we are excited to announce a new release. This one adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik since the beginning and is utterly important for us, but also for you, our users. Our goal is to keep constantly improving the user experience by making the handling of Traefik even more easy, that you can focus on your real issues. </p><h3 id=\"enhanced-ingress-support\">Enhanced Ingress Support</h3><p>As announced with the 2.1 release, this release is focusing on user experience. For that reason, we brought back extended Ingress Support. Prior to Traefik v2.2, plain Kubernetes Ingress Objects were only supported without annotations. As our community told us, they have a valuable use-case where they want to run Traefik as a simple Ingress Controller, and don't want to fully commit to the IngressRoute in order to stay better included with the Kubernetes ecosystem. For that reason, we’re supporting Ingress Objects with a sub-set of annotations again.</p><pre><code class=\"language-yaml\">kind: Ingress\napiVersion: networking.k8s.io/v1beta1\nmetadata:\n  name: foo\n  namespace: bar\n  annotations:\n    traefik.ingress.kubernetes.io/router.entrypoints: web, websecure\n    traefik.ingress.kubernetes.io/router.middlewares: redirect-http@kuberntes-crd\n    external-dns.alpha.kubernetes.io/hostname: *.mycompany.org\nspec:\n  rules:\n  - host: foo.com\n    http:\n      paths:\n      - path: /bar\n        backend:\n          serviceName: service1\n          servicePort: 80</code></pre><p>Additionally, not all the behavior we want to be configurable for our users fit into the idea of an Ingress, therefore we're also supporting a subset of annotations on Service Objects to fill the gap.</p><pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: service1\n  namespace: bar\n  annotations: traefik.ingress.kubernetes.io/service.sticky: \"true\"\nspec:\n  type: ClusterIP\n  ports:\n  - port: 80\n    name: http</code></pre><p>A list of all annotations (Ingress and Service) can be found here <a href=\"https://docs.traefik.io/master/routing/providers/kubernetes-ingress/\">https://docs.traefik.io/master/routing/providers/kubernetes-ingress/</a></p><h2 id=\"entrypoint-redirection-and-default-router-configuration\">Entrypoint Redirection And Default Router Configuration</h2><p>Traefik 2.x is really powerful, given the reworked architecture allowing us to operate from Layer 4 and above. Additionally, the new concept of routers, middlewares and services allows for more flexibility. As a result, you told us that the configuration ended up being a bit too verbose, and that you're missing some sort of redirects on Entrypoints, as we had something similar with Traefik 1.x.</p><p>For that reason, we introduced the concepts of Entrypoint redirects, and default router configuration.</p><p>With that release, it's possible to configure redirects bound to an Entrypoint through the static configuration. Additionally, you can also set defaults for the other areas a router can handle.</p><pre><code class=\"language-yaml\">http:\n    redirections:\n        entryPoint:\n          to: foobar\n          scheme: foobar\n    middlewares:\n      - foobar\n      - foobar\n    tls:\n      options: foobar\n      certResolver: foobar\n      domains:\n        - main: foobar\n          sans:\n          - foobar\n          - foobar\n        - main: foobar\n          sans:\n          - foobar\n          - foobar</code></pre><p>Traefik will then create a default router, which will handle the configured redirects for you. For everything starting with <strong>middlewares</strong>, the default values will be copied automatically to all the routers you create.</p><h2 id=\"key-value-stores\">Key Value Stores</h2><p>Another long awaited feature have been the addition of Key Value Stores as a dynamic configuration provider in Traefik v2.Not only have former stores are re-added again (such as e.g. etcd or Consul), but new ones such as Redis have been added providing more supported platforms.</p><h2 id=\"udp\">UDP</h2><p>Support for TCP is one of the major changes from Traefik Version to Version 2. Now, with the new release we're also adding support for UDP! The only requirement is enabling an Entrypoint to be UDP based and that’s it.</p><pre><code class=\"language-yaml\">[entryPoints]\n  [entryPoints.udp]\n    address = \":8093/udp\"\n  [entryPoints.http]\n    address = \":8093\" # same as \":8093/tcp\"</code></pre><p>For now, we don't have any routing rules, as TLS is not supported currently (so there is no HostSNI), and there is no PathPrefix notion since there are no requests at the transport layer level. However, that’s not preventing you from load balancing your UDP services. That only means that you need to have one dedicated Entrypoint per UDP service you want to load balance.</p><h2 id=\"elastic-apm-tracer\">Elastic APM Tracer</h2><p>Elastic APM is a well known solution in the ecosystem. It's the <a href=\"https://www.elastic.co/de/apm\">APM solution provided by Elastic</a>. Starting now, it's a supported Tracing backend for Traefik as well thanks to a community contribution. Just configure it, and you'll have your traces transferred to that system. </p><h2 id=\"web-ui-enhancement\">Web UI Enhancement</h2><p>Last but not least, there have been a couple of modifications to the Web UI. Now not only will you be able to see your UDP services, but we’ve had a great community contribution to add a dark theme also!</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/03/image.png\" class=\"kg-image\"></figure><h2 id=\"what-s-next\">What's next?</h2><p>As we said with the previous release, focusing on improving the user experience is our goal. Implementing advanced Ingress support on Kubernetes and providing a way to configure defaults on an Entrypoint was one of our first steps. However, there are still things to be done which will be part of the upcoming release(s). Not only on improving the user experience but also on providing additional features. For that please keep raising your voice in the <a href=\"https://github.com/containous/traefik/issues\">issue tracker</a>, on the <a href=\"https://community.containo.us/\">community forum</a>, or better—<a href=\"https://github.com/containous/traefik/pulls\">pull request</a> your way into making Traefik a better tool for everyone.</p>","url":"https://containous.ghost.io/blog/traefik-2-2-ingress/","canonical_url":null,"uuid":"d7ee17a1-2b6a-4486-8694-3db02c494b5e","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e5cd2ba3727400038a2f958","reading_time":4}},{"node":{"id":"Ghost__Post__5e5e2d1c3727400038a2fa13","title":"Announcing Maesh 1.1","slug":"traefik-maesh-1-1","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/04/Maesh1.1-Blog.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/0e11bb0798830e4ec3b9493c39196ca2/f3583/Maesh1.1-Blog.png","srcSet":"/static/0e11bb0798830e4ec3b9493c39196ca2/630fb/Maesh1.1-Blog.png 300w,\n/static/0e11bb0798830e4ec3b9493c39196ca2/2a4de/Maesh1.1-Blog.png 600w,\n/static/0e11bb0798830e4ec3b9493c39196ca2/f3583/Maesh1.1-Blog.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"A few months have passed since the release of Maesh General Availability. During that time we’ve received feedback from you, the community, about use cases you’d like to adopt Maesh for, and we’ve addressed them with this release.","custom_excerpt":"A few months have passed since the release of Maesh General Availability. During that time we’ve received feedback from you, the community, about use cases you’d like to adopt Maesh for, and we’ve addressed them with this release.","visibility":"public","created_at_pretty":"03 March, 2020","published_at_pretty":"March 9, 2020","updated_at_pretty":"22 May, 2020","created_at":"2020-03-03T10:10:36.000+00:00","published_at":"2020-03-09T18:42:45.000+00:00","updated_at":"2020-05-22T00:47:35.000+00:00","meta_title":"Announcing Maesh 1.1. With Helm Version 3 support and more!","meta_description":"Announcing Maesh 1.1. With Helm Version 3 support and more!","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"With Helm Version 3 support and more!\n\nDuring KubeCon North America 2019 in San Diego, we proudly announced the General\nAvailability for Maesh. Since then, roughly three months have passed. During\nthat time we’ve received feedback from you, the community, about use cases you’d\nlike to adopt Maesh for, and we’ve addressed them with this release.\n\nHelm Version 3 Support\nAs of November 2019, Helm 3 has been released to the public. Maesh's Helm chart\nis now Helm v3 compatible, to benefit from all the changes in the internal\narchitecture of Helm v3. As the internal architecture of Helm 3 changed\nenormously, sadly the change causes breaks, so the current chart is not\ndeployable anymore with Helm 2.\n\nFor more information about Helm 3, please check that link\n[https://helm.sh/blog/helm-3-released/].\n\nApplication Namespace Support\nOne request we received was to install Maesh along with your other services in\nthe same namespace, instead of having Maesh need to run in its own namespace.\nWith that new release, we're now supporting that scenario. You can now easily\ninstall Maesh in the same namespace as your applications which allows for\ngreater flexibility and easier management, especially in multi-tenant Kubernetes\nclusters. However, of course it's also still supported to install it in a\nseparate namespace and share it between all your applications.\n\nPerformance Improvement\nAs our Maesh controllers job is to configure the underlying Traefik pods, it\nneeds to make use of the Kubernetes API to get the current state and create a\nproper configuration. With that release, we reworked the internal architecture\nof the controller to make use of listers instead of plain API queries. As\nlisters are making use of a local cache, this is a huge performance improvement.\nLookups are now made to that cache in milliseconds compared to live HTTP calls,\nthus reducing the load on your Kubernetes API as well.\n\nImproved metrics support\nVersion 1.1 brings support for two new metric backends. Starting now, InfluxDB\n[https://www.influxdata.com/] and StatsD [https://github.com/statsd/statsd] can\nbe configured to receive metrics from Maesh. The possible configuration options\nare best visible in the Helm chart. \nhttps://github.com/containous/maesh/blob/v1.1/helm/chart/maesh/values.yaml\n[https://github.com/dtomcej/maesh/blob/v1.1/helm/chart/maesh/values.yaml]\n\nTraefik Upgrade to 2.1\nLast but not least we also upgraded the underlying Traefik that Maesh uses to\ncreate the service mesh to the current version of 2.1 to stay up to date and\nbenefits from the improvements that is bringing on its own. The full changelog\nfor Traefik 2.1 can be read here \nhttps://containo.us/blog/traefik-2-1-in-the-wild/\n[/blog/traefik-2-1-in-the-wild/]\n\nWhat’s Next\nOnce again, we are thankful for the multitude of contributors that went straight\nahead and added Maesh to their development clusters. You provided us with\ninvaluable and early feedback and made this release possible.\n\nBut, it’s just the beginning! Keep telling us what you like, giving us thoughts\nand ideas, and keep (or start) contributing! Pull requests and Issues are the\nbest way to support the product and make it your own.\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">With Helm Version 3 support and more!</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/03/Blog-Post-1.png\" class=\"kg-image\"></figure><p>During KubeCon North America 2019 in San Diego, we proudly announced the General Availability for Maesh. Since then, roughly three months have passed. During that time we’ve received feedback from you, the community, about use cases you’d like to adopt Maesh for, and we’ve addressed them with this release.</p><h2 id=\"helm-version-3-support\">Helm Version 3 Support</h2><p>As of November 2019, Helm 3 has been released to the public. Maesh's Helm chart is now Helm v3 compatible, to benefit from all the changes in the internal architecture of Helm v3. As the internal architecture of Helm 3 changed enormously, sadly the change causes breaks, so the current chart is not deployable anymore with Helm 2.</p><p>For more information about Helm 3, <a href=\"https://helm.sh/blog/helm-3-released/\">please check that link</a>.</p><h2 id=\"application-namespace-support\">Application Namespace Support</h2><p>One request we received was to install Maesh along with your other services in the same namespace, instead of having Maesh need to run in its own namespace. With that new release, we're now supporting that scenario. You can now easily install Maesh in the same namespace as your applications which allows for greater flexibility and easier management, especially in multi-tenant Kubernetes clusters. However, of course it's also still supported to install it in a separate namespace and share it between all your applications.</p><h2 id=\"performance-improvement\">Performance Improvement</h2><p>As our Maesh controllers job is to configure the underlying Traefik pods, it needs to make use of the Kubernetes API to get the current state and create a proper configuration. With that release, we reworked the internal architecture of the controller to make use of listers instead of plain API queries. As listers are making use of a local cache, this is a huge performance improvement. Lookups are now made to that cache in milliseconds compared to live HTTP calls, thus reducing the load on your Kubernetes API as well.</p><h2 id=\"improved-metrics-support\">Improved metrics support</h2><p>Version 1.1 brings support for two new metric backends. Starting now,<a href=\"https://www.influxdata.com/\"> InfluxDB</a> and<a href=\"https://github.com/statsd/statsd\"> StatsD</a> can be configured to receive metrics from Maesh. The possible configuration options are best visible in the Helm chart.<a href=\"https://github.com/dtomcej/maesh/blob/v1.1/helm/chart/maesh/values.yaml\"> https://github.com/containous/maesh/blob/v1.1/helm/chart/maesh/values.yaml</a></p><h2 id=\"traefik-upgrade-to-2-1\">Traefik Upgrade to 2.1</h2><p>Last but not least we also upgraded the underlying Traefik that Maesh uses to create the service mesh to the current version of 2.1 to stay up to date and benefits from the improvements that is bringing on its own. The full changelog for Traefik 2.1 can be read here<a href=\"https://containous.ghost.io/blog/traefik-2-1-in-the-wild/\"> https://containo.us/blog/traefik-2-1-in-the-wild/</a></p><h2 id=\"what-s-next\">What’s Next</h2><p>Once again, we are thankful for the multitude of contributors that went straight ahead and added Maesh to their development clusters. You provided us with invaluable and early feedback and made this release possible.</p><p>But, it’s just the beginning! Keep telling us what you like, giving us thoughts and ideas, and keep (or start) contributing! Pull requests and Issues are the best way to support the product and make it your own.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\">Community Forum</a></li></ul>","url":"https://containous.ghost.io/blog/traefik-maesh-1-1/","canonical_url":null,"uuid":"89f93dd3-b298-4e9b-8d8b-0a855eac69bb","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e5e2d1c3727400038a2fa13","reading_time":2}},{"node":{"id":"Ghost__Post__5dd68f68b6de2b00381d3f6b","title":"Maesh 1.0","slug":"maesh-1-0-802f4be9a9a7","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/maesh-1.0.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b00e1a35700706f1ce67f13a71d0d148/f3583/maesh-1.0.png","srcSet":"/static/b00e1a35700706f1ce67f13a71d0d148/630fb/maesh-1.0.png 300w,\n/static/b00e1a35700706f1ce67f13a71d0d148/2a4de/maesh-1.0.png 600w,\n/static/b00e1a35700706f1ce67f13a71d0d148/f3583/maesh-1.0.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic.","custom_excerpt":"Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic.","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"November 21, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-21T13:21:44.000+00:00","published_at":"2019-11-21T13:21:00.000+00:00","updated_at":"2020-05-22T00:21:18.000+00:00","meta_title":"Maesh 1.0","meta_description":"Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Simpler Service Mesh, Now Production Ready\n\nThree months ago (in September 2019) we were proud to unleash Maesh\n[/blog/announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29/]\n, the simpler service mesh. With so many tools already available on the market,\nwe couldn’t wait to see how the community would react to our vision of the\nconcept.\n\nThe answer is — incredibly well. In less than a month, Maesh had gathered a\ncommunity of people that adopted it right from the start on their development\ncluster. These brave early adopters provided us with invaluable insights about\nvarious cluster configurations and shed light on possible improvements. We\nlistened the best we could, helped them contribute to the project, fixed what\nhad to be fixed, and we’re now contemplating the result of this common effort — \nMaesh 1.0\n\nWhat is Maesh?\nMaesh allows for visibility and management of the traffic that flows inside your\nKubernetes cluster, which is just as important as the ingress and egress\ntraffic. Maesh is designed from the ground up to be straightforward, easy to\ninstall, and easy to use.\n\nBuilt on top of Traefik, Maesh is a simple, yet full-featured service mesh. It\nfits as your de-facto service mesh in your Kubernetes cluster and supports the\nlatest Service Mesh Interface specification (SMI [https://smi-spec.io/]) that\nfacilitates integration with pre-existing solutions. Maesh is opt-in by default,\nwhich means that your existing services are unaffected until you decide to add\nthem to the mesh.\n\nMaesh does not use any sidecar container but handles routing through proxy\nendpoints running on each node. Not using sidecars means that Maesh does not\nmodify your Kubernetes objects, and does not modify your traffic without your\nknowledge. Using the Maesh endpoints is all that is required.\n\nWhat’s New since the Alpha?\nPerformance Improvements\nBased on feedback, we started to rework the inner architecture of Maesh to\nimprove performance and stability. In particular, we made the Maesh controller\nstateless (again) and refactored the internal architecture used to refresh the\nconfiguration. As a result Maesh reacts faster and is more resilient to changes.\nTo make it easier to customize, plenty of options\n[https://github.com/containous/maesh/blob/master/helm/chart/maesh/values.yaml] \nare now configurable (namespaces, the cluster domain, …).\n\nGKE Support\nMany of our early adopters tried to install Maesh (alpha) on GKE with no\nsuccess. The reason was that Maesh relied on CoreDNS to opt-in into the usage of\nthe internal mesh and that GKE doesn’t embed it.\n\nAs a result and to support GKE and distributions that do not ship with CoreDNS,\nwe’ve added support for kube-dns.\n\nFor Maesh 1.0, we’ve tested many distributions but couldn’t test every one of\nthem. If your favorite appears to be unsupported, please raise your voice and\nhelp us fixing that!\n\nSupport for the SMI TCPRoute\nMaesh supported the SMI HTTP part from the beginning, and now supports the TCP\nportion as well. (Bellow is an example of an SMI TCPRoute.)\n\nkind: TrafficTarget\napiVersion: access.smi-spec.io/v1alpha1\nmetadata:\n  name: api-service-target\n  namespace: default\ndestination:\n  kind: ServiceAccount\n  name: api-service\n  namespace: default\nspecs:\n- kind: TCPRoute\n  name: my-tcp-route\nsources:\n- kind: ServiceAccount\n  name: my-other-service\n  namespace: default\n---\napiVersion: specs.smi-spec.io/v1alpha1\nkind: TCPRoute\nmetadata:\n  name: my-tcp-route\n\nkind: TrafficTarget\napiVersion: access.smi-spec.io/v1alpha1\nmetadata:\n  name: api-service-target\n  namespace: default\ndestination:\n  kind: ServiceAccount\n  name: api-service\n  namespace: default\nspecs:\n- kind: TCPRoute\n  name: my-tcp-route\nsources:\n- kind: ServiceAccount\n  name: my-other-service\n  namespace: default\n---\napiVersion: specs.smi-spec.io/v1alpha1\nkind: TCPRoute\nmetadata:\n  name: my-tcp-route\n\n\n\n--------------------------------------------------------------------------------\n\nWhat’s Next\nOnce again, we are thankful for the multitude of contributors that went straight\nahead and added Maesh to their development clusters. You provided us with\ninvaluable and early feedback and made this release possible.\n\nBut it’s just the beginning! Keep telling us what you like, giving us thoughts\nand ideas, and keep (or start) contributing! Pull requests and Issues are the\nbest way to support the product and make it your own.\n\nUseful links\n * Website [/maesh/]\n * Documentation [https://docs.mae.sh/]\n * Github [https://github.com/containous/maesh]\n * Community Forum [https://community.containo.us/c/maesh]","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Simpler Service Mesh, Now Production Ready</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/1_iap46n1HJlw_lNotg3MtzA.png\" class=\"kg-image\"></figure><p>Three months ago (in September 2019) we were <a href=\"https://containous.ghost.io/blog/announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29/\">proud to unleash Maesh</a>, the simpler service mesh. With so many tools already available on the market, we couldn’t wait to see how the community would react to our vision of the concept.</p><p>The answer is — incredibly well. In less than a month, Maesh had gathered a community of people that adopted it right from the start on their development cluster. These brave early adopters provided us with invaluable insights about various cluster configurations and shed light on possible improvements. We listened the best we could, helped them contribute to the project, fixed what had to be fixed, and we’re now contemplating the result of this common effort — <strong><strong>Maesh 1.0</strong></strong></p><h2 id=\"what-is-maesh\">What is Maesh?</h2><p>Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic. Maesh is designed from the ground up to be straightforward, easy to install, and easy to use.</p><p>Built on top of Traefik, Maesh is a simple, yet full-featured service mesh. It fits as your de-facto service mesh in your Kubernetes cluster and supports the latest Service Mesh Interface specification (<a href=\"https://smi-spec.io/\" rel=\"noopener\">SMI</a>) that facilitates integration with pre-existing solutions. Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.</p><p>Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. Not using sidecars means that Maesh does not modify your Kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-20.png\" class=\"kg-image\"></figure><h2 id=\"what-s-new-since-the-alpha\">What’s New since the Alpha?</h2><h3 id=\"performance-improvements\">Performance Improvements</h3><p>Based on feedback, we started to rework the inner architecture of Maesh to improve performance and stability. In particular, we made the Maesh controller stateless (again) and refactored the internal architecture used to refresh the configuration. As a result Maesh reacts faster and is more resilient to changes. To make it easier to customize, <a href=\"https://github.com/containous/maesh/blob/master/helm/chart/maesh/values.yaml\" rel=\"noopener\">plenty of options</a> are now configurable (namespaces, the cluster domain, …).</p><h3 id=\"gke-support\">GKE Support</h3><p>Many of our early adopters tried to install Maesh (alpha) on GKE with no success. The reason was that Maesh relied on CoreDNS to opt-in into the usage of the internal mesh and that GKE doesn’t embed it.</p><p>As a result and to support GKE and distributions that do not ship with CoreDNS, we’ve added support for kube-dns.</p><p>For Maesh 1.0, we’ve tested many distributions but couldn’t test every one of them. If your favorite appears to be unsupported, please raise your voice and help us fixing that!</p><h3 id=\"support-for-the-smi-tcproute\">Support for the SMI TCPRoute</h3><p>Maesh supported the SMI HTTP part from the beginning, and now supports the TCP portion as well. (Bellow is an example of an SMI TCPRoute.)</p><pre><code class=\"language-yaml\">kind: TrafficTarget\napiVersion: access.smi-spec.io/v1alpha1\nmetadata:\n  name: api-service-target\n  namespace: default\ndestination:\n  kind: ServiceAccount\n  name: api-service\n  namespace: default\nspecs:\n- kind: TCPRoute\n  name: my-tcp-route\nsources:\n- kind: ServiceAccount\n  name: my-other-service\n  namespace: default\n---\napiVersion: specs.smi-spec.io/v1alpha1\nkind: TCPRoute\nmetadata:\n  name: my-tcp-route</code></pre><!--kg-card-begin: markdown--><pre><code>kind: TrafficTarget\napiVersion: access.smi-spec.io/v1alpha1\nmetadata:\n  name: api-service-target\n  namespace: default\ndestination:\n  kind: ServiceAccount\n  name: api-service\n  namespace: default\nspecs:\n- kind: TCPRoute\n  name: my-tcp-route\nsources:\n- kind: ServiceAccount\n  name: my-other-service\n  namespace: default\n---\napiVersion: specs.smi-spec.io/v1alpha1\nkind: TCPRoute\nmetadata:\n  name: my-tcp-route\n</code></pre>\n<!--kg-card-end: markdown--><hr><h2 id=\"what-s-next\">What’s Next</h2><p>Once again, we are thankful for the multitude of contributors that went straight ahead and added Maesh to their development clusters. You provided us with invaluable and early feedback and made this release possible.</p><p>But it’s just the beginning! Keep telling us what you like, giving us thoughts and ideas, and keep (or start) contributing! Pull requests and Issues are the best way to support the product and make it your own.</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://containous.ghost.io/maesh/\">Website</a></li><li><a href=\"https://docs.mae.sh/\">Documentation</a></li><li><a href=\"https://github.com/containous/maesh\" rel=\"noopener\">Github</a></li><li><a href=\"https://community.containo.us/c/maesh\" rel=\"noopener\">Community Forum</a></li></ul>","url":"https://containous.ghost.io/blog/maesh-1-0-802f4be9a9a7/","canonical_url":null,"uuid":"c50521f7-f849-4c76-a75f-3cb3067a6de6","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd68f68b6de2b00381d3f6b","reading_time":3}},{"node":{"id":"Ghost__Post__5dd548aeec5ed3003878884c","title":"13 Key Considerations When Selecting an Ingress Controller for Kubernetes","slug":"13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/13-keys-considerations-ingress.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/c55e2e1f948717dedf6b7ee99f99d704/f3583/13-keys-considerations-ingress.png","srcSet":"/static/c55e2e1f948717dedf6b7ee99f99d704/630fb/13-keys-considerations-ingress.png 300w,\n/static/c55e2e1f948717dedf6b7ee99f99d704/2a4de/13-keys-considerations-ingress.png 600w,\n/static/c55e2e1f948717dedf6b7ee99f99d704/f3583/13-keys-considerations-ingress.png 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ","custom_excerpt":"Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"October 8, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T14:07:42.000+00:00","published_at":"2019-10-08T14:11:00.000+00:00","updated_at":"2020-05-21T22:06:35.000+00:00","meta_title":"Considerations When Picking an Ingress Controller for Kubernetes","meta_description":"Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Manuel Zapf","slug":"manuel","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/11/b_manuel-zapf-foto.1024x1024.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#kubernetes-ingress-related-resource","slug":"hash-kubernetes-ingress-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Evaluating Ingress Controllers\nIngresses are critical to any successful Kubernetes (k8s) deployment. Ingresses\nallow you to define how external (and/or internal) traffic is routed to services\nwithin your cluster. The Kubernetes documentation\n[https://kubernetes.io/docs/concepts/services-networking/ingress/] states that:\n\n> “An Ingress can be configured to give Services externally-reachable URLs, load\nbalance traffic, terminate SSL / TLS, and offer name based virtual hosting.”\nHowever, Ingresses themselves don’t do anything — they’re just metadata. The\nheavy lifting is performed by Ingress Controllers. An Ingress without an Ingress\nController won’t do anything. There’s one more catch: while there are a number\nof system controllers (like ReplicaSet Controller, Endpoints Controller,\nNamespace Controller and others) that are managed by the Kubernetes control\nplane, Ingress Controllers are not automatically started with a cluster — you\nhave to install, configure and manage your own Ingress Controllers.\n\nIt’s also possible to have multiple Ingress Controllers in the same cluster. You\ncan divide the “routing space” by using Ingress class annotations, so that each\nIngress knows which Ingress Controller should be handling it. You could end up\nusing a combination of Ingress Controllers for different scenarios within the\nsame cluster. For example, you may have one Ingress Controller for handling\nexternal traffic coming in to the cluster including bindings to SSL\ncertificates, and have another internal Ingress Controller with no SSL binding\nthat handles in-cluster traffic.\n\nThere are scores of Ingress Controllers to choose from. The Kubernetes\ndocumentation has a list of popular Ingress Controllers here\n[https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers]\n.\n\nThese controllers have varied feature sets and varying levels of community or\ncommercial support. Some are “pure” edge routers, while others have features\nmore akin to service meshes.\n\nSelecting the Right Ingress Controller\nSo how do you choose the right Ingress Controller? There are several criteria\nthat are important to consider when doing so. In this post we’re not going to do\na feature comparison between specific Ingress Controllers, since there are many\nhead-to-head comparisons on the internet already, and because there are so many\nIngress Controllers. Rather, we’re going to discuss what features you should be\nweighing when selecting an Ingress Controller.\n\n1/ Traffic Protocol\nAre you just routing HTTP(S), HTTP/2 or websockets? Do you want to route TCP/UDP\nor gRPC? Not all Ingress Controllers support all these protocols, so you’ll have\nto check which protocols an Ingress Controller supports.\n\n2/ Dynamic Configuration Updates\nDo you require zero-downtime configuration changes — often called “hitless\nreloads”? Some Ingress Controllers require downtime in order to update\nconfiguration, while others update dynamically without downtime.\n\n3/ Resiliency\nDo you need rate limiting, retries or circuit breakers at the edge, or have you\nbuilt this functionality into your services yourself? Some Ingress Controllers\nsupport these features, which means you won’t have to code them yourself.\n\n4/ External Load Balancer Integration\nAre you integrating with an external, managed cloud-based load balancer? Make\nsure the Ingress Controller you select integrates well with your external load\nbalancer in order to reduce work and management for your networking team.\n\n5/ Service Mesh\nIngress Controllers can be configured to handle external traffic (traffic\noriginating outside the cluster) or internal traffic or both. If you need to\nobserve or trace internal traffic, you may need a special breed of Ingress\nController — a Service Mesh. Kubernetes provides standards for Service Meshes\nthrough the SMI Specification for interoperability. If you do require a Service\nMesh, make sure you pick the right tool for the right job. Ingress Controllers\nand Service Meshes are not mutually exclusive.\n\n6/ API Gateway\nDo you need an Ingress Controller or an API gateway, or something that does\nboth? Typically API gateways integrate business logic, while edge routers are\ntypically business agnostic. For example, API Gateways let you monitor traffic\nper customer, or measure transactions for billing purposes. If you require\nbusiness logic at the edge, you should probably look at an API gateway instead\nof an Ingress Controller. Just as with Service Meshes, Ingress Controller and\nAPI gateways are not mutually exclusive.\n\n7/ High Availability\nCan you afford downtime when a server restarts for either planned or unplanned\nmaintenance? If so, you need high availability for your Ingress Controller. Not\nall Ingress Controllers support high availability.\n\n8/ Load Balancing Algorithms\nWhat sort of algorithm-based routing do you need? Most Ingress Controllers\nsupport Round Robin, but if you want Least Connection so that the load on your\nservices is taken into account, you’ll need an Ingress Controller that supports\nmore advanced load balancing algorithms.\n\n9/ Advanced Traffic Shifting\nDo you need to perform canary testing (shifting a percentage of traffic to\ndifferent services for progressive exposure)? Load balancing lets you spread the\nload of a service, but not all load balancers can split traffic using more\nsophisticated rules. If you’re testing in production using techniques like\ncanary testing, make sure the Ingress Controller you select supports traffic\nshifting.\n\n10/ Resources Constraints\nAre you cost sensitive as far as resources in your cluster are concerned?\nIngress Controllers can be resource intensive, so if you are cost sensitive,\nyou’re going to be better off with a light-weight Ingress Controller. Some\nIngress Controllers support scaling up and down, while others do not.\n\n11/ Monitoring\nDo you need to integrate with existing metrics and log collection systems? Some\nIngress Controllers offer limited monitoring and logging and may not support\nyour specific monitoring and logging tooling.\n\n12/ Support\nDo you need enterprise support? Open source Ingress Controllers are easy on the\ncheck book, but what happens when you need support in the middle of the night?\nRemember, some open source Ingress Controllers offer enterprise support plans.\n\n13/ Ecosystem\nMake sure the Ingress Controller you are considering has support in the\nKubernetes partner ecosystem.\n\nConclusion\nAs you can see, there are many factors that require thought before you can\nselect the right Ingress Controller for your clusters. Don’t just select a\nhype-driven, popular option — be deliberate about your requirements and then\nevaluate Ingress Controllers according to the criteria we’ve listed. If you do,\nyou’ll have made an informed decision about a very important part of your\ninfrastructure!\n\n [https://info.containo.us/request-white-paper-routing-in-the-cloud]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-106.png\" class=\"kg-image\"></figure><h2 id=\"evaluating-ingress-controllers\">Evaluating Ingress Controllers</h2><p>Ingresses are critical to any successful Kubernetes (k8s) deployment. Ingresses allow you to define how external (and/or internal) traffic is routed to services within your cluster. The Kubernetes <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress/\" rel=\"noopener\">documentation</a> states that:</p><blockquote><em><em>“An Ingress can be configured to give Services externally-reachable URLs, load balance traffic, terminate SSL / TLS, and offer name based virtual hosting.”</em></em></blockquote><p>However, Ingresses themselves don’t do anything — they’re just <em><em>metadata</em></em>. The heavy lifting is performed by <em><em>Ingress Controllers</em></em>. An Ingress without an Ingress Controller won’t do anything. There’s one more catch: while there are a number of system controllers (like ReplicaSet Controller, Endpoints Controller, Namespace Controller and others) that are managed by the Kubernetes control plane, Ingress Controllers are not automatically started with a cluster — you have to install, configure and manage your own Ingress Controllers.</p><p>It’s also possible to have multiple Ingress Controllers in the same cluster. You can divide the “routing space” by using Ingress class annotations, so that each Ingress knows which Ingress Controller should be handling it. You could end up using a combination of Ingress Controllers for different scenarios within the same cluster. For example, you may have one Ingress Controller for handling external traffic coming in to the cluster including bindings to SSL certificates, and have another internal Ingress Controller with no SSL binding that handles in-cluster traffic.</p><p>There are scores of Ingress Controllers to choose from. The Kubernetes documentation has a list of popular Ingress Controllers <a href=\"https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers\" rel=\"noopener\">here</a>.</p><p>These controllers have varied feature sets and varying levels of community or commercial support. Some are “pure” edge routers, while others have features more akin to service meshes.</p><h2 id=\"selecting-the-right-ingress-controller\">Selecting the Right Ingress Controller</h2><p>So how do you choose the right Ingress Controller? There are several criteria that are important to consider when doing so. In this post we’re not going to do a feature comparison between specific Ingress Controllers, since there are many head-to-head comparisons on the internet already, and because there are so many Ingress Controllers. Rather, we’re going to discuss what features you should be weighing when selecting an Ingress Controller.</p><h3 id=\"1-traffic-protocol\">1/ Traffic Protocol</h3><p>Are you just routing HTTP(S), HTTP/2 or websockets? Do you want to route TCP/UDP or gRPC? Not all Ingress Controllers support all these protocols, so you’ll have to check which protocols an Ingress Controller supports.</p><h3 id=\"2-dynamic-configuration-updates\">2/ Dynamic Configuration Updates</h3><p>Do you require zero-downtime configuration changes — often called “hitless reloads”? Some Ingress Controllers require downtime in order to update configuration, while others update dynamically without downtime.</p><h3 id=\"3-resiliency\">3/ Resiliency</h3><p>Do you need rate limiting, retries or circuit breakers at the edge, or have you built this functionality into your services yourself? Some Ingress Controllers support these features, which means you won’t have to code them yourself.</p><h3 id=\"4-external-load-balancer-integration\">4/ External Load Balancer Integration</h3><p>Are you integrating with an external, managed cloud-based load balancer? Make sure the Ingress Controller you select integrates well with your external load balancer in order to reduce work and management for your networking team.</p><h3 id=\"5-service-mesh\">5/ Service Mesh</h3><p>Ingress Controllers can be configured to handle external traffic (traffic originating outside the cluster) or internal traffic or both. If you need to observe or trace internal traffic, you may need a special breed of Ingress Controller — a Service Mesh. Kubernetes provides standards for Service Meshes through the SMI Specification for interoperability. If you do require a Service Mesh, make sure you pick the right tool for the right job. Ingress Controllers and Service Meshes are not mutually exclusive.</p><h3 id=\"6-api-gateway\">6/ API Gateway</h3><p>Do you need an Ingress Controller or an API gateway, or something that does both? Typically API gateways integrate business logic, while edge routers are typically business agnostic. For example, API Gateways let you monitor traffic per customer, or measure transactions for billing purposes. If you require business logic at the edge, you should probably look at an API gateway instead of an Ingress Controller. Just as with Service Meshes, Ingress Controller and API gateways are not mutually exclusive.</p><h3 id=\"7-high-availability\">7/ High Availability</h3><p>Can you afford downtime when a server restarts for either planned or unplanned maintenance? If so, you need high availability for your Ingress Controller. Not all Ingress Controllers support high availability.</p><h3 id=\"8-load-balancing-algorithms\">8/ Load Balancing Algorithms</h3><p>What sort of algorithm-based routing do you need? Most Ingress Controllers support Round Robin, but if you want Least Connection so that the load on your services is taken into account, you’ll need an Ingress Controller that supports more advanced load balancing algorithms.</p><h3 id=\"9-advanced-traffic-shifting\">9/ Advanced Traffic Shifting</h3><p>Do you need to perform canary testing (shifting a percentage of traffic to different services for progressive exposure)? Load balancing lets you spread the load of a service, but not all load balancers can split traffic using more sophisticated rules. If you’re testing in production using techniques like canary testing, make sure the Ingress Controller you select supports traffic shifting.</p><h3 id=\"10-resources-constraints\">10/ Resources Constraints</h3><p>Are you cost sensitive as far as resources in your cluster are concerned? Ingress Controllers can be resource intensive, so if you are cost sensitive, you’re going to be better off with a light-weight Ingress Controller. Some Ingress Controllers support scaling up and down, while others do not.</p><h3 id=\"11-monitoring\">11/ Monitoring</h3><p>Do you need to integrate with existing metrics and log collection systems? Some Ingress Controllers offer limited monitoring and logging and may not support your specific monitoring and logging tooling.</p><h3 id=\"12-support\">12/ Support</h3><p>Do you need enterprise support? Open source Ingress Controllers are easy on the check book, but what happens when you need support in the middle of the night? Remember, some open source Ingress Controllers offer enterprise support plans.</p><h3 id=\"13-ecosystem\">13/ Ecosystem</h3><p>Make sure the Ingress Controller you are considering has support in the Kubernetes partner ecosystem.</p><h2 id=\"conclusion\">Conclusion</h2><p>As you can see, there are many factors that require thought before you can select the right Ingress Controller for your clusters. Don’t just select a hype-driven, popular option — be deliberate about your requirements and then evaluate Ingress Controllers according to the criteria we’ve listed. If you do, you’ll have made an informed decision about a very important part of your infrastructure!</p><!--kg-card-begin: markdown--><p><a href=\"https://info.containo.us/request-white-paper-routing-in-the-cloud\"><img src=\"https://containous.ghost.io/content/images/2019/12/request-white-paper-routing-in-the-cloud.png\" alt=\"request-white-paper-routing-in-the-cloud\"></a></p>\n<!--kg-card-end: markdown-->","url":"https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/","canonical_url":null,"uuid":"2c5e7ed6-3b40-4690-b39b-772ba9a0f24c","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd548aeec5ed3003878884c","reading_time":4}}]}},"pageContext":{"slug":"manuel","limit":9,"skip":0,"numberOfPages":2,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":2,"previousPagePath":null,"nextPagePath":"/author/manuel/page/2/"}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}