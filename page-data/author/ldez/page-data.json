{"componentChunkName":"component---src-templates-author-tsx","path":"/author/ldez/","result":{"data":{"ghostAuthor":{"slug":"ldez","name":"Ludovic Fernandez","bio":null,"cover_image":null,"profile_image":"//www.gravatar.com/avatar/9185f906b875328134ba0d4a6bb6085a?s=250&d=mm&r=x","location":null,"website":"https://ldez.github.io","twitter":"@ludnadez","facebook":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5dd550aeec5ed3003878892e","title":"Traefik 2.0 & Docker 101","slug":"traefik-2-0-docker-101-fc2893944b9d","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/11/traefik-2-101-docker.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/19e113d66274fb69bbfde43d3e491cc0/f3583/traefik-2-101-docker.png","srcSet":"/static/19e113d66274fb69bbfde43d3e491cc0/630fb/traefik-2-101-docker.png 300w,\n/static/19e113d66274fb69bbfde43d3e491cc0/2a4de/traefik-2-101-docker.png 600w,\n/static/19e113d66274fb69bbfde43d3e491cc0/f3583/traefik-2-101-docker.png 1200w,\n/static/19e113d66274fb69bbfde43d3e491cc0/bbee5/traefik-2-101-docker.png 1800w,\n/static/19e113d66274fb69bbfde43d3e491cc0/0ef64/traefik-2-101-docker.png 2400w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Docker friends — Welcome!\nToday we decided to dedicate some time to walk you through the 2.0 changes using practical & common scenarios.","custom_excerpt":"Docker friends — Welcome!\nToday we decided to dedicate some time to walk you through the 2.0 changes using practical & common scenarios.","visibility":"public","created_at_pretty":"20 November, 2019","published_at_pretty":"October 1, 2019","updated_at_pretty":"21 May, 2020","created_at":"2019-11-20T14:41:50.000+00:00","published_at":"2019-10-01T14:37:00.000+00:00","updated_at":"2020-05-21T22:02:15.000+00:00","meta_title":"Traefik 2.0 & Docker 101","meta_description":"Docker friends — Welcome!\nToday we decided to dedicate some time to walk you through the 2.0 changes using practical & common scenarios.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},{"name":"Ludovic Fernandez","slug":"ldez","bio":null,"profile_image":"//www.gravatar.com/avatar/9185f906b875328134ba0d4a6bb6085a?s=250&d=mm&r=x","twitter":"@ludnadez","facebook":null,"website":"https://ldez.github.io"}],"primary_author":{"name":"Gerald Croes","slug":"gerald","bio":null,"profile_image":"https://containous.ghost.io/content/images/2019/12/ghost.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Docker","slug":"docker","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Tips & Tricks the Documentation Doesn’t Tell You\n\nDocker friends — Welcome!\n\nToday we decided to dedicate some time to walk you through the 2.0 changes using\npractical & common scenarios. Hopefully, after having read this article, you’ll\nunderstand every concept there is to know, and you’ll keep learning by yourself,\ndiscovering tips & tricks to share with the community.\n\nBefore we go further, I’ll assume for this article that you already have a\ndocker setup using Traefik 2.0. Since I like to use docker-compose files for\nbasic demonstrations, I’ll use the following base compose file:\n\nversion: \"3.3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker=true\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n  \n  my-app:\n    image: containous/whoami:v1.3.0\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-01.yml]\nNothing fancy, we declare an entrypoint\n[https://docs.traefik.io/v2.0/routing/entrypoints/] (web for port 80), enable\nthe docker provider [https://docs.traefik.io/v2.0/providers/overview/], attach\nour traefik container to the needed ports and make sure we can listen to Docker\nthought the socket. We also have an application my-app we’ll expose later.\n\nSide Note: You can get the examples from our repository if you want to play with\nthem. (Yes, we know how dangerous it can be to copy/paste some YAML :-))\n\nNow that we’re all set, let’s start!\n\n\n--------------------------------------------------------------------------------\n\nLet’s Enable the Dashboard!\nBecause we all enjoy seeing what we’re doing, we’ll first enable Traefik’s\nDashboard in development mode, and all we need to do is add one argument to the\nTraefik command itself.\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker\n      - --api.insecure # Don't do that in production\n#   ...\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-02.yml]\nThere we are! By adding --api.insecure we’ve enabled the API along with the\ndashboard. But beware, in this first step, we’ve enabled the insecure\ndevelopment mode — Don’t do that in production!\n\nOf course, we’ll see at the end of the article how to enable a secured\ndashboard, but for now, you can enjoy and see it on localhost:8080/dashboard/\n\n\n--------------------------------------------------------------------------------\n\nMy Application Handles Requests on \"example.com\"\nIf you only need to route requests to my-app based on the host, then attach one \nlabel to your container — That’s it!\n\nservices:\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-03.yml]\nQuick Explanation\nIn English, this label means, “Hey Traefik! (traefik.) This HTTP router (\nhttp.routers.) I call my-app (my-app.) must catch requests to example.com (\nrule=Host(`example.com`)).”\n\nMore Details (Optional Read)\nTraefik 2.0 introduces the notion of Routers\n[https://docs.traefik.io/v2.0/routing/routers/]. Routers define the routes that\nconnect your services to the requests, and you use rules\n[https://docs.traefik.io/v2.0/routing/routers/#rule] to define what makes the\nconnection. This is the reason why you see routers in the label, as well as rule\n.\n\nTraefik 2.0 also introduces TCP support (in addition to the existing HTTP\nsupport). Since Traefik supports both protocols, it wants to know what kind of\nprotocol you’re interested in, which explains the http keyword in the label.\n\n\n--------------------------------------------------------------------------------\n\nMy Application Listens on a Specific Port\nWhat happens if your application listens on a different port than the default \n:80? Let’s say it listens on :8082. We’ll build on the previous example and add\n(again) one label.\n\nservices:\n  my-service:\n    image: containous/whoami:v1.3.0\n    command:\n      - --port=8082 # Our service listens on 8082\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.services.my-app.loadbalancer.server.port=8082\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-04.yml]\nQuick Explanation\nIn English, this label means, “Hey Traefik! (traefik.) This HTTP service (\nhttp.services.) I call my-app (my-app.) will load balance incoming requests\nbetween servers (.server) that listen on port 8082 (.port=8082).”\n\nMore Details (Optional Read)\nTraefik 2.0 introduces the notion of Services\n[https://docs.traefik.io/v2.0/routing/services/]. Services are the targets for\nthe routes. They usually define how to reach your programs in your cluster.\nServices can have different types. The most common one is the LoadBalancer\n[https://docs.traefik.io/v2.0/routing/services/#servers-load-balancer] type. The\nLoadBalancer type is a round robin between all the available instances (called \nserver). By default, Traefik considers that your program is available on the\nport exposed by the Dockerfile of your program, but you can change that by\nexplicitly defining the port.\n\nSince we specify only one service in the example, there is no need to define the\ntarget of the previously defined router explicitly.\n\nSide Note: The—-port=8082 command is specific to our whoami application and has\nnothing to do with Traefik. It tells whoami to start listening on 8082, so we\ncan simulate our use case.\n\n\n--------------------------------------------------------------------------------\n\nI Need BasicAuth (Or Any Piece of Middleware)\nOnce Traefik has found a match for the request, it can process it before\nforwarding it to the service. In the following example, we’ll add a BasicAuth\nmechanism for our route. This is done with two additional labels.\n\nservices:\n  my-svc:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.routers.my-app.middlewares=auth\n      - traefik.http.middlewares.auth.basicauth.users=test:xxx\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-05.yml]\nQuick Explanation\nIn English, the first label means, “Hey Traefik! (traefik.) My HTTP router I\ncalled my-app, remember? (http.routers.my-app.) I’d like to attach to it a piece\nof middleware named auth (.middlewares=auth).”\n\nOf course, since we haven’t yet declared the auth middleware, we need to be a\nbit more explicit, so the second label means, “Hey Traefik! (traefik.) Let’s\ntalk about an HTTP middleware (http.middlewares.) I call auth (auth.). It’s a\nBasicAuth middleware (basicauth.). Since you probably need users to know who can\ndo what, here is the users list (.users=test:xxx).”\n\nMore Details (Optional Read)\nTraefik 2.0 introduces the notion of Middleware\n[https://docs.traefik.io/v2.0/middlewares/overview/]. Middleware is a way to\ndefine behaviors and tweak the incoming request before forwarding it to the\nservice. Since they act before the request is forwarded, they are attached to\nRouters. You can define middleware and reuse them as many times as you like\n(this is why you need to name them, in the example auth). There are many kinds\nof middleware, and BasicAuth\n[https://docs.traefik.io/v2.0/middlewares/basicauth/] is one of them. Each\nmiddleware has a different set of parameters to define their behaviors (in the\nexample, we define the users list).\n\n\n--------------------------------------------------------------------------------\n\nI Need HTTPS\nWith Traefik, enabling automatic certificate generation is a matter of 4 lines\nof configuration, and enabling HTTPS on your routes is a matter of 2 lines of\nconfiguration.\n\n1 — Enabling Automatic Certificate Generation\n\nWe’ll introduce a little tip here — Since Traefik is launched as a container,\nwe’ll attach labels to it for common configuration options. (What is specific to\nother containers will, of course, stay on other containers, we’re not messy\npeople!)\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.websecure.address=:443\n      # ...\n      - --certificatesresolvers.le.acme.email=my@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n      # ...\n    ports:\n      # ...\n      - \"443:443\"\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml]\nQuick Explanation\nWe’ve seen already the first command line given to Traefik. In English, it\nmeans, “I have an entrypoint (entrypoints.) I call websecure (websecure.) that\nuses port 443 (.address=:443).” And since Traefik now listens to 443, we need to\ntell Docker that it should bind external port 443 to our service’s port 443 (\n\"443:443\").\n\nNow, the others are a bit trickier, but nothing crazy if you’ve had time to\ndrink your coffee/tea. The first says, “I’d like a mechanism to generate\ncertificates for me (certificatesresolvers.) that I’ll call le (le.). It’s an\nacme resolver (acme.), my account there is my@email.com (email=my@email.com).”\n(Disclaimer: not my real email address, don’t try it.)\n\nThe second says, “This mechanism named le I told you about, the acme stuff (\ncertificatesresolvers.le.acme.), it will save the certificates in the file \n/acme.json (storage=/acme.json).”\n\nAnd the third is our inner geek speaking, “Since this le mechanism I defined\nbefore (certificatesresolvers.le.acme.) supports different challenges for\ncertificate generation, I’ll choose … the TLS challenge (tlschallenge=true).”\n\nThat was a bit more text than usual, but here we are: we have a fully functional\nmechanism to generate/renew certificates for us!\n\nMore Details (Optional Read)\nTraefik 2.0 introduces the notion of CertificatesResolvers\n[https://docs.traefik.io/v2.0/https/acme/]. Certificates resolvers are a system\nthat handles certificate generation/renewal/disposal for you. They detect the\nhosts you’ve defined for your routers and get the matching certificates.\n\nCurrently, certificates resolvers leverage Let’s Encrypt\n[https://letsencrypt.org/] to get certificates, and expect you to configure your\naccount (which is basically your email address). In order to prove Let’s Encrypt\nthat you’re the owner of the domains you’ll request certificates for, LE will\ngive Traefik a challenge. There are multiple possible challenges, and we chose\nin the example the TLSChallenge. In the documentation, you’ll find a description\nfor each other challenges\n[https://docs.traefik.io/v2.0/https/acme/#the-different-acme-challenges] (\ndnsChallenge [https://docs.traefik.io/v2.0/https/acme/#dnschallenge] and \nhttpChallenge [https://docs.traefik.io/v2.0/https/acme/#httpchallenge]).\n\nKnow that advanced users can define multiple CertificatesResolvers using\ndifferent challenges, and that they can use them to generate wildcards … but\nthat’s a story we’ll talk about later :-)\n\n2 — Enabling Automatic Certificate Generation\n\nNow that we have a mechanism to generate certificates for us, let’s leverage it\nto enable HTTPS on our route. We’ll only need two labels!\n\nmy-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.routers.my-app.middlewares=auth\n      - traefik.http.routers.my-app.tls.certresolver=le\n      - traefik.http.routers.my-app.entrypoints=websecure\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml]\nQuick Explanation\nIn English, the first label means, “Hey Traefik! (traefik.) My HTTP router (\nhttp.routers.) I call my-app (my-app.) uses TLS and the CertificateResolver\nnamed le (certresolver=le).”\n\nAnd the second says, “Traefik! (traefik.) this router, you know? (\nhttp.routers.my-app) It will only listen to the entrypoint I call websecure (\nentrypoints=websecure).”\n\nMore Details (Optional Read)\nTraefik 2.0 allows you to define TLS termination directly on your routers\n[https://docs.traefik.io/v2.0/routing/routers/#tls]!\n\nAlso, by default, routers listen to every known entrypoints. In our example, we\nwanted Traefik to limit the use of https on port 443, which is the reason why we\ntold the router to listen only to websecure (defined to port 443 with \nentrypoints.websecure.address=:443)\n\n\n--------------------------------------------------------------------------------\n\nI Want HTTPS Redirection!\nNow that we have HTTPS routes, let’s redirect every non-https requests to their\nhttps equivalent. For that, we’ll reuse the previous trick and add just 4 labels \nto declare a redirect middleware and a catch-all router for unsecured routes.\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    # ...\n    labels:\n      # ...\n      \n      # middleware redirect\n      - \"traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https\"\n      \n      # global redirect to https\n      - \"traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\"\n      - \"traefik.http.routers.redirs.entrypoints=web\"\n      - \"traefik.http.routers.redirs.middlewares=redirect-to-https\"\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-07.yml]\nQuick Explanation\nIn English, the first label means, “Hey Traefik! (traefik.) let’s declare an\nHTTP middleware (http.middlewares.) we’ll call redirect-to-https (\nredirect-to-https.). It’s a RedirectScheme\n[https://docs.traefik.io/v2.0/middlewares/redirectscheme/] middleware (\nredirectscheme.) that will force the scheme to https (scheme=https).”\n\nThen, let’s see the router part, “Hey Traefik! (you know the drill) (traefik.) I\nhave an HTTP router (http.routers.) I’ll call redirs (redirs.) that will match\nrequests on any host (rule=hostregexp(`{host:.+}`)) Yes sir! I’m insane and will\ncatch everything, that’s how greedy I am.”\n\nThen, we add, “Hey Traefik! (traefik.) I was kidding … the redirs HTTP router (\nhttp.routers.redirs.) won’t catch everything but just requests on port 80 (\nentrypoints=web).”\n\nFinally, we’ll add the redirect middleware to the router. “Traefik? (traefik.)\nOn the redirs HTTP router (http.routers.redirs.) we’ll add the redirect-to-https \nmiddleware (middlewares=redirect-to-https).”\n\nMore Details (Optional Read)\nBy now, we’ve seen everything there is to know, so no additional details to\nlearn about :-)\n\n\n--------------------------------------------------------------------------------\n\nCompiling Everything for a Secured Dashboard!\nNow that we’ve manipulated every important notion (Entrypoints, Routers,\nMiddleware, Services, CertificatesResolvers & TLS), we can combine them to\nobtain a secured Dashboard!\n\nversion: \"3.3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --entrypoints.websecure.address=:443\n      - --providers.docker\n      - --api\n      - --certificatesresolvers.le.acme.email=your@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n      - \"./acme.json:/acme.json\"\n    labels:\n      # Dashboard\n      - \"traefik.http.routers.traefik.rule=Host(`api.example.com`)\"\n      - \"traefik.http.routers.traefik.service=api@internal\"\n      - \"traefik.http.routers.traefik.middlewares=admin\"\n      - \"traefik.http.routers.traefik.tls.certresolver=le\"\n      - \"traefik.http.routers.traefik.entrypoints=websecure\"\n      - \"traefik.http.middlewares.admin.basicauth.users=admin:xxx\"\n\n      # ...\n\nFull compose file available there.\n[https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-09.yml]\nQuick Explanation\nFirst, we remove the insecure api (specifying --api instead of --api.insecure).\n\nThen, we tell Traefik (traefik.) to add an HTTP router called traefik (\nhttp.routers.traefik.) catching requests on api.example.com (\nrule=Host(`api.example.com`)).\n\nThis router (traefik.http.routers.traefik.) will forward requests to a service\ncalled api@internal (service=api@internal), uses a middleware named admin (\nmiddlewares=admin), and uses tls (tls=true) with a certresolver called le (\ntls.certresolver=le).\n\nFinally, we declare the admin middleware (\ntraefik.http.middlewares.admin.basicauth.users=admin:xxx).\n\nMore Details (Optional Read)\nThe only subtle thing to know is that when you enable the api (in default mode,\nit creates an internal service called api@internal (It’s then up to you to\nproperly secure it).\n\n\n--------------------------------------------------------------------------------\n\nQuestions? Where to Go Next?\nHopefully, we’ve gone through important questions you’ll have when dealing with\nTraefik 2.0 in a Docker setup, and we hope this article brings many answers.\n\nIf you want to keep the conversation going, let us know on the community forum\n[https://community.containo.us/c/traefik/traefik-v2]!\n\nIn the meantime — Happy Traefik!","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">Tips & Tricks the Documentation Doesn’t Tell You</p><!--kg-card-end: html--><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-109.png\" class=\"kg-image\"></figure><p>Docker friends — Welcome!</p><p>Today we decided to dedicate some time to walk you through the 2.0 changes using practical &amp; common scenarios. Hopefully, after having read this article, you’ll understand every concept there is to know, and you’ll keep learning by yourself, discovering tips &amp; tricks to share with the community.</p><p>Before we go further, I’ll assume for this article that you already have a docker setup using Traefik 2.0. Since I like to use docker-compose files for basic demonstrations, I’ll use the following base compose file:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">version: \"3.3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker=true\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n  \n  my-app:\n    image: containous/whoami:v1.3.0</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-01.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><p><em><em>Nothing fancy, we declare an </em></em><a href=\"https://docs.traefik.io/v2.0/routing/entrypoints/\" rel=\"noopener\"><em><em>entrypoint</em></em></a><em><em> (</em></em><code><em><em>web</em></em></code><em><em> for port </em></em><code><em><em>80</em></em></code><em><em>), enable the docker </em></em><a href=\"https://docs.traefik.io/v2.0/providers/overview/\" rel=\"noopener\"><em><em>provider</em></em></a><em><em>, attach our traefik container to the needed ports and make sure we can listen to Docker thought the socket. We also have an application </em></em><code><em><em>my-app</em></em></code><em><em> we’ll expose later.</em></em></p><p><strong><strong>Side Note</strong></strong>: You can get the examples from our repository if you want to play with them. (Yes, we know how dangerous it can be to copy/paste some YAML :-))</p><p>Now that we’re all set, let’s start!</p><hr><h2 id=\"let-s-enable-the-dashboard-\">Let’s Enable the Dashboard!</h2><p>Because we all enjoy seeing what we’re doing, we’ll first enable Traefik’s Dashboard in <em><em>development</em></em> mode, and all we need to do is add <em><em>one</em></em> argument to the Traefik command itself.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --providers.docker\n      - --api.insecure # Don't do that in production\n#   ...</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-02.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><p>There we are! By adding <code>--api.insecure</code> we’ve enabled the API along with the dashboard. But beware, in this first step, we’ve enabled the insecure development mode — Don’t do that in production!</p><p>Of course, we’ll see at the end of the article how to enable a secured dashboard, but for now, you can enjoy and see it on localhost:8080/dashboard/</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-11.png\" class=\"kg-image\"></figure><hr><h2 id=\"my-application-handles-requests-on-example-com\">My Application Handles Requests on \"example.com\"</h2><p>If you only need to route requests to <code>my-app</code> based on the host, then attach <em><em>one</em></em> label to your container — That’s it!</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-03.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation\">Quick Explanation</h3><p>In English, this label means, “Hey Traefik! (<code>traefik.</code>) This HTTP router (<code>http.routers.</code>) I call my-app (<code>my-app.</code>) must catch requests to example.com (<code>rule=Host(`example.com`)</code>).”</p><h3 id=\"more-details-optional-read-\">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href=\"https://docs.traefik.io/v2.0/routing/routers/\" rel=\"noopener\">Routers</a>. Routers define the routes that connect your services to the requests, and you use <a href=\"https://docs.traefik.io/v2.0/routing/routers/#rule\" rel=\"noopener\">rules</a> to define <em><em>what</em></em> makes the connection. This is the reason why you see <code>routers</code> in the label, as well as <code>rule</code>.</p><p>Traefik 2.0 also introduces TCP support (in addition to the existing HTTP support). Since Traefik supports both protocols, it wants to know what kind of protocol you’re interested in, which explains the <code>http</code> keyword in the label.</p><hr><h2 id=\"my-application-listens-on-a-specific-port\">My Application Listens on a Specific Port</h2><p>What happens if your application listens on a different port than the default <code>:80</code>? Let’s say it listens on <code>:8082</code>. We’ll build on the previous example and add (again) <em><em>one</em></em> label.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  my-service:\n    image: containous/whoami:v1.3.0\n    command:\n      - --port=8082 # Our service listens on 8082\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.services.my-app.loadbalancer.server.port=8082</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-04.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-1\">Quick Explanation</h3><p>In English, this label means, “Hey Traefik! (<code>traefik.</code>) This HTTP service (<code>http.services.</code>) I call my-app (<code>my-app.</code>) will load balance incoming requests between servers (<code>.server</code>) that listen on port 8082 (<code>.port=8082</code>).”</p><h3 id=\"more-details-optional-read--1\">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href=\"https://docs.traefik.io/v2.0/routing/services/\" rel=\"noopener\">Services</a>. Services are the <em><em>targets</em></em> for the routes. They usually define how to reach your programs in your cluster. Services can have different types. The most common one is the <a href=\"https://docs.traefik.io/v2.0/routing/services/#servers-load-balancer\" rel=\"noopener\">LoadBalancer</a> type. The LoadBalancer type is a round robin between all the available instances (called <code>server</code>). By default, Traefik considers that your program is available on the port exposed by the Dockerfile of your program, but you can change that by explicitly defining the port.</p><p>Since we specify only one service in the example, there is no need to define the target of the previously defined router explicitly.</p><p>Side Note: The<code>—-port=8082</code> command is specific to our <code>whoami</code> application and has nothing to do with Traefik. It tells <code>whoami</code> to start listening on 8082, so we can simulate our use case.</p><hr><h2 id=\"i-need-basicauth-or-any-piece-of-middleware-\">I Need BasicAuth (Or Any Piece of Middleware)</h2><p>Once Traefik has found a match for the request, it can process it before forwarding it to the service. In the following example, we’ll add a BasicAuth mechanism for our route. This is done with <em><em>two</em></em> additional labels.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  my-svc:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.routers.my-app.middlewares=auth\n      - traefik.http.middlewares.auth.basicauth.users=test:xxx</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-05.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-2\">Quick Explanation</h3><p>In English, the first label means, “Hey Traefik! (<code>traefik.</code>) My HTTP router I called my-app, remember? (<code>http.routers.my-app.</code>) I’d like to attach to it a piece of middleware named auth (<code>.middlewares=auth</code>).”</p><p>Of course, since we haven’t yet declared the <code>auth</code> middleware, we need to be a bit more explicit, so the second label means, “Hey Traefik! (<code>traefik.</code>) Let’s talk about an HTTP middleware (<code>http.middlewares.</code>) I call auth (<code>auth.</code>). It’s a BasicAuth middleware (<code>basicauth.</code>). Since you probably need users to know who can do what, here is the users list (<code>.users=test:xxx</code>).”</p><h3 id=\"more-details-optional-read--2\">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href=\"https://docs.traefik.io/v2.0/middlewares/overview/\" rel=\"noopener\">Middleware</a>. Middleware is a way to define behaviors and tweak the incoming request before forwarding it to the service. Since they act before the request is forwarded, they are attached to Routers. You can define middleware and reuse them as many times as you like (this is why you need to name them, in the example <code>auth</code>). There are many kinds of middleware, and <a href=\"https://docs.traefik.io/v2.0/middlewares/basicauth/\" rel=\"noopener\">BasicAuth</a> is one of them. Each middleware has a different set of parameters to define their behaviors (in the example, we define the users list).</p><hr><h2 id=\"i-need-https\">I Need HTTPS</h2><p>With Traefik, enabling automatic certificate generation is a matter of <em><em>4 lines of configuration, </em></em>and enabling HTTPS on your routes is a matter of<em><em> 2 lines of configuration</em></em>.</p><p><strong><strong>1 — Enabling Automatic Certificate Generation</strong></strong></p><p>We’ll introduce a little tip here — Since Traefik is launched as a container, we’ll attach labels to it for common configuration options. (What is specific to other containers will, of course, stay on other containers, we’re not messy people!)</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.websecure.address=:443\n      # ...\n      - --certificatesresolvers.le.acme.email=my@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n      # ...\n    ports:\n      # ...\n      - \"443:443\"</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-3\">Quick Explanation</h3><p>We’ve seen already the first command line given to Traefik. In English, it means, “I have an entrypoint (<code>entrypoints.</code>) I call websecure (<code>websecure.</code>) that uses port 443 (<code>.address=:443</code>).” And since Traefik now listens to 443, we need to tell Docker that it should bind external port 443 to our service’s port 443 (<code>\"443:443\"</code>).</p><p>Now, the others are a bit trickier, but nothing crazy if you’ve had time to drink your coffee/tea. The first says, “I’d like a mechanism to generate certificates for me (<code>certificatesresolvers.</code>) that I’ll call le (<code>le.</code>). It’s an acme resolver (<code>acme.</code>), my account there is <code>my@email.com</code> (<code>email=my@email.com</code>).” (Disclaimer: not my real email address, don’t try it.)</p><p>The second says, “This mechanism named <code>le</code> I told you about, the acme stuff (<code>certificatesresolvers.le.acme.</code>), it will save the certificates in the file <code>/acme.json </code>(<code>storage=/acme.json</code>).”</p><p>And the third is our inner geek speaking, “Since this <code>le</code> mechanism I defined before (<code>certificatesresolvers.le.acme.</code>) supports different challenges for certificate generation, I’ll choose … the TLS challenge (<code>tlschallenge=true</code>).”</p><p>That was a bit more text than usual, but here we are: we have a fully functional mechanism to generate/renew certificates for us!</p><h3 id=\"more-details-optional-read--3\">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href=\"https://docs.traefik.io/v2.0/https/acme/\" rel=\"noopener\">CertificatesResolvers</a>. Certificates resolvers are a system that handles certificate generation/renewal/disposal for you. They detect the hosts you’ve defined for your routers and get the matching certificates.</p><p>Currently, certificates resolvers leverage <a href=\"https://letsencrypt.org/\" rel=\"noopener\">Let’s Encrypt</a> to get certificates, and expect you to configure your account (which is basically your email address). In order to prove Let’s Encrypt that you’re the owner of the domains you’ll request certificates for, LE will give Traefik a challenge. There are multiple possible challenges, and we chose in the example the TLSChallenge. In the documentation, you’ll find a description for each <a href=\"https://docs.traefik.io/v2.0/https/acme/#the-different-acme-challenges\" rel=\"noopener\">other challenges</a> (<a href=\"https://docs.traefik.io/v2.0/https/acme/#dnschallenge\" rel=\"noopener\">dnsChallenge</a> and <a href=\"https://docs.traefik.io/v2.0/https/acme/#httpchallenge\" rel=\"noopener\">httpChallenge</a>).</p><p>Know that advanced users can define multiple CertificatesResolvers using different challenges, and that they can use them to generate wildcards … but that’s a story we’ll talk about later :-)</p><p><strong><strong>2 — Enabling Automatic Certificate Generation</strong></strong></p><p>Now that we have a mechanism to generate certificates for us, let’s leverage it to enable HTTPS on our route. We’ll only need <em><em>two</em></em> labels!</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">my-app:\n    image: containous/whoami:v1.3.0\n    labels:\n      - traefik.http.routers.my-app.rule=Host(`example.com`)\n      - traefik.http.routers.my-app.middlewares=auth\n      - traefik.http.routers.my-app.tls.certresolver=le\n      - traefik.http.routers.my-app.entrypoints=websecure</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-4\">Quick Explanation</h3><p>In English, the first label means, “Hey Traefik! (<code>traefik.</code>) My HTTP router (<code>http.routers.</code>) I call <em><em>my-app</em></em> (<code>my-app.</code>) uses TLS and the CertificateResolver named le (<code>certresolver=le</code>).”</p><p>And the second says, “Traefik! (<code>traefik.</code>) this router, you know? (<code>http.routers.my-app</code>) It will only listen to the <em><em>entrypoint</em></em> I call <em><em>websecure </em></em>(<code>entrypoints=websecure</code>).”</p><h3 id=\"more-details-optional-read--4\">More Details (Optional Read)</h3><p>Traefik 2.0 allows you to define TLS termination <a href=\"https://docs.traefik.io/v2.0/routing/routers/#tls\" rel=\"noopener\">directly on your routers</a>!</p><p>Also, by default, routers listen to every known <em><em>entrypoints</em></em>. In our example, we wanted Traefik to limit the use of https on port <code>443</code>, which is the reason why we told the router to listen only to <em><em>websecure</em></em> (defined to port 443 with <code>entrypoints.websecure.address=:443</code>)</p><hr><h2 id=\"i-want-https-redirection-\">I Want HTTPS Redirection!</h2><p>Now that we have HTTPS routes, let’s redirect every non-https requests to their https equivalent. For that, we’ll reuse the previous trick and add just <em><em>4 labels</em></em> to declare a redirect middleware and a catch-all router for unsecured routes.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">services:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    # ...\n    labels:\n      # ...\n      \n      # middleware redirect\n      - \"traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https\"\n      \n      # global redirect to https\n      - \"traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)\"\n      - \"traefik.http.routers.redirs.entrypoints=web\"\n      - \"traefik.http.routers.redirs.middlewares=redirect-to-https\"</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-07.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-5\">Quick Explanation</h3><p>In English, the first label means, “Hey Traefik! (<code>traefik.</code>) let’s declare an HTTP middleware (<code>http.middlewares.</code>) we’ll call redirect-to-https (<code>redirect-to-https.</code>). It’s a <a href=\"https://docs.traefik.io/v2.0/middlewares/redirectscheme/\" rel=\"noopener\">RedirectScheme</a> middleware (<code>redirectscheme.</code>) that will force the scheme to https (<code>scheme=https</code>).”</p><p>Then, let’s see the router part, “Hey Traefik! (you know the drill) (<code>traefik.</code>) I have an HTTP router (<code>http.routers.</code>) I’ll call redirs (<code>redirs.</code>) that will match requests on any host (<code>rule=hostregexp(`{host:.+}`)</code>) Yes sir! I’m insane and will catch everything, that’s how greedy I am.”</p><p>Then, we add, “Hey Traefik! (<code>traefik.</code>) I was kidding … the <em><em>redirs</em></em> HTTP router (<code>http.routers.redirs.</code>) won’t catch everything but just requests on port 80 (<code>entrypoints=web</code>).”</p><p>Finally, we’ll add the redirect middleware to the router. “Traefik? (<code>traefik.</code>) On the <em><em>redirs</em></em> HTTP router (<code>http.routers.redirs.</code>) we’ll add the <em><em>redirect-to-https</em></em> middleware (<code>middlewares=redirect-to-https</code>).”</p><h3 id=\"more-details-optional-read--5\">More Details (Optional Read)</h3><p>By now, we’ve seen everything there is to know, so no additional details to learn about :-)</p><hr><h2 id=\"compiling-everything-for-a-secured-dashboard-\">Compiling Everything for a Secured Dashboard!</h2><p>Now that we’ve manipulated every important notion (Entrypoints, Routers, Middleware, Services, CertificatesResolvers &amp; TLS), we can combine them to obtain a secured Dashboard!</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">version: \"3.3\"\n\nservices:\n  traefik:\n    image: \"traefik:v2.0.0\"\n    command:\n      - --entrypoints.web.address=:80\n      - --entrypoints.websecure.address=:443\n      - --providers.docker\n      - --api\n      - --certificatesresolvers.le.acme.email=your@email.com\n      - --certificatesresolvers.le.acme.storage=/acme.json\n      - --certificatesresolvers.le.acme.tlschallenge=true\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n      - \"./acme.json:/acme.json\"\n    labels:\n      # Dashboard\n      - \"traefik.http.routers.traefik.rule=Host(`api.example.com`)\"\n      - \"traefik.http.routers.traefik.service=api@internal\"\n      - \"traefik.http.routers.traefik.middlewares=admin\"\n      - \"traefik.http.routers.traefik.tls.certresolver=le\"\n      - \"traefik.http.routers.traefik.entrypoints=websecure\"\n      - \"traefik.http.middlewares.admin.basicauth.users=admin:xxx\"\n\n      # ...</code></pre><figcaption><a href=\"https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-09.yml\" rel=\"noopener\">Full compose file available there.</a></figcaption></figure><h3 id=\"quick-explanation-6\">Quick Explanation</h3><p>First, we remove the insecure api (specifying <code>--api</code> instead of <code>--api.insecure</code>).</p><p>Then, we tell Traefik (<code>traefik.</code>) to add an HTTP router called traefik (<code>http.routers.traefik.</code>) catching requests on <em><em>api.example.com</em></em> (<code>rule=Host(`api.example.com`)</code>).</p><p>This router (<code>traefik.http.routers.traefik.</code>) will forward requests to a service called api@internal (<code>service=api@internal</code>), uses a middleware named admin (<code>middlewares=admin</code>), and uses tls (<code>tls=true</code>) with a certresolver called <em><em>le</em></em> (<code>tls.certresolver=le</code>).</p><p>Finally, we declare the admin middleware (<code>traefik.http.middlewares.admin.basicauth.users=admin:xxx</code>).</p><h3 id=\"more-details-optional-read--6\">More Details (Optional Read)</h3><p>The only subtle thing to know is that when you enable the api (in default mode, it creates an internal service called <code>api@internal</code> (It’s then up to you to properly secure it).</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-12.png\" class=\"kg-image\"></figure><hr><h2 id=\"questions-where-to-go-next\">Questions? Where to Go Next?</h2><p>Hopefully, we’ve gone through important questions you’ll have when dealing with Traefik 2.0 in a Docker setup, and we hope this article brings many answers.</p><p>If you want to keep the conversation going, let us know on the <a href=\"https://community.containo.us/c/traefik/traefik-v2\" rel=\"noopener\">community forum</a>!</p><p>In the meantime — Happy Traefik!</p>","url":"https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/","canonical_url":null,"uuid":"56123f92-a17f-4afe-a461-a255ae2f2e1e","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd550aeec5ed3003878892e","reading_time":9}}]}},"pageContext":{"slug":"ldez","limit":9,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}