{"componentChunkName":"component---src-templates-author-tsx","path":"/author/traefiklabs/page/12/","result":{"data":{"ghostAuthor":{"slug":"traefiklabs","name":"Traefik Labs","bio":null,"cover_image":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","location":null,"website":null,"twitter":null,"facebook":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5dd6a3a8b6de2b00381d3fbf","title":"Canary Releases with Traefik on GKE at HolidayCheck","slug":"canary-releases-with-traefik-on-gke-at-holidaycheck-d3c0928f1e02","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/canary.jpeg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/4c2bbcade8901a28828ba71afaa01bc5/619a6/canary.jpg","srcSet":"/static/4c2bbcade8901a28828ba71afaa01bc5/9dc27/canary.jpg 300w,\n/static/4c2bbcade8901a28828ba71afaa01bc5/4fe8c/canary.jpg 600w,\n/static/4c2bbcade8901a28828ba71afaa01bc5/619a6/canary.jpg 1068w","sizes":"(max-width: 1068px) 100vw, 1068px"}}},"excerpt":"In this post, I would like to introduce you into how Traefik helped us shape our cloud ecosystem at HolidayCheck...","custom_excerpt":"In this post, I would like to introduce you into how Traefik helped us shape our cloud ecosystem at HolidayCheck...","visibility":"public","created_at_pretty":"21 November, 2019","published_at_pretty":"May 21, 2019","updated_at_pretty":"22 May, 2020","created_at":"2019-11-21T14:48:08.000+00:00","published_at":"2019-05-21T14:47:00.000+00:00","updated_at":"2020-05-22T00:09:11.000+00:00","meta_title":"Canary Releases with Traefik on GKE at HolidayCheck","meta_description":"In this post, I would like to introduce you into how Traefik helped us shape our cloud ecosystem at HolidayCheck...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Case Studies","slug":"case-studies","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":"Learn from our users and customers why they choose Traefik and TraefikEE as a modern load balancer to manage network traffic.","meta_title":"Case studies | Containous","visibility":"public"}],"plaintext":"In this post, I would like to introduce you into how Traefik [/traefik/] helped\nus shape our cloud ecosystem at HolidayCheck\n[https://www.holidaycheckgroup.com/?lang=en]. In particular, I will give a brief\nin-depth introduction on how we implemented our canary release process for our\nmicroservice architecture with Traefik on Google Kubernetes Engine (GKE).\n\nAbout HolidayCheck\nHolidayCheck AG operates the biggest independent hotel review and booking portal\nin the German-speaking area. Our vision is to become the most Urlauber*-friendly\ncompany in the world! Our business portfolio has full package (flight, hotel,\ninsurance), hotel-only, and cruise offerings. In addition to that, we are a\nplatform which shares hotel reviews and pictures.\n\n * Urlauber: German term for holidaymaker, vacationer\n\nBackground\nOur teams strive to keep a high level of urgency for delivery. Therefore they\nmaintain their delivery pipelines themselves. An inquiry across our continuous\ndelivery (CD) pipelines showed that our teams use one of the following designs:\n\n * Production follows Staging: This is the most classic design among all. It\n   prevails in services with older staged workflows where changes are tested in\n   an isolated staging environment without real user traffic.\n * Production with Feature Flags: This workflow is in place for a constant high\n   pace of changes, especially with UX impact.\n * Production with A/B Tests: Another variation of the last design is to keep\n   multiple versions of the system online (e.g., A and B version) and split user\n   traffic manually by an operator.\n\nAlthough all three designs have a positive impact on our release quality\nalready, they are still very tedious to operate or widen the human error vector.\nTo minimize toil and human errors, we introduced another complementary release\nstrategy — canary releases.\n\nCanary Releases: Our Design\nIn short canary releases is an automation extension for our CD pipelines to\ncompare a new release (the canary group) against the previous version. Ideally,\nthe old deployment (the main group) is not touched by this operation. Instead, a\nnew deployment with the old configuration, the control group, is created at the\nsame time as the canary.\n\nOur design is based upon a strict set of decisions:\n\n 1. User traffic needs to be split across the main deployment and the other two\n    groups, whereas canary and control need an equal traffic share to keep\n    comparisons sane.\n 2. The CD pipeline needs a data source (e.g., metrics, logs, etc.) to evaluate\n    the canary soundness in comparison to the control instance. The decisions\n    can vary from shifting more traffic to the canary/control group, take canary\n    down or replace the current main with the canary.\n 3. The three instance groups need to operate independently from each other in\n    isolation.\n\nEnter Traefik Splitting\nOne of the significant benefits to using Traefik is that we can rely on building\non low-entry barrier features. Although our platform is hosted on GKE, we still\nneed to tailor features according to our use cases. Canary releases being one of\nthem requires us to split traffic across deployments.\n\nTraefik being our single proxy to route traffic to our deployments, has a\nbuilt-in feature to split traffic across deployment groups through a single\nIngress. Therefore a canary deployment can be accomplished with the following\nIngress specification:\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-service: 60%\n      my-service-canary: 20%\n      my-service-control: 20%\n  name: my-service\nspec:\n  rules:\n  - http:\n      paths:\n      - backend:\n          serviceName: my-service\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-service-canary\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-service-control\n          servicePort: 80\n        path: /\n\nOur Canary Workflow\nDespite that traffic splitting is a cornerstone to enable canary releases, it is\nnot sufficient. We still need to handle our canary deployments on GKE\nautomatically. Our CDs should be able to automatically make one of the following\ndecisions by comparing the canary with the control group:\n\n 1. Split more traffic from the main group to the canary and control groups.\n 2. Demote the canary and control groups because of an unacceptable error rate\n    and shift full traffic back to the main group.\n 3. Promote the canary group to become the new main group and remove the control\n    and old main groups.\n\nFurthermore, before traffic splitting we need to provide resources for our\ncanary and control deployments. On the one hand, this ensures that an\nappropriate replica count exists to handle the traffic. On the other hand,\ntraffic splitting can only happen from a third-party inside Kubernetes that can\nobserve the replica count of the canary and control deployments.\n\nIn short, the above CD decisions are accomplished by sending updates for the\ncanary and control deployments to the Kubernetes API server. A separate canary\ncontroller handles the rest.\n\nThe Canary Controller\nAfter sending the updates to Kubernetes the deployments of the canary and\ncontrol groups, as well as the Ingress object, will be reconciled by a canary\ncontroller. The controller is responsible for the following actions:\n\n * Scale the canary and control deployments:\n   The number of replicas for the canary and control deployments is based on the\n   traffic share\n\ncanaryReplicas = controlGroupReplicas =\n  ceil(appReplicas * canaryTrafficPercent / 100)\n\n * Enable the canary and control deployments: This means to identify the Ingress\n   object of the main deployment and add the service weights annotation for each\n   deployment.\n * Disable the canary and control deployments: In case of promotion/demotion of\n   the canary release, the controller removes the service weights from the\n   Ingress object.\n\nA Canary Release from Kubernetes Perspective\nIf you are using Kubernetes, a simple deployment can contain multiple\nannotations to express use case specific information. Thus, our CD pipelines\ncommunicate each action by updating the annotations of the required deployment\nspecifications. These annotations declare the requested state of our canary\nrelease, which in turn is reconciled by the canary controller.\n\nOur canary release implementation requires the following annotations to express\nthe state, as well as the Traefik service weight per deployment:\n\n * holidaycheck.com/canary-active: bool: Represents the current state of the\n   canary release in each canary and control deployment.\n * holidaycheck.com/canary-percent: float: Represents the service weight which\n   should be applied for each the canary and control deployment.\n\nLet’s say we have a service my-service at version v1.6:\n\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: my-service\n  namespace: my-namespace\nspec:\n  replicas: 10\n  template:\n      name: my-service\n    spec:\n      automountServiceAccountToken: false\n      containers:\n      - image: our-registry/my-service:v1.6\n        imagePullPolicy: IfNotPresent\n\nWe want to evaluate a newer version v1.7 of this service with a canary release,\ne.g.:\n\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  annotations:\n    holidaycheck.com/canary-active: \"false\"\n    holidaycheck.com/canary-percent: \"20.0\"\n  name: my-service-canary\n  namespace: my-namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: my-service-canary\n    spec:\n      containers:\n      - image: our-registry/my-service:v1.7\n\nAccordingly, a control deployment will be an almost identical copy of the main\ndeployment specification. The only addition here is the extra annotations, e.g.:\n\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  annotations:\n    holidaycheck.com/canary-active: \"false\"\n    holidaycheck.com/canary-percent: \"20.0\"\n  name: my-service-control\n  namespace: my-namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: my-service-control\n    spec:\n      containers:\n      - image: our-registry/my-service:v1.6\n\nNext, the canary controller will reconcile the state of our three deployments to\nadhere to our replica count specification. Therefore splitting 20% of our\ntraffic from a deployment with ten replicas results in canary and control\ndeployments with two replicas each.\n\nFinally, the controller will translate the canary annotation canary-percent for\neach deployment to the appropriate Traefik service weights annotation in the\nIngress object. Also the canary-active will be set to true for the canary and\ncontrol deployments:\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-service: 60%\n      my-service-control: 20%\n      my-service-canary: 20%\n  name: my-service\n\nNote: To minimize toil creating the above specifications, our teams use a small\nCLI tool that generates and applies those for them to Kubernetes.\n\nChallenges\nOne challenge remains, namely how to separate Traefik backend metrics per\nendpoint. The current Traefik v1.7implementation does not provide a distinction\nof metrics per backend endpoint. However, you can circumvent this issue by\nrelying on application level metrics, which can be separated by custom labels\nfor the canary, control, and main group accordingly.\n\nConclusion\nI hope this article has been helpful and will help you to tailor your canary\nrelease workflow for your platform based on Traefik’s excellent features.\n\nIn summary, we met our main goal to build a slim solution for canary releases\nwith Traefik without introducing the complexity of a full service mesh.\n\nThe above implementation is based on:\n\n * Traefik v1.7\n * Kubernetes v1.12","html":"<p>In this post, I would like to introduce you into how <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> helped us shape our cloud ecosystem at <a href=\"https://www.holidaycheckgroup.com/?lang=en\" rel=\"noopener\">HolidayCheck</a>. In particular, I will give a brief in-depth introduction on how we implemented our canary release process for our microservice architecture with Traefik on Google Kubernetes Engine (GKE).</p><h2 id=\"about-holidaycheck\">About HolidayCheck</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-22.png\" class=\"kg-image\"></figure><p>HolidayCheck AG operates the biggest independent hotel review and booking portal in the German-speaking area. Our vision is to become the most Urlauber*-friendly company in the world! Our business portfolio has full package (flight, hotel, insurance), hotel-only, and cruise offerings. In addition to that, we are a platform which shares hotel reviews and pictures.</p><ul><li><em><em>Urlauber: German term for holidaymaker, vacationer</em></em></li></ul><h2 id=\"background\">Background</h2><p>Our teams strive to keep a high level of urgency for delivery. Therefore they maintain their delivery pipelines themselves. An inquiry across our continuous delivery (CD) pipelines showed that our teams use one of the following designs:</p><ul><li><em><em>Production follows Staging</em></em>: This is the most classic design among all. It prevails in services with older staged workflows where changes are tested in an isolated staging environment without real user traffic.</li><li><em><em>Production with Feature Flags</em></em>: This workflow is in place for a constant high pace of changes, especially with UX impact.</li><li><em><em>Production with A/B Tests</em></em>: Another variation of the last design is to keep multiple versions of the system online (e.g., A and B version) and split user traffic manually by an operator.</li></ul><p>Although all three designs have a positive impact on our release quality already, they are still very tedious to operate or widen the human error vector. To minimize toil and human errors, we introduced another complementary release strategy — canary releases.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-23.png\" class=\"kg-image\"></figure><h2 id=\"canary-releases-our-design\">Canary Releases: Our Design</h2><p>In short canary releases is an automation extension for our CD pipelines to compare a new release (<em><em>the canary group</em></em>) against the previous version. Ideally, the old deployment (<em><em>the main group</em></em>) is not touched by this operation. Instead, a new deployment with the old configuration, <em><em>the control group</em></em>, is created at the same time as the canary.</p><p>Our design is based upon a strict set of decisions:</p><ol><li>User traffic needs to be split across the main deployment and the other two groups, whereas canary and control need an equal traffic share to keep comparisons sane.</li><li>The CD pipeline needs a data source (e.g., metrics, logs, etc.) to evaluate the canary soundness in comparison to the control instance. The decisions can vary from shifting more traffic to the canary/control group, take canary down or replace the current main with the canary.</li><li>The three instance groups need to operate independently from each other in isolation.</li></ol><h2 id=\"enter-traefik-splitting\">Enter Traefik Splitting</h2><p>One of the significant benefits to using Traefik is that we can rely on building on low-entry barrier features. Although our platform is hosted on GKE, we still need to tailor features according to our use cases. Canary releases being one of them requires us to split traffic across deployments.</p><p>Traefik being our single proxy to route traffic to our deployments, has a built-in feature to split traffic across deployment groups through a single Ingress. Therefore a canary deployment can be accomplished with the following Ingress specification:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-service: 60%\n      my-service-canary: 20%\n      my-service-control: 20%\n  name: my-service\nspec:\n  rules:\n  - http:\n      paths:\n      - backend:\n          serviceName: my-service\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-service-canary\n          servicePort: 80\n        path: /\n      - backend:\n          serviceName: my-service-control\n          servicePort: 80\n        path: /</code></pre><h2 id=\"our-canary-workflow\">Our Canary Workflow</h2><p>Despite that traffic splitting is a cornerstone to enable canary releases, it is not sufficient. We still need to handle our canary deployments on GKE automatically. Our CDs should be able to automatically make one of the following decisions by comparing the canary with the control group:</p><ol><li>Split more traffic from the main group to the canary and control groups.</li><li>Demote the canary and control groups because of an unacceptable error rate and shift full traffic back to the main group.</li><li>Promote the canary group to become the new main group and remove the control and old main groups.</li></ol><p>Furthermore, before traffic splitting we need to provide resources for our canary and control deployments. On the one hand, this ensures that an appropriate replica count exists to handle the traffic. On the other hand, traffic splitting can only happen from a third-party inside Kubernetes that can observe the replica count of the canary and control deployments.</p><p>In short, the above CD decisions are accomplished by sending updates for the canary and control deployments to the Kubernetes API server. A separate canary controller handles the rest.</p><h2 id=\"the-canary-controller\">The Canary Controller</h2><p>After sending the updates to Kubernetes the deployments of the canary and control groups, as well as the Ingress object, will be reconciled by a canary controller. The controller is responsible for the following actions:</p><ul><li><em><em>Scale the canary and control deployments</em></em>:<br>The number of replicas for the canary and control deployments is based on the traffic share</li></ul><pre><code>canaryReplicas = controlGroupReplicas =\n  ceil(appReplicas * canaryTrafficPercent / 100)</code></pre><ul><li><em><em>Enable the canary and control deployments:</em></em> This means to identify the Ingress object of the main deployment and add the service weights annotation for each deployment.</li><li><em><em>Disable the canary and control deployments:</em></em> In case of promotion/demotion of the canary release, the controller removes the service weights from the Ingress object.</li></ul><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-24.png\" class=\"kg-image\"></figure><h2 id=\"a-canary-release-from-kubernetes-perspective\">A Canary Release from Kubernetes Perspective</h2><p>If you are using Kubernetes, a simple deployment can contain multiple annotations to express use case specific information. Thus, our CD pipelines communicate each action by updating the annotations of the required deployment specifications. These annotations declare the requested state of our canary release, which in turn is reconciled by the canary controller.</p><p>Our canary release implementation requires the following annotations to express the state, as well as the Traefik service weight per deployment:</p><ul><li><code>holidaycheck.com/canary-active: bool</code>: Represents the current state of the canary release in each canary and control deployment.</li><li><code>holidaycheck.com/canary-percent: float</code>: Represents the service weight which should be applied for each the canary and control deployment.</li></ul><p>Let’s say we have a service <code>my-service</code> at version <code>v1.6</code>:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: my-service\n  namespace: my-namespace\nspec:\n  replicas: 10\n  template:\n      name: my-service\n    spec:\n      automountServiceAccountToken: false\n      containers:\n      - image: our-registry/my-service:v1.6\n        imagePullPolicy: IfNotPresent</code></pre><p>We want to evaluate a newer version <code>v1.7</code> of this service with a canary release, e.g.:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  annotations:\n    holidaycheck.com/canary-active: \"false\"\n    holidaycheck.com/canary-percent: \"20.0\"\n  name: my-service-canary\n  namespace: my-namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: my-service-canary\n    spec:\n      containers:\n      - image: our-registry/my-service:v1.7</code></pre><p>Accordingly, a control deployment will be an almost identical copy of the main deployment specification. The only addition here is the extra annotations, e.g.:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  annotations:\n    holidaycheck.com/canary-active: \"false\"\n    holidaycheck.com/canary-percent: \"20.0\"\n  name: my-service-control\n  namespace: my-namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: my-service-control\n    spec:\n      containers:\n      - image: our-registry/my-service:v1.6</code></pre><p>Next, the canary controller will reconcile the state of our three deployments to adhere to our replica count specification. Therefore splitting 20% of our traffic from a deployment with ten replicas results in canary and control deployments with two replicas each.</p><p>Finally, the controller will translate the canary annotation <code>canary-percent</code> for each deployment to the appropriate Traefik service weights annotation in the Ingress object. Also the <code>canary-active</code> will be set to <code>true</code> for the canary and control deployments:</p><pre><code class=\"language-yaml\">apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  annotations:\n    traefik.ingress.kubernetes.io/service-weights: |\n      my-service: 60%\n      my-service-control: 20%\n      my-service-canary: 20%\n  name: my-service</code></pre><p><em><em>Note: To minimize toil creating the above specifications, our teams use a small CLI tool that generates and applies those for them to Kubernetes.</em></em></p><h2 id=\"challenges\">Challenges</h2><p>One challenge remains, namely how to separate Traefik backend metrics per endpoint. The current Traefik <code>v1.7</code>implementation does not provide a distinction of metrics per backend endpoint. However, you can circumvent this issue by relying on application level metrics, which can be separated by custom labels for the canary, control, and main group accordingly.</p><h2 id=\"conclusion\">Conclusion</h2><p>I hope this article has been helpful and will help you to tailor your canary release workflow for your platform based on Traefik’s excellent features.</p><p>In summary, we met our main goal to build a slim solution for canary releases with Traefik without introducing the complexity of a full service mesh.</p><p>The above implementation is based on:</p><ul><li>Traefik v1.7</li><li>Kubernetes v1.12</li></ul>","url":"https://containous.ghost.io/blog/canary-releases-with-traefik-on-gke-at-holidaycheck-d3c0928f1e02/","canonical_url":null,"uuid":"f2a7086b-dc30-4f82-8a20-d90968a1285f","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd6a3a8b6de2b00381d3fbf","reading_time":6}},{"node":{"id":"Ghost__Post__5e3cb8f9cf5e3c00386baf42","title":"Scale your TLS-ized APIs with Kubernetes Ingress by Wandera","slug":"scale-your-tls-ized-apis-with-kubernetes-ingress-by-wandera","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/02/Wandera--1-.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/a7ca4aae03232f9ce7857d8e403eb797/b41c1/Wandera--1-.png","srcSet":"/static/a7ca4aae03232f9ce7857d8e403eb797/630fb/Wandera--1-.png 300w,\n/static/a7ca4aae03232f9ce7857d8e403eb797/2a4de/Wandera--1-.png 600w,\n/static/a7ca4aae03232f9ce7857d8e403eb797/b41c1/Wandera--1-.png 784w","sizes":"(max-width: 784px) 100vw, 784px"}}},"excerpt":"Jakub Coufal from Wondera demonstrates the benefits of configuring ExternalDNS, Cert-manager, Traefik and Prometheus with HPA from an operational perspective, while allowing developers to easily deploy ingresses without the hassle of cluster-specific configurations. ","custom_excerpt":"Jakub Coufal from Wondera demonstrates the benefits of configuring ExternalDNS, Cert-manager, Traefik and Prometheus with HPA from an operational perspective, while allowing developers to easily deploy ingresses without the hassle of cluster-specific configurations. ","visibility":"public","created_at_pretty":"07 February, 2020","published_at_pretty":"May 16, 2019","updated_at_pretty":"01 July, 2020","created_at":"2020-02-07T01:10:17.000+00:00","published_at":"2019-05-16T01:11:00.000+00:00","updated_at":"2020-07-01T23:00:56.000+00:00","meta_title":"Scale your TLS-ized APIs with Kubernetes Ingress by Wandera","meta_description":"Wandera demonstrates how to configure ExternalDNS, Cert-manager, Traefik and Prometheus with HPA from an operational perspective, with Kubernetes Ingress.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Resources","slug":"resources","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Resources","slug":"resources","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Online Meetup","slug":"online-meetup","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":"Online Meetup  | Containous","visibility":"public"}],"plaintext":"Jakub Coufal from Wandera demonstrates the benefits of configuring ExternalDNS,\nCert-manager, Traefik and Prometheus with HPA from an operational perspective,\nwhile allowing developers to easily deploy ingresses without the hassle of\ncluster-specific configurations.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">\nJakub Coufal from Wandera demonstrates the benefits of configuring ExternalDNS, Cert-manager, Traefik and Prometheus with HPA from an operational perspective, while allowing developers to easily deploy ingresses without the hassle of cluster-specific configurations. \n</p><!--kg-card-end: html--><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/NR4mxM8SP_k?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure>","url":"https://containous.ghost.io/resources/scale-your-tls-ized-apis-with-kubernetes-ingress-by-wandera/","canonical_url":null,"uuid":"51b88811-26c5-45f5-a6c7-8ac7bc06c416","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e3cb8f9cf5e3c00386baf42","reading_time":0}},{"node":{"id":"Ghost__Post__5e13b9067fd27c00383d0791","title":"Containous Announces the General Availability of Traefik Enterprise Edition","slug":"containous-announces-the-general-availability-of-traefik-enterprise-edition","featured":false,"feature_image":null,"featureImageSharp":null,"excerpt":"SAN FRANCISCO – April 18, 2019 – Containous Inc, the company behind the popular open source cloud native edge router Traefik, has announced the general availability of Traefik Enterprise Edition. TraefikEE offers production benefits for business-critical deployments.","custom_excerpt":"SAN FRANCISCO – April 18, 2019 – Containous Inc, the company behind the popular open source cloud native edge router Traefik, has announced the general availability of Traefik Enterprise Edition. TraefikEE offers production benefits for business-critical deployments.","visibility":"public","created_at_pretty":"06 January, 2020","published_at_pretty":"April 18, 2019","updated_at_pretty":"22 May, 2020","created_at":"2020-01-06T22:47:34.000+00:00","published_at":"2019-04-18T15:00:00.000+00:00","updated_at":"2020-05-22T01:18:51.000+00:00","meta_title":"Containous Announces the General Availability of TraefikEE","meta_description":"Containous has announced the general availability of Traefik Enterprise Edition. TraefikEE offers production benefits for business-critical deployments.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Press","slug":"press","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Press","slug":"press","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"SAN FRANCISCO – April 18, 2019 – Containous [/] Inc, the company behind the\npopular open source cloud native edge router Traefik [/traefik/], has announced\nthe general availability of Traefik Enterprise Edition. TraefikEE offers\nproduction benefits for business-critical deployments.\n\nWith more than 650 million downloads, Traefik has become a key player in\nmicroservice infrastructures and is widely used by major companies in their\nproduction environments.\n\nIn the latter part of 2018, Containous released the early access of TraefikEE to\na select group of users, allowing them to refine the software. Today, Containous\nis proud to announce that TraefikEE has reached the 1.0 milestone, and is ready\nfor production.\n\nTraefikEE is built on top of Traefik and adds distributed features to address\nthe needs of enterprise customers. It runs at the edge of your platform to route\nthe traffic to applications and microservices alike.\n\nKey highlights of Traefik Enterprise Editions include: \n\n * High Availability: TraefikEE is fault tolerant and runs natively in cluster\n   mode without any extra configuration or external Key Value Store.\n * Scalability: TraefikEE allows the adding or shrinking of your nodes as\n   needed, automatically, by using auto-scaling tools.\n * Security: TraefikEE sets apart the responsibilities of your nodes, allowing\n   the control plane only to deal with your infrastructure components. And, it\n   relies on encrypted communications between nodes to add an extra layer of\n   security.\n * Smooth Operations: TraefikEE comes with an additional CLI that manages to\n   deploy and operate a cluster with several nodes in only one command line.\n   Currently, Kubernetes and Docker Swarm Mode are supported.\n * Dashboard: TraefikEE comes with a dashboard to visualize your cluster nodes\n   configuration and status, in addition to aggregated data plane metrics.\n * Global Support Services: TraefikEE provides enterprise-class technical\n   support to help you reduce risk, optimize productivity, and ensure success,\n   with direct access to the core Traefik team.\n\n“We are thrilled to announce the General Availability of TraefikEE. This product\nis a game changer for the enterprise edge-routing ecosystem. I’m very proud of\nthe entire team who made this possible. This is a strategic step for Containous,\nand we look forward to adding many more features later this year”, said Emile\nVauge, CEO at Containous.\n\nWith TraefikEE, Containous continues to innovate and define new ways to access\nmicroservice platforms, pushing the limits of automation and scalability.\n\nTraefik Enterprise Edition is available today, for more information and to start\na free trial, please visit https://containo.us/traefikee [/traefikee/]. Full\ndocumentation may be found on https://docs.containo.us\n[https://docs.containo.us/].\n\nAbout Containous\nContainous [/] is the company that supports the development of Traefik\n[/traefik/], the popular open source cloud native edge router. Traefik is widely\nused around the globe with over 650 million downloads. Containous brings the\nfuture of software architecture by offering the most powerful tools to ease the\ndeployment of your modern IT environments.\n\nFind out more about Containous at containo.us [/] and follow @containous\n[https://twitter.com/containous] on Twitter.","html":"<p>SAN FRANCISCO – April 18, 2019 – <a href=\"https://containous.ghost.io/\" rel=\"nofollow\">Containous</a> Inc, the company behind the popular open source cloud native edge router <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, has announced the general availability of Traefik Enterprise Edition. TraefikEE offers production benefits for business-critical deployments.</p><p>With more than 650 million downloads, Traefik has become a key player in microservice infrastructures and is widely used by major companies in their production environments.</p><p>In the latter part of 2018, Containous released the early access of TraefikEE to a select group of users, allowing them to refine the software. Today, Containous is proud to announce that TraefikEE has reached the 1.0 milestone, and is ready for production.</p><p>TraefikEE is built on top of Traefik and adds distributed features to address the needs of enterprise customers. It runs at the edge of your platform to route the traffic to applications and microservices alike.</p><p>Key highlights of Traefik Enterprise Editions include: </p><ul><li>High Availability: TraefikEE is fault tolerant and runs natively in cluster mode without any extra configuration or external Key Value Store.</li><li>Scalability: TraefikEE allows the adding or shrinking of your nodes as needed, automatically, by using auto-scaling tools.</li><li>Security: TraefikEE sets apart the responsibilities of your nodes, allowing the control plane only to deal with your infrastructure components. And, it relies on encrypted communications between nodes to add an extra layer of security.</li><li>Smooth Operations: TraefikEE comes with an additional CLI that manages to deploy and operate a cluster with several nodes in only one command line. Currently, Kubernetes and Docker Swarm Mode are supported.</li><li>Dashboard: TraefikEE comes with a dashboard to visualize your cluster nodes configuration and status, in addition to aggregated data plane metrics.</li><li>Global Support Services: TraefikEE provides enterprise-class technical support to help you reduce risk, optimize productivity, and ensure success, with direct access to the core Traefik team.</li></ul><p>“We are thrilled to announce the General Availability of TraefikEE. This product is a game changer for the enterprise edge-routing ecosystem. I’m very proud of the entire team who made this possible. This is a strategic step for Containous, and we look forward to adding many more features later this year”, said Emile Vauge, CEO at Containous.</p><p>With TraefikEE, Containous continues to innovate and define new ways to access microservice platforms, pushing the limits of automation and scalability.</p><p>Traefik Enterprise Edition is available today, for more information and to start a free trial, please visit <a href=\"https://containous.ghost.io/traefikee/\">https://containo.us/traefikee</a>. Full documentation may be found on <a href=\"https://docs.containo.us/\" rel=\"nofollow\">https://docs.containo.us</a>.</p><p><strong>About Containous</strong><br><a href=\"https://containous.ghost.io/\" rel=\"nofollow\">Containous</a> is the company that supports the development of <a href=\"https://containous.ghost.io/traefik/\">Traefik</a>, the popular open source cloud native edge router. Traefik is widely used around the globe with over 650 million downloads. Containous brings the future of software architecture by offering the most powerful tools to ease the deployment of your modern IT environments.</p><p>Find out more about Containous at <a href=\"https://containous.ghost.io/\" rel=\"nofollow\">containo.us</a> and follow <a href=\"https://twitter.com/containous\" rel=\"nofollow\">@containous</a> on Twitter.</p>","url":"https://containous.ghost.io/press/containous-announces-the-general-availability-of-traefik-enterprise-edition/","canonical_url":null,"uuid":"b8605e31-e673-49a6-b18f-b7f0a41af630","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e13b9067fd27c00383d0791","reading_time":2}},{"node":{"id":"Ghost__Post__5e3cb9cecf5e3c00386baf52","title":"HolidayCheck Cloud Platform Using Traefik","slug":"holidaycheck-cloud-platform-using-traefik","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/02/Holiday-Check-1.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/2ad6a7f3e7602f57bfc91be636ba76c3/b41c1/Holiday-Check-1.png","srcSet":"/static/2ad6a7f3e7602f57bfc91be636ba76c3/630fb/Holiday-Check-1.png 300w,\n/static/2ad6a7f3e7602f57bfc91be636ba76c3/2a4de/Holiday-Check-1.png 600w,\n/static/2ad6a7f3e7602f57bfc91be636ba76c3/b41c1/Holiday-Check-1.png 784w","sizes":"(max-width: 784px) 100vw, 784px"}}},"excerpt":"Periklis Tsirakidis from HolidayCheck shows how they shaped Traefik to fit into HolidayCheck's platform, and how it serves to standardize and empower continuous delivery in a Kubernetes agnostic way for HolidayCheck's product teams","custom_excerpt":"Periklis Tsirakidis from HolidayCheck shows how they shaped Traefik to fit into HolidayCheck's platform, and how it serves to standardize and empower continuous delivery in a Kubernetes agnostic way for HolidayCheck's product teams","visibility":"public","created_at_pretty":"07 February, 2020","published_at_pretty":"April 9, 2019","updated_at_pretty":"01 July, 2020","created_at":"2020-02-07T01:13:50.000+00:00","published_at":"2019-04-09T01:15:00.000+00:00","updated_at":"2020-07-01T22:59:29.000+00:00","meta_title":"HolidayCheck Cloud Platform Using Traefik","meta_description":"HolidayCheck shows how Traefik is used to fit into HolidayCheck's platform,  to standardize continuous delivery in a Kubernetes agnostic way.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Resources","slug":"resources","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Resources","slug":"resources","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Online Meetup","slug":"online-meetup","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":"Online Meetup  | Containous","visibility":"public"}],"plaintext":"Periklis Tsirakidis from HolidayCheck shows how they shaped Traefik to fit into\nHolidayCheck's platform, and how it serves to standardize and empower continuous\ndelivery in a Kubernetes agnostic way for HolidayCheck's product teams.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">\nPeriklis Tsirakidis from HolidayCheck shows how they shaped Traefik to fit into HolidayCheck's platform, and how it serves to standardize and empower continuous delivery in a Kubernetes agnostic way for HolidayCheck's product teams.\n</p><!--kg-card-end: html--><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/3QTwu14sLVc?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure>","url":"https://containous.ghost.io/resources/holidaycheck-cloud-platform-using-traefik/","canonical_url":null,"uuid":"f1f9140b-080c-447d-8b11-5e92fdef9e93","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e3cb9cecf5e3c00386baf52","reading_time":0}},{"node":{"id":"Ghost__Post__5e3cba8ccf5e3c00386baf62","title":"Real Life Examples from Rookout to Optimize your Traefik Onboarding Experience","slug":"real-life-examples-from-rookout-to-optimize-your-traefik-onboarding-experience","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/02/Rookout--1-.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/5e110658da57954cc053963e4c8d2cac/b41c1/Rookout--1-.png","srcSet":"/static/5e110658da57954cc053963e4c8d2cac/630fb/Rookout--1-.png 300w,\n/static/5e110658da57954cc053963e4c8d2cac/2a4de/Rookout--1-.png 600w,\n/static/5e110658da57954cc053963e4c8d2cac/b41c1/Rookout--1-.png 784w","sizes":"(max-width: 784px) 100vw, 784px"}}},"excerpt":"Watch a step by step guide on how to install Traefik on Kubernetes, combine Traefik with your CI to deploy dev environments, route traffic by HTTP headers, and turn your Kubernetes cluster into a VPN ","custom_excerpt":"Watch a step by step guide on how to install Traefik on Kubernetes, combine Traefik with your CI to deploy dev environments, route traffic by HTTP headers, and turn your Kubernetes cluster into a VPN ","visibility":"public","created_at_pretty":"07 February, 2020","published_at_pretty":"April 2, 2019","updated_at_pretty":"15 July, 2020","created_at":"2020-02-07T01:17:00.000+00:00","published_at":"2019-04-02T01:19:00.000+00:00","updated_at":"2020-07-15T00:38:53.000+00:00","meta_title":"Examples from Rookout to Optimize a Traefik Onboarding Experience","meta_description":"Learn how to install Traefik on Kubernetes, combine Traefik with your CI to deploy dev environments, and route traffic by HTTP headers.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Resources","slug":"resources","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Resources","slug":"resources","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Online Meetup","slug":"online-meetup","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":"Online Meetup  | Containous","visibility":"public"}],"plaintext":"Watch a step by step guide on how to install Traefik on Kubernetes, combine\nTraefik with your CI to deploy dev environments, route traffic by HTTP headers,\nand turn your Kubernetes cluster into a VPN","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">\nWatch a step by step guide on how to install Traefik on Kubernetes, combine Traefik with your CI to deploy dev environments, route traffic by HTTP headers, and turn your Kubernetes cluster into a VPN \n</p><!--kg-card-end: html--><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/0yYnnxt0Bfk?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure>","url":"https://containous.ghost.io/resources/real-life-examples-from-rookout-to-optimize-your-traefik-onboarding-experience/","canonical_url":null,"uuid":"9a7117ae-ccc1-4447-9e4a-a3dbddef8790","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e3cba8ccf5e3c00386baf62","reading_time":0}},{"node":{"id":"Ghost__Post__5e3cbb69cf5e3c00386baf72","title":"RiksTV's Cloud Infrastructure Using Traefik","slug":"rikstvs-cloud-infrastructure-using-traefik","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/02/RisksTV.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/dfd1c2c24c0e900a498dc9993fced8ec/b41c1/RisksTV.png","srcSet":"/static/dfd1c2c24c0e900a498dc9993fced8ec/630fb/RisksTV.png 300w,\n/static/dfd1c2c24c0e900a498dc9993fced8ec/2a4de/RisksTV.png 600w,\n/static/dfd1c2c24c0e900a498dc9993fced8ec/b41c1/RisksTV.png 784w","sizes":"(max-width: 784px) 100vw, 784px"}}},"excerpt":"In this online meetup, Trond Hindenes from RiksTV shows how Traefik fits into RiksTVs stack, and how it fits together with other products such as ALB, Kubernetes and Consul.","custom_excerpt":"In this online meetup, Trond Hindenes from RiksTV shows how Traefik fits into RiksTVs stack, and how it fits together with other products such as ALB, Kubernetes and Consul.","visibility":"public","created_at_pretty":"07 February, 2020","published_at_pretty":"February 26, 2019","updated_at_pretty":"25 June, 2020","created_at":"2020-02-07T01:20:41.000+00:00","published_at":"2019-02-26T01:23:00.000+00:00","updated_at":"2020-06-25T00:38:11.000+00:00","meta_title":"RiksTV's Cloud Infrastructure Using Traefik","meta_description":"Trond Hindenes from RiksTV shows how Traefik fits into RiksTVs stack, and how it fits together with other products such as ALB, Kubernetes and Consul.\n</p>","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Resources","slug":"resources","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Resources","slug":"resources","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Online Meetup","slug":"online-meetup","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":"Online Meetup  | Containous","visibility":"public"}],"plaintext":"Traefik has been an important part of RiksTVs cloud infrastructure since day\none, both for traditional services and for our Kubernetes-based workloads. In\nthis online meetup, Trond Hindenes from RiksTV shows how Traefik fits into\nRiksTVs stack, and how it fits together with other products such as ALB,\nKubernetes and Consul.","html":"<!--kg-card-begin: html--><p class=\"post-sub-title\">\nTraefik has been an important part of RiksTVs cloud infrastructure since day one, both for traditional services and for our Kubernetes-based workloads. In this online meetup, Trond Hindenes from RiksTV shows how Traefik fits into RiksTVs stack, and how it fits together with other products such as ALB, Kubernetes and Consul.\n</p><!--kg-card-end: html--><figure class=\"kg-card kg-embed-card\"><iframe width=\"480\" height=\"270\" src=\"https://www.youtube.com/embed/022gbgxYJZk?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></figure>","url":"https://containous.ghost.io/resources/rikstvs-cloud-infrastructure-using-traefik/","canonical_url":null,"uuid":"f7049368-1a93-46f7-bc13-23f556783657","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e3cbb69cf5e3c00386baf72","reading_time":0}},{"node":{"id":"Ghost__Post__5e13e5997fd27c00383d0840","title":"Introducing Traefik Enterprise Edition: We Made It Distributed","slug":"introducing-traefik-enterprise-edition-we-made-it-distributed","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/01/TechCrunch-Logo.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/87e79284f2cd00329a42482614b767ce/9a128/TechCrunch-Logo.jpg","srcSet":"/static/87e79284f2cd00329a42482614b767ce/9dc27/TechCrunch-Logo.jpg 300w,\n/static/87e79284f2cd00329a42482614b767ce/4fe8c/TechCrunch-Logo.jpg 600w,\n/static/87e79284f2cd00329a42482614b767ce/9a128/TechCrunch-Logo.jpg 700w","sizes":"(max-width: 700px) 100vw, 700px"}}},"excerpt":null,"custom_excerpt":null,"visibility":"public","created_at_pretty":"07 January, 2020","published_at_pretty":"December 11, 2018","updated_at_pretty":"09 January, 2020","created_at":"2020-01-07T01:57:45.000+00:00","published_at":"2018-12-11T01:57:00.000+00:00","updated_at":"2020-01-09T19:42:22.000+00:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"News","slug":"news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"News","slug":"news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":null,"html":null,"url":"https://containous.ghost.io/news/introducing-traefik-enterprise-edition-we-made-it-distributed/","canonical_url":null,"uuid":"67720b70-53ad-4e97-b5dc-4ac1258e8f0a","codeinjection_foot":null,"codeinjection_head":"<script type=\"text/javascript\">\n      window.location.href = \"https://techcrunch.com/sponsor/unlisted/introducing-traefik-enterprise-edition/\"\n</script>","codeinjection_styles":"","comment_id":"5e13e5997fd27c00383d0840","reading_time":null}},{"node":{"id":"Ghost__Post__5dd7fce3f1db6f0038c745f2","title":"Golang Configuration Made Easy With Flæg And Stært","slug":"golang-configuration-made-easy-with-flaeg-and-staert-2818921e78e","featured":false,"feature_image":"https://containous.ghost.io/content/images/2019/12/flaeg.png","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/ada72671fe3e0047e44e11e1e62cd0ad/9b73b/flaeg.png","srcSet":"/static/ada72671fe3e0047e44e11e1e62cd0ad/630fb/flaeg.png 300w,\n/static/ada72671fe3e0047e44e11e1e62cd0ad/2a4de/flaeg.png 600w,\n/static/ada72671fe3e0047e44e11e1e62cd0ad/9b73b/flaeg.png 710w","sizes":"(max-width: 710px) 100vw, 710px"}}},"excerpt":"There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files...","custom_excerpt":"There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files...","visibility":"public","created_at_pretty":"22 November, 2019","published_at_pretty":"August 4, 2016","updated_at_pretty":"22 May, 2020","created_at":"2019-11-22T15:21:07.000+00:00","published_at":"2016-08-04T15:21:00.000+00:00","updated_at":"2020-05-22T00:17:35.000+00:00","meta_title":"Golang Configuration Made Easy With Flæg And Stært","meta_description":"There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files...","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Traefik Labs","slug":"traefiklabs","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/09/TraefikLabs-symbol-transparent-bg@3x.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Product News","slug":"product-news","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"There are many ways to provide a configuration to a program. Some use Command\nLine Interfaces, others use configuration files. Any setting changes can require\na refactor on many lines of code. The configuration loading process have to be\nvery robust. If not, programs could not work as we expected. Unfortunately \ngolang [https://golang.org/] programs are no exception. For instance, adding a\nnew argument in a CLI requires to create a flag, to parse data, to deal with the\nhelp section, to manage default values and to affect the collected value into\nthe configuration structure.\n\nClose your eyes and imagine a library able to automatically manage all this\nconfiguration process for you. You can open them because we did it :)\n\n\n--------------------------------------------------------------------------------\n\nFlæg\nFlæg [https://github.com/containous/flaeg/] is a Go package for building\ndynamically a powerful modern Command Line Interface and loading a program\nconfiguration structure from arguments. Go developers don’t need to worry about\nkeeping flags and commands updated anymore : it works by itself !\n\nFlæg package was born from the need of Træfik [/traefik/], the famous reverse\nproxy created by Emile Vauge [https://github.com/emilevauge]. It was more and\nmore difficult to maintain the list of `flags`: parameters passed in argument\nwhich drive the program.\n\nThanks to Flæg [https://github.com/containous/flaeg/], the maintenance became a\nthing of the past. The `flags` are auto generated from the field names of the\nconfiguration structure. To do that, developers just have to add a StructTag\n[https://golang.org/pkg/reflect/#StructTag] following the field to create a flag\non it. The helper (i.e. what is displayed with -help argument) is generated from\nthe key `description` in the StructTag\n[https://golang.org/pkg/reflect/#StructTag]\n\nHere an example of a complex configuration with StructTag\n[https://golang.org/pkg/reflect/#StructTag] that Flæg can process:\n\nflaegdemo.config.goGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/bbd5672a81175e07492c6c9e7b43aba7]Flæg\n[https://github.com/containous/flaeg/] is able to load the argument values\n​​given in the configuration structure through reflection\n[https://en.wikipedia.org/wiki/Reflection_(computer_programming)]. The package\nsupports most of field types, but no collections. Hopefully users can add a\ncustom parser on specific types as collections or even whole structures.\n\nLet’s see how simple it is to use Flæg.\n\nFirst we will create a trivial command which do nothing but print the\nconfiguration:\n\nGolang Configuration Made Easy With Flæg And StærtGolang Configuration Made\nEasy\nWith Flæg And Stært - flaegdemo.cmd.go262588213843476Gist\n[https://gist.github.com/cocap10/600d3491c9f005195c3c8bc9234dfc99]Then, we only\nhave to create a Flæg object and call the function Run :\n\nflaegdemo.use.goGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/69620f12c8fad0953269df5edb3bb58d]Let’s try this\nprogram. We will first call the helper :\n\nflaegdemo.help.shGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/b8cb3e8f78d1661eefd0f48f46e38e65]As you can\nsee, the generated flags match the fields of the configuration structure with\nsubstructures `DatabaseInfo` and `OwnerInfo`. Default values ​​can be defined\ndirectly in the fields of the configuration structure. These fields will be\nunchanged if their `flags` are not used in argument.\n\nThen, we can try the program:\n\nflaegdemo.try.shGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/090406f9f88d59d89e7dd0f09edcd8eb]Flæg also\nhandles sub-command, like the “version” command in the example :\n\nflaegdemo.sub.cmd.goGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/2a88cf1605f3d4187c15e129d8b58a1d]\nflaegdemo.version.try.shGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/5112adbf0f83027dc0fb7e30bd5cea80]To learn much\nmore about Flæg, please visit the github project page \nhttps://github.com/containous/flaeg.\n\nThanks to Flæg, we have a nice solution to load the configuration from the\nflags. The maintenance is now way simpler than it used to be, which is\nappreciated on open source projects. But how can we manage merging this CLI\nconfiguration with other sources like configuration files ?\n\n\n--------------------------------------------------------------------------------\n\nStært\nThe CLI is not the only way to provide configuration to a program. There are\nother sources of configuration. For instance, Træfik can take a configuration\nfrom flags, from a config file and from a distributed Key-Value Store.\n\nWe created Stært [https://github.com/containous/staert/] to merge those\nconfiguration sources. So far, only flags (using Flæg\n[https://github.com/containous/flaeg/]), TOML config file and Key-Value Stored\n[https://github.com/containous/staert#kvstore] configuration are implemented,\nbut we did the package in such way that it is easy to add other sources.\n\nStært uses the same Command type\n[https://github.com/containous/staert#the-command] as Flæg\n[https://github.com/containous/flaeg].\n\nWe just have to create some sources\n[https://github.com/containous/staert#use-st%C3%A6rt-with-sources] :\n\nstaertdemo.create.sources.goGitHub Gist: instantly share code, notes, and\nsnippets.262588213843476Gist\n[https://gist.github.com/cocap10/d8f1742a119e5f0069790f4fbf230d59]Then, we can\ncreate a Stært [https://github.com/containous/staert] object and use it :\n\nstaertdemo.use.goGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/6742ba6bf48d82b62feae2c6c8f2af4c]Stært will\nload the configuration in the row and overwrite it following precedence order :\n\n * Key-Value Store source\n * Flæg source\n * TOML config file source\n\nHere an example of TOML file :\n\nstaertdemo.try.tomlGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/6273109426155223099407cd9a2624cc]And there is\nthe way to store the Key-Value :\n\nstaertdemo.kv.mdGitHub Gist: instantly share code, notes, and snippets.\n262588213843476Gist\n[https://gist.github.com/cocap10/3115098a4c56b4bc13df9cc0182ac556]This was a\nsimple example of what we can do with Stært.\n\nTo conclude, those two packages made us save a lot of time on the Træfik project\n[https://github.com/containous/traefik]. We can now load and merge several\nconfigurations from different sources. Any changes on the configuration\nstructure are automagically handled.\n\nMore features are described on the Github project pages, please visit :\n\n * Flæg: https://github.com/containous/flaeg/\n * Stært: https://github.com/containous/staert/","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://miro.medium.com/max/1420/0*ABKj5V2gw7tezUc5.\" class=\"kg-image\"></figure><p>There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files. Any setting changes can require a refactor on many lines of code. The configuration loading process have to be very robust. If not, programs could not work as we expected. Unfortunately <a href=\"https://golang.org/\" rel=\"noopener\">golang</a> programs are no exception. For instance, adding a new argument in a CLI requires to create a flag, to parse data, to deal with the help section, to manage default values and to affect the collected value into the configuration structure.</p><p>Close your eyes and imagine a library able to automatically manage all this configuration process for you. You can open them because we did it :)</p><hr><h2 id=\"fl-g\">Flæg</h2><p><a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">Flæg</a> is a Go package for building dynamically a powerful modern Command Line Interface and loading a program configuration structure from arguments. Go developers don’t need to worry about keeping flags and commands updated anymore : it works by itself !</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2019/11/image-99.png\" class=\"kg-image\"></figure><p>Flæg package was born from the need of <a href=\"https://containous.ghost.io/traefik/\">Træfik</a>, the famous reverse proxy created by <a href=\"https://github.com/emilevauge\" rel=\"noopener\">Emile Vauge</a>. It was more and more difficult to maintain the list of `flags`: parameters passed in argument which drive the program.</p><p>Thanks to <a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">Flæg</a>, the maintenance became a thing of the past. The `flags` are auto generated from the field names of the configuration structure. To do that, developers just have to add a <a href=\"https://golang.org/pkg/reflect/#StructTag\" rel=\"noopener\">StructTag</a> following the field to create a flag on it. The helper (i.e. what is displayed with <em><em>-help</em></em> argument) is generated from the key `description` in the <a href=\"https://golang.org/pkg/reflect/#StructTag\" rel=\"noopener\">StructTag</a></p><p>Here an example of a complex configuration with <a href=\"https://golang.org/pkg/reflect/#StructTag\" rel=\"noopener\">StructTag</a> that Flæg can process:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/bbd5672a81175e07492c6c9e7b43aba7\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.config.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p><a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">Flæg</a> is able to load the argument values ​​given in the configuration structure through <a href=\"https://en.wikipedia.org/wiki/Reflection_(computer_programming)\" rel=\"noopener\">reflection</a>. The package supports most of field types, but no collections. Hopefully users can add a custom parser on specific types as collections or even whole structures.</p><p>Let’s see how simple it is to use Flæg.</p><p>First we will create a trivial command which do nothing but print the configuration:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/600d3491c9f005195c3c8bc9234dfc99\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Golang Configuration Made Easy With Flæg And Stært</div><div class=\"kg-bookmark-description\">Golang Configuration Made Easy With Flæg And Stært - flaegdemo.cmd.go</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>Then, we only have to create a Flæg object and call the function Run :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/69620f12c8fad0953269df5edb3bb58d\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.use.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>Let’s try this program. We will first call the helper :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/b8cb3e8f78d1661eefd0f48f46e38e65\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.help.sh</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>As you can see, the generated flags match the fields of the configuration structure with substructures `DatabaseInfo` and `OwnerInfo`. Default values ​​can be defined directly in the fields of the configuration structure. These fields will be unchanged if their `flags` are not used in argument.</p><p>Then, we can try the program:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/090406f9f88d59d89e7dd0f09edcd8eb\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.try.sh</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>Flæg also handles sub-command, like the “version” command in the example :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/2a88cf1605f3d4187c15e129d8b58a1d\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.sub.cmd.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/5112adbf0f83027dc0fb7e30bd5cea80\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">flaegdemo.version.try.sh</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>To learn much more about Flæg, please visit the github project page <a href=\"https://github.com/containous/flaeg\" rel=\"noopener\">https://github.com/containous/flaeg</a>.</p><p>Thanks to Flæg, we have a nice solution to load the configuration from the flags. The maintenance is now way simpler than it used to be, which is appreciated on open source projects. But how can we manage merging this CLI configuration with other sources like configuration files ?</p><hr><h2 id=\"st-rt\">Stært</h2><p>The CLI is not the only way to provide configuration to a program. There are other sources of configuration. For instance, Træfik can take a configuration from flags, from a config file and from a distributed Key-Value Store.</p><p>We created <a href=\"https://github.com/containous/staert/\" rel=\"noopener\">Stært</a> to merge those configuration sources. So far, only flags (using <a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">Flæg</a>), TOML config file and <a href=\"https://github.com/containous/staert#kvstore\" rel=\"noopener\">Key-Value Stored</a> configuration are implemented, but we did the package in such way that it is easy to add other sources.</p><p>Stært uses the same <a href=\"https://github.com/containous/staert#the-command\" rel=\"noopener\">Command type</a> as <a href=\"https://github.com/containous/flaeg\" rel=\"noopener\">Flæg</a>.</p><p>We just have to <a href=\"https://github.com/containous/staert#use-st%C3%A6rt-with-sources\" rel=\"noopener\">create some sources</a> :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/d8f1742a119e5f0069790f4fbf230d59\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">staertdemo.create.sources.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>Then, we can create a <a href=\"https://github.com/containous/staert\" rel=\"noopener\">Stært</a> object and use it :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/6742ba6bf48d82b62feae2c6c8f2af4c\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">staertdemo.use.go</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>Stært will load the configuration in the row and overwrite it following precedence order :</p><ul><li>Key-Value Store source</li><li>Flæg source</li><li>TOML config file source</li></ul><p>Here an example of TOML file :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/6273109426155223099407cd9a2624cc\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">staertdemo.try.toml</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>And there is the way to store the Key-Value :</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://gist.github.com/cocap10/3115098a4c56b4bc13df9cc0182ac556\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">staertdemo.kv.md</div><div class=\"kg-bookmark-description\">GitHub Gist: instantly share code, notes, and snippets.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicon.ico\"><span class=\"kg-bookmark-author\">262588213843476</span><span class=\"kg-bookmark-publisher\">Gist</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/gists/gist-og-image.png\"></div></a></figure><p>This was a simple example of what we can do with Stært.</p><p>To conclude, those two packages made us save a lot of time on the <a href=\"https://github.com/containous/traefik\" rel=\"noopener\">Træfik project</a>. We can now load and merge several configurations from different sources. Any changes on the configuration structure are automagically handled.</p><p>More features are described on the Github project pages, please visit :</p><ul><li>Flæg: <a href=\"https://github.com/containous/flaeg/\" rel=\"noopener\">https://github.com/containous/flaeg/</a></li><li>Stært: <a href=\"https://github.com/containous/staert/\" rel=\"noopener\">https://github.com/containous/staert/</a></li></ul>","url":"https://containous.ghost.io/blog/golang-configuration-made-easy-with-flaeg-and-staert-2818921e78e/","canonical_url":null,"uuid":"510efcc8-d4ef-4366-abc5-eb4f607702ad","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dd7fce3f1db6f0038c745f2","reading_time":5}}]}},"pageContext":{"slug":"traefiklabs","limit":9,"skip":99,"numberOfPages":12,"humanPageNumber":12,"prevPageNumber":11,"nextPageNumber":null,"previousPagePath":"/author/traefiklabs/page/11/","nextPagePath":null}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}