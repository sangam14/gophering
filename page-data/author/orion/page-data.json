{"componentChunkName":"component---src-templates-author-tsx","path":"/author/orion/","result":{"data":{"ghostAuthor":{"slug":"orion","name":"Orion Letizi","bio":null,"cover_image":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","location":null,"website":null,"twitter":null,"facebook":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5f0f2f71554944004519ecc4","title":"Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik","slug":"introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/b55bc938e5dafa9f9ee2110650843365/47498/Introducing-Traefik-Pilot---Blog-1.jpg","srcSet":"/static/b55bc938e5dafa9f9ee2110650843365/9dc27/Introducing-Traefik-Pilot---Blog-1.jpg 300w,\n/static/b55bc938e5dafa9f9ee2110650843365/4fe8c/Introducing-Traefik-Pilot---Blog-1.jpg 600w,\n/static/b55bc938e5dafa9f9ee2110650843365/47498/Introducing-Traefik-Pilot---Blog-1.jpg 1200w,\n/static/b55bc938e5dafa9f9ee2110650843365/52258/Introducing-Traefik-Pilot---Blog-1.jpg 1800w,\n/static/b55bc938e5dafa9f9ee2110650843365/a41d1/Introducing-Traefik-Pilot---Blog-1.jpg 2000w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Today, we’re excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production.","custom_excerpt":"Today, we’re excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production.","visibility":"public","created_at_pretty":"15 July, 2020","published_at_pretty":"July 16, 2020","updated_at_pretty":"04 August, 2020","created_at":"2020-07-15T16:31:45.000+00:00","published_at":"2020-07-16T13:25:52.000+00:00","updated_at":"2020-08-04T22:37:55.000+00:00","meta_title":"Introducing Traefik Pilot: a New SaaS Control Platform for Traefik","meta_description":"We're excited to announce the preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production.","og_description":null,"og_image":null,"og_title":null,"twitter_description":"We’re excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production.","twitter_image":"https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Twitter@2x.png","twitter_title":"Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik","authors":[{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Announcements","slug":"announcements","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"#pilot-related-resource","slug":"hash-pilot-related-resource","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"Today, we’re excited to announce the early-access preview of Traefik Pilot, a\nnew SaaS global control plane, to simplify the management of Traefik running in\nproduction. Pilot extends the capabilities of Traefik, providing a powerful\nobservability and control platform for every one of your Traefik instances in a\nsingle unified dashboard.\n\nIn addition, Traefik Pilot introduces plugins for Traefik, including a first of\nits kind open marketplace, which extends Traefik middleware with custom,\npurpose-built requests and responses processing.\n\nThe preview release of Pilot includes:\n\n * Custom Middleware Plugins! Our brand new plugins marketplace including\n   examples of custom middleware\n * Centralized view of your production Traefik instances\n * Availability and security vulnerability alerts with notifications\n\nGet started with Pilot › [https://pilot.traefik.io/]\n\nCustom Middleware Plugins\nOne of the most frequently requested features from the Traefik community is the \nability to easily create and share custom\n[https://github.com/containous/traefik/issues/1336] plugins and extend the\nfunctionality of our existing middleware catalog. Built on Yaegi\n[/blog/announcing-yaegi-263a1e2d070a/], the new plugin system offers an elegant,\nextensible, and high-performance way to augment Traefik's capabilities without\nthe need to modify or compile the Traefik source code.\n\nTraefik plugins are add-on packages that empower users to apply transformations\nand enhancements to both requests and responses, which are handled by Traefik.\nThere have been several middleware pull requests\n[https://github.com/containous/traefik/pulls?q=is%3Apr+label%3Aarea%2Fmiddleware+label%3Aresolution%2Fdeclined+is%3Aclosed] \ndeclined due to implementations that are tied to a specific use case or for\nlacking the abstraction necessary to be accepted upstream into Traefik.\nDevelopers are now equipped with the tools needed to write plugins in Go\n[https://github.com/containous/plugindemo], and sharing them with the world is\nas easy as publishing them on GitHub. The new plugin engine enables the\ncommunity to install their custom middleware using Traefik Pilot without\ncompiling a single line of code.\n\nThe initial release of Pilot includes a free to use plugin marketplace that\nextends Traefik by installing middleware plugins directly from the catalog. In\naddition, you can just as easily create, publish, and install your own. On\nlaunch day, the catalog will contain a few sample plugins that serve as advanced\ntutorials for developers to build their own. We expect the catalog to expand\nrapidly, especially as the Traefik community begins to write and share their new\ncreations.\n\nLearn more › [https://docs.traefik.io/v2.3/plugins/overview/]\n\nSecurity and Availability Alerting\nKeeping track of your Traefik installations and ensuring they are healthy,\navailable, and secure has, until today, required a significant amount of effort.\nTypically this involved deploying a system to gather metrics and creating an\nalerting system to notify you if there is a problem. With Pilot's introduction,\nwe're now the first managed SaaS provider to offer security and availability\nmonitoring of your cloud-native software load balancers, for free.\n\nOnce Traefik is registered, a built-in heartbeat mechanism will check-in with\nPilot periodically and report the health and availability of your Traefik\ninstance. In addition, Pilot will check for common vulnerabilities and exposure\n(CVE) [https://cve.mitre.org/] bulletins that apply to your Traefik installation\nand configuration, which may indicate a security risk to your Traefik\ndeployments. You may now use the dashboard to configure your alert settings and\nget notified of issues through email or custom webhooks before they become\nemergencies.\n\nGet Started by Connecting Your Traefik Instance\nPilot requires the most recent version of Traefik, v2.3 RC. You will also now\nfind a convenient link on the Traefik dashboard to register your instance with\nPilot.\n\nOnce logged into Pilot, registering your Traefik instance by adding a unique\ntoken to your static configuration. This will automatically extend your\ninstallation's functionality by monitoring the health of your installation,\nenabling the use of custom middleware plugins, and reporting relevant\nvulnerabilities that apply to your environment.\n\nJust the Beginning\nThis initial preview release brings exciting and new capabilities to the Traefik\necosystem, and this is just the beginning. We're even more excited by what we\nalready have queued up for future iterations. Keep an eye out for Pilot to\nbroaden the range and reach of your existing Traefik deployments. We're just\ngetting started and have plans for additional capabilities from microservices\nrouting and orchestrator ingress to expanding out to the global edge.\n\nJump in the cockpit with Pilot today and let us know what you think. What kinds\nof plugins will you write [https://github.com/containous/plugindemo]?\n\nUseful links\n * Get started with Pilot › [https://pilot.traefik.io/]\n * Pilot documentation [https://docs.traefik.io/v2.3/plugins/overview/]\n * Traefik [/traefik/]\n * Community forum [https://community.containo.us/c/traefik/5]","html":"<figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog.jpg\" class=\"kg-image\" alt=\"Introducing Traefik Pilot\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Introducing-Traefik-Pilot---Blog.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Introducing-Traefik-Pilot---Blog.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Introducing-Traefik-Pilot---Blog.jpg 1600w, https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog.jpg 2400w\" sizes=\"(min-width: 1200px) 1200px\"></figure><p>Today, we’re excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production. Pilot extends the capabilities of Traefik, providing a powerful observability and control platform for every one of your Traefik instances in a single unified dashboard.</p><p>In addition, Traefik Pilot introduces plugins for Traefik, including a first of its kind open marketplace, which extends Traefik middleware with custom, purpose-built requests and responses processing.</p><p>The preview release of Pilot includes:</p><ul><li>Custom Middleware Plugins! Our brand new plugins marketplace including examples of custom middleware</li><li>Centralized view of your production Traefik instances</li><li>Availability and security vulnerability alerts with notifications</li></ul><p><a href=\"https://pilot.traefik.io/\">Get started with Pilot ›</a></p><h2 id=\"custom-middleware-plugins\">Custom Middleware Plugins</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png\" class=\"kg-image\" alt=\"Traefik Pilot Plugins Marketplace\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 1600w, https://containous.ghost.io/content/images/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 2094w\" sizes=\"(min-width: 720px) 720px\"></figure><p>One of the most frequently requested features from the Traefik community is the <a href=\"https://github.com/containous/traefik/issues/1336\">ability to easily create and share custom</a> plugins and extend the functionality of our existing middleware catalog. Built on <a href=\"https://containous.ghost.io/blog/announcing-yaegi-263a1e2d070a/\">Yaegi</a>, the new plugin system offers an elegant, extensible, and high-performance way to augment Traefik's capabilities without the need to modify or compile the Traefik source code.</p><p>Traefik plugins are add-on packages that empower users to apply transformations and enhancements to both requests and responses, which are handled by Traefik. There have been several middleware <a href=\"https://github.com/containous/traefik/pulls?q=is%3Apr+label%3Aarea%2Fmiddleware+label%3Aresolution%2Fdeclined+is%3Aclosed\">pull requests</a> declined due to implementations that are tied to a specific use case or for lacking the abstraction necessary to be accepted upstream into Traefik. Developers are now equipped with the tools needed to <a href=\"https://github.com/containous/plugindemo\">write plugins in Go</a>, and sharing them with the world is as easy as publishing them on GitHub. The new plugin engine enables the community to install their custom middleware using Traefik Pilot without compiling a single line of code.</p><p>The initial release of Pilot includes a free to use plugin marketplace that extends Traefik by installing middleware plugins directly from the catalog. In addition, you can just as easily create, publish, and install your own. On launch day, the catalog will contain a few sample plugins that serve as advanced tutorials for developers to build their own. We expect the catalog to expand rapidly, especially as the Traefik community begins to write and share their new creations.</p><p><a href=\"https://docs.traefik.io/v2.3/plugins/overview/\">Learn more ›</a></p><h2 id=\"security-and-availability-alerting\">Security and Availability Alerting</h2><p>Keeping track of your Traefik installations and ensuring they are healthy, available, and secure has, until today, required a significant amount of effort. Typically this involved deploying a system to gather metrics and creating an alerting system to notify you if there is a problem. With Pilot's introduction, we're now the first managed SaaS provider to offer security and availability monitoring of your cloud-native software load balancers, for free.</p><!--kg-card-begin: markdown--><p>Once Traefik is registered, a built-in heartbeat mechanism will check-in with Pilot periodically and report the health and availability of your Traefik instance. In addition, Pilot will check for <a href=\"https://cve.mitre.org/\" target=\"_blank\" rel=\"nofollow\">common vulnerabilities and exposure (CVE)</a> bulletins that apply to your Traefik installation and configuration, which may indicate a security risk to your Traefik deployments. You may now use the dashboard to configure your alert settings and get notified of issues through email or custom webhooks before they become emergencies.</p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Profile-Settings-1.png\" class=\"kg-image\" alt=\"Traefik Pilot Profile Settings\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Traefik-Pilot-Profile-Settings-1.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Traefik-Pilot-Profile-Settings-1.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Traefik-Pilot-Profile-Settings-1.png 1600w, https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Profile-Settings-1.png 2158w\" sizes=\"(min-width: 720px) 720px\"></figure><h2 id=\"get-started-by-connecting-your-traefik-instance\">Get Started by Connecting Your Traefik Instance</h2><p>Pilot requires the most recent version of Traefik, v2.3 RC. You will also now find a convenient link on the Traefik dashboard to register your instance with Pilot.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://lh4.googleusercontent.com/bEKbwjNoD7pW83nqgjE4LdndIcQnNihoDJsN77_Vk5A4a5ZUwbaWDiIbYgalA3TQ6fnMeFeQc5upiceLRWoRSLIDZamSg6yTBskb-EzDngqIfts-kQk6bl6M7E7Sy5_BePfJ1KY\" class=\"kg-image\" alt=\"Traefik Dashboard including Pilot\"></figure><p>Once logged into Pilot, registering your Traefik instance by adding a unique token to your static configuration. This will automatically extend your installation's functionality by monitoring the health of your installation, enabling the use of custom middleware plugins, and reporting relevant vulnerabilities that apply to your environment.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Instance-Registration.png\" class=\"kg-image\" alt=\"Traefik Pilot Instance Registration\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/07/Traefik-Pilot-Instance-Registration.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Traefik-Pilot-Instance-Registration.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Traefik-Pilot-Instance-Registration.png 1600w, https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Instance-Registration.png 2156w\" sizes=\"(min-width: 720px) 720px\"></figure><h2 id=\"just-the-beginning\">Just the Beginning</h2><p>This initial preview release brings exciting and new capabilities to the Traefik ecosystem, and this is just the beginning. We're even more excited by what we already have queued up for future iterations. Keep an eye out for Pilot to broaden the range and reach of your existing Traefik deployments. We're just getting started and have plans for additional capabilities from microservices routing and orchestrator ingress to expanding out to the global edge.</p><p>Jump in the cockpit with Pilot today and let us know what you think. <a href=\"https://github.com/containous/plugindemo\">What kinds of plugins will you write</a>?</p><h2 id=\"useful-links\">Useful links</h2><ul><li><a href=\"https://pilot.traefik.io/\">Get started with Pilot ›</a></li><li><a href=\"https://docs.traefik.io/v2.3/plugins/overview/\">Pilot documentation</a></li><li><a href=\"https://containous.ghost.io/traefik/\">Traefik</a></li><li><a href=\"https://community.containo.us/c/traefik/5\">Community forum</a></li></ul>","url":"https://containous.ghost.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/","canonical_url":null,"uuid":"bc637eb4-bfba-4246-9d92-c79db48c2d7b","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f0f2f71554944004519ecc4","reading_time":4}},{"node":{"id":"Ghost__Post__5e9890445df7fe004475aa62","title":"Connecting Users to Applications with Kubernetes Ingress Controllers","slug":"connecting-users-to-applications-with-kubernetes-ingress-controllers","featured":false,"feature_image":"https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg","featureImageSharp":{"childImageSharp":{"fluid":{"src":"/static/1caf24ae2a6677b201631dedaab14f3e/47498/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg","srcSet":"/static/1caf24ae2a6677b201631dedaab14f3e/9dc27/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg 300w,\n/static/1caf24ae2a6677b201631dedaab14f3e/4fe8c/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg 600w,\n/static/1caf24ae2a6677b201631dedaab14f3e/47498/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"excerpt":"Kubernetes is the de facto standard for teams developing cloud-native applications. In this article, we’ll review one of the most critical aspects of Kubernetes networking: The Ingress Controller.","custom_excerpt":"Kubernetes is the de facto standard for teams developing cloud-native applications. In this article, we’ll review one of the most critical aspects of Kubernetes networking: The Ingress Controller.","visibility":"public","created_at_pretty":"16 April, 2020","published_at_pretty":"April 21, 2020","updated_at_pretty":"12 October, 2020","created_at":"2020-04-16T17:05:08.000+00:00","published_at":"2020-04-21T13:30:00.000+00:00","updated_at":"2020-10-12T17:54:08.000+00:00","meta_title":"Connecting Users to Apps with Kubernetes Ingress Controllers","meta_description":"In this article, we’ll briefly review one of the most critical but perhaps confusing aspects of Kubernetes networking: The Ingress Controller.","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Orion Letizi","slug":"orion","bio":null,"profile_image":"https://containous.ghost.io/content/images/2020/04/QNSM0403.jpg","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Blog","slug":"blog","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"Kubernetes","slug":"kubernetes","description":null,"feature_image":null,"featureImageSharp":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Containerization technologies such as Docker [https://www.docker.com/] have been\nrapidly adopted by software teams, and the ensuing ability to easily package\napplication components into reusable parts has given rise to the widespread use\nof microservices. However, these benefits have come with a price tag as\ndevelopers are faced with challenges around orchestrating and managing\nconnectivity to the underlying containers in a datacenter. Kubernetes\n[https://kubernetes.io/] (k8s) is the de facto standard for teams developing\ncloud-native applications and directly addresses these issues. In this article,\nwe’ll briefly review one of the most critical but perhaps confusing aspects of\nKubernetes networking: The Ingress Controller.\n\nFrom Pods to Production\nLet’s start with a typical scenario: A development team is tasked with writing a\nbackend API service for external applications/users. In the early phases of\ndevelopment, an engineer may instantiate a local instance of the containerized\nimplementation on development machines using direct docker invocations or even\ndocker-compose. At some point, though, they’ll want to deploy a version of the\nservice to a shared development or staging cluster in the same manner as the\nfinal production configuration. Pods, the fundamental deployable units defined\nby k8s, and higher-level abstractions such as Deployment resources can help\nautomate lifecycle management of containers during this step, but they don’t\naddress how applications are accessed over the network. Kubernetes provides a\ndedicated resource abstraction for this purpose.\n\nExposing applications as k8s services\nWhen deployed within Pods, containers are assigned IP addresses that may change\nover time due to a variety of lifecycle operations. This immediately poses\nchallenges when other components need to find and establish network connections\nwith them. The Service resource defined as part of Kubernetes networking manages\nthese aspects automatically. Users can define Services that get associated with\nunderlying Pods through selectors and allows them to be accessed through a\nuser-specified service name. Where connections can be established from and how\nthey’re implemented depends upon the Service type configured. The most commonly\nused service types offered by k8s are:\n\n * ClusterIP\n * NodePort\n * LoadBalancer\n\nClusterIP service type\nThe ClusterIP is enabled by default if no type is defined in the Service\nresource definition. When invoked, k8s creates a virtual cluster IP address that\ncan be used to connect to the underlying Pods. The caveat, though, is that this\nIP address is routable only within the cluster itself. ClusterIP services are\noften used for exposing internal-only application endpoints to each other.\n\nNodePort service type\nThe NodePort type provides the simplest mechanism for external access to\nservices. Specifically, it opens a specific port (within a k8s configured port\nrange) on every node in the cluster. Underneath, a ClusterIP service is created,\nand clients that attempt to connect to an exposed NodePort are routed through.\nWhile the NodePort service type extends a method to access services from outside\nof the cluster, it has some drawbacks including:\n\n * Services can only be exposed on ports from a range (30000-32767 by default)\n * One port can only be mapped to a single service\n * Clients connect through a node and if the corresponding IP of the underlying\n   host / VM changes, they need to be updated accordingly\n\nLoadBalancer service type\nThe LoadBalancer type is often used in cloud environments in order to automate\nthe provisioning of external load balancers outside of the underlying k8s\ncluster. While this enables external network access and avoids the problem of IP\naddresses shifting out from underneath clients, the use of LoadBalancer Service\ntypes can quickly lead to high costs from the underlying cloud (e.g. GCE or\nAWS).\n\nWhile the three Service types above are viable alternatives for some use cases,\nwhen application developers want to expose their services externally without the\nlimitations of NodePort and LoadBalancer types, there’s a better alternative\nextended by Kubernetes networking.\n\nK8s networking and the Ingress resource abstraction\nKubernetes defines a native Ingress resource abstraction that exposes HTTP and\nHTTPS endpoints and routes traffic based upon rules defined by the user. The\nIngress resource is a natural fit when developers and devops engineers want to\nexpose multiple underlying services through a single external endpoint and/or\nload balancer. The Ingress resource definition allows them to route traffic to\ndefined Service resources based upon, for example, host and/or prefix rules.\nTherefore, it complements the Service resource capabilities to provide a\nflexible method for enabling external access. However, defining an Ingress\nresource on its own doesn’t actually expose services outside Kubernetes since it\nsimply conveys a request for networking configuration.\n\nThe wizard behind the curtain: Ingress Controllers\nOur discussion thus far has helped highlight the need for ingress resources, but\nit leaves open the question of how corresponding requests are acted upon. The\nanswer comes in the form of Ingress Controllers which are responsible for\nconsuming inbound requests and creating the corresponding routing specifications\nin a technology-specific manner. Typically, the specific controller installed in\na k8s cluster is selected and deployed by operators. There are many potential\noptions available, but a few illustrative examples include:\n\n * AWS ALB - An instance of an Ingress Controller tied to a specific public\n   cloud, it satisfies inbound Ingress resource requests using AWS Application\n   Load Balancers\n   [https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html]\n * NGINX - Implements Ingress resources using the NGINX open source software\n * Traefik - A leading open source Kubernetes Ingress Controller [/traefik/] \n   that makes setting up routes between Kubernetes services and the outside\n   world simple and reliable\n\nThere need not be a strict either / or decision when it comes to choosing\nIngress Controllers\n[/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/]\n, and k8s operators can elect to deploy multiple controllers if desired. The\nselection process should take into consideration the benefits specific\ncontrollers like Traefik [/traefik/] may provide such as:\n\n * Lets Encrypt support for automated certificate management\n * Traffic splitting based upon custom weight definitions\n * Flexibly route definitions including support for name and path based routing\n   as well as route prioritization\n * Custom resource definitions that provide additional controller-specific\n   enhancements\n\nBy integrating controllers that align with their use cases, development teams\ncan enjoy a variety of capabilities provided by Kubernetes for external access\nwithout having to become networking experts.\n\nWant to learn more about Kubernetes Ingress? Check out this video\n[https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes] \nthat describes the different patterns for deploying external load balancers in\nKubernetes.","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg\" class=\"kg-image\" alt=\"Connecting Users to Applications with Kubernetes Ingress Controllers\" srcset=\"https://containous.ghost.io/content/images/size/w600/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 1000w, https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 1200w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Containerization technologies such as <a href=\"https://www.docker.com/\">Docker</a> have been rapidly adopted by software teams, and the ensuing ability to easily package application components into reusable parts has given rise to the widespread use of microservices. However, these benefits have come with a price tag as developers are faced with challenges around orchestrating and managing connectivity to the underlying containers in a datacenter. <a href=\"https://kubernetes.io/\">Kubernetes</a> (k8s) is the de facto standard for teams developing cloud-native applications and directly addresses these issues. In this article, we’ll briefly review one of the most critical but perhaps confusing aspects of Kubernetes networking: The Ingress Controller.</p><h2 id=\"from-pods-to-production\">From Pods to Production</h2><p>Let’s start with a typical scenario: A development team is tasked with writing a backend API service for external applications/users. In the early phases of development, an engineer may instantiate a local instance of the containerized implementation on development machines using direct docker invocations or even docker-compose. At some point, though, they’ll want to deploy a version of the service to a shared development or staging cluster in the same manner as the final production configuration. Pods, the fundamental deployable units defined by k8s, and higher-level abstractions such as Deployment resources can help automate lifecycle management of containers during this step, but they don’t address how applications are accessed over the network. Kubernetes provides a dedicated resource abstraction for this purpose.</p><h2 id=\"exposing-applications-as-k8s-services\">Exposing applications as k8s services</h2><p>When deployed within Pods, containers are assigned IP addresses that may change over time due to a variety of lifecycle operations. This immediately poses challenges when other components need to find and establish network connections with them. The Service resource defined as part of Kubernetes networking manages these aspects automatically. Users can define Services that get associated with underlying Pods through selectors and allows them to be accessed through a user-specified service name. Where connections can be established from and how they’re implemented depends upon the Service type configured. The most commonly used service types offered by k8s are:</p><ul><li>ClusterIP</li><li>NodePort</li><li>LoadBalancer</li></ul><h3 id=\"clusterip-service-type\">ClusterIP service type</h3><p>The ClusterIP is enabled by default if no type is defined in the Service resource definition. When invoked, k8s creates a virtual cluster IP address that can be used to connect to the underlying Pods. The caveat, though, is that this IP address is routable only within the cluster itself. ClusterIP services are often used for exposing internal-only application endpoints to each other.</p><h3 id=\"nodeport-service-type\">NodePort service type</h3><p>The NodePort type provides the simplest mechanism for external access to services. Specifically, it opens a specific port (within a k8s configured port range) on every node in the cluster. Underneath, a ClusterIP service is created, and clients that attempt to connect to an exposed NodePort are routed through. While the NodePort service type extends a method to access services from outside of the cluster, it has some drawbacks including:</p><ul><li>Services can only be exposed on ports from a range (30000-32767 by default)</li><li>One port can only be mapped to a single service</li><li>Clients connect through a node and if the corresponding IP of the underlying host / VM changes, they need to be updated accordingly</li></ul><h3 id=\"loadbalancer-service-type\">LoadBalancer service type</h3><p>The LoadBalancer type is often used in cloud environments in order to automate the provisioning of external load balancers outside of the underlying k8s cluster. While this enables external network access and avoids the problem of IP addresses shifting out from underneath clients, the use of LoadBalancer Service types can quickly lead to high costs from the underlying cloud (e.g. GCE or AWS).</p><p>While the three Service types above are viable alternatives for some use cases, when application developers want to expose their services externally without the limitations of NodePort and LoadBalancer types, there’s a better alternative extended by Kubernetes networking.</p><h2 id=\"k8s-networking-and-the-ingress-resource-abstraction\">K8s networking and the Ingress resource abstraction</h2><p>Kubernetes defines a native Ingress resource abstraction that exposes HTTP and HTTPS endpoints and routes traffic based upon rules defined by the user. The Ingress resource is a natural fit when developers and devops engineers want to expose multiple underlying services through a single external endpoint and/or load balancer. The Ingress resource definition allows them to route traffic to defined Service resources based upon, for example, host and/or prefix rules. Therefore, it complements the Service resource capabilities to provide a flexible method for enabling external access. However, defining an Ingress resource on its own doesn’t actually expose services outside Kubernetes since it simply conveys a request for networking configuration.</p><h2 id=\"the-wizard-behind-the-curtain-ingress-controllers\">The wizard behind the curtain: Ingress Controllers</h2><p>Our discussion thus far has helped highlight the need for ingress resources, but it leaves open the question of how corresponding requests are acted upon. The answer comes in the form of Ingress Controllers which are responsible for consuming inbound requests and creating the corresponding routing specifications in a technology-specific manner. Typically, the specific controller installed in a k8s cluster is selected and deployed by operators. There are many potential options available, but a few illustrative examples include:</p><ul><li>AWS ALB - An instance of an Ingress Controller tied to a specific public cloud, it satisfies inbound Ingress resource requests using <a href=\"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html\">AWS Application Load Balancers</a></li><li>NGINX - Implements Ingress resources using the NGINX open source software</li><li>Traefik - A leading open source <a href=\"https://containous.ghost.io/traefik/\">Kubernetes Ingress Controller</a> that makes setting up routes between Kubernetes services and the outside world simple and reliable</li></ul><p>There need not be a strict either / or decision when it comes to <a href=\"https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/\">choosing Ingress Controllers</a>, and k8s operators can elect to deploy multiple controllers if desired. The selection process should take into consideration the benefits specific controllers like <a href=\"https://containous.ghost.io/traefik/\">Traefik</a> may provide such as:</p><ul><li>Lets Encrypt support for automated certificate management</li><li>Traffic splitting based upon custom weight definitions</li><li>Flexibly route definitions including support for name and path based routing as well as route prioritization</li><li>Custom resource definitions that provide additional controller-specific enhancements</li></ul><p>By integrating controllers that align with their use cases, development teams can enjoy a variety of capabilities provided by Kubernetes for external access without having to become networking experts.</p><p>Want to learn more about <strong>Kubernetes Ingress</strong>? <a href=\"https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes\">Check out this video</a> that describes the <strong>different patterns for deploying external load balancers in Kubernetes.</strong></p>","url":"https://containous.ghost.io/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/","canonical_url":null,"uuid":"f0bf868a-e778-4b14-bfa8-cb19bbf59318","codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e9890445df7fe004475aa62","reading_time":4}}]}},"pageContext":{"slug":"orion","limit":9,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}},"staticQueryHashes":["1274566015","2561578252","2731221146","394248586","4145280475","749840385"]}