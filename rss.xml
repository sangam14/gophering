<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Traefik Labs: Makes Networking Boring]]></title><description><![CDATA[Traefik is the world’s most popular cloud-native application networking stack, helping developers and devops build, deploy run microservices quickly and easily.]]></description><link>https://traefik.io/</link><image><url>https://traefik.io/favicon.svg</url><title>Traefik Labs: Makes Networking Boring</title><link>https://traefik.io/</link></image><generator>Ghost</generator><lastBuildDate>Tue, 22 Dec 2020 13:13:34 GMT</lastBuildDate><atom:link href="https://traefik.io/rss.xml/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[For Developers, Traefik Enterprise 2.3 Adds Support for GitOps and OpenAPI]]></title><description><![CDATA[Traefik Enterprise 2.3 introduces new features for developers and DevOps engineers, including support for GitOps practices and OpenAPI.]]></description><link>https://traefik.io/blog/traefik-enterprise-adds-support-for-gitops-and-openapi/</link><guid isPermaLink="false">Ghost__Post__5fd92aa6255eda00390e23da</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Tue, 22 Dec 2020 13:00:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg" class="kg-image" alt="For Developers, Traefik Enterprise 2.3 Adds Support for GitOps and OpenAPI" srcset="https://containous.ghost.io/content/images/size/w600/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg 1600w, https://containous.ghost.io/content/images/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><img src="https://containous.ghost.io/content/images/2020/12/Traefik-Enterprise-2.3-Adds-Support-for-GitOps-and-OpenAPI-1.jpg" alt="For Developers, Traefik Enterprise 2.3 Adds Support for GitOps and OpenAPI"/><p>IT operations teams aren’t the only ones who need an efficient, secure, easy-to-use application networking layer. Developers, architects, and DevOps pros number among Traefik’s most enthusiastic users.</p><p>Cloud-native methods – including containerization, REST APIs, and microservices – have brought networking front and center in modern software delivery. As a result, application developers need tools that give them greater control over network infrastructure, and the team at Traefik Labs is always working to see that their needs are met.</p><p>Traefik Enterprise 2.3, the latest version of the commercially supported, production-grade edition of Traefik, includes two new features aimed squarely at developers and DevOps engineers. The first is support for GitOps practices when deploying Traefik, while the second leverages the OpenAPI standard to make service discovery and integration easier. Let’s take a look at each.</p><h2 id="infrastructure-automation-with-gitops"><strong>Infrastructure Automation with GitOps</strong></h2><!--kg-card-begin: markdown--><p>Briefly, <a href="https://www.gitops.tech/" target="_blank" rel="nofollow">GitOps</a> is a method of implementing continuous delivery (CD) for cloud-native applications that uses Git repositories as the source of truth. The technique was originally developed at Weaveworks for use with Kubernetes but has since been adapted to other environments. The central idea is to make developers comfortable when operating infrastructure by allowing them to do it using tools with which they are already familiar.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>In the past, much of infrastructure configuration relied on command-line tools, and this was true of Traefik Enterprise, as well. It supplied the <code>teectl</code> tool, which eliminates some of the drudgework of configuration and installation, but this approach isn’t well-suited to CD pipelines.</p>
<!--kg-card-end: markdown--><p>Traefik Enterprise 2.3 introduces a new internal service to further streamline the process for a GitOps flow for Kubernetes. The procedure is as simple as specifying your Traefik Enterprise license in a Kubernetes Secret, creating a ConfigMap with your static configuration, and querying the service via HTTP to generate your installation manifest, like so:</p><!--kg-card-begin: markdown--><p><code>curl &quot;https://install.enterprise.traefik.io/v2.3&quot; --output manifest.yaml</code></p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Once you’ve reviewed the manifest and made any necessary modifications, you can store it in a Git repository in the appropriate directory structure, and then integrate it with GitOps tools such as <a href="https://argoproj.github.io/argo-cd/" target="_blank" rel="nofollow">Argo CD</a>.</p>
<!--kg-card-end: markdown--><p>The advantages of this approach are several. For one thing, Git automatically keeps a version history of your config files, so you can easily roll back to an earlier version if necessary. Also, Traefik Enterprise’s ability to update the static configuration without a restart means you can apply updates with minimal interruption of service. To learn more about GitOps-style installation, <a href="https://doc.traefik.io/traefik-enterprise/installing/kubernetes/gitops/">consult the documentation</a>.</p><h2 id="service-visibility-with-openapi"><strong>Service Visibility with OpenAPI</strong></h2><!--kg-card-begin: markdown--><p>As services proliferate on the network, so do the connections between them. That means APIs, and lots of them. Staying on top of them all can be challenging for any developer, which is why Traefik Enterprise 2.3 incorporates a new API Portal built around the <a href="https://www.openapis.org/" target="_blank" rel="nofollow">OpenAPI specification</a>.</p>
<!--kg-card-end: markdown--><p>OpenAPI (initially known as Swagger) is a language-agnostic interface description language for REST APIs. The API descriptions themselves are defined in JSON files. The idea is to make it easier to auto-generate consistent reference documentation for service APIs, no matter who designed and implemented them.</p><!--kg-card-begin: markdown--><p>To use OpenAPI descriptions with Traefik Enterprise, simply enable the new API Portal feature by editing the static configuration to include a path (for example, <code>spec.json</code>) to where the JSON files can be found on each service entrypoint. From there, anyone with access can browse the catalog of the services and their accompanying APIs from Traefik Enterprise’s internal web UI:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://lh6.googleusercontent.com/9GR3S1hfXIGNjLLMwppW07wlFXhiFFxkcS-QffLpLO2UHNnoTSufM1Czo8fpseTBFc8UsxnjD88_fAH0hZ4-ltylQRSDgCZJ4BrnK_m6P61aVlol2m_R2Pak4jZIYbU1GGZHr8tU" class="kg-image" alt="For Developers, Traefik Enterprise 2.3 Adds Support for GitOps and OpenAPI"/></figure><p>What’s more, because the API Portal is just another service managed by Traefik, administrators can choose from the full range of access controls provided by Traefik Middlewares, including Traefik Enterprise’s exclusive, enterprise-grade authentication methods.</p><!--kg-card-begin: markdown--><p>To view some examples of how to write API descriptions using OpenAPI, consult the project’s <a href="https://github.com/OAI/OpenAPI-Specification/tree/master/examples" target="_blank" rel="nofollow">public specification repository</a>. More information on how to use OpenAPI with Traefik Enterprise is available in the <a href="https://doc.traefik.io/traefik-enterprise/operations/apiportal/">documentation</a>.</p>
<!--kg-card-end: markdown--><h2 id="empowering-developers"><strong>Empowering Developers</strong></h2><p>These latest features are just two examples of the ways in which Traefik Enterprise helps give developers greater control over the environments where their apps and services run. As cloud-native architectures continue to encourage organizations to adopt methods like DevOps and site reliability engineering (SRE), you can expect Traefik Labs to continue to deliver features that support this new model.</p><p>Other examples of developer-centric technologies that are baked into Traefik Enterprise include support for <a href="https://traefik.io/blog/lock-down-your-network-with-traefik-enterprise-and-vault/">certificate management using HashiCorp Vault</a>; authentication tools including JWT, LDAP, and <a href="https://traefik.io/blog/unlock-the-potential-of-data-apis-with-strong-authentication-and-traefik-enterprise/">OpenID Connect</a>; and a <a href="https://doc.traefik.io/traefik-enterprise/features/#service-mesh">service mesh</a> layer that enables fine-grained control over inter-service communication. </p><p>To learn more about how Traefik Enterprise can help your organization boost developer productivity and reduce time-to-delivery, contact Traefik Labs to <a href="https://info.traefik.io/en/request-demo-traefik-enterprise">request a demo</a>. Or better yet, sign up for a <a href="https://info.traefik.io/get-traefik-enterprise-free-for-30-days">30-day free trial</a>  and explore the features of Traefik Enterprise for yourself.</p>]]></content:encoded></item><item><title><![CDATA[Unleash the Power of Traefik for High Availability Load Balancing]]></title><description><![CDATA[What if it was possible to achieve true high availability using only Traefik Proxy, Traefik Enterprise, and a few other, easy-to-deploy open-source networking tools?]]></description><link>https://traefik.io/blog/unleash-the-power-of-traefik-for-high-availability-load-balancing/</link><guid isPermaLink="false">Ghost__Post__5fd818d9255eda00390e23b8</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Tue, 15 Dec 2020 06:42:35 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg" class="kg-image" alt="Unleash the Power of Traefik for High Availability Load Balancing" srcset="https://containous.ghost.io/content/images/size/w600/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg 1600w, https://containous.ghost.io/content/images/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/12/Unleash-the-Power-of-Traefik-for-High-Availability-Load-Balancing-1.jpg" alt="Unleash the Power of Traefik for High Availability Load Balancing"/><p>Every Traefik user knows that it makes the job of application networking easier. At Traefik Labs, we like to say Traefik “makes networking boring.” And yet, because Traefik is so easy to use, it’s also easy to overlook how powerful it is.</p><p>Traefik has earned a strong following among organizations that develop cloud-native applications, due to how effortlessly it integrates with technologies like Docker and Kubernetes. But the same capabilities that allow it to network containers can also help solve bigger networking challenges.</p><p>One use case for which there is growing demand is high availability (HA). With the proliferation of the managed SaaS application delivery model, ensuring maximum uptime and consistent quality of service is more important than ever. Achieving this for a global market remains a challenge.</p><h2 id="home-grown-ha"><strong>Home-Grown HA</strong></h2><p>For organizations that want to achieve true cloud-scale high availability, the solution is often to turn to proprietary cloud-based solutions or to deploy dedicated hardware load balancers. Yet these approaches don't mesh well with modern, cloud-native application development methods. Not only does it increase costs and time-to-delivery, but it takes network configuration out of the hands of developers, making it harder to employ practices like agile development, DevOps, and site reliability engineering (SRE).</p><p>But what if there was a different approach? What if it was possible to achieve true high availability using only Traefik Proxy, Traefik Enterprise, and a few other, easy-to-deploy open-source networking tools? We recently published a new <a href="https://info.traefik.io/request-technical-paper-traefik-ha">Expert Guide</a> that explains how to do just that.</p><p>In the paper, you’ll explore three scenarios designed to increase total traffic capacity and uptime without resorting to complex or proprietary systems:</p><h2 id="case-1-active-passive-nodes"><strong>Case 1: Active/Passive Nodes</strong></h2><p>In this first case, you’ll learn how to set up a two-node cluster of Traefik instances, where one of them is active at any given time. Should the active instance fail, the other instance automatically takes over.</p><h2 id="case-2-kubernetes-ingress"><strong>Case 2: Kubernetes Ingress</strong></h2><p>Building on the first case, you’ll see how to use Traefik Enterprise as a multi-node Kubernetes Ingress controller, complete with SSL termination and a rate-limiting feature to prevent network congestion from excessive requests.</p><h2 id="case-3-cloud-scale-load-balancing"><strong>Case 3: Cloud-Scale Load Balancing</strong></h2><p>Finally, you’ll use Traefik Enterprise and additional open source tools to build a truly enterprise-grade network environment that’s capable of scaling to handle massive amounts of requests.</p><h2 id="sounds-interesting-how-can-i-learn-more">Sounds interesting, how can I learn more?</h2><p>If any of this sounds like an itch you’ve been eager to scratch within your own organization, <a href="https://info.traefik.io/request-technical-paper-traefik-ha">download the paper</a> and dive right in. You’ll receive a link to the Expert Guide, which includes instructions on how to download the accompanying configuration files for the walk-through.Also, if you want to begin building hands-on experience with Traefik Enterprise, there are two great ways to explore the high availability features it has to offer. The first is to contact Traefik Labs and<a href="https://info.traefik.io/en/request-demo-traefik-enterprise"> request a guided demo</a> that will help you understand how Traefik Enterprise can benefit your organization. Or, if you’re ready to roll up your sleeves, sign up for a<a href="https://info.traefik.io/get-traefik-enterprise-free-for-30-days"> 30-day free trial</a> and see for yourself how easy it is to get started.</p>]]></content:encoded></item><item><title><![CDATA[From Zero to Hero: Getting Started with k0s and Traefik]]></title><description><![CDATA[K0s is a new Kubernetes distribution from Mirantis. It's similar to Rancher Labs' K3s, yet it ships only the bare minimum of extensions. K0s is a new Kubernetes distribution from Mirantis. This post covers how to configure k0s to include Traefik and begin routing your applications with CRDs.]]></description><link>https://traefik.io/blog/from-zero-to-hero-getting-started-with-k0s-and-traefik/</link><guid isPermaLink="false">Ghost__Post__5fce60e016db8f0039b4334b</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Kevin Crawley]]></dc:creator><pubDate>Tue, 08 Dec 2020 16:10:36 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/12/Getting-Started-with-k0s-and-Traefik-2.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/12/Getting-Started-with-k0s-and-Traefik-1.png" class="kg-image" alt="From Zero to Hero: Getting Started with k0s and Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/12/Getting-Started-with-k0s-and-Traefik-1.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Getting-Started-with-k0s-and-Traefik-1.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Getting-Started-with-k0s-and-Traefik-1.png 1600w, https://containous.ghost.io/content/images/2020/12/Getting-Started-with-k0s-and-Traefik-1.png 2400w" sizes="(min-width: 720px) 720px"/></figure><!--kg-card-begin: markdown--><img src="https://containous.ghost.io/content/images/2020/12/Getting-Started-with-k0s-and-Traefik-2.png" alt="From Zero to Hero: Getting Started with k0s and Traefik"/><p><a href="https://k0sproject.io/" target="_blank" rel="nofollow">K0s</a> is a new Kubernetes distribution from Mirantis. It's similar to Rancher Labs' K3s, yet it ships with only the bare minimum of extensions. This allows flexibility for users who want to customize it to their needs by defining their own ingress, storage, and other controllers in the CRD manifest, configuring the cluster during bootstrap.</p>
<!--kg-card-end: markdown--><p>In the examples below, I’ll guide you through how to accomplish getting a functioning Kubernetes cluster by:</p><ol><li>Installing k0s on a clean Linux VM</li><li>Configuring Traefik and MetalLB as an extension</li><li>Starting k0s</li><li>Deploying the Traefik Dashboard IngressRoute and an example service</li></ol><h2 id="step-1">Step 1</h2><p>Before we start, you should plan to do this on a clean install of Linux, probably in a VM. You will be running k0s as a server/worker, and the worker installs components into the <code>/var/lib</code> filesystem as root (so root access is a requirement). My understanding is there are plans to allow non-root workers in the future. Hopefully, in addition to non-root, the k0s binary will allow worker installations in a configurable location.</p><blockquote>Note: Cleanly shutting down and wiping the cluster is not a feature yet in the k0s binary. For now, rebooting the system and wiping <code>/var/lib/k0s</code> is the easiest option.</blockquote><p>Once you have a clean Linux VM (I’m using Ubuntu 20.04.1), you’ll want to install the Helm and <code>kubectl</code> binaries.</p><pre><code class="language-bash">curl -O https://get.helm.sh/helm-v3.4.1-linux-amd64.tar.gz
tar xvzf helm-v3.4.1-linux-amd64.tar.gz
sudo mv linux-amd64/helm /usr/local/bin

curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin</code></pre><p>Once those are installed, install the k0s binary, create the working directory for k0s, and create a default config.</p><blockquote>Note: The installer and running k0s itself both require root</blockquote><pre><code class="language-bash"># make sure you're running as root
curl -sSLf get.k0s.sh | sh
# create the working directory and set the permissions
mkdir -p /var/lib/k0s &amp;&amp; chmod 755 /var/lib/k0s
# create the default config
k0s default-config &gt; /var/lib/k0s/k0s.yaml</code></pre><h2 id="step-2">Step 2</h2><!--kg-card-begin: markdown--><p>In this step, you’ll configure Traefik and <a href="https://metallb.universe.tf/" rel="nofollow">MetalLB</a> as extensions that will be installed during the cluster's bootstrap. Traefik will function as an ingress controller and MetalLB will allow you to access services from a logical IP address deployed as a <a href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer" rel="nofollow">service load balancer</a>. You will want to have a small range of IP addresses that are addressable on your network, preferably outside the range of your DHCP server.</p>
<!--kg-card-end: markdown--><p>Modify the newly created k0s.yaml file in <code>/var/lib/k0s/k0s.yaml</code>:</p><pre><code class="language-yaml">apiVersion: k0s.k0sproject.io/v1beta1
kind: Cluster
metadata:
  name: k0s
...
extensions:
  helm:
    repositories:
    - name: traefik
      url: https://helm.traefik.io/traefik
    - name: bitnami
      url: https://charts.bitnami.com/bitnami
    charts:
    - name: traefik
      chartname: traefik/traefik
      version: "9.11.0"
      namespace: default
    - name: metallb
      chartname: bitnami/metallb
      version: "1.0.1"
      namespace: default
      values: |2
        configInline:
          address-pools:
          - name: generic-cluster-pool
            protocol: layer2
            addresses:
            - 172.16.100.215-172.16.100.220</code></pre><p>Again, be sure to provide a range of IPs for MetalLB that are addressable on your network if you want to access the LoadBalancer and Ingress services from outside this machine.</p><h2 id="step-3">Step 3</h2><p>Now it's time to run k0s and let it automatically set up the server and worker, and deploy and configure Traefik and MetalLB:</p><pre><code class="language-bash">cd /var/lib/k0s
k0s server --enable-worker &lt;/dev/null &amp;&gt;/dev/null &amp;</code></pre><p>After a minute or two, you should be able to access the cluster using the certificate generated by k0s, located in <code>/var/lib/k0s/pki/admin.conf</code>, and see that MetalLB was deployed along with the Traefik Ingress Controller.</p><pre><code class="language-bash">root@k0s-host ➜ export KUBECONFIG=/var/lib/k0s/pki/admin.conf
root@k0s-host ➜ kubectl get all
NAME                                                 READY   STATUS    RESTARTS   AGE
pod/metallb-1607085578-controller-864c9757f6-bpx6r   1/1     Running   0          81s
pod/metallb-1607085578-speaker-245c2                 1/1     Running   0          60s
pod/traefik-1607085579-77bbc57699-b2f2t              1/1     Running   0          81s

NAME                         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE
service/kubernetes           ClusterIP      10.96.0.1        &lt;none&gt;           443/TCP                      96s
service/traefik-1607085579   LoadBalancer   10.105.119.102   172.16.100.215   80:32153/TCP,443:30791/TCP   84s

NAME                                        DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE
daemonset.apps/metallb-1607085578-speaker   1         1         1       1            1           kubernetes.io/os=linux   87s

NAME                                            READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/metallb-1607085578-controller   1/1     1            1           87s
deployment.apps/traefik-1607085579              1/1     1            1           84s

NAME                                                       DESIRED   CURRENT   READY   AGE
replicaset.apps/metallb-1607085578-controller-864c9757f6   1         1         1       81s
replicaset.apps/traefik-1607085579-77bbc57699              1         1         1       81s</code></pre><p>Take note of the IP address assigned to the Traefik Load Balancer here:</p><pre><code>NAME                         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE
service/traefik-1607085579   LoadBalancer   10.105.119.102   172.16.100.215   80:32153/TCP,443:30791/TCP   84s</code></pre><p>You will need the <code>EXTERNAL-IP</code> (in this case, <code>172.16.100.215</code>) later, when accessing Ingress resources on your cluster.</p><h2 id="step-4">Step 4</h2><ul><li>Deploy the Traefik dashboard</li><li>Deploy the sample “whoami” service</li></ul><p>Now that you have a functional and addressable load balancer on your cluster, you can easily deploy the Traefik dashboard and access it from anywhere on your local network (provided that you configured MetalLB with an addressable range).</p><p>Create the Traefik Dashboard <a href="https://doc.traefik.io/traefik/providers/kubernetes-crd/">IngressRoute</a> in a YAML file:</p><pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: dashboard
spec:
  entryPoints:
    - web
  routes:
    - match: PathPrefix(`/dashboard`) || PathPrefix(`/api`)
      kind: Rule
      services:
        - name: api@internal
          kind: TraefikService</code></pre><p>And deploy it:</p><pre><code class="language-bash">root@k0s-host ➜ kubectl apply -f traefik-dashboard.yaml
ingressroute.traefik.containo.us/dashboard created</code></pre><p>You can now access it from your browser by visiting <code>http://172.16.100.215/dashboard/</code>:</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/12/image.png" class="kg-image" alt="From Zero to Hero: Getting Started with k0s and Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/12/image.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/image.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/image.png 1600w, https://containous.ghost.io/content/images/2020/12/image.png 1743w" sizes="(min-width: 720px) 720px"/></figure><p>Great, now let’s deploy a simple “whoami” service.</p><!--kg-card-begin: markdown--><p>Create the <code>whoami</code> Deployment, Service, and <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="nofollow">Kubernetes Ingress</a> manifest:</p>
<!--kg-card-end: markdown--><pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: whoami-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: whoami
  template:
    metadata:
      labels:
        app: whoami
    spec:
      containers:
      - name: whoami-container
        image: containous/whoami
---
apiVersion: v1
kind: Service
metadata:
  name: whoami-service
spec:
  ports:
  - name: http
    targetPort: 80
    port: 80
  selector:
    app: whoami
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: whoami-ingress
spec:
  rules:
  - http:
      paths:
      - path: /whoami
        pathType: Exact
        backend:
          service:
            name: whoami-service
            port:
              number: 80</code></pre><p>And now, deploy and test it…</p><pre><code class="language-bash">root@k0s-host ➜ kubectl apply -f whoami.yaml
deployment.apps/whoami-deployment created
service/whoami-service created
ingress.networking.k8s.io/whoami-ingress created
# test the route
root@k0s-host ➜ curl http://172.16.100.215/whoami
Hostname: whoami-deployment-85bfbd48f-7l77c
IP: 127.0.0.1
IP: ::1
IP: 10.244.214.198
IP: fe80::b049:f8ff:fe77:3e64
RemoteAddr: 10.244.214.196:34858
GET /whoami HTTP/1.1
Host: 172.16.100.215
User-Agent: curl/7.68.0
Accept: */*
Accept-Encoding: gzip
X-Forwarded-For: 172.16.100.77
X-Forwarded-Host: 172.16.100.215
X-Forwarded-Port: 80
X-Forwarded-Proto: http
X-Forwarded-Server: traefik-1607085579-77bbc57699-b2f2t
X-Real-Ip: 172.16.100.77</code></pre><h2 id="summary">Summary</h2><!--kg-card-begin: markdown--><p>This post covered installing k0s, setting up a fully functional Load Balancer and Ingress controller for use in your local environment. From here, you could use a tool such as <a href="https://ngrok.io" target="_blank" rel="nofollow">ngrok</a> to expose your Load Balancer to the world and <a href="https://doc.traefik.io/traefik/v2.0/user-guides/crd-acme/">set up Let’s Encrypt</a> so you can provision your own SSL certificates.</p>
<p>The design of k0s as a single binary installer that allows modular customizability makes it a unique offering in the Kubernetes community. You can learn more about how to leverage Kubernetes Ingress with Traefik on <a h="" ref="https://traefik.io/solutions/kubernetes-ingress/">our site</a>. In addition, you can learn more about installing k0s on <a href="https://www.mirantis.com/blog/how-to-set-up-k0s-kubernetes-a-quick-and-dirty-guide/" rel="nofollow">Mirantis' blog</a>. While k0s is still relatively new to the scene, I hope this post gives you an idea of what it’s capable of and how you can start experimenting with your own customized Kubernetes setup.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Observing Kubernetes Ingress Traffic using Metrics]]></title><description><![CDATA[Monitoring Kubernetes ingress traffic is a critical part of an effective strategy for detecting and managing potential issues in real-time.]]></description><link>https://traefik.io/blog/observing-kubernetes-ingress-traffic-using-metrics/</link><guid isPermaLink="false">Ghost__Post__5fc64b2616db8f0039b432b7</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Kevin Crawley]]></dc:creator><pubDate>Thu, 03 Dec 2020 02:13:39 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/12/Blog@2x-2.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/12/Blog@2x.png" class="kg-image" alt="Observing Kubernetes Ingress Traffic using Metrics" srcset="https://containous.ghost.io/content/images/size/w600/2020/12/Blog@2x.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Blog@2x.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Blog@2x.png 1600w, https://containous.ghost.io/content/images/2020/12/Blog@2x.png 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/12/Blog@2x-2.png" alt="Observing Kubernetes Ingress Traffic using Metrics"/><p>Enterprise engineering teams are continuously striving to deliver the best user facing experience possible for the applications they manage. Adopting Kubernetes (k8s) is helping in this regard by allowing organizations to easily manage lifecycle operations for workloads in a repeatable manner. Because of this, Kubernetes has been a key enabler towards accelerating implementation of purpose-specific services to meet business requirements. While k8s provides a strong foundation for stable operations, proactive measures must still be taken to avoid negative impacts including performance or functional issues. Monitoring Kubernetes ingress traffic is a critical part of an effective strategy for detecting and managing potential issues in real-time. In this article, we’ll discuss this topic including:</p><ul><li>Where to integrate in a Kubernetes system to obtain metrics</li><li>How monitoring data can be stored effectively</li><li>What visualization tools can be used to understand metrics data</li></ul><h3 id="obtaining-ingress-traffic-metrics">Obtaining ingress traffic metrics</h3><p>Where and how ingress traffic network statistics can be collected depends upon the <a href="https://traefik.io/blog/combining-ingress-controllers-and-external-load-balancers-with-kubernetes/">adopted approach</a> for exposing services. Let’s dive into the two strategies often used with Kubernetes:</p><ol><li>External Load Balancers</li><li>Ingress Controllers</li></ol><!--kg-card-begin: markdown--><h3 id="metricswithexternalloadbalancers">Metrics with External Load Balancers</h3>
<p>When service configurations are defined appropriately by operators, Kubernetes can automate the deployment of managed load balancers. For example, when launched within AWS, a Kubernetes Service can instantiate a cloud load balancer instance without any out-of-band provisioning steps required by developers. The implementations of these load balancers are black boxes, but they all expose mechanisms for monitoring and tracing. In the case of AWS, time-series data and request logs can be collected and accessed using accompanying integrated services such as CloudWatch and CloudTrail. One potential drawback of these tightly integrated proprietary services is that these systems often do not integrate easily with external data storage and visualization tools.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png" class="kg-image" alt="Observing Kubernetes Ingress Traffic using Metrics" srcset="https://containous.ghost.io/content/images/size/w600/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png 1600w, https://containous.ghost.io/content/images/2020/12/Capturing-Metrics-from-Load-Balancers-and-Ingress-Controllers.png 2310w" sizes="(min-width: 720px) 720px"><figcaption>Capturing Metrics from Load Balancers and Ingress Controllers</figcaption></img></figure><!--kg-card-begin: markdown--><h3 id="metricswithingresscontrollers">Metrics with Ingress Controllers</h3>
<p>When thinking about monitoring Ingress Controllers, it’s useful to keep in mind that they are implemented as standard Kubernetes applications. This means that any monitoring approaches adopted by organizations to track the health and liveliness of k8s workloads can be applied to Ingress Controllers. Tracking network traffic statistics in particular, however, requires taking advantage of controller-specific mechanisms. Similar to external load balancers, the specific metrics exposed vary depending on the controller, but any production quality implementation will provide built-in metric collection capabilities that can be integrated with an external data storage system.</p>
<!--kg-card-end: markdown--><h3 id="data-storage-for-ingress-monitoring">Data storage for Ingress Monitoring</h3><p>Selecting a data storage solution is an important part of defining a traffic monitoring architecture for Ingress Controllers. There are two general categories of implementations that one can choose between: </p><ol><li>Self-managed (typically open source) database systems</li><li>Managed SaaS database systems.</li></ol><!--kg-card-begin: markdown--><p>While applications often use general-purpose SQL databases for their structured data, with monitoring data it’s advantageous to utilize a system optimized for storing and querying time-series data. There are multiple open source options for time-series databases, including <a href="https://www.influxdata.com/" rel="nofollow">InfluxDB</a> and <a href="https://prometheus.io/" rel="nofollow">Prometheus</a>, either is typically deployed in the same k8s cluster as the Ingress controller. Once these systems are provisioned, it’s just a matter of configuring settings for the Ingress controller to enable automated metric data collection in the database.</p>
<p>Some teams may prefer to take the route of a fully managed data provider to avoid the overheads of maintaining a database. There are options such as <a href="https://datadoghq.com" rel="nofollow">DataDog</a> or <a href="https://www.elastic.co/elastic-stack" rel="nofollow">Elasticsearch</a> available that meet this demand in the form of a cloud-based SaaS monitoring platform. The providers are well supported by controller implementations due to their popularity, and Ingress controllers such as Traefik are designed to easily integrate with it.</p>
<h2 id="visualizingingresstrafficmetrics">Visualizing Ingress Traffic Metrics</h2>
<p>Getting metrics into a database is a first step towards effective ingress monitoring, but providing engineering teams with actionable information in real-time requires being able to easily interpret the information. Visualizing time-series data is the most effective way to convert raw metrics into human-digestible form. For example, visualizations are often combined into dashboards and used by Site Reliability Engineers to track the status of services and as an information source when live-site issues occur. <a href="https://grafana.com/" rel="nofollow">Grafana</a> is a widely adopted open source software for data visualization which works well with databases such as InfluxDB and Prometheus. Alternatively, the managed solutions mentioned earlier, such as DataDog, provide built-in visualization capabilities as part of their holistic platforms.</p>
<p><img src="https://containous.ghost.io/content/images/2020/12/2020-12-01_8-53-38.png" alt="Observing Kubernetes Ingress Traffic using Metrics"/></p>
<p><img src="https://containous.ghost.io/content/images/2020/12/2020-12-01_8-16-14.png" alt="Observing Kubernetes Ingress Traffic using Metrics"/></p>
<h2 id="summary">Summary</h2>
<p>Monitoring ingress traffic is an important part of managing the health of external-facing services. As outlined in this article, best-of-breed metric storage and visualization technologies can be adopted for Kubernetes monitoring by virtue of capabilities provided by Ingress Controller implementations such as Traefik. This means organizations can easily rollout effective monitoring for k8s clusters providing peace of mind for engineering teams and end-users.</p>
<p>Furthermore, Traefik metrics and reporting are available through Traefik Enterprise and Traefik Pilot. You can <a href="https://info.traefik.io/en/request-demo-traefik-enterprise">sign up for a demo</a> of Traefik Enterprise today, and <a href="https://traefik.io/traefik-pilot/">Traefik Pilot</a> is already available for users of the popular open source Traefik Proxy project.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Traefik Hackaethon Is a Wrap]]></title><description><![CDATA[Traefik Labs inaugural Traefik Hackaethon is a wrap. The event took place over three days and included multiple contributors from around the world. ]]></description><link>https://traefik.io/blog/traefik-hackaethon-is-a-wrap/</link><guid isPermaLink="false">Ghost__Post__5fb434904a99b50039ce6d86</guid><category><![CDATA[Blog]]></category><category><![CDATA[Community]]></category><dc:creator><![CDATA[Kevin Crawley]]></dc:creator><pubDate>Tue, 24 Nov 2020 05:42:29 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/11/Traefik-Hackaethon-Is-a-Wrap.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg" class="kg-image" alt="Traefik Hackaethon Is a Wrap" srcset="https://containous.ghost.io/content/images/size/w600/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg 1600w, https://containous.ghost.io/content/images/2020/11/Traefik-Hackaethon-Is-a-Wrap-1.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/11/Traefik-Hackaethon-Is-a-Wrap.jpg" alt="Traefik Hackaethon Is a Wrap"/><p>Traefik Labs inaugural <a href="https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/">Traefik Hackaethon</a> is a wrap. The event took place over three days on a Discord server that included contributors from around the world. Over 50 individuals joined the event and contributed several new plugins for Traefik, multiple bug fixes for Yaegi, and new features and capabilities for Traefik itself. This event was the first time Traefik Labs officially organized a hackathon. We couldn’t be more pleased with the collaboration between first-time contributors and long-time maintainers within our community.</p><!--kg-card-begin: markdown--><h2 id="contributionsarewelcomehere">Contributions Are Welcome Here</h2>
<!--kg-card-end: markdown--><p>There are two distinct categories of contributions for this event: new plugins for <a href="https://pilot.traefik.io/">Traefik Pilot</a> and pull requests for our open source projects <a href="https://github.com/traefik/traefik">Traefik</a> and <a href="https://github.com/traefik/yaegi">Yaegi</a>. Over a dozen individual contributors created new plugins, and we were pleasantly surprised by contributions to our open source projects in the form of new features, bug reports, and other improvements.</p><p>In this post, I’ll cover the contributions that the team was most impressed with and which were awarded the grand prizes. In addition to the grand prizes, several others deserve mention for their collective efforts, and I’ll cover those too! I want to give a special thanks to the engineering team at Traefik for engaging with the community and working with them to bring their ideas to life.</p><p>The entire team is looking forward to the next time we do this, and I’ll talk a little bit about that at the end of this post.</p><!--kg-card-begin: markdown--><h2 id="thegrandprizes">The Grand Prizes</h2>
<p>One of the newest features of Traefik is support for adding customized functionality to the processing of requests handled by the Traefik Proxy. These are called Traefik Plugins, and nearly all ten bounties were claimed by our contributors! Each of the grand prizes went to a team or individual who contributed a plugin. The second prize has a bit of a caveat attached to it, but more on that later.</p>
<h3 id="firstprizeteamfail2ban">First Prize - Team Fail2Ban</h3>
<p><a href="https://pilot.traefik.io/plugins/280093067746214409/fail2-ban">https://pilot.traefik.io/plugins/280093067746214409/fail2-ban</a></p>
<p><a href="https://pilot.traefik.io/plugins/280093067746214409/fail2-ban"><img style="float: right; margin: 10px; width: 260px;" src="https://containous.ghost.io/content/images/2020/11/fail2ban-snap.png" alt="Traefik Hackaethon Is a Wrap"/></a></p>
<p>The first prize went to a team that was formed by a few contributors who had earlier worked on another plugin named <a href="https://pilot.traefik.io/plugins/279923829278507529/header-transformation">Header Transformation</a> (more about that below). One of the contributors not only produced a <a href="https://blog.moulard.org/traefik-hackaethon/">great blog post</a> about their experience with the event, but they came together to create a handy plugin that will block requests originating from a source that fails to authenticate after a specific number of times. While the concept of <a href="https://en.wikipedia.org/wiki/Fail2ban" rel="nofollow">Fail2ban</a> isn’t necessarily new, nor is the implementation of it within a reverse proxy, this is the first time it’s become accessible without the use of external dependencies, complex <a href="https://en.wikipedia.org/wiki/Iptables" rel="nofollow">iptables</a>, or integrations with commercial packages. The implementation is complete and functionality impressive, given the tight deadlines and scope of the plugin. Thank you to Tom and the team for putting together two great plugins.</p>
<h3 id="secondprizeteambrotli">Second Prize - Team Brotli</h3>
<p><a href="https://github.com/traefik/yaegi/pulls?q=is%3Apr+author%3Arsteube">https://github.com/traefik/yaegi/pulls?q=is%3Apr+author%3Arsteube</a></p>
<p><a href="https://github.com/traefik/yaegi/pulls?q=is%3Apr+author%3Arsteube"><img style="float: right; margin: 10px; width: 260px" src="https://containous.ghost.io/content/images/2020/11/brotli-snap.png" alt="Traefik Hackaethon Is a Wrap"/></a></p>
<p>This plugin (that is still in progress) gets the second place award after the creator worked to implement a compression algorithm ported entirely over to Go, which coincidentally helped us bring even more compatibility to our <a href="https://github.com/traefik/yaegi">runtime Go interpreter Yaegi</a>. When we kicked off this Hackathon, we knew that the underlying engine that interprets code in real time, usually compiled, is still considered experimental. That didn’t stop this contributor. He worked all three days with Marc, the Yaegi project lead, to identify and fix numerous issues they found while incorporating the ported compression algorithm. This work led to several PRs and improvements made by the author and the Yaegi team. While the plugin wasn’t eligible for the plugin bounty, we felt his contributions to the Yaegi project were so impactful that this contributor deserved the second grand prize.</p>
<h3 id="thirdprizeteamcontainersondemand">Third Prize - Team Containers On-Demand</h3>
<p><a href="https://pilot.traefik.io/plugins/280027003970650633/containers-on-demand">https://pilot.traefik.io/plugins/280027003970650633/containers-on-demand</a></p>
<p><a https:="" containous.ghost.io="" blog="" traefik-hackaethon-is-a-wrap="" href=""><img style="float: right; margin: 10px; width: 260px;" src="https://containous.ghost.io/content/images/2020/11/cod-snap.png" alt="Traefik Hackaethon Is a Wrap"/></a></p>
<p>Imagine being able to scale up services from zero with Traefik when the load balancer receives a request. Two developers on this team hatched this idea together after discussing the concept and built a service that integrates with Docker Swarm to interact with the Docker API. The judges felt this plugin deserved the grand prize for two distinct reasons: First, developers’ persistence in finding a solution that works given the design constraints; and second, their creativity in deciding what to build. The plugin engine was created for users to be creative and bend Traefik in ways the developers at Traefik Labs might never have considered. This team’s contribution fits nicely into the vision the team had.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="pluginbounties">Plugin Bounties</h2>
<p>Each of the above plugins was awarded a bounty (except for Brotli, since it’s technically still a WIP), but there are a few plugins that deserve mention.</p>
<h3 id="traefikfaultinjection">Traefik Fault Injection</h3>
<p><a href="https://pilot.traefik.io/plugins/279918789803378185/fault-injection">https://pilot.traefik.io/plugins/279918789803378185/fault-injection</a></p>
<p>Purposely introducing faults and errors into an environment is a practice known as chaos engineering. This plugin allows for failures to be induced programmatically via the load balancer. It can be used to purposely inject failures of a specific type and rate to any service. Teams that are looking to build for resilience and solutions engineers who are looking to induce failures without having to modify application source code may find this plugin useful.</p>
<h3 id="headertransformation">Header Transformation</h3>
<p><a href="https://pilot.traefik.io/plugins/279923829278507529/header-transformation">https://pilot.traefik.io/plugins/279923829278507529/header-transformation</a></p>
<p>Authored by Team Fail2ban, this plugin allows for headers to be modified based on simple regex-based rulesets: <code>Set</code>, <code>Rename</code>, <code>Del</code>, and <code>Join</code>. Using these rules, operators can modify headers sent from the client before they reach their service destination.</p>
<h3 id="datadogevent">Datadog Event</h3>
<p><a href="https://pilot.traefik.io/plugins/280005610925195785/datadog-event">https://pilot.traefik.io/plugins/280005610925195785/datadog-event</a></p>
<p>Operators who install this plugin may generate an event in Datadog when a response code or contents matches a regex-based rule.</p>
<h2 id="opensourcecontributions">Open Source Contributions</h2>
<p>We saw several PRs opened against Yaegi and Traefik Proxy. These included bug fixes, documentation improvements, new features, and capabilities. Below are two of the larger pull requests proposed, and while they’re both incomplete, we want to thank the authors for their contribution and hard work.</p>
<h3 id="exponentialbackoffforretrymiddleware">Exponential Backoff for Retry Middleware</h3>
<p><a href="https://github.com/traefik/traefik/pull/7460">https://github.com/traefik/traefik/pull/7460</a></p>
<p>The author of this PR initially tried to implement a DynamoDB cache plugin, but he encountered a limitation with the AWS SDK and Yaegi. Instead of giving up, he jumped right into an open issue and started working with the open source engineers at Traefik to develop a solution.</p>
<h3 id="fluentdloghook">FluentD Log Hook</h3>
<p><a href="https://github.com/bearstech/traefik/pull/1">https://github.com/bearstech/traefik/pull/1</a></p>
<p>This work is incomplete, but it seems to be ninety-percent there. This feature, when merged, would allow operators of Traefik to directly connect access logs to a log exporter, rather than having to use a log scraping implementation. We’re looking forward to seeing this feature finished up and opened as a PR.</p>
<h2 id="anditsawrap">And ... It's A Wrap</h2>
<p><img src="https://containous.ghost.io/content/images/2020/11/Haekaton-scene.png" alt="Traefik Hackaethon Is a Wrap"/></p>
<p>We couldn’t be more excited to see the contributions and collaboration at our first Traefik Hackaethon. We’ll be doing this again next year and have already started planning for the spring. In the meantime, our team would love to hear from you on ideas for themes and bounties. We’ve <a href="https://community.traefik.io/t/traefik-hackaethon-2-0/8632">opened a thread</a> on our community forums to discuss what you’d like to see the next time.</p>
<p>Thank you to all the participants, and your contributions to the Traefik ecosystem are sincerely appreciated. We can’t wait to see what you’re going to build next.</p>
<!--kg-card-end: markdown--><p/>]]></content:encoded></item><item><title><![CDATA[Lock Down Your Network with Traefik Enterprise and Vault]]></title><description><![CDATA[Traefik Enterprise 2.3 now supports Vault for certificate management in two ways: as a key-value store for certificates, and as a certificate resolver.]]></description><link>https://traefik.io/blog/lock-down-your-network-with-traefik-enterprise-and-vault/</link><guid isPermaLink="false">Ghost__Post__5fb312644a99b50039ce6d0d</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Tue, 17 Nov 2020 05:26:08 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg" class="kg-image" alt="Lock Down Your Network with Traefik Enterprise and Vault" srcset="https://containous.ghost.io/content/images/size/w600/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg 1600w, https://containous.ghost.io/content/images/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/11/Lock-Down-Your-Network-with-Traefik-Enterprise-and-Vault-1.jpg" alt="Lock Down Your Network with Traefik Enterprise and Vault"/><p>Every organization has secrets. Likewise, every application and service must manage sensitive information – such as usernames and passwords, license keys, database credentials, and so on – that should be kept away from prying eyes.</p><!--kg-card-begin: markdown--><p>Among the most important secrets that modern apps must maintain are the <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="nofollow">TLS certificates</a> that make encrypted HTTPS communications possible. The good news for Traefik Enterprise users is that handling these secrets is now easier than ever, thanks to support for Vault in Traefik Enterprise 2.3.</p>
<p><a href="https://www.vaultproject.io/" target="_blank" rel="nofollow">Vault</a> is an <a href="https://github.com/hashicorp/vault" target="_blank" rel="nofollow">open source</a> tool developed and maintained by HashiCorp that provides a secure and encrypted central data store for secrets. Traefik Enterprise 2.3 can use Vault for certificate management in two ways. First, it can use Vault as a key-value store for certificates. Second, it can enlist Vault as a certificate resolver, allowing it to dynamically generate certificates on the fly. Let’s examine both use cases.</p>
<!--kg-card-end: markdown--><h2 id="using-vault-as-a-key-value-store-for-certificates"><strong>Using Vault as a Key-Value Store for Certificates</strong></h2><p>Traefik has long been able to discover and connect with a variety of key-value stores, such as Consul, etcd, and ZooKeeper. The Vault provider for Traefik Enterprise 2.3 and later can connect to Vault in a similar way, using it as a key-value store for storing and retrieving TLS certificates.</p><!--kg-card-begin: markdown--><p>The first step is to setup the Vault secrets engine for use with Traefik Enterprise. As of now, Traefik Enterprise supports the <a href="https://www.vaultproject.io/docs/secrets/kv/kv-v2" target="_blank" rel="nofollow">KV Secrets Engine – Version 2</a>, which is currently the default and is easily enabled from the command line. It’s a good idea to use a dedicated KV store for TLS certificates, and bear in mind that all certificates must be base64-encoded and stored in the root of the KV secrets engine.</p>
<!--kg-card-end: markdown--><p>From there, it’s a straightforward matter of enabling the Vault Provider in Traefik Enterprise’s static configuration. This takes just a few lines of code, and a typical example (in YAML) might look like this:</p><!--kg-card-begin: markdown--><pre><code class="language-yaml">providers:
  plugin:
    vault:
      url: &quot;http://127.0.0.1:8200&quot;
      token: &quot;s.CUDDqqjiIFXF60KVSeJOxeb5&quot;
      enginePath: &quot;secret&quot;
      syncInterval: &quot;5s&quot;
      rescanInterval: &quot;60s&quot;
</code></pre>
<!--kg-card-end: markdown--><p>This snippet points to the URL of the Vault server and supplies the token that’s needed to authenticate with it. (The Vault Provider only supports token authentication at this time.) It also specifies how often the provider will pull data from the Vault KV store.</p><p>That’s it! Once configured, Traefik Enterprise will detect certificates in the store to serve them. And, as usual for Traefik Enterprise, the configuration refreshes automatically whenever you insert or delete certificates from the Vault store.</p><p>If you’d like to learn more about how to setup and configure the Vault Provider for Traefik Enterprise, check out the <a href="https://doc.traefik.io/traefik-enterprise/providers/vault-kv/">documentation</a>.</p><h2 id="using-vault-as-a-certificate-resolver-for-pki"><strong>Using Vault as a Certificate Resolver for PKI</strong></h2><!--kg-card-begin: markdown--><p>Experienced Traefik users will be familiar with its support for automatic certificate generation using the ACME protocol and compatible service providers, such as <a href="https://doc.traefik.io/traefik-enterprise/tls/acme/">Let’s Encrypt</a>. Traefik Enterprise 2.3 adds a new, additional means of automating certificate generation in the form of support for <a href="https://www.hashicorp.com/products/vault/pki-with-vault" target="_blank" rel="nofollow">Vault Public Key Infrastructure (PKI)</a>.</p>
<!--kg-card-end: markdown--><p>The Vault PKI secrets engine includes built-in authentication and authorization functions that make it possible to generate certificates on the fly, without getting bogged down in the traditional, manual process of generating keys and submitting to a certificate authority (CA).</p><p>This automation is especially valuable in dynamic, microservices-based environments, where services tend to be short-lived and container instances are rapidly created and destroyed, according to demand.</p><p>Setting up Vault as a <a href="https://doc.traefik.io/traefik/https/acme/#certificate-resolvers">certificate resolver</a> is almost as easy as configuring the Vault Provider, as discussed earlier. Once Vault is installed with the PKI secrets engine enabled, configuring the feature requires adding just a few lines to Traefik Enterprise’s static configuration. For example:</p><!--kg-card-begin: markdown--><pre><code>certificatesResolvers:
  resolverName:
	vault:
  	url: &quot;http://127.0.0.1:8200&quot;
  	token: &quot;s.CUDDqqjiIFXF60KVSeJOxeb5&quot; # Your Vault auth token goes here
  	enginePath: &quot;pki&quot;
  	role: &quot;vault-role&quot;
</code></pre>
<!--kg-card-end: markdown--><p>Once the certificate resolver is configured, assigning it to routes in Traefik Enterprise will trigger Vault to generate certificates for requests that match the appropriate patterns. To read more about how this works, consult the <a href="https://doc.traefik.io/traefik-enterprise/tls/vault-pki/">documentation</a>. There’s also a handy <a href="https://doc.traefik.io/traefik-enterprise/operations/vault-pki-guide/">user guide</a> available that walks through the process of deploying a simple TLS-enabled service with Vault on Kubernetes.</p><h2 id="get-secure-with-traefik-enterprise"><strong>Get Secure with Traefik Enterprise</strong></h2><p>Traefik Labs is pleased to offer support for Vault in Traefik Enterprise as further proof of our commitment to provide best-of-breed features that security-conscious enterprises demand. Using Vault to manage secrets is a step forward in securing your network; using Vault with Traefik Enterprise makes taking that step even easier. If you’d like to learn more about these and other advanced features of Traefik Enterprise, the best way is to try them out for yourself. Sign up for a <a href="https://info.traefik.io/get-traefik-enterprise-free-for-30-days">30-day free trial</a> and explore how Traefik Enterprise can help make your infrastructure more nimble, reliable, and secure.</p>]]></content:encoded></item><item><title><![CDATA[Leveraging your Ingress Controller to easily migrate to Kubernetes]]></title><description><![CDATA[In this article, we’ll delve into the question of migrating legacy applications by discussing the specific challenges these workloads pose and outlining a strategy to overcome them.]]></description><link>https://traefik.io/blog/leveraging-your-ingress-controller-to-easily-migrate-to-kubernetes/</link><guid isPermaLink="false">Ghost__Post__5f7f21459ccef80039928ddc</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Kevin Crawley]]></dc:creator><pubDate>Tue, 10 Nov 2020 01:46:18 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg" class="kg-image" alt="Leveraging your Ingress Controller to easily migrate to Kubernetes" srcset="https://containous.ghost.io/content/images/size/w600/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg 1600w, https://containous.ghost.io/content/images/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><!--kg-card-begin: markdown--><img src="https://containous.ghost.io/content/images/2020/11/Leveraging-your-Ingress-Controller-to-easily-migrate-to-Kubernetes-1.jpg" alt="Leveraging your Ingress Controller to easily migrate to Kubernetes"/><p>Many enterprise organizations choose <a href="https://kubernetes.io" target="_blank" rel="nofollow">Kubernetes (k8s)</a> as the foundation of their IT modernization efforts due to its alignment with cloud native practices. However, a question naturally arises during the adoption process: How should existing legacy applications be handled as part of a broader Kubernetes migration? As it turns out, the answer ties to the Ingress Controller, one of the core components in a Kubernetes cluster. In this article, we’ll delve into the question of migrating legacy applications by discussing the specific challenges these workloads pose and outlining a strategy to overcome them.</p>
<h2 id="legacyapplicationsandkubernetes">Legacy applications and Kubernetes</h2>
<p>The functionality provided by legacy workloads typically encapsulates significant business value for organizations. Having been designed and implemented in an earlier era, they also tend to gravitate towards monolithic architectures powered by older programming languages and toolchains. For these reasons, they're often stagnant with little ongoing development other than to address high priority bugs or significant security vulnerabilities.</p>
<p>Here lies the dilemma: on the one hand, these legacy workloads are highly valuable. Modifying them in any way, including their operating environment, creates risks associated with the business's daily operation. On the other hand, leaving them out of a Kubernetes migration means maintaining older operating environments and preventing teams from reaping the benefits provided by Kubernetes with these critical applications. What's needed is a way for IT leaders to mitigate the migration risks associated with legacy applications.</p>
<p>Discussions around Ingress Controllers often arise as part of networking and routing in Kubernetes, particularly in <a href="https://traefik.io/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/">connecting external users to applications</a>. Due to their strategic placement in the overall architecture, in practice, their capabilities can extend benefits to use cases well beyond just connectivity. As we'll discuss in more detail, used effectively, Ingress Controllers can help ease the process of migrating and running legacy applications on Kubernetes by reducing or mitigating many of the risks that may otherwise prevent IT from making the transition process. To illustrate where Ingress Controllers fit into the overall migration picture, consider a high-level outline of a general migration strategy (we'll dive into each area next):</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/10/Strangler_Pattern_Blog_Image.svg" class="kg-image" alt="Leveraging your Ingress Controller to easily migrate to Kubernetes"><figcaption>Migrating your Legacy Applications using Kubernetes Ingress</figcaption></img></figure><!--kg-card-begin: markdown--><ul>
<li>Deploy legacy workloads on Kubernetes - Get legacy applications running on k8s as simply and quickly as possible</li>
<li>Select an option for ongoing development / maintenance:
<ul>
<li>Build around a legacy application - Use Ingress Controller functionality to route traffic in a manner which allows for building on top of legacy without modifying it</li>
<li>Build your way out of a legacy application - Use Ingress Controller functionality to enable iterative refactoring of legacy</li>
</ul>
</li>
</ul>
<h2 id="liftandshiftdeploylegacyworkloadsonkubernetes">Lift and Shift: Deploy legacy workloads on Kubernetes</h2>
<p>The first step of our migration strategy entails establishing a baseline for deploying legacy codebase running on Kubernetes. The goal is to help achieve a standardizing operating environment for all workloads and serve as a starting point for further improvements. To accomplish this, one must containerize the monolithic codebase and its associated dependencies. While there is no single recipe for containerization that will work across all applications, there are well-known items that need addressing as part of a &quot;lift and shift&quot; operation.</p>
<p>First, an appropriate Docker base image should be selected or defined for the legacy application. Depending upon the language and technology stack used in its implementation, there may be viable candidates available on <a href="https://hub.docker.com/" rel="nofollow" target="_blank">Docker Hub</a>. Otherwise, DevOps engineers will need to craft a custom image. Once the team establishes a base image, they leverage it to iterate on the monolithic application's candidate release images. In some cases, engineers will augment base images by injecting build artifacts. In others, it may be necessary to generate artifacts using the base image itself through multi-stage build processes. Once the containerized image is available, it can be deployed onto a Kubernetes cluster and validated.</p>
<h2 id="buildaroundlegacyapplicationswithingresscontrollers">Build around legacy applications with Ingress Controllers</h2>
<p>Once the team establishes a baseline deployment, they have options for managing the future legacy workload. There will inevitably be a need to extend the monolith functionally, and this is where Ingress Controllers can help reduce complexity and risk. Specifically, instead of taking an approach where developers must modify or refactor the legacy applications, the core application can be left intact while using Ingress Controllers. This approach permits additional functionality by injecting new services that logically sit between end users and the monolith. Since developers are empowered to build these services from scratch, they are implementable using cloud native best practices. Traffic from external users routes to the intervening service layer by configuring the Ingress Controller for the cluster. When requests are received, the containerized legacy application operates as needed for specific functionality.</p>
<h2 id="buildawayfromlegacyapplicationswithingresscontrollers">Build away from legacy applications with Ingress Controllers</h2>
<p>An alternative approach towards realizing additional functionality around a legacy application once deployed on Kubernetes is to employ the so-called Strangler pattern. As may be apparent from the name, this strategy consists of replacing legacy codebases gradually by migrating features to new microservice implementations, which may also incorporate additional capabilities. Compared to a wholesale reimplementation, the overall risk spreads over time. In addition, if needed, teams can always fall back to the original implementation since it is left intact. The Ingress Controller is the key to enabling this strategy on Kubernetes as it allows operators to route traffic from external users to the refactored microservices versus the legacy application. As functionality continues to shift away from the monolith, it is &quot;strangled&quot; out, and eventually, the legacy application is ready to be removed from the cluster altogether.</p>
<h2 id="conclusion">Conclusion</h2>
<p>For many enterprise organizations, legacy applications continue to support critical processes that form the business's backbone. Therefore, IT leaders need to understand potential strategies for handling these workloads during a Kubernetes migration.</p>
<p>In this article, we've reviewed how Ingress Controllers can significantly reduce the risk of legacy migrations while also enabling continued development around legacy implementations. While the directions outlined are available today with available Ingress Controllers, this area is also rapidly evolving within the Kubernetes ecosystem, as evidenced by its <a href="https://traefik.io/blog/kubernetes-ingress-service-api-demystified/">Service API evolution</a>. Enterprises can safely assume that the ability to leverage resources such as Ingress Controllers to help ease migration challenges is only going to improve in the future.</p>
<p><a href="https://info.traefik.io/en/request-demo-traefik-enterprise">Learn more about Traefik Enterprise</a> today and learn how businesses are leveraging the power of enterprise-grade Kubernetes Ingress to solve their most demanding challenges.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[The Complete Traefik Training  Course]]></title><description><![CDATA[The Complete Traefik Training Course  course by Brian Christner of The Byte provides real-world examples, hands-on labs and guided lessons on the features available with Traefik Proxy. ]]></description><link>https://traefik.io/blog/the-complete-traefik-training-course/</link><guid isPermaLink="false">Ghost__Post__5f9c81f69895340039a505c9</guid><category><![CDATA[Blog]]></category><category><![CDATA[Partners]]></category><dc:creator><![CDATA[Brian Christner]]></dc:creator><pubDate>Tue, 03 Nov 2020 14:30:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/10/Blog--1-.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/11/Blog@2x.png" class="kg-image" alt="The Complete Traefik Training  Course" srcset="https://containous.ghost.io/content/images/size/w600/2020/11/Blog@2x.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/11/Blog@2x.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/11/Blog@2x.png 1600w, https://containous.ghost.io/content/images/2020/11/Blog@2x.png 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/10/Blog--1-.png" alt="The Complete Traefik Training  Course"/><p>Hi! My name is Brian Christner—Docker Captain, Traefik Ambassador, DevOps professional, and the creator of the Complete Traefik Training Course. I’m happy to announce that theByte, in collaboration with Traefik Labs, has created a full in-depth Traefik Training course. </p><p>We created this course to help you get up to speed quickly configuring and deploying Traefik. This course provides real-world examples, hands-on labs, and guided lessons in order for you to fully immerse yourself with all the features available with the Traefik Proxy. The aim of the course is to help you get up and running with Traefik.</p><p>Maybe you are already familiar with Traefik or just getting started. The Traefik Training course guides you through a tour of the available features, use cases, and answers a lot of the "<strong>Why?"</strong> questions you may have.</p><h2 id="why-traefik-training">Why Traefik Training?</h2><p>Traefik is an amazing tool. I’ve been using it for over three years now and immersed myself in the project as a contributor—using it both for personal and customer projects. However, I have received consistent feedback from customers and users requesting a Traefik Training course to walk through <em>configuration, deployment, and operating Traefik and an explanation of why certain things behave and configured</em>.  Based on the feedback we created the Traefik Training course.  </p><p>The Traefik documentation is a great place to start. The Traefik Training course extends the documentation with a guided tour on how best to use Traefik to fully understand the potential for your use case. </p><h3 id="what-will-you-learn">What will you learn?</h3><p>The Traefik Training course contains over 5 hours of lessons, 20+ hands-on labs, and a ton of real-world experience from deploying the Traefik Proxy for real-world projects built into the course. The course covers the background of Traefik,  getting started with Traefik, configuration, deployment, and Day 2 operations. </p><h3 id="what-you-ll-get-">What you'll get:</h3><p><strong>✅  A robust course RECOMMENDED by Traefik Labs!</strong></p><p><strong>📹  Videos:</strong> Over 5 hours of course material</p><p><strong>🥼  LABS: </strong>More than 20+ Hands-on Labs with access to code examples and templates</p><p><strong>🚦 COLLAB:</strong> A course built in cooperation with the Traefik Labs team</p><p><strong>🎯 LEARN: </strong>A thorough understanding of Reverse Proxies, Load Balancers, and the Traefik Architecture</p><p><strong>💡 EXAMPLES: </strong>Deploy a Monitoring stack of Prometheus, Grafana, and Traefik</p><p><strong>👨‍🏫 Instructor: </strong>Learn from the Pro, Brian Christner Docker Captain &amp; Traefik Ambassador.</p><p><strong>🔑 ACCESS: </strong>to a Private Slack Channel with engineers, professionals, and fellow students.</p><p><strong>📊 UPDATES: </strong>Lifetime free course updates</p><p><strong>🏆 CERTIFICATE: </strong>Certificate of completion</p><h2 id="course-syllabus">Course Syllabus</h2><ul><li>Course introduction</li><li>Getting Started with Traefik</li><li>Configure Traefik</li><li>Routers &amp; Services</li><li>HTTPS / TLS / Let's Encrypt</li><li>Middlewares</li><li>Observability</li><li>Operations</li><li>Advanced Tips</li><li>Course Wrap and Next Steps</li></ul><h3 id="start-learning-traefik-today">Start Learning Traefik Today</h3><p>It has never been easier to learn Traefik. The Complete Traefik Training course is the perfect course to configure, deploy, and manage Traefik helping you get started, and experiencing the benefits of Traefik very quickly. The course will enable you to start connecting your workload to Traefik today.</p><!--kg-card-begin: markdown--><p>For any questions you may have during, or after the course, please ping me on <a href="https://twitter.com/idomyowntricks" target="_blank" rel="nofollow">Twitter</a>.</p>
<p>👉 Get Started Learning Traefik Today. <a href="https://www.thebyte.io/traefik-training" target="_blank">Sign up here!</a></p>
<!--kg-card-end: markdown--><p/>]]></content:encoded></item><item><title><![CDATA[How Vaudoise Insurance Deployed Traefik Enterprise to Successfully Modernize with Microservices]]></title><description><![CDATA[As an insurance company, security and service uptime are two of Vaudoise's highest requirements. Traefik Enterprise provides high availability and encryption capabilities necessary for Vaudoise, in a single, easy-to-use solution.]]></description><link>https://traefik.io/blog/how-vaudoise-insurance-deployed-traefik-enterprise-to-successfully-modernize-with-microservices/</link><guid isPermaLink="false">Ghost__Post__5f97b3e69895340039a5049a</guid><category><![CDATA[Blog]]></category><category><![CDATA[Case Studies]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Tue, 27 Oct 2020 06:05:22 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg" class="kg-image" alt="How Vaudoise Insurance Deployed Traefik Enterprise to Successfully Modernize with Microservices" srcset="https://containous.ghost.io/content/images/size/w600/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg 1600w, https://containous.ghost.io/content/images/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise-2.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><h2 id="about-vaudoise-insurance"><strong>About Vaudoise Insurance</strong></h2><!--kg-card-begin: markdown--><img src="https://containous.ghost.io/content/images/2020/10/How-Vaudoise-Insurance-Deployed-Traefik-Enterprise.png" alt="How Vaudoise Insurance Deployed Traefik Enterprise to Successfully Modernize with Microservices"/><p><a href="https://www.vaudoise.ch" target="_blank" rel="nofollow">Vaudoise Insurance</a> is the only independent private insurance company with a decision-making center in French-speaking Switzerland. Founded in 1895, it is one of the ten largest private insurers in the Swiss market. Vaudoise provides individuals and SMEs with high-level advice and solutions in all areas of insurance and pension provision. Through its network of around 100 branches across Switzerland, it offers its customers local service, in terms of both advice and claims settlement. The Group employs roughly 1,550 people, including around 100 apprentices.</p>
<!--kg-card-end: markdown--><h2 id="overview"><strong>Overview</strong></h2><p>How do you modernize a company with 125 years of history? Vaudoise Insurance entered the digital age decades ago, yet the technical debt incurred by years of legacy computing was becoming too much to manage. Its monolithic systems were burdensome to upgrade and rolling out new features required coordination from multiple teams. The pace of change was too slow.</p><p>Vaudoise’s technical teams needed to become more agile to match the pace of today’s business environment. Its 150-200 IT staffers shared the task of managing some 300 applications, and too many of these were silos. What the company’s development teams wanted was to expose more of its internal data via APIs, making it easier to build new, lightweight applications based on microservices.</p><p>Complicating matters was the fact that insurance is a highly regulated industry, particularly when it comes to data privacy. That meant Vaudoise would need to continue to host and manage some of its applications on premises, and any new technologies introduced could not significantly add to the existing management burden.</p><h2 id="challenge"><strong>Challenge</strong></h2><p>Vaudoise’s strategy was to begin developing new applications as Docker containers, while simultaneously modernizing its monolithic, legacy applications by decomposing them into containerized services. The intent was that this would not only speed time-to-delivery for new applications, but it would also allow development teams to experiment with new technologies (such as NoSQL databases) that simply weren’t available to their legacy systems.</p><p>Damien Desvignes and Patrick Monbaron, application lifecycle management (ALM) engineer and system engineer at Vaudoise, belong to the multidisciplinary team responsible for the Docker platform. The company chose Docker Enterprise as its container platform, both because of its proven technology and because its Docker Swarm mode orchestration layer was significantly less complicated to deploy than alternatives (such as Kubernetes).</p><p>Still this left Damien and Patrick’s team with another problem. Now that it had decided how it would host its containers and services, how would it publish them?</p><blockquote>"We needed a tool that would allow us to dynamically publish new services, or change the configuration of existing services, that was simple to handle and that did not need a restart, unlike the usual nginx-based tools.”<strong> </strong>Patrick Monbaron, system engineer at Vaudoise</blockquote><blockquote>“As an insurance company, security and service uptime are two of our highest requirements. Traefik Enterprise provides high availability and encryption capabilities necessary for Vaudoise, in a single, easy-to-use solution.”<strong> </strong>Patrick Monbaron, system engineer at Vaudoise</blockquote><h2 id="solution"><strong>Solution</strong></h2><p>Prior to the company initiative, Damien had successfully used Traefik for over 3 years and was confident that its ease-of-use, versatile feature set, and broad ecosystem made it the right choice for application networking with containers.</p><p>As Vaudoise started this new containerized application strategy, Damien immediately sought out <a href="https://traefik.io/traefik-enterprise/">Traefik Enterprise</a> to help satisfy the company’s production networking requirements. Traefik Enterprise provides out-of-the-box high availability (HA) and security features that are essential for a business operating in the insurance industry. For example, Traefik Enterprise can interface with the Docker Universal Control Plane (UCP) to enable role-based access control (RBAC) on the cluster. Additionally, Traefik Enterprise includes fast, responsive enterprise support from Traefik Labs, giving Vaudoise the peace of mind of having a partner to rely on.</p><p>From an operations perspective, Patrick and his infrastructure team benefited from using Traefik Enterprise by securing and managing Docker Swarm ingress traffic, making it faster and easier to deploy new services. Even HTTPS encryption is now centrally managed by the infrastructure team, leaving developers free to concentrate on software delivery, without a lot of cross-team coordination.</p><blockquote>“Developers are a lot more autonomous than before. Dev teams can manage the rewrite rules on their own, for example, which was not possible before.” Patrick Monbaron, system engineer at Vaudoise</blockquote><h2 id="bottom-line"><strong>Bottom Line</strong></h2><p>Vaudoise Insurance is only at the beginning of its journey with containers and Traefik Enterprise. Damien and Patrick are looking forward to working with features introduced in recent versions of Traefik, including the ability to support applications that use the TCP and UDP protocols, in addition to HTTP. Emerging technologies such as service mesh – a feature offered by Traefik Enterprise 2.2 – are also under consideration.</p><p>Down the road, Vaudoise may even consider moving from Docker Swarm to a more full-featured container orchestrator, such as Kubernetes, confident that Traefik Enterprise will continue to support that new environment.</p><p>Already, however, the features of Traefik Enterprise – including enterprise support from Containous – have been instrumental in Vaudoise’s IT modernization journey. Traefik’s vibrant and active ecosystem, coupled with the enterprise features and evolving technology roadmap of Traefik Enterprise, allow Vaudoise to proceed with confidence, knowing it will be well-positioned for continued success as it moves into the next phase of its long history</p><h2 id="what-s-next">What’s Next?</h2><ul><li>Discover <a href="https://traefik.io/traefik-enterprise/">Traefik Enterprise</a>, and <a href="https://info.traefik.io/en/request-demo-traefik-enterprise">request your demo</a>.</li></ul>]]></content:encoded></item><item><title><![CDATA[Traefik Enterprise 2.3 Arrives with Vault Support, GitOps Compliance, and More]]></title><description><![CDATA[Traefik Enterprise 2.3 has arrived. Now, with Vault support, GitOps Compliance, support for HTTP caching, and an API portal. ]]></description><link>https://traefik.io/blog/traefik-enterprise-2-3-arrives-with-vault-support-gitops-compliance-and-more/</link><guid isPermaLink="false">Ghost__Post__5f88c505c254310039a24349</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Nicolas Mengin]]></dc:creator><pubDate>Mon, 19 Oct 2020 17:21:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/10/Traefik-Enterprise-2.3.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/10/Blog@2x.jpg" class="kg-image" alt="Traefik Enterprise 2.3 Arrives with Vault Support, GitOps Compliance, and More" srcset="https://containous.ghost.io/content/images/size/w600/2020/10/Blog@2x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Blog@2x.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/10/Blog@2x.jpg 1600w, https://containous.ghost.io/content/images/2020/10/Blog@2x.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/10/Traefik-Enterprise-2.3.jpg" alt="Traefik Enterprise 2.3 Arrives with Vault Support, GitOps Compliance, and More"/><p>We are pleased to announce that a new version of Traefik Enterprise is here, bringing with it an array of new capabilities. Among the new features in this latest release are integration with Vault, a new way to automate Traefik Enterprise installation, support for HTTP caching, and an API portal.</p><h2 id="secure-your-infrastructure-in-a-vault">Secure Your Infrastructure in a Vault</h2><p>The more APIs your infrastructure contains, the more complicated TLS certificate management becomes.</p><!--kg-card-begin: markdown--><p>To solve this problem, many companies have used <a href="https://www.vaultproject.io/" target="_blank" rel="nofollow">Vault</a> to manage their certificates securely. Customers have asked us to help them easily serve these certificates using Traefik Enterprise, and this is now possible with Traefik Enterprise 2.3.</p>
<!--kg-card-end: markdown--><h3 id="vault-as-a-provider">Vault as a Provider</h3><p>Traefik Enterprise has always been able to read certificates from key-value stores such as Consul or etcd. It’s now possible to use <a href="https://doc.traefik.io/traefik-enterprise/v2.3/providers/vault-kv/">Vault in the same way</a>, thanks for the new Vault provider in Traefik Enterprise 2.3.</p><p>Configure your Traefik Enterprise cluster to reach your Vault server and it will detect the certificates to serve them:</p><!--kg-card-begin: markdown--><pre><code class="language-yaml"># Static Configuration
providers:
  plugin:
    vault:
      url: &quot;http://127.0.0.1:8200&quot; # Vault server URL
      token: &quot;s.CUDDqqjiIFXF60KVSeJOxeb5&quot; # Vault Authentication Token
</code></pre>
<!--kg-card-end: markdown--><p>As usual with Traefik Enterprise, the configuration will be refreshed automatically each time you insert or delete certificates in your Vault server.</p><h3 id="vault-pki-support">Vault PKI Support</h3><p>Many organizations use Vault to generate TLS certificates on the fly using its public key infrastructure (PKI) feature. Now you can take advantage of this capability with Traefik Enterprise.</p><p>Based on our experience with Let’s Encrypt, we created a new <a href="https://doc.traefik.io/traefik-enterprise/v2.3/tls/vault-pki/">certificate resolver</a> to integrate Traefik Enterprise with Vault PKI.</p><!--kg-card-begin: markdown--><pre><code class="language-yaml"># Static Configuration
certificatesResolvers:
  vaultResolver:
    vault:
      url: &quot;http://127.0.0.1:8200&quot; # Vault server URL
      token: &quot;s.CUDDqqjiIFXF60KVSeJOxeb5&quot; # Vault Authentication Token
      role: &quot;vault-role&quot; # Role to use to generate certificates
</code></pre>
<!--kg-card-end: markdown--><p>Once this feature is enabled, Traefik Enterprise can use Vault to create and renew all your TLS certificates, which in turn helps to ease management of your APIs.</p><p>Don’t hesitate to take a look at our <a href="https://doc.traefik.io/traefik-enterprise/v2.3/operations/vault-pki-guide/">documentation</a> for more information about this feature.</p><h2 id="gitops-automation">GitOps Automation</h2><p>More and more organizations use GitOps tools to automate their deployments. Customers have asked us for better integration of Traefik Enterprise with these tools, and with this release, we’ve delivered.</p><!--kg-card-begin: markdown--><p>Traefik Enterprise 2.3 brings a couple of features to improve our compliance with popular GitOps tools (such as <a href="https://argoproj.github.io/argo-cd/" target="_blank" rel="nofollow">Argo CD</a>).</p>
<!--kg-card-end: markdown--><p>You can now download a customized Traefik Enterprise manifest to install a cluster in Kubernetes from <a href="https://doc.traefik.io/traefik-enterprise/v2.3/installing/kubernetes/gitops/#custom-installation-parameters">a web service</a>. Additionally, you can provide your <a href="https://doc.traefik.io/traefik-enterprise/v2.3/installing/kubernetes/gitops/#installation">static configuration in a Kubernetes ConfigMap</a>, so the configuration can be discovered and automatically reloaded by Traefik Enterprise.</p><figure class="kg-card kg-image-card"><img src="https://lh4.googleusercontent.com/-Pa5DLSEh9dMm66du3HKBOh0T7XCGlLlE8qkUAMB1HzQSN5zcl4o2swUFEEgHHH_e7T6S1XsoIhA8akMiUmPM0mbb35uqpokH2Ysp9x1HKqtU8-escEqiRqNrxte3tcuzCZzjG7o" class="kg-image" alt="Traefik Enterprise 2.3 Arrives with Vault Support, GitOps Compliance, and More"/></figure><p>If you’re interested in the feature, <a href="https://doc.traefik.io/traefik-enterprise/v2.3/installing/kubernetes/gitops/">follow our step by step installation documentation</a> and try it out for yourself.</p><h2 id="speed-up-your-traffic-with-http-caching">Speed Up Your Traffic with HTTP Caching</h2><p>Having an infrastructure that can manage all of your traffic is a good thing. But having this infrastructure optimized for your needs is even better.</p><!--kg-card-begin: markdown--><p>With this in mind, Traefik Enterprise 2.3 introduces a new <a href="https://doc.traefik.io/traefik-enterprise/v2.3/middlewares/http-cache/">HTTP Cache middleware</a> based on <a href="https://tools.ietf.org/html/rfc7234" target="_blank" rel="nofollow">RFC 7234</a>. It speeds up your external traffic and optimizes your internal traffic by caching HTTP responses in Traefik Enterprise proxies. Thus, you can reduce the workload on your services for most HTTP requests.</p>
<!--kg-card-end: markdown--><p>You just have to set this middleware on your router and Traefik Enterprise will start improving your response times automatically:</p><!--kg-card-begin: markdown--><pre><code class="language-yaml"># Dynamic Configuration
http:
  middlewares:
    test-http-cache:
      plugin:
        httpCache:
          maxTtl: 600
          memory:
            limit: &quot;3Gi&quot;
</code></pre>
<!--kg-card-end: markdown--><h2 id="api-portal-for-developers">API Portal for Developers</h2><p>Deploying a microservice architecture means managing infrastructure with many APIs. These APIs are typically provided by multiple teams in the organization and they are often exposed to external partners.</p><p>But how to share the APIs information with all the involved parties? That's where Traefik Enterprise 2.3 comes in. </p><!--kg-card-begin: markdown--><p>With this new release, you need only describe your APIs’ specifications in the popular <a href="https://www.openapis.org/" target="_blank" rel="nofollow">OpenAPI</a> format and expose them using Traefik Enterprise’s new API portal feature:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-yaml"># Static Configuration
apiportal:
  url: spec.json
</code></pre>
<!--kg-card-end: markdown--><p>With just a few lines of configuration, your API specification is reachable from your service.</p><figure class="kg-card kg-image-card"><img src="https://lh5.googleusercontent.com/PyheB6IehP5nZYC1A-g8MPqFir_xQDUAeeQQg22FnVo4jgzizDsq82Soy4ZRnu7TyNV3RlrsCJ3gWbfqtwn1BYOySEjLvvWkAiyNn-naYo0aRRJ5Hs0zWgh9d0_rEyOCKy22NCNp" class="kg-image" alt="Traefik Enterprise 2.3 Arrives with Vault Support, GitOps Compliance, and More"/></figure><p>Need to monitor all your APIs at a glance? No worries, Traefik Enterprise provides you a dedicated web UI.<br/></p><figure class="kg-card kg-image-card"><img src="https://lh3.googleusercontent.com/qjEqe2DVQD_pfr8V3ls4bLffXgwKtcX-J_ZnS_UO4V3plp8mrUzLzjDoUoVYm7i3aI_OvPzx7p5pYE9-Z8Ap8aWPIuSvUYVJHrh72HuHSzPTwhUQBMVQCQWXxZz5nK5u-ksffUwM" class="kg-image" alt="Traefik Enterprise 2.3 Arrives with Vault Support, GitOps Compliance, and More"/></figure><h2 id="what-s-next">What's Next?</h2><p>With the addition of Vault support, Traefik Enterprise adds support for enterprise authentication protocols and Let’s Encrypt to its portfolio of security capabilities.</p><p>In future releases, we’ll continue to develop enterprise-specific features to solve networking issues for companies who choose Traefik Enterprise.</p><p>Take a closer look at <a href="https://traefik.io/traefik-enterprise/">Traefik Enterprise’s features to learn more</a>. If you want to test drive this new version, <a href="https://info.traefik.io/get-traefik-enterprise-free-for-30-days">sign up for a free trial of Traefik Enterprise 2.3 today</a>.</p>]]></content:encoded></item><item><title><![CDATA[Traefik Hackaethon 2020: Middleware Plugins Brain Dump]]></title><description><![CDATA[The team at Traefik Labs will be hosting a Hackathon next week, and plugins are a significant theme. Awards, bounties, and prizes are available for those who participate. ]]></description><link>https://traefik.io/blog/traefik-hackaethon-2020-middleware-plugins-brain-dump/</link><guid isPermaLink="false">Ghost__Post__5f7f0f1a9ccef80039928d25</guid><category><![CDATA[Blog]]></category><category><![CDATA[Announcements]]></category><dc:creator><![CDATA[Kevin Crawley]]></dc:creator><pubDate>Mon, 12 Oct 2020 23:04:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg" class="kg-image" alt="Traefik Hackaethon 2020: Middleware Plugins Brain Dump" srcset="https://containous.ghost.io/content/images/size/w600/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg 1600w, https://containous.ghost.io/content/images/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><!--kg-card-begin: markdown--><img src="https://containous.ghost.io/content/images/2020/10/Traefik-Hackaethon-2020---Middleware-Plugins-Brain-Dump-1.jpg" alt="Traefik Hackaethon 2020: Middleware Plugins Brain Dump"/><p>One of the most powerful features of the Traefik software-based load balancer is its support for <a href="https://doc.traefik.io/traefik/middlewares/overview/">middlewares</a>. These packages are responsible for applying transformations, validations, redirections, omissions, and additions to requests before passing them on, either to another middleware package or to their final destination.</p>
<!--kg-card-end: markdown--><p>Over the past several years, Traefik has received dozens of ideas and concepts for middlewares through feature and pull requests. Some of these proposals suggested additional functionality for existing middlewares. Others introduced bespoke middleware for specific use cases.</p><!--kg-card-begin: markdown--><p>When these proposals weren't aligned to the vision of the Traefik community they languished on the Traefik issue board. There they lay dormant, waiting for the day that users could easily build <a href="https://traefik.io/blog/unleash-custom-networking-logic-with-traefik-plugins/">custom plugins for Traefik</a>. That day is here, and this post will provide an outline for those interested in building and extending the capabilities of Traefik with their own middlewares.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>The team at Traefik Labs will be hosting a Hackathon next week, and plugins are a significant theme. Awards, bounties, and prizes are available for those who participate. You can learn more and <a href="https://info.traefik.io/traefik-hackaethon-2020">sign up here</a>. In the meantime, here are some great ideas for middleware plugins that drew from issues on the Traefik repository.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/10/Haekaton-scene.svg" class="kg-image" alt="Traefik Hackaethon 2020: Middleware Plugins Brain Dump"><figcaption>Oct 20-22nd: Traefik's Inaugeral Hackaethon - <a href="https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/">Sign Up Today</a></figcaption></img></figure><!--kg-card-begin: markdown--><h2 id="popularmiddlewareideas">Popular Middleware Ideas</h2>
<h3 id="forwardauthwithselectiveheaders">Forward-Auth with Selective Headers</h3>
<p><a href="https://github.com/containous/traefik/issues/6493">https://github.com/containous/traefik/issues/6493</a></p>
<p>The forward auth middleware included with Traefik will forward all headers included in the original request. But in some cases, users may want to exclude specific headers from the forwarded request. Instead, they would rather the headers are forwarded only in the response from the auth server.</p>
<h3 id="queryparametermodification">Query Parameter Modification</h3>
<p><a href="https://github.com/containous/traefik/issues/6276">https://github.com/containous/traefik/issues/6276</a></p>
<p>In some cases, operators may want to modify the request's query keys or convert query parameters into a path. In either scenario, this can be useful for several use cases. But along with the usefulness comes additional complexity in test scenarios and implementations. These constraints make it a prime candidate for adoption as a custom plugin.</p>
<h3 id="headertransformation">Header Transformation</h3>
<p><a href="https://github.com/traefik/traefik/issues/6047">https://github.com/traefik/traefik/issues/6047</a></p>
<p>The scope of the Header middleware's current implementation is limited to adding or removing headers (which is only available through a file type provider). Users may want to perform more complex operations on headers, such as renaming a key or transforming a value. These operations could be achievable through regex or simple pattern matching.</p>
<h3 id="enhancedretryandbackoff">Enhanced Retry and Backoff</h3>
<p><a href="https://github.com/traefik/traefik/issues/5282">https://github.com/traefik/traefik/issues/5282</a><br>
<a href="https://github.com/traefik/traefik/issues/4578">https://github.com/traefik/traefik/issues/4578</a></br></p>
<p>Cases exist where operators may want to retry on certain conditions, such as a 5xx error or connection refused. Without exponential backoff or retries based on response code, retrying on those parameters isn't feasible. For additional inspiration, <a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#the-retry-gatewayfilter-factory" target="_blank" rel="nofollow">Spring Cloud Gateway</a> has a design that handles both cases.</p>
<h3 id="customresponsecodeoverrides">Custom Response Code Overrides</h3>
<p><a href="https://github.com/traefik/traefik/issues/2039">https://github.com/traefik/traefik/issues/2039</a></p>
<p>When users receive an error message, this can sometimes indicate a particular resource's presence or absence. Also, when it’s impossible to modify the client’s behavior this can be worked-around by intercepting an erroneous response and handling it by return a different error response or page. This plugin would effectively intercept the service's error response and map an alternative response, such as a 200 response instead of a 501 response, or a 404 rather than a 401 or 403.</p>
<h3 id="cdnallowlist">CDN AllowList</h3>
<p><a href="https://github.com/traefik/traefik/issues/4145">https://github.com/traefik/traefik/issues/4145</a></p>
<p>CDNs publish their IP addresses from consumable public resources. When hosting a particular resource that should only be accessible from the CDN (for cache-fronting reasons), it’s logical that users want to block any request that does not originate from an IP address published on that list.</p>
<h3 id="basicauthoverrides">BasicAuth Overrides</h3>
<p><a href="https://github.com/traefik/traefik/issues/4429">https://github.com/traefik/traefik/issues/4429</a></p>
<p>In some instances, users have asked to allow Basic Auth to allow programmatic overrides by either a custom header or originating from a specific IP address (or set of IP addresses). Both options could be implemented into a custom authentication plugin, with support for IP ranges as well.</p>
<h3 id="ratelimitingenhancements">Rate Limiting Enhancements</h3>
<p><a href="https://github.com/traefik/traefik/issues/4548">https://github.com/traefik/traefik/issues/4548</a><br>
<a href="https://github.com/traefik/traefik/issues/6042">https://github.com/traefik/traefik/issues/6042</a></br></p>
<p>Users have requested the ability to incorporate multiple rate limiting strategies concurrently; for example, combining client.ip and request.host on a single frontend. Users have also asked to store rate limiting data external to Traefik, enabling more extended duration limits to survive restarts and share limits across multiple instances. These would likely be two separate plugins as they’re two distinctly different features.</p>
<h3 id="responseheaderredirect">Response Header Redirect</h3>
<p><a href="https://github.com/traefik/traefik/issues/5154">https://github.com/traefik/traefik/issues/5154</a></p>
<p>There is a request to allow a service to command Traefik to internally redirect to another service provider through a custom header. This capability could be useful when the client doesn't require exposure to an internal redirect's details.</p>
<h3 id="brotlicompression">Brotli Compression</h3>
<p><a href="https://github.com/traefik/traefik/issues/4202">https://github.com/traefik/traefik/issues/4202</a></p>
<p>This plugin has already been implemented as a PR to Traefik. However, the licensing model on one of the dependencies prevented it from being merged as-is. This compression middleware would be relatively straightforward to implement as a plugin.</p>
<h3 id="additionalpluginideas">Additional Plugin Ideas</h3>
<p>There are other plugin ideas out there. We don't want to limit your creativity, either, so plugin bounties are not limited to this list. As long as the plugin isn't trivial and is deemed functionality by the judges, it is eligible for the prize. Here are a few more issues if you're not interested in the ideas listed above.</p>
<ul>
<li>HTTP Cache Backends - <a href="https://github.com/traefik/traefik/issues/878">https://github.com/traefik/traefik/issues/878</a></li>
<li>Containers on Demand - <a href="https://github.com/traefik/traefik/issues/6993">https://github.com/traefik/traefik/issues/6993</a></li>
<li>Open Policy Agent - <a href="https://github.com/traefik/traefik/issues/4894">https://github.com/traefik/traefik/issues/4894</a></li>
</ul>
<h2 id="wrappingup">Wrapping Up</h2>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/10/Twitter.jpg" class="kg-image" alt="Traefik Hackaethon 2020: Middleware Plugins Brain Dump" srcset="https://containous.ghost.io/content/images/size/w600/2020/10/Twitter.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Twitter.jpg 1000w, https://containous.ghost.io/content/images/2020/10/Twitter.jpg 1024w" sizes="(min-width: 720px) 720px"><figcaption><a href="https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/">Sign up for the Hackaethon today</a> and receive a t-shirt and sticker for participating!</figcaption></img></figure><!--kg-card-begin: markdown--><p>In addition to the plugin ideas curated above, we are working on putting together a list of issues that contributors can work on if they're not interested in building a plugin. We want to ensure that anyone can participate in the Hackaethon, including features, bugs, and documentation tasks that anyone can pick up and start working on.</p>
<p>For those interested in building custom plugins, we have a meetup scheduled next week before the Hackaethon to demonstrate how easy they are to develop. You can <a href="https://us02web.zoom.us/webinar/register/WN_9LpcglyRSJy89iEYN0ZsbQ" rel="nofollow" target="_blank">sign up for the plugin meetup</a> and receive the link today. We’re looking forward to seeing everyone at the meetup and the Hackaethon next week and look forward to seeing what you build.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Install And Configure Traefik with Helm]]></title><description><![CDATA[Install And Configure Traefik with Helm by Robin Sherrer and Daniele Di Rosa. Learn how they went from Traefik 1.x to 2.0, installing and configuring Helm. ]]></description><link>https://traefik.io/blog/install-and-configure-traefik-with-helm/</link><guid isPermaLink="false">Ghost__Post__5f5fc262a72a090039800e87</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[containeroo]]></dc:creator><pubDate>Tue, 06 Oct 2020 14:00:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/09/Kubernetes-and-Helm-blog-1.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://containous.ghost.io/content/images/2020/09/Kubernetes-and-Helm-blog-1.jpg" alt="Install And Configure Traefik with Helm"/><p><strong>Guest post by Traefik Ambassador, Robin Scherrer and Daniele Di Rosa aka Containeroo.</strong></p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Kubernetes-and-Helm-blog-2.jpg" class="kg-image" alt="Install And Configure Traefik with Helm" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Kubernetes-and-Helm-blog-2.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Kubernetes-and-Helm-blog-2.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Kubernetes-and-Helm-blog-2.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Kubernetes-and-Helm-blog-2.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><!--kg-card-begin: markdown--><p>When we started our container journey with Docker some years ago, we looked for an easy to configure reverse proxy to expose our services to the internet. Daniele had seen a video about the best Docker projects where Emile Vauge, founder of Traefik, delivered a presentation about Traefik. And, we decided to give Traefik a shot. We started with using Traefik 1.x, and then moved to Traefik 2.0 a couple of years later.</p>
<p>When Traefik 2.0 was released, we spent the weekend figuring out how it works, and the next week, decided to help others have a tremendous “getting started” experience by writing a simple step by step guide. And, with our roles on the Kubernetes team at work, we went on to replace the existing reverse proxy Ambassador with Traefik.</p>
<h2 id="thetutorial">The Tutorial</h2>
<p>In this tutorial, we will show you how to install and configure Traefik using the official Helm chart. We will also show you how to configure Traefik with Cloudflare. This makes wildcard Let's Encrypt certificates possible.<br>
Helm makes it easy to deploy applications onto your Kubernetes cluster. Even though Traefik supports both Ingress as well as Traefik IngressRoute, we prefer to use the CRD instead of Ingress which results in a lot of annotations.</br></p>
<h2 id="prerequisites">Prerequisites</h2>
<ul>
<li>Kubernetes Cluster</li>
<li>Helm <a href="https://helm.sh" target="_blank" rel="nofollow">official docs</a></li>
<li>Kubeconfig file for Helm to access your Kubernetes Cluster (<code>~/.kube/config</code>)</li>
</ul>
<h2 id="preparehelmchart">Prepare Helm Chart</h2>
<p>First, you’ll need to add the official Helm repository to your Helm client. You can do that by issuing the following command:</p>
<pre><code class="language-bash">helm repo add traefik https://helm.traefik.io/traefik
helm repo update
</code></pre>
<p>In order to configure the Helm chart, you'll need to specify certain values. You can find all the values possible <a href="https://github.com/traefik/traefik-helm-chart/blob/master/traefik/values.yaml" target="_blank" rel="nofollow">here</a>.<br>
Open your favourite editor and set the values you want to change. Here is an example <code>traefik-chart-values.yaml</code> file:</br></p>
<pre><code class="language-yaml">additionalArguments:
  - --providers.file.filename=/data/traefik-config.yaml
  - --entrypoints.websecure.http.tls.certresolver=cloudflare
  - --entrypoints.websecure.http.tls.domains[0].main=example.com
  - --entrypoints.websecure.http.tls.domains[0].sans=*.example.com
  - --certificatesresolvers.cloudflare.acme.dnschallenge.provider=cloudflare
  - --certificatesresolvers.cloudflare.acme.email=mail@example.com
  - --certificatesresolvers.cloudflare.acme.dnschallenge.resolvers=1.1.1.1
  - --certificatesresolvers.cloudflare.acme.storage=/certs/acme.json
ports:
  web:
    redirectTo: websecure
env:
  - name: CF_API_EMAIL
    valueFrom:
      secretKeyRef:
        key: email
        name: cloudflare-api-credentials
  - name: CF_API_KEY
    valueFrom:
      secretKeyRef:
        key: apiKey
        name: cloudflare-api-credentials
ingressRoute:
  dashboard:
    enabled: false
persistence:
  enabled: true
  path: /certs
  size: 128Mi
volumes:
  - mountPath: /data
    name: traefik-config
    type: configMap
</code></pre>
<p>With this values file, you are configuring Traefik to:</p>
<ul>
<li>use <code>/data/traefik-config.yaml</code> as a static configuration file</li>
<li>use Cloudflare as a certificates resolver</li>
<li>set the domain <code>example.com</code> as the certificates main domain</li>
<li>set <code>*.example.com</code> as the certificates sans</li>
<li>store the certificates in <code>/certs/acme.json</code></li>
</ul>
<h2 id="installtraefik">Install Traefik</h2>
<p>As a first step, you’ll need to create a Kubernetes namespace:</p>
<pre><code class="language-bash">kubectl create namespace traefik
</code></pre>
<p>Before you deploy the Helm chart, you’ll need to add the secret containing the Cloudflare credentials along with the configmap including the static configuration.<br>
Create a <code>traefik-config.yaml</code> file with the following content:</br></p>
<pre><code class="language-yaml">---
apiVersion: v1
kind: Secret
metadata:
  name: cloudflare-api-credentials
  namespace: traefik
type: Opaque
stringData:
  email: your@cloudflare.email
  apiKey: YOURCLOUDFLAREAPIKEY
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: traefik-config
  namespace: traefik
data:
  traefik-config.yaml: |
    http:
      middlewares:
        headers-default:
          headers:
            sslRedirect: true
            browserXssFilter: true
            contentTypeNosniff: true
            forceSTSHeader: true
            stsIncludeSubdomains: true
            stsPreload: true
            stsSeconds: 15552000
            customFrameOptionsValue: SAMEORIGIN
</code></pre>
<p>As an example, we've added a <code>headers-default</code> middleware. For the complete static configuration, please consult the <a href="https://docs.traefik.io/reference/static-configuration/file/">Traefik docs</a>.<br>
Next, you can apply the secret and configmap you created above:</br></p>
<pre><code class="language-bash">kubectl apply -f traefik-config.yaml
</code></pre>
<p>This will create the secret and configmap in the <code>traefik</code> namespace.<br>
Now it's time to deploy Traefik! The following command will install Traefik in the <code>traefik</code> namespace and with the configuration you created above::</br></p>
<pre><code class="language-bash">helm install traefik traefik/traefik --namespace=traefik --values=traefik-chart-values.yaml
</code></pre>
<h2 id="makethedashboardaccessible">Make the Dashboard Accessible</h2>
<p>In order to access the Traefik dashboard, you’ll first need to create an HTTP basic auth middleware. This also requires a secret with the htpasswd credentials.<br>
Use the following command to create a base64 encoded htpasswd file with a <code>kangoroo</code> user and the password <code>jack</code>:</br></p>
<pre><code class="language-bash">htpasswd -nb kangoroo jack | openssl base64
</code></pre>
<p>Apply the secret and the middleware to your Kubernetes cluster:</p>
<pre><code class="language-yaml">---
apiVersion: v1
kind: Secret
metadata:
  name: traefik-dashboard-auth
  namespace: traefik
data:
  users: |2
    a2FuZ29yb286JGFwcjEkdGlQbFBINXYkYlJrUHBSUlYuYUxUWnhFRzdYbmduMAoK
---
apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: traefik-dashboard-basicauth
  namespace: traefik
spec:
  basicAuth:
    secret: traefik-dashboard-auth
</code></pre>
<p>Now you can apply the following <code>traefik-dashboard-ingressroute.yaml</code> file:</p>
<pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: traefik-dashboard
  namespace: traefik
spec:
  entryPoints:
    - websecure
  routes:
    - match: Host(`traefik.example.com`)
      kind: Rule
      middlewares:
        - name: traefik-dashboard-basicauth
          namespace: traefik
      services:
        - name: api@internal
          kind: TraefikService
</code></pre>
<p>Please change the matching host rule accordingly under the <code>routes</code> section.<br>
Since Traefik exposes the dashboard in a special way, you’ll need to tell the IngressRoute to use the preconfigured service named <code>api@internal</code> with kind <code>TraefikService</code>.</br></p>
<h2 id="theingressroutecrd">The IngressRoute CRD</h2>
<p>As we've mentioned above, Traefik both supports Ingress and IngressRoute as a configuration.<br>
The CRD has a few advantages:</br></p>
<ul>
<li>eliminate or reduce the number of annotations on the Ingress controllers</li>
<li>abstract commonly used rules and configuration</li>
<li>separate concerns across multiple use-cases and configurations<br>
To deploy a simple <code>whoami</code> application service, please refer to the appendix.<br>
Here is an example IngressRoute for the <code>whoami</code> service:</br></br></li>
</ul>
<pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: whoami
  namespace: traefik
spec:
  entryPoints:
    - websecure
  routes:
    - match: Host(`whoami.example.com`)
      kind: Rule
      middlewares:
        - name: headers-default@file
      services:
        - name: whoami
          port: 80
</code></pre>
<p>This IngressRoute tells Traefik to listen via the <code>websecure</code> entrypoint and forward all the traffic matching the host <code>whoami.example.com</code> to the <code>whoami</code> Kubernetes service. It also configures the route to use the <code>headers-default</code> middleware you configured in <code>traefik-config.yaml</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As you can see, getting started with Traefik as an Ingress controller isn't that hard :-)  Helm makes it really easy to reconfigure or update Traefik.</p>
<p>Traefik documentation has a lot of good information and can be a great resource once you’ve gotten started using this guide. We bet it will answer most of your questions!</p>
<p>You can find us on <a href="https://twitter.com/containeroo" target="_blank" rel="nofollow">Twitter</a>, <a href="https://medium.com/@containeroo" target="_blank" rel="nofollow">Medium</a> or <a href="https://github.com/containeroo" target="_blank" rel="nofollow">GitHub</a>. Feel free to ask any questions regarding Traefik and Kubernetes. We are happy to help!</p>
<h2 id="appendix">Appendix</h2>
<h3 id="whoamiexampledeployment">Whoami Example Deployment</h3>
<pre><code class="language-yaml">---
apiVersion: v1
kind: Pod
metadata:
  name: whoami
  namespace: traefik
  labels:
    app: whoami
spec:
  containers:
    - name: whoami
      image: containous/whoami:latest
      ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: whoami
  namespace: traefik
spec:
  ports:
    - port: 80
      protocol: TCP
      targetPort: 80
  selector:
    app: whoami
  type: ClusterIP
</code></pre>
<h2 id="aboutus">About Us</h2>
<p>Because of our knowledge in Docker, we were able to switch departments at work, and are now working in the Kubernetes department. One of the first things we did was eliminate the existing reverse proxy and switch to Traefik :-D</p>
<p>Robin:<br>
Swiss IT nerd since forever. Interested in open source technologies like Ansible, Docker, Kubernetes, Traefik, Python and Golang. Maintainer of several GitHub repos and Docker images for containeroo. Addicted to music, tv shows and YouTube. Speaking German and English. <a href="https://twitter.com/rxbn" target="_blank" rel="nofollow">Twitter</a>, <a href="https://reddit.com/u/rxbn" target="_blank" rel="nofollow">Reddit</a> or <a href="https://github.com/rxbn" target="_blank" rel="nofollow">GitHub</a>.</br></p>
<p>Daniele:<br>
Couch potato, film and series junky, hobby-columnist for Containeroo, likes Traefik, Ansible, Docker and K8s. Hates corn and dill. Born and raised in Switzerland. Star me on <a href="https://github.com/gi8lino" target="_blank" rel="nofollow">GitHub</a>.</br></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Announcing Traefik Mesh 1.4 - New Name, New Features]]></title><description><![CDATA[Traefik Mesh 1.4 brings some under-the-hood changes and new features, including support for a new version of the Service Mesh Interface (SMI) specification, enabling filtering by headers and more.]]></description><link>https://traefik.io/blog/announcing-traefik-mesh-1-4-new-name-new-features/</link><guid isPermaLink="false">Ghost__Post__5f61ed21a72a090039800f23</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Thu, 01 Oct 2020 14:17:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg" class="kg-image" alt="Announcing Traefik Mesh 1.4 - New Name, New Features" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><!--kg-card-begin: markdown--><img src="https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Mesh-1.4---New-Name--New-Features-1.jpg" alt="Announcing Traefik Mesh 1.4 - New Name, New Features"/><p>Today, we're renaming the Maesh project to Traefik Mesh, and this corresponds with the renaming of the company behind the project to Traefik Labs. You can learn more about the company-wide rebranding effort <a href="https://traefik.io/blog/traefik-labs-incubating-the-future-of-cloud-native-networking/" target="_blank" rel="nofollow">here</a>.</p>
<!--kg-card-end: markdown--><p>In addition to the renaming, Traefik Mesh 1.4 also brings some under-the-hood changes and new features, including support for a new version of the Service Mesh Interface (SMI) specification, enabling filtering by headers and more.</p><h2 id="renaming-of-the-project">Renaming of the Project</h2><p>As mentioned, the project is now called Traefik Mesh. The name change includes some changes in the project configuration as well. You'll notice that the annotation prefix, the binary name, the prefix for environment variables, and the configuration file's default name have all changed.</p><!--kg-card-begin: markdown--><p>More importantly, we changed the DNS name to opt-in into the mesh usage from <code>.maesh</code> to <code>.traefik.mesh</code>. However, we made all of it backward compatible, so you should not encounter problems while transitioning from Maesh to Traefik Mesh. More information about the migration path is available <a href="https://doc.traefik.io/traefik-mesh/migration/traefik-mesh-v1/#traefik-mesh-v14" target="_blank" rel="nofollow">in the documentation</a>.</p>
<!--kg-card-end: markdown--><h2 id="going-back-to-traefik-to-traefik">Going Back to Traefik ... to Traefik</h2><p>For Maesh 1.3, we designed and implemented a custom proxy based on Traefik so we could evolve and iterate on the technology quickly. However, the capabilities we needed for this evolution have since all been introduced upstream into Traefik, allowing us to fall back to regular Traefik Proxy nodes for service communication. With this 1.4 release, Traefik Mesh now uses the standard Traefik image distribution as its service mesh proxy, which means Traefik Proxy features will be available to environments that use Traefik Mesh.</p><h2 id="header-filtering-for-traffic-targets">Header Filtering for Traffic Targets</h2><!--kg-card-begin: markdown--><p>With the release of <a href="https://github.com/servicemeshinterface/smi-spec/releases/tag/v0.5.0" target="_blank" rel="nofollow">SMI specification v0.5.0</a>, filtering based on headers introduced in the <a href="https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md" target="_blank" rel="nofollow">Traffic Specs API v1alpha3</a> enables routing of requests based on arbitrary parameters such as browser types, and cookies. In addition to the headers, these are compatible with other filters, including request types (GET, PUT, etc.) and paths. By utilizing these new features, it's now possible to have additional flexibility when routing requests.</p>
<p>You can read more about this feature's capabilities and find examples in the <a href="https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-specs/v1alpha3/traffic-specs.md#http-header-filters" target="_blank" rel="nofollow">SMI specification</a> documents on Github.</p>
<!--kg-card-end: markdown--><h2 id="header-and-path-filtering-for-traffic-splits">Header and Path Filtering for Traffic Splits</h2><!--kg-card-begin: markdown--><p>The latest version of the spec empowers Traefik Mesh users to now run canary and A/B testing utilizing Headers, cookies, request type, and more. With the v1alpha3 release, Header filtering supports utilizing TrafficSplit and the matches attribute linked to an HTTPRouteGroup. A real world example is available in the <a href="https://github.com/servicemeshinterface/smi-spec/blob/master/apis/traffic-split/v1alpha3/traffic-split.md#specification" target="_blank" rel="nofollow">SMI specification document</a>, covering how this capability allows you to split traffic based on the aforementioned new filters.</p>
<!--kg-card-end: markdown--><h2 id="looking-ahead">Looking Ahead</h2><p>The team is continuing work implementing mTLS, and the goal is to launch that feature with the next release. With the introduction of mTLS we anticipate some significant changes. We’ll be discussing those changes on Github and publishing a Release Candidate, which needs your feedback. In addition to mTLS, we are continuing to work with the SMI group by incorporating the latest version of the specification and contributing towards the implementation of routing UDP traffic. We expect to have that ready for the next release as well.</p><p>We love hearing from the community on how you’re using Traefik Mesh today in your environments and what features you’d like to see in the future. Let us know by opening a Feature Request or reaching out to us on our community forums.</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://traefik.io/traefik-mesh/">Website</a></li><li><a href="https://doc.traefik.io/traefik-mesh/">Documentation</a></li><li><a href="https://traefik.io/traefik-mesh/">Github</a></li><li><a href="https://community.traefik.io/c/traefik-mesh/15">Community Forum</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Announcing Traefik Enterprise 2.2, now an all-in-one ingress, API management, and service mesh solution]]></title><description><![CDATA[Traefik Enterprise 2.2 includes integrated service mesh capabilities, an improved web UI, support for OpenID Connect authentication, and more.]]></description><link>https://traefik.io/blog/announcing-traefik-enterprise-2-2-now-an-all-in-one-ingress-api-management-and-service-mesh-solution/</link><guid isPermaLink="false">Ghost__Post__5f6531426bd3ed003915e5e9</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Nicolas Mengin]]></dc:creator><pubDate>Tue, 29 Sep 2020 14:00:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Enterprise-2.2-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Enterprise-2.2.jpg" class="kg-image" alt="Announcing Traefik Enterprise 2.2, now an all-in-one ingress, API management, and service mesh solution" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Announcing-Traefik-Enterprise-2.2.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Announcing-Traefik-Enterprise-2.2.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Announcing-Traefik-Enterprise-2.2.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Enterprise-2.2.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><img src="https://containous.ghost.io/content/images/2020/09/Announcing-Traefik-Enterprise-2.2-1.jpg" alt="Announcing Traefik Enterprise 2.2, now an all-in-one ingress, API management, and service mesh solution"/><p><a href="https://traefik.io/traefik-enterprise/">Traefik Enterprise 2.2</a> is here, bringing with it a number of new features and enhancements to our enterprise-grade, cloud-native edge router built on Traefik technology. This latest release includes integrated service mesh capabilities, an improved web UI, support for OpenID Connect authentication, and more.</p><h2 id="integrated-service-mesh"><strong>Integrated Service Mesh</strong></h2><p>Managing a microservice architecture built on Kubernetes requires dealing with external and internal connections (sometimes called north-south and east-west connections, respectively). An ingress controller is the software that routes the north-south connections from the external network, while a service mesh is the increasingly popular choice for managing east-west connections between services on the internal network..</p><p>The usual case is to split the responsibilities between a separate ingress controller and service mesh. But the downside of this architecture is that it means that you have to install, configure, and maintain two different tools, often with very different capabilities and configuration styles.</p><p>That's where Traefik Enterprise 2.2 comes in.</p><p>Traefik Enterprise can now act as both a Kubernetes ingress controller, based on the well-known Traefik edge router, and a service mesh based on Traefik Mesh, the lightweight and simpler service mesh.</p><p>Thus, Traefik Enterprise simplifies your workflow:</p><ul><li>It enables you to install both your ingress controller and your service mesh with a single command</li><li>It requires a single configuration file to manage them together</li><li>It comes with a dashboard to monitor your whole network environment easily</li></ul><p>Traefik Enterprise’s service mesh is designed to be non-invasive. It requires no sidecar containers and does not modify your Kubernetes objects, and it’s 100% opt-in.</p><p>Take advantage of this feature by following <a href="https://doc.traefik.io/traefik-enterprise/operations/service-mesh/">the comprehensive guide in the documentation.</a></p><h2 id="improved-webui"><strong>Improved WebUI</strong></h2><p>The key to managing microservices infrastructure is monitoring. You can’t fix the problems in your infrastructure if you don’t know what and where they are.</p><p>To this end, we’ve updated the Traefik Enterprise dashboard with features that allow you to monitor your cluster alerts at a glance.</p><figure class="kg-card kg-image-card"><img src="https://lh3.googleusercontent.com/jwBeNWko1GGuIZSIC4yhBQgNXQ4CI6PW2W_61Y25aaHfFTvWrHIzfUydIU-N8freBJ_WvHVvxir6UuEocZqfPzo0STBnEN__bQaa_mP_WpDJASJQ9E_m3vSrBtf97oAs8madpsk" class="kg-image" alt="Announcing Traefik Enterprise 2.2, now an all-in-one ingress, API management, and service mesh solution"/></figure><p>If an error occurs in your cluster, your services, routers, or middlewares configuration, it will be reported on the new welcome page. From there, you will be able to navigate to the error source to fix it.</p><figure class="kg-card kg-image-card"><img src="https://lh3.googleusercontent.com/VCZR58NdsYD1HKVDhIyit9bVcp3CdywV9bpRX9fT1wcij4Qp2-3o_rbesk-Ncu-Yoio3QacblGbXiM2_i-purKbClCJLIBYoaB51iJ55-i6FkIl8ZqYL5hvW5_UoOBj4yWnpUiY" class="kg-image" alt="Announcing Traefik Enterprise 2.2, now an all-in-one ingress, API management, and service mesh solution"/></figure><p>Additionally, if you choose to enable the new service mesh option, Traefik Enterprise 2.2’s enhanced dashboard provides a diagram to monitor your service mesh connections.</p><p>Using it, you won't have to read through all of your Kubernetes configuration files to know why your Kubernetes services don’t communicate as expected!</p><figure class="kg-card kg-image-card"><img src="https://lh5.googleusercontent.com/1tekIayHmgN5ZA1BjRwvxyPAD8_S684J6Qr-jK4g4-6ANNoo-Rs6k0qA7h0WAgIDEPxq3GOHLw9CfA9iqB5uXV2H7FRVZ2j3uQeiTyl_j4kizrqy50ggZpVW3gL2M6FsEMgjTa4" class="kg-image" alt="Announcing Traefik Enterprise 2.2, now an all-in-one ingress, API management, and service mesh solution"/></figure><h2 id="openid-connect"><strong>OpenID Connect</strong></h2><p>Whether you expose one API or hundreds, if you want to sleep well at night, you will have to secure your infrastructure. Authentication is a critical component of this.</p><p>Traefik Enterprise has acknowledged this need. That's why, on top of the existing authentication middlewares (such as LDAP, OAuth 2.0 token introspection, and JWT), v2.2 adds a new <a href="https://doc.traefik.io/traefik-enterprise/middlewares/oidc/">OpenID Connect (OIDC) middleware</a>.</p><!--kg-card-begin: markdown--><p><a href="https://openid.net/connect/" target="_blank" rel="nofollow">OIDC</a> is a very popular framework built on top of OAuth 2.0 to handle authentication workflows.</p>
<!--kg-card-end: markdown--><p>Using the OIDC middleware, you'll secure your applications by delegating the authentication to an external provider (such as GitHub, Google Accounts, LinkedIn, etc.) with a straightforward configuration. Here’s an example:</p><!--kg-card-begin: markdown--><pre><code class="language-yaml">http:
middlewares:
myoidc:
plugin:
oidcAuth:
source: googleSource
redirectUrl: example.com/callback
session:
secret: mysupersecret123
</code></pre>
<!--kg-card-end: markdown--><p>Securing a service couldn’t be easier.</p><h2 id="traefik-enterprise-provider"><strong>Traefik Enterprise provider</strong></h2><p>One of the main advantages of Traefik Enterprise has always been the dynamic configuration. Are you a Kubernetes user? Create a CRD, and let the magic happen. Docker user? Add labels to your container… et voilà!</p><p>But if you are a bare metal user, so far you have had to share your configuration file between machines manually. To ease your work, Traefik Enterprise 2.2 includes a new internal provider that allows you to set your configuration using the teectl CLI.</p><p>You need only execute one command and your cluster is automatically updated. The configuration is still stored in a file for ease of maintenance.</p><!--kg-card-begin: markdown--><pre><code class="language-bash">teectl apply dyn-configuration.yaml
</code></pre>
<!--kg-card-end: markdown--><h2 id="what-s-next"><strong>What's Next?</strong></h2><p>With the addition of service mesh support, Traefik Enterprise brings important new functionality on top of its existing high availability, distributed services, and enterprise authentication protocols. We’ll continue to develop more exciting features to benefit customers who choose Traefik Enterprise.</p><p>Take a closer look at <a href="https://traefik.io/traefik-enterprise/">Traefik Enterprise’s features</a> to learn more. If you want to test drive this new version, <a href="https://info.traefik.io/get-traefik-enterprise-free-for-30-days">sign up for a free trial of Traefik Enterprise 2.2 today</a>.</p>]]></content:encoded></item><item><title><![CDATA[Introducing Traefik Pilot 1.0: the Traefik Control Center]]></title><description><![CDATA[Today, we’re announcing that Traefik Pilot 1.0 is available and ready to connect with all Traefik instances, everywhere.]]></description><link>https://traefik.io/blog/introducing-traefik-pilot-1-0-one-place-to-manage-all-your-traefik-instances/</link><guid isPermaLink="false">Ghost__Post__5f6c0a086bd3ed003915e724</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Pierre Erraud]]></dc:creator><pubDate>Thu, 24 Sep 2020 15:38:23 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/09/Traefik-Pilot-the-control-center-for-Traefik-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg" class="kg-image" alt="Introducing Traefik Pilot 1.0: the Traefik Control Center" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Traefik-Pilot-the-control-center-for-Traefik.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/09/Traefik-Pilot-the-control-center-for-Traefik-1.jpg" alt="Introducing Traefik Pilot 1.0: the Traefik Control Center"/><p>In July, we debuted a <a href="https://traefik.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/">preview release</a> of <a href="https://traefik.io/traefik-pilot/">Traefik Pilot</a>, a new SaaS platform that extends the functionality of Traefik. Today, we’re announcing that Traefik Pilot 1.0 is available and ready to connect with all Traefik instances, everywhere.</p><p>Traefik is known for its extensive compatibility with third-party vendors and its ability to adapt to multiple topologies. Traefik Pilot extends this flexibility and ease-of-use beyond the data center to provide a similar experience for the entire ecosystem of components that make up a complete application. It achieves this in a number of ways.</p><p>First, Traefik Pilot provides visibility into cloud-native architectures. Containerized applications and microservices are dynamic by nature, and they typically involve multiple network connections linking diverse components. Apps teams want to know what is happening within their installations: to visualize the history and durations of requests, to analyze changes in behavior, and to see when load has peaked and for how long. Such capabilities are essential to pinpoint the root causes of issues within the infrastructure.</p><p>While visibility is good, however, being notified or alerted is better. Traefik Pilot’s timely alerts allow operators to mitigate issues, apply processes, or analyze anomalous situations in real time, which leads to higher availability and improved end user experience.</p><p>In addition to these features, Traefik Pilot also introduces the ability for Traefik operators to <a href="https://traefik.io/blog/unleash-custom-networking-logic-with-traefik-plugins/">create their own plugins</a>, including custom middlewares, and easily find and share plugins with others through the Traefik Pilot online plugin catalog.</p><p>Traefik Pilot 1.0 brings a number of enhancements since the release candidate. Let’s take a look at some of the most significant ones.</p><h2 id="improved-web-ui">Improved web UI</h2><p>We heard users’ feedback from the preview release, and as a result, we have transformed the UI to make the Traefik Pilot user experience even more straightforward. We think you’ll agree that these modifications allow everyone to use Traefik Pilot in the most natural way possible.</p><figure class="kg-card kg-image-card"><img src="https://lh5.googleusercontent.com/u6I9Ey-FC64mBgKTk9ywWLDvwXsn321r_5OQXYUuT2PBk7yXc7HsKPMbOUFDg4vMINBq7fuXt77SL0BO5QylRbaaLtjUmRH-wmRBN0lSk6rslkbfJl6PrSSHmv5VeOD4SiQ4DBA" class="kg-image" alt="Introducing Traefik Pilot 1.0: the Traefik Control Center"/></figure><h2 id="new-metrics-dashboard">New metrics dashboard</h2><p>Would you like metrics for your Traefik instances? Just connect your instances to Traefik Pilot, and voilà!</p><p>Starting today, all instances registered in Traefik Pilot will benefit from this new feature, which allows you to diagnose and record changes in the usage of the instances or services behind Traefik through graphs spanning a day, a week, or a month.</p><figure class="kg-card kg-image-card"><img src="https://lh5.googleusercontent.com/GzICwYarm48ofOcT8G-lXWxhWKyH7HwYvdl05uKsQ_fFmTyzRkatHfgpto1TTh4rv7JJppjUhX4_Ong4HcRzQPLwNUbMOdthbJ4Q-BWYEMSAPFfk6CKRHp_nCmNlW1QA0T__uos" class="kg-image" alt="Introducing Traefik Pilot 1.0: the Traefik Control Center"/></figure><h2 id="enhanced-alerts">Enhanced alerts</h2><p>Traefik Pilot 1.0 offers two types of alerts. They can be enabled in your profile settings and can be delivered either by email or through a webhook.</p><p>First, Traefik Pilot can notify you when a Traefik instance no longer has access to the internet. If a connected Traefik instance fails to contact Traefik Pilot for 5 minutes, it will be marked as unreachable in the Traefik Pilot dashboard. If the instance still does not contact Traefik Pilot after 10 minutes, the instance will disappear from the dashboard and you will be notified of the lack of connectivity..</p><p>Traefik Pilot can also raise an alert when a security vulnerability is found in Traefik. Starting today, for any CVE involving Traefik, if your instance is connected to Traefik Pilot and is vulnerable, you will receive a notification through the same communication channels.</p><h2 id="growing-plugin-ecosystem">Growing plugin ecosystem</h2><p>Since the preview release, Traefik Pilot has made it possible to extend the functionality of Traefik with plugins. We are proud and encouraged to see the plugins that have already been created by the community.</p><figure class="kg-card kg-image-card"><img src="https://lh3.googleusercontent.com/_c72__zIyl4c8BGJYXRRKGoy6Pb8JZh9WKBLbft_y4my0QN-WvNb0gdaThyKBqIBBImOUTqi5gqg4_JR3lSFokyMY8mwVjfby5r_HxXTM5m08vY3oZAIHyPW43LOZprJnXYtuL4" class="kg-image" alt="Introducing Traefik Pilot 1.0: the Traefik Control Center"/></figure><p>Plugins are a feature that opens up a wide range of possibilities with Traefik. Although this feature is still experimental, we are looking forward to seeing how the community around plugins continues to grow. To learn more about creating your own plugins, consult the <a href="https://github.com/traefik/plugindemo">developer documentation</a>.</p><h2 id="onward-and-upward">Onward and upward</h2><p>We have a lot of ideas for the continuation of Traefik Pilot, including additional types of alerts and more. </p><p>One particular area of focus is on multi-cluster management, with the aim of making it possible to easily manage multiple datacenters. Because most (but not all) HTTP traffic is now encrypted with TLS, we plan to provide tools for Traefik Pilot to simplify certificate management. </p><p>We are also working on connecting Traefik Enterprise to Traefik Pilot, to bring all the features of Traefik Pilot to your Traefik Enterprise instances. </p><p>Finally, there will probably be one or more surprises. For now, we hope you enjoy all the features that <a href="https://pilot.traefik.io/">Traefik Pilot 1.0</a> has to offer, and we <a href="https://community.traefik.io/c/traefik-pilot/18">welcome your feedback</a>.</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://traefik.io/traefik-pilot">Traefik Pilot</a></li><li><a href="https://pilot.traefik.io/">Get started</a></li><li><a href="https://docs.traefik.io/v2.3/plugins/overview/">Pilot documentation</a></li><li><a href="https://traefik.io/traefik/">Traefik</a></li><li><a href="https://community.containo.us/c/traefik/5">Community forum</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Houston, we have Plugins! Traefik 2.3 Announcement]]></title><description><![CDATA[Traefik 2.3, the latest version of the most popular open source cloud native proxy, is now available. With plugins, ECS provider, and more!]]></description><link>https://traefik.io/blog/houston-we-have-plugins-traefik-2-3-announcement/</link><guid isPermaLink="false">Ghost__Post__5f61e3c3a72a090039800ee6</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Wed, 23 Sep 2020 14:30:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/09/Traefik2-3-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Traefik2-3.jpg" class="kg-image" alt="Houston, we have Plugins! Traefik 2.3 Announcement" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Traefik2-3.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Traefik2-3.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Traefik2-3.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Traefik2-3.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/09/Traefik2-3-1.jpg" alt="Houston, we have Plugins! Traefik 2.3 Announcement"/><p>Today we're proud to announce the latest release of Traefik! Traefik 2.3 brings in new capabilities, including the Traefik Plugin system, integration with Traefik Pilot, support for Amazon ECS, and support for the Kubernetes IngressClass API resource launched in Kubernetes 1.18. Let’s dive in and explore what these features mean for you, our users.</p><h3 id="traefik-plugins">Traefik Plugins</h3><p>With Go 1.8's release in March 2017, our community's <a href="https://github.com/traefik/traefik/issues/1336">most requested feature</a> has been to add middleware plugin support to Traefik. Well, it's here. Traefik now supports the ability to add custom middleware functionality to your environment easily. Today, several useful plugins in the marketplace are waiting for you to use, such as <a href="https://pilot.traefik.io/plugins/276809782519661056/block-path">BlockPath</a> and <a href="https://pilot.traefik.io/plugins/276812076107694611/deny-ip-plugin">Deny Ip</a>. Plugins are designed to function and operate just like any other native <a href="https://docs.traefik.io/middlewares/overview/">middlewares</a> already distributed with Traefik.</p><p>The plugin system operates in conjunction with Traefik Pilot, which maintains a catalog of community created plugins and a hash for each version published by the author. For security, Pilot ensures that you are running the actual code committed and tagged on GitHub every time Traefik launches.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/09/image-3.png" class="kg-image" alt="Houston, we have Plugins! Traefik 2.3 Announcement" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/image-3.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/image-3.png 1000w, https://containous.ghost.io/content/images/2020/09/image-3.png 1359w" sizes="(min-width: 720px) 720px"><figcaption>Custom middleware plugins for the community, by the community</figcaption></img></figure><p>You can either <a href="https://doc.traefik.io/traefik/v2.3/plugins/using-plugins/">get started</a> using the <a href="https://pilot.traefik.io/plugins">existing plugins marketplace</a> or <a href="https://github.com/traefik/plugindemo">create your own plugin</a>. We can't wait to see what the community is going to build!</p><h3 id="traefik-pilot-integration">Traefik Pilot Integration</h3><p>Traefik Pilot is a managed SaaS application offered by Traefik Labs that helps operators of Traefik ensure their environments are operating efficiently and securely. This new integration brings users not only the plugins mentioned above but a centralized platform that provides performance metrics, security, and update notifications in real time. You can get started with Traefik Pilot today by signing up and configuring your Traefik instances with a uniquely generated key.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/09/image-2.png" class="kg-image" alt="Houston, we have Plugins! Traefik 2.3 Announcement" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/image-2.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/image-2.png 1000w, https://containous.ghost.io/content/images/2020/09/image-2.png 1359w" sizes="(min-width: 720px) 720px"><figcaption>Traefik Pilot automatically collects performance metrics from your Traefik instances</figcaption></img></figure><p>Once registered and activated, your Traefik instance will periodically send information to Traefik Pilot, providing you with insight into the performance, security, and availability of your Traefik instances.</p><p>Traefik Pilot will monitor the following data points on every Traefik instance you register:</p><!--kg-card-begin: markdown--><ul>
<li>Health Status and Availability Alerts</li>
<li>Version Information and Security Alerts</li>
<li>Performance Metrics
<ul>
<li>Requests per second</li>
<li>Total requests</li>
<li>Request duration</li>
</ul>
</li>
</ul>
<!--kg-card-end: markdown--><p>For additional details about Traefik Pilot and the features available upon registration of your Traefik instance, please check out the product announcement for Pilot.</p><h2 id="amazon-ecs-provider"><strong>Amazon ECS Provider</strong></h2><p>Amazon ECS is a managed orchestration service that can be used either on its own or in conjunction with Fargate, the AWS serverless compute engine for containers. The ECS provider for Traefik allows for the dynamic configuration of the provider using labels attached to your ECS containers.</p><!--kg-card-begin: markdown--><p>This feature was contributed by <a href="https://github.com/alekitto" target="_blank" rel="nofollow">alekitto</a>, a community member, who refactored code from v1.x to support ECS by implementing the provider for the latest versions of Traefik. Thanks to his time and effort, the rest of the Traefik community can benefit while running their ECS workloads.</p>
<!--kg-card-end: markdown--><p>More information on how to activate or configure the provider is available here: <a href="https://doc.traefik.io/traefik/v2.3/providers/ecs/">https://doc.traefik.io/v2.3/providers/ecs/</a></p><h2 id="kubernetes-ingressclass"><strong>Kubernetes IngressClass</strong></h2><!--kg-card-begin: markdown--><p>With the release of Kubernetes 1.18, <a href="https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/" target="_blank" rel="nofollow">improvements made to the Ingress API</a> have made possible new capabilities in Traefik 2.3. This release includes the ability to specify how Ingress paths should match, and features a new IngressClass resource that allows users to specify how controllers should implement Ingress resources. You can use these new APIs in Traefik with this release, which means better interoperability and vendor neutrality.</p>
<p>Also, Ingress resources utilizing the new <code>pathType</code> field will be supported accordingly. More information on how to utilize the support for the new IngressClass resource can be found both in <a href="https://doc.traefik.io/traefik/providers/kubernetes-ingress/#ingressclass">our documentation</a> and the Kubernetes <a href="https://v1-18.docs.kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="nofollow">official docs</a>.</p>
<!--kg-card-end: markdown--><h2 id="the-road-ahead">The Road Ahead</h2><p>We're excited about the work we have ahead of us for the next release, Traefik 2.4. We are planning to revamp the Getting Started guides for 2.x, and with that will include common use case examples with introductions to more complex topics for popular platforms such as Kubernetes and Docker Swarm. This work comes after hearing from the community how we could improve the documentation and begin with more transparent explanations on the new configuration approaches and how to get started with it.</p><p>Also, we're looking at the configuration of Traefik itself and how we can abstract everyday use cases into a simpler and easy to use format. You'll be hearing more about this and other enhancements to Traefik, including support for the latest Kubernetes Service API that the team at Google has been working on, and features to support the inclusion of mTLS in Traefik Mesh.</p><p>We love hearing from the community on how you're using Traefik and what features you'd like to see in the future. Let us know by opening a <a href="https://github.com/traefik/traefik/issues/new?template=Feature_request.md">Feature Request</a> or reaching out to us on our community forums.</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://traefik.io/traefik/">Website</a></li><li><a href="https://doc.traefik.io/traefik/v2.3/">Documentation</a></li><li><a href="https://github.com/traefik/traefik">Github</a></li><li><a href="https://community.traefik.io/c/traefik/traefik-v2">Forum</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Traefik Labs: Incubating the Future of Cloud Native Networking]]></title><description><![CDATA[Today is a big day for Containous and the entire Traefik community! As Traefik crosses yet another major download milestone, we continue on our mission of simplifying cloud-native networking by launching our first cloud offering. ]]></description><link>https://traefik.io/blog/traefik-labs-incubating-the-future-of-cloud-native-networking/</link><guid isPermaLink="false">Ghost__Post__5f6ab0a66bd3ed003915e68a</guid><category><![CDATA[Blog]]></category><category><![CDATA[Announcements]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Wed, 23 Sep 2020 12:30:48 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg" class="kg-image" alt="Traefik Labs: Incubating the Future of Cloud Native Networking" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/09/Traefik-Labs---Incubating-the-Future-of-Cloud-Native-Networking-1.jpg" alt="Traefik Labs: Incubating the Future of Cloud Native Networking"/><p>Today is a big day for Containous and the entire Traefik community. As we cross yet another major download milestone with Traefik, we continue to execute and deliver on our mission of simplifying cloud-native networking by launching a new product, our first cloud offering. And in recognition of the impact that Traefik has made to enterprise organizations all around the world, we are very proud to announce a refreshed brand and new company name that pays homage to our open-source roots.</p><h2 id="from-humble-beginnings-to-great-success">From Humble Beginnings to Great Success</h2><p>It’s hard to believe, but it was five years ago, in 2015, when I wrote the very first lines of code for Traefik. I started developing Traefik because of a basic need for an application proxy that was highly automated, open-source, and designed from the ground up for DevOps organizations and microservices platforms. Following the initial public announcement, a strong community of passionate people quickly gathered around the project. Some of these people eventually contributed code. Some contributed ideas. Countless more used the software and provided feedback. At that time, I could never have imagined that this idea would become a huge success.</p><p>Fast forward to today, Traefik just crossed the 2 billion downloads mark, with 30,000+ GitHub stars, more than 500 active contributors from all around the globe, and users from the world’s largest companies like Conde Nast, eBay, and Mailchimp. As a result, Traefik is now one of the most popular open-source projects in the world. Unlike other successful open-source projects, Traefik didn’t emerge from a large establishment like Google, Microsoft or Facebook. It was willed into existence, built by a dedicated community of people who shared a common need. The success of Traefik is a testament to every single person who joined us on this journey.</p><h2 id="a-tribute-to-our-origins">A Tribute to our Origins</h2><p>In recognition of Traefik’s momentum and its importance to our mission, we felt it was an appropriate and opportune time to pay tribute to our “heritage”. Thus, we are officially changing our company name to Traefik Labs and tweaking our product names to further support the Traefik brand. The product lineup will now include: Traefik Proxy (the original Traefik), Traefik Enterprise and Traefik Mesh (formerly Maesh).</p><p>Yet despite the name change, our organization’s mission remains unchanged. In fact, it serves as an opportunity for us to better align our products with the broader cloud-native networking challenges we continue to see plaguing enterprises. Traefik is, and will continue to be, the core engine of our product stack, even as the company builds new solutions that deliver additional functionality beyond Traefik. And as we introduce new products and services going forward, our new company name will better reflect the continued role of open source around a strong community as a foundational pillar in driving innovation.</p><h2 id="the-cloud-native-networking-struggle-is-real">The (Cloud-Native Networking) Struggle is Real</h2><p>As companies press forward with their cloud-native strategies, many are facing the harsh realization of just how different it is to run and operate containerized applications and microservices at scale. Gone are the days where you could deploy and manage applications one-by-one via a manual, almost artisanal, process. Simply put, automation is no longer a “nice to have”, but a requirement in order to realize the promised benefits of faster software releases, better reliability, simpler management, and more.</p><p>To address this need, an entire ecosystem of technologies, vendors, and communities have emerged in recent years to drive the DevOps movement and culture, where huge progress has been made in automating compute and storage infrastructure within cloud-native environments. Unfortunately, the same can’t be said for networking, where silos of technologies make integration and automation extremely difficult.</p><p>In my (pre-pandemic) travels around the world, countless enterprises articulated this same networking challenge when deploying applications as microservices in production. They are investing in container orchestration platforms (on-premises and in the public cloud), and investing in DevOps tools. But they are also desperately looking for that same fundamental transformation in networking, which is becoming increasingly urgent as they accelerate their digital transformation plans due to the pandemic.</p><h2 id="building-the-traefik-cloud-native-networking-stack-">Building the Traefik Cloud-Native Networking ‘Stack’</h2><p>With that challenge in mind, our strategy at Traefik Labs is clear: we are creating the simplest, most comprehensive cloud-native stack to help enterprises manage their entire network across data centers, on-premises servers and public clouds all the way to the edge. We have already revolutionized the application networking layer with Traefik Proxy, Enterprise and Mesh, bringing open-source based, cloud-native and simple solutions to DevOps organizations. We are now reusing this successful pattern to expand to the rest of the networking stack. </p><p>We’re taking a step in this direction today with the official release of Traefik Pilot. Traefik Pilot is a platform that provides monitoring and control of your Traefik Proxy instances through a unified dashboard, serving as the control center for the entire network stack. It also introduces a new hub for hosting user-created plug-ins built on the open-source <a href="https://traefik.io/blog/announcing-yaegi-263a1e2d070a/">Yaegi</a> project we’ve been nurturing in the recent years.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png" class="kg-image" alt="Traefik Labs: Incubating the Future of Cloud Native Networking" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png 1600w, https://containous.ghost.io/content/images/2020/09/The-Traefik-Cloud-Native-Networking-Stack.png 2048w" sizes="(min-width: 720px) 720px"><figcaption>The Traefik Cloud-Native Networking ‘Stack’</figcaption></img></figure><p>As a result, <a href="https://pilot.traefik.io/">Traefik Pilot</a> is now a cornerstone piece within the Traefik ‘Stack’. By leveraging and integrating our existing products, Traefik ‘Stack’ represents the single, integrated, networking solution enterprises need for cloud-native applications and microservices. As we look toward the future, the Traefik ‘Stack’ will soon encompass edge services like Web Application Firewall, multi-region load balancing and much more, to meet the evolving needs of application and operations teams alike.</p><p>Lastly, it should go without saying, that the core of this new ‘Stack’ will forever be open-source. The cloud-native revolution was built on open-source technologies and strong communities. We will continue to take the same simple, open-source, cloud-native approach we used in building Traefik and apply it to everything we do. This is our commitment to our customers and our community, together we will build the future of cloud-native networking.</p><p>We’ll have a lot more to say about these projects in the upcoming weeks and months, so watch this space for more details. In the meantime, I want to again extend our thanks to everyone who has joined us in our Traefik journey. As always, we’re eager to hear from you and we look forward to shaping the future of cloud-native networking together!</p>]]></content:encoded></item><item><title><![CDATA[Announcing the Inaugural Traefik Hackaethon 2020 in October]]></title><description><![CDATA[Join the team of engineers who maintain Traefik and the Traefik Ambassadors for a week of virtual hacking and collaboration on the open source projects Traefik and Maesh.]]></description><link>https://traefik.io/blog/announcing-the-inaugural-traefik-hackaethon-2020-in-october/</link><guid isPermaLink="false">Ghost__Post__5f61f4b1a72a090039800f54</guid><category><![CDATA[Blog]]></category><category><![CDATA[Announcements]]></category><dc:creator><![CDATA[Kevin Crawley]]></dc:creator><pubDate>Thu, 17 Sep 2020 17:09:59 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg" class="kg-image" alt="Announcing the Inaugural Traefik Hackaethon 2020 in October" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/09/Announcing-the-Inaugural-Traefik-Hackaethon-2020-1.jpg" alt="Announcing the Inaugural Traefik Hackaethon 2020 in October"/><p>Join the team of engineers who maintain Traefik and the Traefik Ambassadors for a week of virtual hacking and collaboration on the open source projects Traefik and Maesh. The hackathon will take place for three days, across multiple time zones, on October 20th through the 22nd. All participants who <a href="https://info.containo.us/traefik-hackaethon-2020">sign up today</a> will receive an invitation to the Discord server a few days before the event where they will be able to connect, collaborate, and pair up with other participants and developers to contribute towards making Traefik even better.</p><p>All participants will receive a limited edition t-shirt, stickers, and bonus prizes are up for grabs including multiple $100 gift card bounties for plugins, and grand prizes of $500, $250, and $100.</p><h2 id="participate-and-collaborate">Participate and Collaborate</h2><p>To be eligible as a participant, be sure to sign up for the event below and check-in for at least one day during the hackaethon and participate in the activities! During the event, you’ll be provided a link where you can provide details about your contribution, whether you’ve created a Traefik Plugin, contributed to an issue or PR, or had a PR merged in one of our projects. Be sure to include your address so we can send you some swag, and enter you for the grand prize drawings.</p><p>In the coming weeks, we’ll post more about the event, so be sure to <a href="https://info.containo.us/traefik-hackaethon-2020">sign up now</a> so you can be notified about upcoming meetups and blog posts that are related to the event. We’ll be hosting a meetup about building your own plugin, and posting a blog on ideas for plugin development so keep an eye out.</p><p>There are plenty of cool activities to get involved in, and not all of them involve writing code:</p><ul><li>Build Traefik Plugins for the newly announced Traefik Pilot Plugin Marketplace</li><li>Contribute new features, fix bugs, or even reproduce some hard to find bugs in Traefik and Maesh</li><li>Pair up with other developers and contributors to write documentation, tests, feature requests, and more</li></ul><!--kg-card-begin: html--><p style="text-align: center"><a href="https://info.containo.us/traefik-hackaethon-2020" target="_blank"><b>Sign Up for the Hackaethon 2020 Invitation</b></a></p><!--kg-card-end: html--><h3 id="plugin-bounties">Plugin Bounties</h3><p>Plugins are eligible to be awarded a $100 gift card bounty. Successful implementations of a plugin during the Hackaethon may be awarded a bounty after meeting the quality criteria by the judges. Participants may implement their own plugin ideas or implement the suggested plugins from the blog post, either are equally eligible for the bounty. Up to 10 plugins will each be awarded a $100 gift card bounty.</p><p><strong>Quality Criteria:</strong></p><ul><li>Functionality - Does it do what it says it does</li><li>Testing - Are there functional unit tests that confirm the functionality</li><li>Value - Will the community actually use this</li></ul><h3 id="grand-prizes">Grand Prizes</h3><p>Every participant who contributes during the Hackaethon is eligible to be awarded the grand prize. Judges will determine the winners based on their level of participation, contributions, and engagement with the community during the event.</p><ul><li>1st Prize -- $500 gift card and exclusive Hackaethon Hoodie</li><li>2nd Prize - $250 gift card</li><li>3rd Prize - $100 gift card</li></ul><h2 id="see-you-in-october">See You in October</h2><p>We are really excited about engaging with the community, collaborating with other developers, our ambassadors, and working together to make the most powerful and easiest to use open source cloud native networking tools on the planet. We are looking forward to seeing you all in October.</p>]]></content:encoded></item><item><title><![CDATA[Achieve zero-downtime deployments with Traefik and Kubernetes]]></title><description><![CDATA[Containers and Kubernetes have revolutionized software delivery. Releasing apps and services as stateless container images makes it easy to create and destroy container instances as demand requires.]]></description><link>https://traefik.io/blog/achieve-zero-downtime-deployments-with-traefik-and-kubernetes/</link><guid isPermaLink="false">Ghost__Post__5f5970b6ff947b00398fd523</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Thu, 10 Sep 2020 14:18:42 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg" class="kg-image" alt="Achieve zero-downtime deployments with Traefik and Kubernetes" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/09/Achieve-zero-downtime-deployments-with-Traefik-and-Kubernetes-1.jpg" alt="Achieve zero-downtime deployments with Traefik and Kubernetes"/><p>Rapid release cycles are the hallmark of modern software development. The cloud-native ecosystem tooling includes containers, Kubernetes, microservices, and agile development methods, all of which support and encourage frequent delivery and deployment. The hidden downside, however, is that every change to production is another chance for something to go wrong.</p><p>In the worst-case scenario, that "something" means downtime.</p><p>Testing is always the first line of defense against service disruption. Unfortunately, cloud-native application architectures can be surprisingly complex, and the full extent of the interactions between APIs and services can be hard to map and predict. Because of this, the traditional testing march from development through staging is unlikely to catch every issue before new code reaches production.</p><p>Today’s network-centric applications call for new, network-centric approaches to software testing and deployment. As a modern, cloud-native edge router, Traefik is ready to help.</p><h2 id="routing-around-downtime"><strong>Routing around downtime</strong></h2><p>Containers and Kubernetes have revolutionized software delivery. Releasing apps and services as stateless container images makes it easy to create and destroy container instances as demand requires. Is an application experiencing a traffic spike? Operators may add additional instances to the cluster and use a load balancer to distribute requests accordingly.</p><p>This model gets really interesting, however, when instances of more than one version of the same software serve requests within the same cluster. Mixing old and new versions like this makes it possible to configure routing rules to test the production environment's latest version. More importantly, the new version can be released gradually – and even withdrawn, should problems arise – all with virtually no downtime.</p><p>Three popular variations on this idea are <strong>blue-green deployments</strong>, <strong>canary releases</strong>, and <strong>A/B testing</strong>. Although all three are related, each is also distinct.</p><h3 id="blue-green-deployments"><strong>Blue-green deployments</strong></h3><p>In this pattern, “green” refers to the current, stable version of the software, while “blue” refers to an upcoming release that introduces new features and fixes. Instances of both versions operate simultaneously in the same production environment. Concurrently, a proxy router (such as Traefik) ensures that only requests sent to a private address can reach the blue instances.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Diagram-Blue-green-deployments.png" class="kg-image" alt="Achieve zero-downtime deployments with Traefik and Kubernetes" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Diagram-Blue-green-deployments.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Diagram-Blue-green-deployments.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Diagram-Blue-green-deployments.png 1600w, https://containous.ghost.io/content/images/2020/09/Diagram-Blue-green-deployments.png 1695w" sizes="(min-width: 720px) 720px"/></figure><p>There are two ways to test such a setup. The first is to run synthetic tests against the blue instances, confident that they are being staged in an environment that matches production exactly. A more ambitious method involves <em>traffic mirroring</em>, in which the green instances handle incoming requests, but a duplicate of every request is also sent to the blue instances. Although this can be resource intensive, it creates an accurate simulation of what would happen if the blue instances were running the show.</p><p>Once all test cases and integrations are satisfied, switching over from the green to the blue version is as simple as updating the routing rules. In effect, blue becomes green, and eventually the next iteration of the software is deployed as the new blue. Equally important, it’s just as easy to revert the routing rules and roll back to the earlier green version, should some last-minute catastrophe occur.</p><h3 id="canary-releases"><strong>Canary releases</strong></h3><p>The canary release model takes blue-green testing a step further by deploying new features and patches into active production, albeit in a measured way. The router is configured such that the current, stable version of the software handles most requests, but a limited percentage of requests route to instances of the new, “canary” version.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Diagram-canary-releases.png" class="kg-image" alt="Achieve zero-downtime deployments with Traefik and Kubernetes" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Diagram-canary-releases.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Diagram-canary-releases.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Diagram-canary-releases.png 1600w, https://containous.ghost.io/content/images/2020/09/Diagram-canary-releases.png 1695w" sizes="(min-width: 720px) 720px"/></figure><p>True to the “canary in a coal mine” metaphor, if instances of the canary release start dropping dead (or exhibiting problems in some way), they can be withdrawn for bug fixes while the stable release carries on as before. If things go smoothly, on the other hand, the proportion of requests handled by the canary release can be gradually increased until it reaches 100 percent.</p><p>This model breaks down quickly, however, when the canary release is too large and introduces too many changes at once. It works best for microservice architectures, where features or fixes can be released incrementally and evaluated on their particular merits.</p><h3 id="a-b-testing"><strong>A/B testing</strong></h3><p>This technique is sometimes confused with the previous two, but it has its own purpose, which is to evaluate two distinct versions of an upcoming release to see which will be more successful. This tactic is common for UI development. For example, suppose a new feature will soon roll out to an application, but it’s unclear how best to expose it to users. To find out, two versions of the UI including the the feature, run in tandem – Version A and Version B – and the proxy router sends a limited number of requests to each one.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Diagram-A-B-Testing.png" class="kg-image" alt="Achieve zero-downtime deployments with Traefik and Kubernetes" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Diagram-A-B-Testing.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Diagram-A-B-Testing.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Diagram-A-B-Testing.png 1600w, https://containous.ghost.io/content/images/2020/09/Diagram-A-B-Testing.png 1695w" sizes="(min-width: 720px) 720px"/></figure><p>From there, metrics can help determine which version is the better choice. Does Version A do a better job of convincing users to try the new feature? Do users complete the UI sequence faster using Version B, or do they tend to cancel before the end? Each version of the new UI can be trialed with a small number of users while routing rules ensure that the stable version continues to serve the majority of requests.</p><h2 id="network-effects"><strong>Network effects</strong></h2><p>These techniques can be invaluable for testing modern, cloud-native software architectures, especially when compared to traditional waterfall-style deployment models. When used correctly, they can help spot unforeseen regressions, integration failures, performance bottlenecks, and usability issues within the production environment, but before new code graduates to a stable, production release.</p><p>What all three approaches share in common is that they rely on the ease of deployment afforded by containers and Kubernetes, coupled with cloud-native networking techniques, to route requests to testable deployments while minimizing disruptions to production code. That’s a powerful combination – one that’s squarely within Traefik’s wheelhouse – and if employed judiciously, it can effectively bring overall application downtime to zero. </p><p><a href="https://containo.us/solutions/kubernetes-ingress/">Click here</a> to learn more about Traefik, a centralized routing solution for any Kubernetes cluster, that enables better application uptime. </p>]]></content:encoded></item><item><title><![CDATA[Unlock the potential of data APIs with strong authentication and Traefik Enterprise]]></title><description><![CDATA[One of the top goals for enterprises today is to open up the data held within legacy systems and expose it through APIs, microservices, and other modern means.]]></description><link>https://traefik.io/blog/unlock-the-potential-of-data-apis-with-strong-authentication-and-traefik-enterprise/</link><guid isPermaLink="false">Ghost__Post__5f4ee6313a6f7f00398c1198</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Wed, 02 Sep 2020 14:30:58 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg" class="kg-image" alt="Unlock the potential of data APIs with strong authentication and Traefik Enterprise" srcset="https://containous.ghost.io/content/images/size/w600/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg 1600w, https://containous.ghost.io/content/images/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/09/Unlock-the-potential-of-data-APIs-with-strong-authentication-and-Traefik-Enterprise-1.jpg" alt="Unlock the potential of data APIs with strong authentication and Traefik Enterprise"/><p>When it comes to enterprise IT infrastructure, security is of paramount importance. Between the need for data protection and privacy, regulatory requirements, and the constant threat of bad actors on the network, there is little room for error when designing and maintaining enterprise systems.</p><p>Because of this, strong authentication is a critical component of any IT modernization project. One of the top goals for enterprises today is to open up the data held within legacy systems and expose it through APIs, microservices, and other modern means. And yet, while this data represents untapped business value, it’s essential to only expose it in controlled ways by using authentication to ensure each request’s validity.</p><p>Traefik can help. As a modern, cloud-native edge router, Traefik’s goal is to direct valid requests from the external network to applications and services, while minimizing the risk posed by malformed, malicious, or fraudulent requests. One way it can do this is by acting as an intermediary to ensure that transactions are authorized. What’s more, Traefik Enterprise (TraefikEE) bundles additional, exclusive features to provide enterprise-grade authentication – including, most recently, support for OpenID Connect.</p><h2 id="who-goes-there">Who goes there?</h2><p>One of Traefik’s key concepts is its use of<a href="https://docs.traefik.io/v2.2/middlewares/overview/"> <em>middlewares</em></a>, which are pluggable components that provide conditional controls over network traffic. These controls can take various forms, including enabling security features such as rate limiting, restricting requests by IP address, and authentication.</p><p>TraefikEE’s enterprise authentication middlewares work by referencing external <em>authentication sources</em>. For example, the LDAP middleware connects to an LDAP server to verify credentials. In this way, Traefik can act as a gatekeeper at the edge of the internal network by intercepting incoming requests and authenticating them against the external source before forwarding them to the appropriate applications.</p><p>This model can be particularly critical for legacy modernization projects because it allows authentication to occur externally to the application. One benefit of this is that it makes it possible to add modern authentication methods to legacy applications to satisfy the latest security requirements, without making any direct modifications to legacy code.</p><h2 id="enterprise-options"><strong>Enterprise options</strong></h2><p>In addition to LDAP, Traefik Enterprise offers several other middlewares for enterprise authentication, and the collection continues to grow. Among the methods that TraefikEE supports are:</p><h3 id="hmac"><strong>HMAC</strong></h3><p>Hash-based message authentication codes (<a href="https://docs.containo.us/middlewares/hmac/">HMAC</a>) is a method of using cryptographic hash functions with a shared secret (also known as a symmetric key) to ensure the content delivered in an HTTP request is valid and genuine. Like digital signatures, HMAC can verify a message sender’s identity and that the message’s content is unaltered from the moment of the HMAC’s  creation. The technique can be used to secure file transfers, API calls, and other machine-to-machine interactions.</p><h3 id="jwt"><strong>JWT</strong></h3><p>JSON web tokens (<a href="https://docs.containo.us/middlewares/jwt/">JWT</a>) is another popular tool used to authenticate API calls and SSO applications. It’s a method of digitally signing information as a JSON object. The JWT includes a set of “claims,” which typically describe the things that an authenticated user is allowed to do. TraefikEE”s JWT middleware also includes support for JSON web key sets.</p><h3 id="openid-connect"><strong>OpenID Connect</strong></h3><p>TraefikEE also includes<a href="https://docs.containo.us/middlewares/oidc/"> support for OpenID Connect</a>, an authentication layer built on top of the OAuth 2.0 protocol. OpenID Connect allows an application to obtain user login information by exchanging cryptographic tokens with an identity provider, and is often used to implement federated single sign-on (SSO) between multiple applications.</p><!--kg-card-begin: markdown--><p>OpenID Connect has become a popular option for enterprises because it allows operators to self-host their on-premises identity provider or choose from a growing number of third-party options. <a href="https://www.okta.com/openid-connect/" target="_blank" rel="nofollow">Okta</a>, for example, is a cloud-hosted enterprise identity platform that supports authentication via OpenID Connect. Several public options are also available, allowing users to authenticate based on their logins for services such as <a href="https://developers.google.com/identity/protocols/oauth2/openid-connect" target="_blank" rel="nofollow">Google</a> and <a href="https://developer.paypal.com/docs/connect-with-paypal/" target="_blank" rel="nofollow">Paypal</a>.If full authentication isn’t needed, TraefikEE also supplies a middleware for verifying the authorization of requests via the <a href="https://docs.containo.us/middlewares/oauth-intro/">OAuth 2.0 token introspection</a> method.</p>
<!--kg-card-end: markdown--><h2 id="authentication-the-easy-way"><strong>Authentication the easy way</strong></h2><p>The best thing about implementing enterprise authentication using TraefikEE, however, is how easy it is to do. Enabling any of the authentication middleware mentioned here is generally as simple as adding a few lines to your Traefik configuration to supply the necessary credentials and point the middleware to your authentication source.</p><p>The authentication options available in TraefikEE today offer a powerful range of options for exposing enterprise applications and data securely, without requiring extensive and risky legacy code changes. You can expect other such features to be included over time, as we continue our commitment to ensure TraefikEE is a premier tool for enterprise application networking.To learn more about how Traefik and Traefik Enterprise can help you lock down enterprise data with secure authentication, watch our recent webinar, “<a href="https://info.containo.us/webinar-recording-enterprise-best-practices-to-expose-and-secure-microservices-apis">Enterprise best practices to expose and secure microservices and APIs</a>”. We’ll discuss deploying OAuth and OpenID Connect with Okta to secure user logins, and we’ll also walk through enabling mutual TLS (mTLS) for secure machine-to-machine communications.</p>]]></content:encoded></item><item><title><![CDATA[Naologic Selects Traefik to Effortlessly Scale Networking to Meet Fast Business Growth]]></title><description><![CDATA[Implementing Traefik at Naologic saved them over a thousand hours of engineering time, and eliminated time-consuming manual configuration of NGINX.]]></description><link>https://traefik.io/blog/naologic-surpasses-scaling-demands-of-microservice-infrastructure-by-using-traefik/</link><guid isPermaLink="false">Ghost__Post__5f29efcbaf4f3b0045f364ec</guid><category><![CDATA[Blog]]></category><category><![CDATA[Case Studies]]></category><dc:creator><![CDATA[Patricia Dugan ]]></dc:creator><pubDate>Tue, 25 Aug 2020 14:30:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg" class="kg-image" alt="Naologic Selects Traefik to Effortlessly Scale Networking to Meet Fast Business Growth" srcset="https://containous.ghost.io/content/images/size/w600/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg 1600w, https://containous.ghost.io/content/images/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><h2 id="about-naologic">About Naologic</h2><!--kg-card-begin: markdown--><img src="https://containous.ghost.io/content/images/2020/08/Naologic-Selects-Traefik-to-Effortlessly-Scale-Networking-to-Meet-Fast-Business-Growth-1.jpg" alt="Naologic Selects Traefik to Effortlessly Scale Networking to Meet Fast Business Growth"/><p><a href="https://naologic.com/" target="_blank" rel="nofollow">Naologic</a> is an end-to-end business management solution that allows service providers to manage their teams, finances, and integrate products. Their low-code Software as a Service ERP platform provides wholesale and B2B e-commerce companies with the ability to configure and deploy custom ERP systems with just a few clicks.</p>
<!--kg-card-end: markdown--><h2 id="overview">Overview</h2><figure class="kg-card kg-image-card"><img src="https://lh4.googleusercontent.com/-g2XXPxWFVe0LuNdf3fpNzvHZOc5U3GGIKfiZ0UHGVbwQU6a0zjOQpEBH20TeqZzifME7Wacj6iyk3VEpLYwooGL-UNUdGNxrBobSK-Oksbk8SHYiMJeyddauxuWs_3zC-NqTURE" class="kg-image" alt="Naologic Selects Traefik to Effortlessly Scale Networking to Meet Fast Business Growth"/></figure><p>Naologic empowers customers to build customizable and scalable ERP systems without the complexity of building functionalities such as searching, invoicing, order processing, and reporting.</p><p>Their main offering, the back-office builder (BOB), is an online editor used to create powerful applications without the need to write code.</p><p>To deliver the platform performance necessary for their customers, Naologic built their infrastructure in a highly elastic and dynamic manner, running on three clusters, with over 100 nodes total. The entire software platform is managed and deployed automatically using Kubernetes, and a Gitlab build pipeline, relying on open source solutions as a fundamental part of the CI/CD toolchain. </p><h2 id="challenge">Challenge</h2><p>In order to service the growing customer base, Naologic uses a managed platform that continuously launches thousands of automated, secure systems with complex configurations behind SSL-capable proxies. At any given time, 20 to 40 ports may be opened for microservices communications (WebSockets, HTTP), using multiple Docker networks. Before implementing Traefik, Naologic was using NGINX and constrained by the sheer volume of configuration changes requiring frequent restarts (causing connection drops), making for an increasingly complex and time-consuming process.</p><h2 id="solution">Solution</h2><p>In order to simplify the  maintenance of their large scale microservice infrastructure, the team at Naologic decided to move the entire platform to Kubernetes with <a href="https://containous.ghost.io/solutions/kubernetes-ingress/">Traefik as their Ingress Controller</a> for managing routing and load balancing of their applications. </p><blockquote><em>“The ease of implementation with Traefik saved us over 1,000 engineering hours. The biggest win was being able to launch new developer environments within days instead of weeks.” - Gabriel Paunescu, CEO</em></blockquote><p>As an additional benefit, Traefik’s auto-discovery feature, with the ability to seamlessly forward Docker network configurations into Traefik, has allowed them to streamline efforts when deploying Docker containers using temporary DNS configurations with their build tool. Since Naologic is operating multiple platforms, including Docker Swarm and Kubernetes, Traefik’s universal approach to configuration means they no longer have to maintain independent routing solutions for their various environments.</p><h2 id="bottom-line">Bottom Line</h2><p>Implementing Traefik at Naologic saved them over a thousand hours of engineering time, and eliminated time-consuming manual configuration of NGINX. With this new combination, Naologic is ready and capable of meeting the high-projected growth that they envision for the future.</p><h2 id="what-s-next">What’s Next?</h2><ul><li>Get started with <a href="https://containous.ghost.io/traefik/" rel="noopener nofollow">Traefik</a> today</li><li>Ready for production deployments? <a href="https://containous.ghost.io/traefikee/">Discover Traefik Enterprise Edition</a>, and <a href="https://info.containo.us/request-demo-traefikee" rel="noopener nofollow">request your demo</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Unleash custom networking logic with Traefik Plugins]]></title><description><![CDATA[With Traefik plugins, you can now easily build, use, and share your own custom extensions to Traefik’s functionality, with minimal development overhead.]]></description><link>https://traefik.io/blog/unleash-custom-networking-logic-with-traefik-plugins/</link><guid isPermaLink="false">Ghost__Post__5f3b0d665751e70039ad7abe</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Wed, 19 Aug 2020 15:32:38 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg" class="kg-image" alt="Unleash custom networking logic with Traefik Plugins" srcset="https://containous.ghost.io/content/images/size/w600/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg 1600w, https://containous.ghost.io/content/images/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><img src="https://containous.ghost.io/content/images/2020/08/Unleash-custom-networking-logic-with-Traefik-Plugins---Blog-1.jpg" alt="Unleash custom networking logic with Traefik Plugins"/><p>Traefik is built to handle the application networking functions that are essential to modern IT. In today’s cloud-native environments, containerized applications and microservices must be in constant communication across networks. Functions like load balancing, inbound traffic management, and network security are more critical than ever. Fortunately, Traefik addresses these needs elegantly and reliably.</p><p>Almost inevitably, however, situations arise that can't easily be handled using standard features and methods. Perhaps an unusual application design requires unorthodox routing, or abnormal traffic conditions call for a novel, short-term fix. Ideally, you should be able to deploy custom logic to handle such niche cases.</p><p>That’s precisely the goal of Traefik plugins, which were introduced in the release-candidate builds of Traefik 2.3. Traefik has always been modular and extensible, and its feature set has grown with the addition of each new <a href="https://docs.traefik.io/providers/overview/">provider</a> and <a href="https://docs.traefik.io/middlewares/overview/">middleware</a>. With the addition of plugins, however, you can now easily build, use, and share their own custom extensions to Traefik’s functionality, with minimal development overhead.</p><h2 id="extensibility-for-everyone"><strong>Extensibility for everyone</strong></h2><p>Application plugins themselves are nothing new. Monolithic desktop apps from the likes of Adobe and Microsoft were among the first to introduce extension mechanisms, and web browsers weren’t far behind. But the earliest plugins shipped as prebuilt binaries, like the applications themselves. That meant they were often quirky to use, difficult to develop, and incompatible across platforms or even application versions.</p><p>As web browsers evolved into the most-used software in the world, however, they also blazed the path for how plugins should be built. As a result of work by Google, Mozilla, and others, creating extensions for today’s web browsers is both simpler and more open than in the past, thanks to key characteristics of their second-generation plugin model:</p><ul><li>Modern browser extensions are written in JavaScript, a language that’s familiar to browser users and anyone involved with web development.</li><li>They are simple to develop and test, requiring no elaborate toolchains or build processes.</li><li>They are shared and distributed securely via a centralized, online marketplace.</li></ul><h2 id="traefik-the-way-you-want-it"><strong>Traefik the way you want it</strong></h2><p>Traefik’s new plugins take cues from modern browser extensions, with the aim of making it as easy to extend Traefik as it is to extend your browser. While traditional Traefik middlewares resemble the older style of binary plugins, Traefik’s new plugin mechanism follows the pattern set by the likes of Chrome and Firefox:</p><ul><li>Traefik plugins are written in <a href="https://golang.org/">Go</a>, the language used to develop Docker, Kubernetes, the Traefik family of projects, and other cloud-native infrastructure software.</li><li>Traefik’s embedded <a href="https://containous.ghost.io/blog/announcing-yaegi-263a1e2d070a/">Yaegi interpreter</a> makes plugin development and testing easy. No code needs to be compiled or linked, making this the first true interpreted Go language plugin mechanism.Plugins are distributed and shared online via an open marketplace that integrates with <a href="https://containous.ghost.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/">Traefik Pilot</a>, the new SaaS control plane for Traefik.</li></ul><figure class="kg-card kg-image-card"><img src="https://lh4.googleusercontent.com/By5DYG5wjOdErYmc54JCuNGPw3M8ICAULWs-1xD9BlCrzm5CpfS6ob2Kx71PKY5xBw8slQQzvbNuxbZqD8SDJiAQChSQYxr0YCoxqdO6MrxhK62exH5MPHpITuxLbiZTE96KA2U" class="kg-image" alt="Unleash custom networking logic with Traefik Plugins"/></figure><p>Naturally, in designing an extension mechanism for Traefik, security is a top concern. Hosting plugins in the centralized Traefik Pilot hub makes it possible to block plugins containing malicious or malformed code for all Traefik users, protecting the entire community. Only open source plugins are allowed, so that their code can be reviewed and inspected for potential defects. And Traefik operators have ultimate control over which plugins are installed and allowed to run in their Traefik instances, as plugins can only be loaded and activated from Traefik’s static configuration at startup.</p><p>Plugins utilize the Go module downloading and verification system to protect users from unauthorized changes to code. We'll share more in-depth details on this and the security features of the runtime interpreter in a later post.</p><h2 id="plugging-in"><strong>Plugging in</strong></h2><p>Because Traefik’s plugin mechanism follows industry best practices, working with Traefik plugins is almost as easy as working with browser extensions. To get up and running with your first plugin involves four key steps:</p><h3 id="1-register-your-traefik-instances"><strong>1. Register your Traefik instances</strong></h3><p>Plugins are only available to Traefik instances that are registered with the Traefik Pilot SaaS service. Registering is as easy aa <a href="https://pilot.traefik.io/">logging into your Pilot account</a> and clicking a button to request a token. Once you add that token to your Traefik instance’s static configuration, you’re ready to begin working with <a href="https://pilot.traefik.io/plugins">plugins from the catalog</a> or to create your own. You’ll also gain the benefits of health monitoring and security vulnerability updates for your registered instances.</p><h3 id="2-develop-your-plugin"><strong>2. Develop your plugin</strong></h3><p>Traefik’s embedded Yaegi interpreter can handle virtually any Go code you throw at it. A good way to start is to read the <a href="https://github.com/containous/plugindemo">documentation</a> and review the source code of the Demo plugin that’s provided with Traefik Pilot. You can gain further inspiration by browsing the source code of contributed plugins in <a href="https://github.com/topics/traefik-plugin">their own repositories</a>.</p><h3 id="3-host-your-plugin-on-github"><strong>3. Host your plugin on GitHub</strong></h3><p>Most developers will already be familiar with GitHub as a way to share code with the community. Every 30 minutes, Traefik Pilot polls GitHub, looking for repositories hosting plugins to add to the public catalog. For your plugin to be recognized, you need only set the topic `traefik-plugin` on your repo and include a manifest, as described in the <a href="https://github.com/containous/plugindemo/blob/master/readme.md">developer documentation</a>.</p><figure class="kg-card kg-image-card"><img src="https://lh6.googleusercontent.com/g8H6MFQddfIOzxLGl7xfgtTztNPaS-iE6cAE3tR6sJWnRHbCUUny1u_mGf1skj3aZCj3JSdD_F5RJ23Q7WlxlRyBy1neUSg9gHV63UaGP7KctsJrMkt2acXy3Z5B9cOFJfmitwg" class="kg-image" alt="Unleash custom networking logic with Traefik Plugins"/></figure><h3 id="4-load-and-activate-your-plugin"><strong>4. Load and activate your plugin</strong></h3><p>Once your plugin is available in the Traefik Pilot catalog, it’s ready for use in your Traefik instances. As mentioned earlier, for security reasons, plugin activation code must be included in an instance’s static configuration. No plugins can be installed or modified while Traefik is running. Some plugins may also need to have options set in the dynamic configuration. Clicking the “Install Plugin” button from the plugin’s page in the Traefik Pilot catalog supplies cut-and-paste templates of the code you’ll need for both the static and dynamic configurations.</p><h2 id="more-to-come"><strong>More to come</strong></h2><p>This first iteration of the Traefik plugin interface gives you what you need to start building and deploying plugins that enable custom routing behaviors, like Traefik middlewares. You can expect forthcoming releases to make plugins even more powerful. For example, future plugins will be able to act as <em>providers</em>, making it possible to use these techniques to extend Traefik’s auto-discovery capabilities to include new orchestrators, cloud providers, key-value stores, and other infrastructure components.</p><p>For now, we hope you’ll take this opportunity to explore how plugins expand the possibilities of Traefik. Join the <a href="https://community.containo.us/c/traefik/5">Traefik community forums</a> to continue the discussion and help make Traefik the most powerful, versatile, and extensible tool for your application networking needs.</p>]]></content:encoded></item><item><title><![CDATA[William & Mary uses Traefik to Streamline Complex Deployments Across Multiple Clouds]]></title><description><![CDATA[Learn how William & Mary uses Traefik to streamline complex deployments across multiple clouds in a heterogenous ecosystem with Docker and Kubernetes. ]]></description><link>https://traefik.io/blog/william-mary-uses-traefik-to-streamline-complex-deployments-across-multiple-clouds/</link><guid isPermaLink="false">Ghost__Post__5f1f638faf4f3b0045f363d9</guid><category><![CDATA[Blog]]></category><category><![CDATA[Case Studies]]></category><dc:creator><![CDATA[Patricia Dugan ]]></dc:creator><pubDate>Mon, 10 Aug 2020 23:02:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg" class="kg-image" alt="William & Mary uses Traefik to Streamline Complex Deployments Across Multiple Clouds" srcset="https://containous.ghost.io/content/images/size/w600/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg 1600w, https://containous.ghost.io/content/images/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><h2 id="about-william-mary">About William &amp; Mary</h2><!--kg-card-begin: markdown--><img src="https://containous.ghost.io/content/images/2020/08/William-Mary-uses-Traefik-to-Streamline-Complex-Deployments-Across-Multiple-Clouds---Blog-1.jpg" alt="William & Mary uses Traefik to Streamline Complex Deployments Across Multiple Clouds"/><p><a href="https://www.wm.edu/" target="_blank" rel="nofollow">William &amp; Mary</a> is a top public research university and one of only eight “Public Ivy” schools in the United States, known for its rigorous academic program. The W&amp;M IT team manages the entire university’s technical infrastructure, ensuring smooth operations for approximately 8,000 students and 1,300 staff. The IT team of roughly 100 people administers campus networking, desktop support, business and administrative faculty support, end-user client support, research, and high-performance computing.</p>
<!--kg-card-end: markdown--><h2 id="overview">Overview</h2><p>As a residential campus, W&amp;M sees high application load and data volumes that peak at specific times in the academic calendar, especially during registration. They operate within a heterogeneous technical infrastructure and host a wide array of technical integrations. Using proprietary software such as their ERP system, which requires updates that adhere to industry-specific regulations, are central to their infrastructure. The team selects open source software when possible, as it enables developer collaboration with industry and other colleges and universities.</p><p>The University’s technical infrastructure has successfully transformed from running primarily on legacy systems to boasting a diverse technical stack, inclusive of bare metal, containers, and the public cloud. It now supports a wide range of services from behind traditional load balancers and VMs, in addition to auto-scaling containerized distributed computing platforms, using Traefik and Kubernetes.</p><h2 id="challenge">Challenge</h2><p>Phil Fenstermacher, the Lead Linux Engineer, is part of the leadership team responsible for building and managing the platforms used by the students and staff at W&amp;M. They are governed by a charter to provide functional solutions that adhere to ever-changing, strict regulatory demands of industry-specific software. There is an expectation to address these technological needs on a lean budget. As innovation continues to change rapidly, and as their workload has grown, the need to evolve from a virtualized environment to an environment facilitating the use of containers and Kubernetes was a priority. </p><p>As an initial step towards transitioning to a container environment, they implemented Docker Swarm and used the internal load balancer that ships with Swarm. Over time, the team at W&amp;M needed a cloud-native reverse proxy as more workloads were containerized and adopted into this new environment. These features included the ability to use persistent sessions, while handling bursty, large workloads along with providing integrations with commercial software required for core business systems. The successful implementation of complex systems such as ERP, CMS, and procurement software was critical. Docker Swarm was easy to use, but these new requirements demanded a feature-rich and protocol-aware load balancer to meet their needs.</p><p>Inspired by an upcoming ERP update, which would require managing hundreds of production and non-production virtual machines, Phil’s team sought to leverage the inherent benefits of containers. Core requirements for this update forbade any rewrites of the commercial software, creating massive amounts of custom wrapper scripts, or changing the fundamental architecture of these applications. Finding a load balancer which seamlessly handled multiple integrations, and functioned well with Kubernetes and Docker Swarm, was the challenge.</p><p>They sought options to evaluate and came across Traefik.</p><h2 id="solution">Solution</h2><p>Traefik checked many of the boxes: it is open source, highly cost-effective, has a <a href="https://containous.ghost.io/community/">great user community</a>, walks in close step with the expanding Kubernetes community, but also works in the existing Docker Swarm environment. In the spirit of academic rigor, though, Phil’s team wanted to test a variety of solutions in the marketplace, such as NGINX, and HAproxy, making comparisons side by side with Traefik. </p><p>Phil’s team observed that Traefik ran smoothly out-of-the-box and surpassed alternatives in the ways that mattered. The other solutions required large amounts of manual configuration and lacked some service discovery capabilities. Also, features one would expect from a modern cloud-native load balancer were suspiciously absent. Traefik offered the functionality the team at W&amp;M needed, including service discovery, persistent sessions, header modifications, Prometheus integration, a visually intuitive dashboard for monitoring, and easy deployment and operation.</p><blockquote><em>“The simplicity of using Traefik for persistent sessions, by simply copy and pasting a line of code has been a game-changer.” - Phil Fenstermacher, Lead Linux Engineer</em></blockquote><p>The University currently runs approximately 100 services through an on-premises deployment of Traefik on Docker Swarm, and another 30 services on Kubernetes in the cloud. A smaller on-premise  Kubernetes cluster hosts everything from academic and enterprise applications. William &amp; Mary’s small engineering team can easily manage the 150+ services and 400+ containers because Traefik’s configuration is kept alongside application configurations using labels in Docker Swarm or an Ingress object in Kubernetes. A similar configuration scheme for both orchestrators means the same engineers can support both without the overhead of another unique system.</p><p>W&amp;M has used Traefik since version 1.3 and has since migrated to Version 2.2 on Kubernetes, which has support for native Ingress resource annotations. The latest version of Traefik makes their engineering workflow more straightforward, notably due to the flexibility of having both Ingress and Traefik's CRDs, which allow for less manual configuration and managing more complex settings with only a single solution.</p><blockquote><em>“It's like the Traefik load balancer is almost the boring piece. We don't spend a lot of time talking about it. We use Traefik, it does what we need, what it's expected to do, and reliably.</em>”</blockquote><h2 id="bottom-line">Bottom line </h2><p>William &amp; Mary selects only high-performance, reliable, and budget-savvy software solutions. They have chosen Traefik to manage the university's load balancing needs, as the software is easy to implement, maintain, and trust. Without Traefik, W&amp;M faced the deployment of its new ERP system in a legacy environment using a traditional load balancer. Ultimately, this would have meant higher costs for both operation and maintenance, all with less predictability, functionality, and consistency.</p><h2 id="what-s-next">What’s Next?</h2><ul><li>Get started with <a href="https://containous.ghost.io/traefik/" rel="noopener nofollow">Traefik</a> today</li><li>Ready for production deployments? <a href="https://containous.ghost.io/traefikee/">Discover Traefik Enterprise Edition</a>, and <a href="https://info.containo.us/request-demo-traefikee" rel="noopener nofollow">request your demo</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Traefik 2.3: Towards Plugins and Beyond!]]></title><description><![CDATA[In this post, Teddy Ferdinand talks about Traefik 2.3, and its features. He dives into Traefik Pilot, our new SaaS control platform, and the middleware plugin management. ]]></description><link>https://traefik.io/blog/traefik-plugins-pilot/</link><guid isPermaLink="false">Ghost__Post__5f1f5d0faf4f3b0045f36388</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Teddy Ferdinand]]></dc:creator><pubDate>Tue, 04 Aug 2020 14:30:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/08/Blog@1x-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/08/Blog@1x.jpg" class="kg-image" alt="Traefik 2.3: Towards Plugins and Beyond!" srcset="https://containous.ghost.io/content/images/size/w600/2020/08/Blog@1x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Blog@1x.jpg 1000w, https://containous.ghost.io/content/images/2020/08/Blog@1x.jpg 1200w" sizes="(min-width: 1200px) 1200px"/></figure><img src="https://containous.ghost.io/content/images/2020/08/Blog@1x-1.jpg" alt="Traefik 2.3: Towards Plugins and Beyond!"/><p>Traefik 2.3 (codename: Picodon - the cheese you can see illustrated below) and is available as a release candidate since mid-July 2020. More than a simple version increment, this release brings a lot of new features. Two significant new features caught my attention:</p><ul><li>Introduction of <a href="https://containous.ghost.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/">Traefik Pilot</a>: a new SaaS platform</li><li>Middleware plugin management</li></ul><!--kg-card-begin: markdown--><p>There are other new features that I won't cover in this post, such as compatibility with ECS, but be sure to check out <a href="https://tferdinand.net/en/" target="_blank" rel="nofollow">my blog</a>, I'll be posting an article on that soon.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/07/picodon.jpeg" class="kg-image" alt="Traefik 2.3: Towards Plugins and Beyond!" srcset="https://containous.ghost.io/content/images/size/w600/2020/07/picodon.jpeg 600w, https://containous.ghost.io/content/images/2020/07/picodon.jpeg 700w"><figcaption>Picodon</figcaption></img></figure><h2 id="is-there-a-pilot-in-the-plane"><strong>Is there a pilot in the plane?</strong></h2><!--kg-card-begin: markdown--><p>Traefik is a complete and powerful reverse proxy, as I already presented in a <a href="https://tferdinand.net/en/traefik-2-reverse-proxy-in-kubernetes/" target="_blank">previous article</a>. Nevertheless, it lacked a managed health check solution.</p>
<!--kg-card-end: markdown--><p>It is now possible for free! The new service was launched in conjunction with the Traefik 2.3 release candidate.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/07/Blog@1x-1.png" class="kg-image" alt="Traefik 2.3: Towards Plugins and Beyond!" srcset="https://containous.ghost.io/content/images/size/w600/2020/07/Blog@1x-1.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Blog@1x-1.png 1000w, https://containous.ghost.io/content/images/2020/07/Blog@1x-1.png 1200w" sizes="(min-width: 720px) 720px"/></figure><p>Traefik Pilot is a new concept, delivering an entirely new approach to network management in the cloud. At the moment, it only facilitates the health check of your Traefik instances, allowing you to receive a notification if it becomes unavailable or unhealthy. Traefik Pilot is available now at <a href="https://pilot.traefik.io/">pilot.traefik.io</a>. Additional features are planned and will launch in the coming months!</p><p>After a quick sign-up, it is now possible to register one or more instances of Traefik.</p><figure class="kg-card kg-image-card"><img src="https://lh3.googleusercontent.com/z6Z52Ixrg3i3IOK0enPGeICQHWk7LVud62tda2goLUx_aHBYmIfO5YuaddKj-IXC28SIpZMkDc5i4F6R1clLQdL39j2z_xog2llgcbnkHnc3HrSEk-sP6NoQfBE6IgKuyZ3Nv85V" class="kg-image" alt="Traefik 2.3: Towards Plugins and Beyond!"/></figure><p>I added the command line parameter in the Traefik startup arguments in my Kubernetes manifest, and after a reboot, the status changed to Green (OK).</p><figure class="kg-card kg-image-card"><img src="https://lh3.googleusercontent.com/Af6WNGucCMKrTTea7SOK4wU0AXfIhm1hvrWiK06FmFBbZThMMoDToRz3l6AOHLIeWyQQLzSJ8xH3yWWtqwwVXbB3nuTdnK3YEym8TZM0NYLkmtryauJe7F06_PqJCzGTlZOP-cgQ" class="kg-image" alt="Traefik 2.3: Towards Plugins and Beyond!"/></figure><p>However, there are a few things to keep in mind:</p><ul><li>This status currently only corresponds to your Traefik container's state and does not mean that the backends are functional.</li><li>This health check is sent from your instance, in "heartbeat" mode, and does not necessarily mean that your server is reachable.</li><li>As the signal transmitted is a heartbeat, it is possible to monitor instances in the Pilot application area.</li></ul><p>By clicking on your profile name at the top right, it is possible to define alarms, via webhooks or by e-mail.</p><figure class="kg-card kg-image-card"><img src="https://lh3.googleusercontent.com/mIpE_f8Is091urCMzXAkgCrrCJARJScSjDRF9LmemzbNfmiEW_DYxPXXdL-6Fc3xYp3OAC3q-Ir04Mbn89CFjLykbenlZaB9FdgzNmiXCFt2DbPzwSR4-Aq5epjCZpLx69zNP4zg" class="kg-image" alt="Traefik 2.3: Towards Plugins and Beyond!"/></figure><p>It is worth noting that it is possible to indicate you wish to receive security alarms linked to the discovery of possible CVE that corresponds to your version of Traefik.</p><h2 id="warm-up-the-plugins"><strong>Warm up the plugins</strong></h2><p>For many years I've been using the ubiquitous Apache HTTP web server. Undoubtedly, one of the enormous strengths of this product is its modularity, allowing the community to extend its functionality.</p><p>Traefik now allows the use of plugins as well. The list is currently rather small, but I do not doubt that the catalog will snowball as the community begins publishing its creations!</p><figure class="kg-card kg-image-card"><img src="https://lh3.googleusercontent.com/R5F_9k2vb-vT_4BTOh1_q0cUn8vfnJNRPgiKjTUi8-UazGQk6EBXA-Rxq9ILZlXQE-dPdUmU4WXIMNadjXcT1qxAsXX21vyY-4gX5SEwxHX6JDZltW4u6Cah9BGRXItAo9_IfrbD" class="kg-image" alt="Traefik 2.3: Towards Plugins and Beyond!"/></figure><p>It is possible to contribute plugins written in Go by following <a href="https://github.com/containous/plugindemo">the guide provided by Containous</a>.<br/></p><p>For this article, I chose the <a href="https://github.com/containous/plugin-blockpath">"Block Path" plugin written by Containous</a>. This plugin allows us to block access to individual pages based on regular expressions dynamically.</p><p>Blocked pages will directly return a 403 (Forbidden) error.</p><p>The interest of this kind of plugins, already existing in most reverse proxies, is to be able to intercept access to individual pages and prevent the backend from receiving the request.</p><p>This type of middleware enables operators:</p><ul><li>To not generate a load (for example, in the case of an admin page that could be brute-forced/DDOS).</li><li>To avoid exposing an undiscovered zero-day flaw, since the backend does not receive any requests.</li></ul><h3 id="install-the-plugin"><strong>Install the Plugin</strong></h3><p>Plugins load via <a href="https://docs.traefik.io/v1.7/basics/#static-traefik-configuration">the static configuration</a> of Traefik. For this part, I loaded it via the command line parameters, since this is how I approach loading my entire configuration in Kubernetes.</p><pre><code class="language-yaml">args:
  - --providers.kubernetescrd
  - --accesslog=true
  - --accesslog.filepath=/var/log/traefik/access.log
  - --accesslog.fields.headers.defaultmode=keep
  - --entrypoints.web.address=:80
  - --entrypoints.websecure.address=:443
  - --certificatesresolvers.le.acme.email=myawesomemail@mail.com
  - --certificatesresolvers.le.acme.storage=/cert/acme.json
  - --certificatesResolvers.le.acme.httpChallenge.entryPoint=web
  - --experimental.pilot.token=mytoken
  - --experimental.plugins.demo.moduleName=github.com/containous/plugin-blockpath
  - --experimental.plugins.demo.version=v0.1.2</code></pre><p>As you can see above, declaring the plugins is manageable via the <code>experimental.plugins</code> arguments.</p><p>In my command line example, "demo" is the name I gave to the plugin before moduleName. Thus, it contains the path to the GitHub repository containing the plugin, version being the Git version to checkout.</p><p>Once this configuration is in place, it is necessary to restart Traefik.</p><h3 id="configuring-the-plugin"><strong>Configuring the plugin</strong></h3><!--kg-card-begin: markdown--><p>The plugin then behaves like a traditional middleware; which I explain in my previous article on Traefik TLS configuration, middlewares are components that exist between Traefik and your backend and modify the normal behavior. For example, in the article mentioned above, the middleware I used allows you to define the necessary security headers for ranking A+ on SSL Labs.</p>
<!--kg-card-end: markdown--><p>The plugin then behaves like a traditional middleware; which I explain in my <a href="https://tferdinand.net/en/traefik-2-tls-configuration/">previous article on Traefik TLS configuration</a>, middlewares are components that exist between Traefik and your backend and modify the normal behavior. For example, in the article mentioned above, the middleware I used allows you to define the necessary security headers for ranking A+ on SSL Labs.</p><p>For this example, I have declared a new middleware for use by Traefik in Kubernetes:</p><pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: demo
spec:
  plugin:
    demo:
      regex: ["^/demo-[a-z]{1,5}"]</code></pre><p>Configuring the plugin declared in the command line arguments requires referencing it in the manifest above in the <code>metadata.name</code> field. In the <code>spec</code> field, we can now configure the plugin according to the schema defined in the plugin's documentation. In the example above, I've used regex to indicate that Traefik should block any request whose path starts with "/demo-" with 1 to 5 lowercase letters.</p><h3 id="load-middleware"><strong>Load middleware</strong></h3><p>Now that I have defined my middleware, I have to load it into my IngressRoute.</p><p>I modify my IngressRoute by declaring it should load this middleware too. As a reminder, you can define multiple middlewares on your IngressRoutes, which will execute in the order specified.</p><pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: traefik-web-ui-tls
  namespace: default
spec:
  entryPoints:
    - websecure
  routes:
  - kind: Rule
    priority: 1
    match: (Host(`www.tferdinand.net`) || Host(`tferdinand.net`)) &amp;&amp; PathPrefix(`/`)
    services:
    - name: ghost-tfe-fr
      port: 2368
      helthcheck:
        path: /
        host: tferdinand.net
        intervalSeconds: 10
        timeoutSeconds: 5
    middlewares:
      - name: security
      - name: demo
  tls:
    certResolver: le
    options:
      name: mytlsoption
      namespace: default
</code></pre><p>As you can see in <code>spec.routes[0].middlewares</code>, I've added a reference to the <code>demo</code> middleware that I installed and configured in the previous steps.</p><h3 id="let-s-test-the-plugin"><strong>Let's test the plugin</strong></h3><p>Now, it's time to test my plugin configuration.</p><figure class="kg-card kg-image-card"><img src="https://lh4.googleusercontent.com/q752UlNP9VLB7Quofs1dfL6MWZIoqLSTopZbxsASgxu2nhJsLpwo_h0ldRuYhbq4_d4m6pq-uiJHDJyqwqnd7X3ZeT9c2-2qd1PnOfItAUmfXoL17ooOXrm7Q6OAQ-13ezfikOHc" class="kg-image" alt="Traefik 2.3: Towards Plugins and Beyond!"/></figure><p>Yes, I also use Windows, and I assume it ;)</p><p>As you can see, the behavior we anticipated is present. Legitimate queries work as expected, and Traefik is blocking the requests which match the schema defined in the demo plugin configuration before ever reaching the backend service.</p><h2 id="in-conclusion-a-small-step-for-containous-a-big-step-for-the-community-"><strong>In conclusion: A small step for Containous, a big step for the community.</strong></h2><p>Traefik Plugins and Traefik Pilot are technology previews and only scratch the surface of their true potential; however, this open modularity will enable the community to extend the core features of Traefik without the necessity of custom forks or compiled code.</p><p>Traefik Pilot and Plugins will potentially allow companies to develop plugins on their own and thus adapt Traefik to their needs.</p><p>Traefik Pilot is an excellent initiative, and I can't wait to see how Containous will take-off with these new features! </p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://pilot.traefik.io/">Get started with Pilot ›</a></li><li><a href="https://docs.traefik.io/v2.3/plugins/overview/">Pilot documentation</a></li><li><a href="https://containous.ghost.io/traefik/">Traefik</a></li><li><a href="https://community.containo.us/c/traefik/5">Community forum</a></li></ul><h3 id="author-s-bio">Author's Bio</h3><!--kg-card-begin: markdown--><p><a href="https://twitter.com/TeddyFERDINAND1" target="_blank" rel="nofollow">Teddy</a> is a Cloud Security Architect at WeScale, an organization made up of cloud experts. He's former Ops, self-taught, and is passionate about containers and automation. He believes that knowledge is wealth that must be shared.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Do Machines Learn? Testing in Production with Traefik]]></title><description><![CDATA[Here is the story about the personalization of a large-scale book reading service and building the infrastructure to evaluate new models utilizing Traefik.]]></description><link>https://traefik.io/blog/do-machines-learn-testing-in-production-with-traefik/</link><guid isPermaLink="false">Ghost__Post__5efb70c61555240039b0bf3d</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Alexander Dmitriev]]></dc:creator><pubDate>Tue, 28 Jul 2020 14:30:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik-1.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://containous.ghost.io/content/images/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik-1.jpg" alt="Do Machines Learn? Testing in Production with Traefik"/><p><strong>Guest post by Alexander Dmitriev, Traefik Ambassador</strong></p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg" class="kg-image" alt="Do Machines Learn? Testing in Production with Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg 1600w, https://containous.ghost.io/content/images/2020/08/Do-Machines-Learn--Testing-in-Production-with-Traefik.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><!--kg-card-begin: markdown--><p>Anyone who runs machine learning models in production while trying to improve model performance most likely knows about <a href="https://en.wikipedia.org/wiki/A/B_testing" target="_blank" rel="nofollow">A/B tests</a>. But what if you are the only machine learning engineer on the project? You must automate these tests as much as possible. And what if you have to make dozens of iterations per year and sometimes deploy new versions several times a week? Here is my story about the personalization of a large-scale book reading service and building the infrastructure to evaluate new models utilizing Traefik.</p>
<!--kg-card-end: markdown--><h2 id="about-mybook">About MyBook</h2><!--kg-card-begin: markdown--><p><a href="https://mybook.ru/" target="_blank" rel="nofollow">MyBook</a> is a subscription reading service that publishes book apps for multiple platforms while striving to provide the best reading experience for our users. We've collected a huge catalog of books, audiobooks, ratings, and summaries that are conveniently always in your pocket. Bookmarks are synced across all our user’s devices and text-audiobook versions. Avid readers can use a subscription with unlimited reading, and those who want just one book can rent it for half price. My name is Alexander Dmitriev, and I am a machine learning engineer. My field of interest is personalization: <a href="https://en.wikipedia.org/wiki/Recommender_system" target="_blank" rel="nofollow">recommender systems</a>, <a href="https://en.wikipedia.org/wiki/Computer_user_satisfaction" target="_blank" rel="nofollow">user satisfaction measurement</a>, and infrastructure for these systems. I love to solve problems end-to-end: discuss the user interface with the product manager, prepare data, train machine learning models, write the service, deploy to production, and support it.</p>
<!--kg-card-end: markdown--><h2 id="building-a-smart-er-recommendation-engine">Building a Smart(er) Recommendation Engine</h2><p>Helping customers find books that are interesting to them is essential for a retail service like ours. MyBook already has talented editors curating popular book selections, so the next logical step was adding frequently updated personal recommendations. When I started at MyBook, my goal was to build a recommender system that discovered and suggested books that a customer might find interesting based on their behaviors. This service is known internally as <em>recsys</em>, and I'll be focusing on the evolution, automation, and maturation of that system in this post.</p><p>Production testing is critical for the development of machine learning systems like <em>recsys</em>. Simulating ephemeral properties such as serendipity, variety, and relevance is not feasible with more traditional approaches to testing such as unit or integration methodologies used during software development.</p><p>When the first version of the recommender service was ready, I added a Flask server, built a Docker container, and deployed it on a newly purchased cloud server. Backend engineers added NGINX as a reverse proxy with SSL support because it had been used for many years on our production systems. The <em>recsys </em>application Flask port was published to the host, and all requests were forwarded.</p><p>So, at first, the architecture looked like this:</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_01@2x.jpg" class="kg-image" alt="Do Machines Learn? Testing in Production with Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/06/MyBook_Diagram_01@2x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/06/MyBook_Diagram_01@2x.jpg 1000w, https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_01@2x.jpg 1200w" sizes="(min-width: 720px) 720px"/></figure><h2 id="the-growing-pains-of-productionized-testing">The Growing Pains of Productionized Testing</h2><!--kg-card-begin: markdown--><p>We regularly performed A/B tests where we measured the <a href="https://en.wikipedia.org/wiki/Mean" target="_blank" rel="nofollow">mean number</a> of books our users added to their bookshelves during a single session. The end results showed us that personalized sets performed 30% better than a fixed set of bestsellers handpicked by our editors. Eventually, all new versions of recsys rolled out through the A/B test against the previous one in production. And it looked something like this:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_02@2x.jpg" class="kg-image" alt="Do Machines Learn? Testing in Production with Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/06/MyBook_Diagram_02@2x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/06/MyBook_Diagram_02@2x.jpg 1000w, https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_02@2x.jpg 1200w" sizes="(min-width: 720px) 720px"/></figure><p>As time passed and new services appeared, the situation became messy and unmanageable:</p><ul><li>Many of the recsys services ports were hardcoded on the backend</li><li>Prior to each A/B test the health checks, Prometheus exports, alerting rules, and Grafana dashboards had to be configured by hand</li><li>This process was required any time a new version of recsys was deployed</li></ul><p>As mentioned before, user tests are must-have in personalization tasks and it's crucial to be able to set up and teardown one as quickly and easily as possible, otherwise this overhead would have driven our velocity and impact close to zero.</p><h2 id="machine-learning-at-scale">Machine Learning at Scale</h2><p>At this stage, it was clear that a better solution was required. I spent some time researching concepts such as service discovery, canary deployments, and cloud-native. Eventually, I discovered <a href="https://containous.ghost.io/traefik/">Traefik</a>, a nice and easy to use reverse-proxy and load balancer which works natively with Docker containers and Docker Swarm.</p><p>After reading the Traefik <a href="https://docs.traefik.io">documentation</a> I discovered that I would get:</p><ul><li>auto-discovery of new containers</li><li>health checks and routing only to healthy containers</li><li>metrics endpoint for Prometheus</li><li>configuration via Docker labels which means all my infrastructure will be described alongside my deployment manifests, perfect</li><li>no more exposed ports on my containers, now they are secure and accessible only inside the Docker network</li></ul><!--kg-card-begin: markdown--><p>For a long time, I was curious about the <a href="https://en.wikipedia.org/wiki/Multi-armed_bandit" target="_blank" rel="nofollow">the multi-armed bandit</a> approach for recsys tests. The idea of this approach is to optimize some kind of reward (e.g. user satisfaction) during the constant test with adjustments made on the fly and to minimize resources (e.g. user sessions) used during the exploration of new choices (recsys models). It seems perfect if you want to test every small iteration or even several versions of service at the same time.</p>
<!--kg-card-end: markdown--><p>I ended up building a couple of different prototypes and came to this solution:</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_03@2x.jpg" class="kg-image" alt="Do Machines Learn? Testing in Production with Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/06/MyBook_Diagram_03@2x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/06/MyBook_Diagram_03@2x.jpg 1000w, https://containous.ghost.io/content/images/2020/06/MyBook_Diagram_03@2x.jpg 1200w" sizes="(min-width: 720px) 720px"/></figure><p>Every service became a router in Traefik terminology, and each recommender engine container became a <a href="https://docs.traefik.io/routing/services/">service</a>.</p><p>Traefik made it possible to assign multiple Docker services to one <a href="https://docs.traefik.io/routing/routers/">routing rule</a> and split traffic between services while <a href="https://docs.traefik.io/routing/services/#weighted-round-robin-service">assigning</a> weights to each one. So here is the most interesting part:</p><!--kg-card-begin: markdown--><ul>
<li>The sum of all weights for different versions of the recsys would always equal 100</li>
<li>All new versions were deployed with weight 1, so they received only 1% of user traffic</li>
<li>Several times a day Python script recalculated recommender performance metrics for each version of recommender (for simplicity let's say CTR or <a href="https://en.wikipedia.org/wiki/Click-through_rate" target="_blank" rel="nofollow">click-through rate</a>) and updated weights for models; so better performing ones receive more user requests while others receive less</li>
</ul>
<!--kg-card-end: markdown--><p>Testing a new version of the recommender engine is as simple as adding a service definition to the docker-compose file and updating the stack. Docker Swarm finds the difference between the desired and current state, starts a new Docker container with `weight = 1`. Traefik finds this container and, after successful health checks, routes 1% of requests to the new version, all while exporting the metrics required for monitoring by our automated scripts. After a set amount of time the CTR metrics are recalculated and if users like the new version, it is reconfigured to receive a larger share of the traffic, and it is constantly being reevaluated against new models.</p><h2 id="traefik-helps-me-do-what-i-love-most">Traefik Helps Me Do What I Love Most</h2><p>We are a small team and I am the only MLE on the project, so I insist on researching and utilizing tools that are easy to use and built with love for the end-user. Traefik definitely meets that criteria. Maintenance costs are close to zero, and the learning curve is flat. This approach is pretty universal no matter which container orchestrator you use and how you configure Traefik, whether you’re using Kubernetes, Docker labels, Consul, Etcd, or something else.</p><p>In summary, I’d recommend <a href="https://containous.ghost.io/traefik/">Traefik</a> to anyone who needs reverse proxy with all necessary features such as service discovery, monitoring, and metrics exporting, which is easy to set up and maintain. It saved me a ton of time so that I could now spend fine-tuning algorithms and adding personal ranking to editors' handpicked book sets, which help users find the books they like. All this effort yielded book consumption increase by tens of percent.</p><h3 id="author-s-bio">Author's Bio</h3><p>Alex Dmitriev is an engineer in embedded electronics and data scientist in metallurgy. Since 2018, he's been a machine learning engineer at MyBook, and is focused on personalization of user experience and infrastructure for ML services.</p>]]></content:encoded></item><item><title><![CDATA[Simplified security for Kubernetes with Traefik and Let’s Encrypt]]></title><description><![CDATA[Encryption for network security is a non-trivial matter, particularly in complex environments. Traefik and Let’s Encrypt can make the process of securing Kubernetes clusters simpler, speedier, and more resilient.]]></description><link>https://traefik.io/blog/simplified-security-for-kubernetes-with-traefik-and-lets-encrypt/</link><guid isPermaLink="false">Ghost__Post__5f161889d90a6e003946cbaa</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Tue, 21 Jul 2020 13:58:29 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg" class="kg-image" alt="Simplified security for Kubernetes with Traefik and Let’s Encrypt" srcset="https://containous.ghost.io/content/images/size/w600/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg 1600w, https://containous.ghost.io/content/images/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt-1.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><!--kg-card-begin: markdown--><img src="https://containous.ghost.io/content/images/2020/07/Simplified-security-for-Kubernetes-with-Traefik-and-Lets-Encrypt.jpg" alt="Simplified security for Kubernetes with Traefik and Let’s Encrypt"/><p>Network encryption – also known as transport layer security (TLS) – is a must for today’s online apps and services. Beyond the obvious need to prevent data breaches and other malicious attacks, there are also regulatory concerns to consider. Network encryption can be an important step in proving <a href="https://gdpr.eu/" target="_blank" rel="nofollow">GDPR</a> compliance, passing a financial audit, or complying with domain-specific regulations such as <a href="https://www.hhs.gov/hipaa/for-professionals/security/laws-regulations/index.html" target="_blank" rel="nofollow">HIPAA</a> or <a href="https://www.pcisecuritystandards.org/" target="_blank" rel="nofollow">PCI DSS</a>, to name just a few examples.</p>
<!--kg-card-end: markdown--><p>Unfortunately, getting encryption right is a non-trivial matter, and throwing containers and Kubernetes into the mix only compounds the issue. The distributed nature of Kubernetes environments and the often-brief lifecycles of containerized workloads both multiply the challenges of network security.</p><!--kg-card-begin: markdown--><p>Still, there’s hope. Newer tools and services – including Traefik and <a href="https://letsencrypt.org/" target="_blank" rel="nofollow">Let’s Encrypt</a> – can make the process of securing Kubernetes clusters simpler, speedier, and more resilient.</p>
<!--kg-card-end: markdown--><h2 id="lowering-barriers-to-encryption"><strong>Lowering barriers to encryption</strong></h2><!--kg-card-begin: markdown--><p>Historically, network encryption has been both laborious and costly. By some estimates, managing a typical certificate and private key can take four hours per year. That may not sound like much, but when multiplied by the requirements of a large infrastructure, this essential maintenance can quickly become burdensome, particularly given the current push by Apple and other vendors to limit the validity of certificates to <a href="https://support.apple.com/en-us/HT211025" target="_blank" rel="nofollow">no more than 398 days</a>.</p>
<p>The alternative, however, is even worse. Expired or invalid certificates can lead to outages and reduced service, resulting in untold <a href="https://www.google.com/search?q=post-mortem+ssl+cert+expired" target="_blank" rel="nofollow">losses in productivity and revenue</a>.</p>
<p>Let’s Encrypt was founded to address these issues. A project of the <a href="https://www.abetterinternet.org/" target="_blank" rel="nofollow">Internet Security Research Group</a>, Let’s Encrypt is a free, nonprofit, automated, and open certificate authority (CA), created with the goal of promoting universal internet security and data privacy through encryption. Its sponsors include some of the largest software vendors and online services in the industry.</p>
<p>Let’s Encrypt will issue an unlimited number of <a href="https://casecurity.org/2013/08/07/what-are-the-different-types-of-ssl-certificates/" target="_blank" rel="nofollow">domain-validated</a> certificates with 90-day validity to the owner of any domain name, free of charge. As of this writing, the project has issued more than 1 billion certificates and it counts some 200 million websites as its clients.</p>
<!--kg-card-end: markdown--><h2 id="automation-let-s-encrypt-s-secret-sauce"><strong>Automation: Let’s Encrypt’s secret sauce</strong></h2><!--kg-card-begin: markdown--><p>Cost reduction is of course welcome, but the most important benefit of Let’s Encrypt is labor reduction via automation. For Kubernetes operators, automation is a way of life. Let’s Encrypt brings that spirit to the world of network security.Central to how Let’s Encrypt works is the ACME (Automated Certificate Management Environment) protocol, which was made an <a href="https://tools.ietf.org/html/rfc8555" target="_blank" rel="nofollow">IETF standard</a> in 2019. It defines a method whereby a computing service and a CA (typically Let’s Encrypt itself) can complete the process of requesting, issuing, and verifying certificates without manual intervention.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/07/7-Steps-to-Automated-Domain-Validation-with-Lets-Encrypt.png" class="kg-image" alt="Simplified security for Kubernetes with Traefik and Let’s Encrypt" srcset="https://containous.ghost.io/content/images/size/w600/2020/07/7-Steps-to-Automated-Domain-Validation-with-Lets-Encrypt.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/7-Steps-to-Automated-Domain-Validation-with-Lets-Encrypt.png 1000w, https://containous.ghost.io/content/images/2020/07/7-Steps-to-Automated-Domain-Validation-with-Lets-Encrypt.png 1050w" sizes="(min-width: 720px) 720px"><figcaption><strong>7 Steps to Automated Domain Validation with Let’s Encrypt</strong></figcaption></img></figure><!--kg-card-begin: markdown--><p>The ACME <a href="https://letsencrypt.org/how-it-works/" target="_blank" rel="nofollow">domain validation process</a> relies on public key cryptography to establish trust. <a href="https://letsencrypt.org/docs/client-options/" target="_blank" rel="nofollow">ACME client software</a>, also known as a certificate management agent, generates a public-private key pair and presents it to a server on the CA’s end, along with a domain name. The server then asks the client to prove that it controls the domain in question by satisfying <a href="https://letsencrypt.org/docs/challenge-types/" target="_blank" rel="nofollow">one or more challenges</a>. If the client completes the challenges and signs some temporary data (a “nonce”) with its private key, the server gives the client’s key pair its stamp of approval.</p>
<!--kg-card-end: markdown--><p>Once the client has an authorized key pair, it can use it to request, renew, or revoke certificates from the CA, as long as the keys remain valid. Automating these tasks can eliminate as much as 95% of the labor involved in managing TLS encryption.</p><h2 id="acme-and-traefik"><strong>ACME and Traefik</strong></h2><p>So how to get this level of automated certificate management for a Kubernetes cluster? One of the easier ways is to deploy the open source<a href="https://containous.ghost.io/traefik/"> Traefik</a> edge router as a<a href="https://docs.traefik.io/providers/kubernetes-ingress/"> Kubernetes Ingress controller</a>. Traefik includes a<a href="https://docs.traefik.io/https/acme/"> built-in ACME client</a>, so no additional software is needed to begin working with Let’s Encrypt.</p><p>When used as an Ingress controller, Traefik ferries requests from the external network to services running within the Kubernetes cluster, using routes defined by Kubernetes<a href="https://kubernetes.io/docs/concepts/services-networking/ingress/"> Ingress resources</a>. Traefik’s ACME client can automatically request and provision certificates for any domain assigned to the cluster, making it possible to add TLS-encrypted routes.</p><p>Traefik aims to reduce setup times by automatically discovering the right configuration for a given infrastructure, so putting the pieces in place is straightforward. Instructions on how to install Traefik into a Kubernetes cluster and enable Let’s Encrypt are available in the<a href="https://docs.traefik.io/user-guides/crd-acme/"> official documentation</a>.</p><h2 id="a-secure-starting-point"><strong>A secure starting point</strong></h2><p>Traefik and Let’s Encrypt together offer to set up basic TLS routing for Kubernetes. As mentioned earlier, however, encryption for network security is a non-trivial matter, particularly in more complex environments. Just for starters, you’ll need genuine domain names that point to servers that are accessible by the public internet for Let’s Encrypt’s domain-validation challenge process to work.</p><p>Further challenges arise when you want to run more than one instance of Traefik, to ensure high availability. It’s currently not possible to run more than one instance of the community-maintained version of Traefik on a cluster with Let’s Encrypt enabled, because there’s no guarantee that any request will be handled by the correct instance of Traefik. One way to address this is to use the commercial<a href="https://containous.ghost.io/traefikee/"> Traefik Enterprise Edition (TraefikEE)</a> product, which offers distributed Let’s Encrypt as a supported feature.</p><!--kg-card-begin: markdown--><p>Organizations with more specific needs – such as interfacing with enterprise vault providers – and who aren’t afraid to take a hands-on, DIY approach may need to install additional, dedicated certificate management software. One such option that’s proven popular is <a href="https://cert-manager.io/docs/" target="_blank" rel="nofollow">cert-manager</a>, which can work in tandem with both Traefik and TraefikEE.</p>
<!--kg-card-end: markdown--><p>The key point, however, is that TLS encryption should be everywhere, and today it can be. The ACME protocol, Let’s Encrypt, and self-configuring software like Traefik can automate away much of the hard work that was once involved with certificate management and secure request routing. In turn, that frees you to concentrate on what really matters, which is how to deliver the most value with your services, rather than how to secure them.</p><p>You can try out the features of TraefikEE, including distributed Let’s Encrypt, by starting a <a href="https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days">30-day free trial</a>.</p>]]></content:encoded></item><item><title><![CDATA[Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik]]></title><description><![CDATA[Today, we’re excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production.]]></description><link>https://traefik.io/blog/introducing-traefik-pilot-a-first-look-at-our-new-saas-control-platform-for-traefik/</link><guid isPermaLink="false">Ghost__Post__5f0f2f71554944004519ecc4</guid><category><![CDATA[Blog]]></category><category><![CDATA[Announcements]]></category><dc:creator><![CDATA[Orion Letizi]]></dc:creator><pubDate>Thu, 16 Jul 2020 13:25:52 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog.jpg" class="kg-image" alt="Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/07/Introducing-Traefik-Pilot---Blog.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Introducing-Traefik-Pilot---Blog.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Introducing-Traefik-Pilot---Blog.jpg 1600w, https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><img src="https://containous.ghost.io/content/images/2020/07/Introducing-Traefik-Pilot---Blog-1.jpg" alt="Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik"/><p>Today, we’re excited to announce the early-access preview of Traefik Pilot, a new SaaS global control plane, to simplify the management of Traefik running in production. Pilot extends the capabilities of Traefik, providing a powerful observability and control platform for every one of your Traefik instances in a single unified dashboard.</p><p>In addition, Traefik Pilot introduces plugins for Traefik, including a first of its kind open marketplace, which extends Traefik middleware with custom, purpose-built requests and responses processing.</p><p>The preview release of Pilot includes:</p><ul><li>Custom Middleware Plugins! Our brand new plugins marketplace including examples of custom middleware</li><li>Centralized view of your production Traefik instances</li><li>Availability and security vulnerability alerts with notifications</li></ul><p><a href="https://pilot.traefik.io/">Get started with Pilot ›</a></p><h2 id="custom-middleware-plugins">Custom Middleware Plugins</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png" class="kg-image" alt="Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 1600w, https://containous.ghost.io/content/images/2020/07/Screen-Shot-2020-07-16-at-15.27.57.png 2094w" sizes="(min-width: 720px) 720px"/></figure><p>One of the most frequently requested features from the Traefik community is the <a href="https://github.com/containous/traefik/issues/1336">ability to easily create and share custom</a> plugins and extend the functionality of our existing middleware catalog. Built on <a href="https://containous.ghost.io/blog/announcing-yaegi-263a1e2d070a/">Yaegi</a>, the new plugin system offers an elegant, extensible, and high-performance way to augment Traefik's capabilities without the need to modify or compile the Traefik source code.</p><p>Traefik plugins are add-on packages that empower users to apply transformations and enhancements to both requests and responses, which are handled by Traefik. There have been several middleware <a href="https://github.com/containous/traefik/pulls?q=is%3Apr+label%3Aarea%2Fmiddleware+label%3Aresolution%2Fdeclined+is%3Aclosed">pull requests</a> declined due to implementations that are tied to a specific use case or for lacking the abstraction necessary to be accepted upstream into Traefik. Developers are now equipped with the tools needed to <a href="https://github.com/containous/plugindemo">write plugins in Go</a>, and sharing them with the world is as easy as publishing them on GitHub. The new plugin engine enables the community to install their custom middleware using Traefik Pilot without compiling a single line of code.</p><p>The initial release of Pilot includes a free to use plugin marketplace that extends Traefik by installing middleware plugins directly from the catalog. In addition, you can just as easily create, publish, and install your own. On launch day, the catalog will contain a few sample plugins that serve as advanced tutorials for developers to build their own. We expect the catalog to expand rapidly, especially as the Traefik community begins to write and share their new creations.</p><p><a href="https://docs.traefik.io/v2.3/plugins/overview/">Learn more ›</a></p><h2 id="security-and-availability-alerting">Security and Availability Alerting</h2><p>Keeping track of your Traefik installations and ensuring they are healthy, available, and secure has, until today, required a significant amount of effort. Typically this involved deploying a system to gather metrics and creating an alerting system to notify you if there is a problem. With Pilot's introduction, we're now the first managed SaaS provider to offer security and availability monitoring of your cloud-native software load balancers, for free.</p><!--kg-card-begin: markdown--><p>Once Traefik is registered, a built-in heartbeat mechanism will check-in with Pilot periodically and report the health and availability of your Traefik instance. In addition, Pilot will check for <a href="https://cve.mitre.org/" target="_blank" rel="nofollow">common vulnerabilities and exposure (CVE)</a> bulletins that apply to your Traefik installation and configuration, which may indicate a security risk to your Traefik deployments. You may now use the dashboard to configure your alert settings and get notified of issues through email or custom webhooks before they become emergencies.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Profile-Settings-1.png" class="kg-image" alt="Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/07/Traefik-Pilot-Profile-Settings-1.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Traefik-Pilot-Profile-Settings-1.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Traefik-Pilot-Profile-Settings-1.png 1600w, https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Profile-Settings-1.png 2158w" sizes="(min-width: 720px) 720px"/></figure><h2 id="get-started-by-connecting-your-traefik-instance">Get Started by Connecting Your Traefik Instance</h2><p>Pilot requires the most recent version of Traefik, v2.3 RC. You will also now find a convenient link on the Traefik dashboard to register your instance with Pilot.</p><figure class="kg-card kg-image-card"><img src="https://lh4.googleusercontent.com/bEKbwjNoD7pW83nqgjE4LdndIcQnNihoDJsN77_Vk5A4a5ZUwbaWDiIbYgalA3TQ6fnMeFeQc5upiceLRWoRSLIDZamSg6yTBskb-EzDngqIfts-kQk6bl6M7E7Sy5_BePfJ1KY" class="kg-image" alt="Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik"/></figure><p>Once logged into Pilot, registering your Traefik instance by adding a unique token to your static configuration. This will automatically extend your installation's functionality by monitoring the health of your installation, enabling the use of custom middleware plugins, and reporting relevant vulnerabilities that apply to your environment.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Instance-Registration.png" class="kg-image" alt="Introducing Traefik Pilot: a First Look at Our New SaaS Control Platform for Traefik" srcset="https://containous.ghost.io/content/images/size/w600/2020/07/Traefik-Pilot-Instance-Registration.png 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Traefik-Pilot-Instance-Registration.png 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Traefik-Pilot-Instance-Registration.png 1600w, https://containous.ghost.io/content/images/2020/07/Traefik-Pilot-Instance-Registration.png 2156w" sizes="(min-width: 720px) 720px"/></figure><h2 id="just-the-beginning">Just the Beginning</h2><p>This initial preview release brings exciting and new capabilities to the Traefik ecosystem, and this is just the beginning. We're even more excited by what we already have queued up for future iterations. Keep an eye out for Pilot to broaden the range and reach of your existing Traefik deployments. We're just getting started and have plans for additional capabilities from microservices routing and orchestrator ingress to expanding out to the global edge.</p><p>Jump in the cockpit with Pilot today and let us know what you think. <a href="https://github.com/containous/plugindemo">What kinds of plugins will you write</a>?</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://pilot.traefik.io/">Get started with Pilot ›</a></li><li><a href="https://docs.traefik.io/v2.3/plugins/overview/">Pilot documentation</a></li><li><a href="https://containous.ghost.io/traefik/">Traefik</a></li><li><a href="https://community.containo.us/c/traefik/5">Community forum</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Traefik and Docker Swarm: A Dynamic Duo for Cloud-Native Container Networking]]></title><description><![CDATA[External reverse proxy and load balancing software like Traefik offer networking features and control that Docker Swarm cannot provide on its own.]]></description><link>https://traefik.io/blog/traefik-and-docker-swarm-a-dynamic-duo-for-cloud-native-container-networking/</link><guid isPermaLink="false">Ghost__Post__5f0dd2aeda8b5600395a511a</guid><category><![CDATA[Blog]]></category><category><![CDATA[Docker]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Wed, 15 Jul 2020 05:37:39 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg" class="kg-image" alt="Traefik and Docker Swarm: A Dynamic Duo for Cloud-Native Container Networking" srcset="https://containous.ghost.io/content/images/size/w600/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg 1600w, https://containous.ghost.io/content/images/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><img src="https://containous.ghost.io/content/images/2020/07/Traefik-and-Docker-Swarm-A-Dynamic-Duo-for-Cloud-Native-Container-Networking-1.jpg" alt="Traefik and Docker Swarm: A Dynamic Duo for Cloud-Native Container Networking"/><p>Docker didn’t invent application containers, but it put them on the map. Docker software helped containers become the most important innovation in application delivery since virtual machines. And with the introduction of Swarm mode, Docker added <em>container orchestration</em> to its toolbox, making it possible to build distributed applications from large collections of containerized microservices.</p><p>Docker Swarm has a lot going for it. For starters, it’s built into the Docker Engine, so it’s available to anyone who can launch Docker containers. It’s also easy to get up and running in a variety of cloud and on-premises environments, unlike more complex tools such as Kubernetes and Mesos.</p><p>Unfortunately, Swarm alone will only get you partway to production. Its “routing mesh” networking model doesn’t supply the availability, security, observability, and control that you’ll need when exposing your applications to the open internet, particularly as they scale to more complex usage scenarios.</p><h2 id="load-balancing-and-reverse-proxies">Load Balancing and Reverse Proxies</h2><p>The smart way to gain these capabilities is to pair Docker Swarm with external reverse proxy and load balancing software. These networking tools act as concierge for requests coming from the external network. They not only route requests to where they need to go (also known as <em>ingress routing</em>), but they also help ensure that backend applications and services don’t become overwhelmed by traffic spikes.</p><p>At its most basic, this type of routing software handles HTTP requests, which sit at Layer 7 of the OSI networking model, known as the <em>application layer</em>. More advanced load balancers extend their capabilities to Layer 4, the <em>transport layer</em>, by also handling TCP requests.</p><p><a href="https://containous.ghost.io/traefik/">Traefik</a> is one such offering that’s particularly well-suited for use with Docker Swarm. Like Swarm mode itself, Traefik aims to eliminate much of the drudgery of maintaining containerized environments by automating routine configuration tasks.Traefik <a href="https://docs.traefik.io/providers/docker/">automatically discovers</a> information about the network and services available in a Docker Swarm cluster, dynamically updating its configuration as the environment changes. This sets it apart from Interlock, the ingress routing component of the commercial Docker Enterprise product, which can become unreliable when its configuration is updated. At the same time, Traefik offers comprehensive observability into the functioning of the network, so operations teams are never left in the dark.</p><h2 id="advanced-routing"><strong>Advanced Routing</strong></h2><p>The ability to update network routes efficiently is particularly important for microservices deployments. By their nature, microservices tend to be stateless and short-lived. New versions of services are typically deployed frequently and instances are scaled dynamically to meet demand. Because of this, routers and load balancers should be able to respond quickly as new container instances appear and disappear.</p><!--kg-card-begin: markdown--><p>This capability of external routers also makes it easy to test new fixes and feature upgrades in ways that are not possible with Docker Swarm alone, including blue-green deployments, canary releases, and <a href="https://www.infoworld.com/article/3565750/4-deployment-strategies-for-resilient-microservices.html" target="_blank" rel="nofollow">similar methods</a>. By crafting routing rules that split traffic between old and new versions of services in user-defined proportions, it’s possible to roll out updates gradually and even roll them back when necessary with zero downtime.</p>
<p>Another important feature of a reverse proxy is the ability to terminate encrypted TLS traffic. Users have come to expect the HTTPS URL and padlock icon that indicate secure connections. In this aspect, Traefik not only supports TLS but – in keeping with the Docker Swarm ethos of easy configuration – it also supports <a href="https://containous.ghost.io/blog/traefik-2-tls-101-23b4fbee81f1/">automated certificate management</a> via a built-in client for <a href="http://letsencrypt.org/" target="_blank" rel="nofollow">Let's Encrypt</a>.</p>
<!--kg-card-end: markdown--><h2 id="future-proof-your-apps">Future-Proof Your Apps</h2><p>Separating the functions of networking and container orchestration has benefits for application lifecycles, too. As an application scales and evolves, inevitably its infrastructure needs will also change. Because Traefik works consistently across on-premises and public cloud environments, it makes it simple to port your Docker Swarm clusters when the time comes, without dramatic configuration changes.</p><p>The commercial product <a href="https://containous.ghost.io/traefikee/">Traefik Enterprise Edition (TraefikEE)</a> also includes features aimed at enterprise deployments. For example, it supports a variety of identity and authentication protocols, including LDAP, JWT, and OpenID Connect. It runs as a cluster for high availability, including clustered support for Let’s Encrypt. And it’s fully compliant with Docker’s Universal Control Plane, giving operations teams centralized control of networking as part of the underlying infrastructure.</p><p>And we must not ignore that it may become necessary to move applications away from Docker Swarm to a more feature-rich orchestrator, such as Kubernetes. A Traefik configuration can be ported from Docker Swarm to Kubernetes without significant changes, meaning the choice you make for routing and load balancing today will not negatively affect your future plans. By comparison, Interlock only works with Docker Enterprise.</p><h2 id="the-route-forward"><strong>The Route Forward</strong></h2><p>Containers are likely to remain the dominant means of application deployment for years to come, and with good reason. What’s more, as the microservices model of application development gains traction, container orchestration will increasingly become an essential component of IT infrastructure.</p><p>Networking, on the other hand, is essential now and for the future. External reverse proxy and load balancing software offer networking features and control that an orchestration layer like Docker Swarm cannot provide on its own. What’s more, the auto-discovery and configuration capabilities of Traefik make it an ideal partner for Docker Swarm and Kubernetes alike.</p><p>To learn more about using Traefik as an ingress proxy and load balancer for Docker Swarm environments, watch our recent webinar, “<a href="https://info.containo.us/webinar-recording-powerful-application-routing-for-docker-swarm">Application Routing for Docker Swarm</a>”.<br/></p>]]></content:encoded></item><item><title><![CDATA[Announcing Maesh 1.3]]></title><description><![CDATA[Maesh 1.3, the latest version of the simpler service mesh, is now even more reliable, flexible, and widely available. ]]></description><link>https://traefik.io/blog/announcing-maesh-1-3/</link><guid isPermaLink="false">Ghost__Post__5efbfbdc1555240039b0bf80</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Thu, 09 Jul 2020 05:45:40 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/07/Announcing-Maesh-1.3-1.jpg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2020/07/Announcing-Maesh-1.3-1.jpg" alt="Announcing Maesh 1.3"/><p class="post-sub-title">The simpler service mesh, now even more reliable, flexible, and widely available.</p><!--kg-card-end: html--><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/07/Announcing-Maesh-1.3.jpg" class="kg-image" alt="Announcing Maesh 1.3"/></figure><p>Maesh 1.3, the latest version of the simpler service mesh, is available today. This release introduces new configuration options and brings important enhancements to the project’s architecture.</p><h2 id="namespace-watchlists">Namespace watchlists</h2><p>Previously, it was possible to configure a set of namespaces to be ignored by the Maesh Controller, via the <code>ignoreNamespaces</code> option. Operators of large clusters found themselves having to define a large number of exceptions if they were only interested in a small subset of namespaces.</p><p>Maesh 1.3 introduces an option that enables operators to specify which namespaces they want to be observed by the Maesh controller called <code>watchNamespaces</code>:</p><!--kg-card-begin: markdown--><pre><code>helm install maesh maesh/maesh --set controller.watchNamespaces={first,second}
</code></pre>
<!--kg-card-end: markdown--><p>For those who rely on <code>ignoreNamespaces</code>, it will still continue to work, we aren’t planning to remove that configuration option.</p><h2 id="support-for-named-targetport-in-service-resources">Support for named TargetPort in Service resources</h2><p>A typical service definition in Kubernetes might look like this:</p><!--kg-card-begin: markdown--><pre><code>apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - port: 80
      targetPort: http
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
  labels:
    app: MyApp
spec:
  selector:
    matchLabels:
      app: MyApp
  template:
    metadata:
      labels:
        app: MyApp
    spec:
      containers:
        - name: nginx
          image: nginx:1.14.2
          ports:
            - containerPort: 80
              name: http
</code></pre>
<!--kg-card-end: markdown--><p>Kubernetes will look for the corresponding Pod matching the selector and for a port on the pod named <code>http</code>. Maesh now supports this and will do the reverse lookup of the targetPort as well, greatly enhancing flexibility.</p><h2 id="real-time-in-memory-port-mapping">Real-Time In-Memory Port Mapping</h2><p>One of the architectural components of earlier versions of Maesh is a database referred to as <code>StateTable</code>, whose job included keeping track of port allocations and holding entries for port mappings. Before Maesh 1.3, port allocations and states were managed inside of a Kubernetes resource called a ConfigMap.</p><p>Maintaining that state externally seems reasonable, but there is always a catch. What if another process or user modifies the table? What if it becomes unavailable due to misconfigured permissions, or becomes so large as to introduce performance issues within the Kubernetes database back-end?</p><!--kg-card-begin: markdown--><p>Because of this, starting in Maesh 1.3, <a href="https://kubernetes.io/docs/concepts/configuration/configmap/" target="_blank" rel="nofollow">ConfigMaps</a> that store <code>StateTable</code> objects are gone. Instead, the Maesh Controller keeps in-memory state tables generated on every initialization and kept in sync with every service update.</p>
<!--kg-card-end: markdown--><h2 id="a-more-reliable-controller-loop">A More Reliable Controller Loop</h2><p>As a consequence of removing the state tables mentioned above, the mechanism with which a controller performs updates in the clusters required a redesign. Previously, it just watched for changes and updated the configuration as they happened. With the state now being stored in memory, that behavior was no longer sufficient, colliding events may impact Maesh's proxy nodes' performance.</p><!--kg-card-begin: markdown--><p>To address that issue, Maesh 1.3 now leverages <a href="https://kubernetes.io/docs/tasks/job/fine-parallel-processing-work-queue/" target="_blank" rel="nofollow">Kubernetes Work Queues</a> to guarantee the correct processing of events that are responsible for updating the in-memory database. The queues help Maesh perform reliably in situations where it must process concurrent events.</p>
<!--kg-card-end: markdown--><h2 id="support-for-coredns-on-aks">Support for CoreDNS on AKS</h2><!--kg-card-begin: markdown--><p>As already mentioned in <a href="https://containous.ghost.io/blog/maesh-1-0-802f4be9a9a7/">a previous release</a>, Maesh relies heavily on CoreDNS for name resolution. Because of this dependency, Maesh is designed to patch CoreDNS through its initialization process. On AKS, there is a <a href="https://docs.microsoft.com/en-us/azure/aks/coredns-custom" target="_blank" rel="nofollow">specific process</a> to follow when customizing CoreDNS and we’ve updated Maesh to conform to that process. As a result of this update, Maesh is now supported on Azure Kubernetes Service.</p>
<!--kg-card-end: markdown--><h2 id="next-steps">Next Steps</h2><p>The changes introduced in this release represent the next step in evolving the Maesh project into a solution the community has been requesting. Research is underway on how Maesh can implement simple, easy to use, end-to-end encryption. Developing and shipping this capability will be the next significant milestone to hit.</p><p>Your participation with the Maesh project is invaluable, and your suggestions are responsible for the improvements and direction this project undergoes. We welcome your continued feedback, PRs, and contributions because that is what keeps Maesh going in the right direction.</p><p>Thank you!</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://containous.ghost.io/maesh/">Website</a></li><li><a href="https://docs.mae.sh/">Documentation</a></li><li><a href="https://github.com/containous/maesh">Github</a></li><li><a href="https://community.containo.us/c/maesh">Community Forum</a><br/></li></ul>]]></content:encoded></item><item><title><![CDATA[Beyond Kubernetes: Bringing Microservices Together with Service Mesh]]></title><description><![CDATA[When adopting microservices, Kubernetes alone may not be enough to handle more complex networking challenges that arise. This is the job of a service mesh.]]></description><link>https://traefik.io/blog/beyond-kubernetes-bringing-microservices-together-with-service-mesh/</link><guid isPermaLink="false">Ghost__Post__5ef263fe60f25700399d089d</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Wed, 24 Jun 2020 06:43:11 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/06/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/06/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh-1.jpg" class="kg-image" alt="Beyond Kubernetes: Bringing Microservices Together with Service Mesh"/></figure><img src="https://containous.ghost.io/content/images/2020/06/Beyond-Kubernetes-Bringing-Microservices-Together-with-Service-Mesh.jpg" alt="Beyond Kubernetes: Bringing Microservices Together with Service Mesh"/><p>When adopting the microservices application model, Kubernetes is a natural starting point. Extensible, open source, and with a thriving ecosystem, Kubernetes has emerged as the go-to orchestrator for containerized infrastructure. When used as the foundation for microservices, however, you may find that Kubernetes alone isn’t enough to handle the more complex networking challenges that arise. This is the job of a <strong>service mesh</strong>.</p><p>One of the most important aspects to consider about the microservices model is its heavy dependence on networking. Unfortunately, a network is seldom as reliable or resilient as its hypothetical diagram suggests. Services fail, network routes change or disappear, and unexpected traffic can disrupt normal usage patterns. This is even more true for containerized microservices, which by their nature tend to be stateless, ephemeral, and disposable. Maintaining the performance and stability of such an environment is anything but simple. Kubernetes addresses the first part of this challenge by automating the lifecycles of containers and their associated applications. When coupled with an <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">Ingress controller</a>, such as Contour or <a href="https://containous.ghost.io/traefik/">Traefik</a>, Kubernetes also manages communications from the external network to workloads running in the cluster and vice versa (sometimes called <em>north-south</em> traffic).</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/06/Service-Mesh-Diagram@2x.jpg" class="kg-image" alt="Beyond Kubernetes: Bringing Microservices Together with Service Mesh"><figcaption>Service Mesh Basics</figcaption></img></figure><p>Of equal importance in a microservices environment, however, are communications between services within the cluster (known as <em>east-west</em> traffic). While basic networking within the cluster is handled by Kubernetes itself, a service mesh is a dedicated infrastructure layer that handles many of the routine networking tasks that are necessary for a loose collection of containerized services to work together as a cohesive application.</p><h2 id="the-role-of-service-mesh">The Role of Service Mesh</h2><p>An important property of a service mesh is that it decouples east-west networking functions from application logic. As the environment scales and new services are added to the mix, they should be able to expect the same level of management as their peers, without code changes or refactoring. Examples of functions of a service mesh include:</p><!--kg-card-begin: markdown--><p><strong>Traffic control.</strong> Communications between the cluster and the external network require routing and management, and so do communications between services on the cluster. Tasks such as advanced <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank" rel="nofollow">load balancing</a> and <a href="https://cloud.google.com/solutions/rate-limiting-strategies-techniques" target="_blank" rel="nofollow">rate limiting</a> of service-to-service traffic are primary functions of the service mesh, which helps to prevent and contain disruptions and performance degradations that misconfigured or misbehaving services can cause.</p>
<!--kg-card-end: markdown--><p><strong>Security. </strong>Even when ingress controls are in place to protect the cluster from external networking threats, attackers may still attempt to exploit trusted relationships between services on the cluster. A service mesh can help here by providing seamless authentication, access control, and management of encrypted links between services, among other security features.</p><p><strong>Observability. </strong>Another important factor is the ability of a service mesh to provide consistent logging, metrics, and visibility into the inner workings of a cluster. The insights gained from these functions are invaluable for maintaining the health and proper operation of microservices-based applications.</p><h2 id="options-and-standards">Options and Standards</h2><p>Over the years, various forms of application middleware have implemented east-west networking functions in various ways. It is only since the rise of containerized infrastructure, and Kubernetes in particular, that the concept of a service mesh as a dedicated layer has truly crystallized. Even so, opinions on how a mesh should be implemented still differ.</p><p>Standardization offers some hope for clarity. Recently, a consortium of cloud-native software vendors has begun collaborating on the<a href="https://smi-spec.io/"> Service Mesh Interface (SMI)</a>, an evolving effort that is shepherded by the Cloud Native<a href="https://cncf.io/"> Computing Foundation (CNCF)</a>. The SMI specification defines APIs for many of the networking functions described earlier. Still, these APIs can be implemented in multiple ways.</p><!--kg-card-begin: markdown--><p>The <a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/#example-1-sidecar-containers" target="_blank" rel="nofollow">sidecar pattern</a> is one way to design a service mesh for Kubernetes. In this model, a so-called sidecar container is deployed alongside each instance of a service within a pod to handle east-west traffic for that instance. This is a popular pattern for implementing a service mesh, and is the method adopted by the likes of Istio and Linkerd (the latter a CNCF incubating project).</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>An alternative method is to deploy a service mesh proxy endpoint that runs as its own pod on each node of a cluster, using the Kubernetes concept of a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="nofollow">DaemonSet</a>. This method has the advantage of being less invasive, in that the mesh proxy does not need to modify any Kubernetes objects and no network traffic is modified without a service owner’s consent. This is the model adopted by <a href="https://containous.ghost.io/maesh/">Maesh</a>.</p>
<!--kg-card-end: markdown--><h2 id="how-to-move-forward">How to Move Forward</h2><p>So, while standardization helps make it easier to know what to expect from a service mesh, important decisions remain before adopting a specific solution. Even choosing how to begin deploying a mesh can be challenging, owing to the potential for disruption of existing communication patterns within a cluster.</p><p>These decisions are made significantly easier when dealing with so-called greenfield projects, where the clustered, microservices-based application is built from the ground up, without dependencies on legacy infrastructure. This is a happy situation to have, but it’s not always realistic, especially in environments where adoption of containerization is already mature.</p><p>If it will be necessary to run some services on a service mesh alongside other services for which it is preferable to have them manage their own east-west traffic, it may be worth looking for a loosely coupled solution, such as Maesh. This has the advantage of allowing the teams that own individual services to opt into the mesh when they are ready, rather than forcing a mass migration with interdependencies that may be difficult to test.</p><p>However you choose to proceed, the key takeaway should be that service mesh for Kubernetes, while still an emerging technology, can often provide the “missing piece” that Kubernetes alone does not. By abstracting key east-west networking features away from application logic, mesh solutions enable distributed, microservices-based applications to operate in a way that is managed, observable, and secure, both when communicating with the outside world and within the cluster itself.</p><p>To learn more, <a href="https://info.containo.us/video-understanding-service-mesh">check out this video</a> about the advantages and disadvantages of a <strong>service mesh</strong>, and the appropriate situations for using one.</p>]]></content:encoded></item><item><title><![CDATA[Securing your Kubernetes environment against external traffic threats]]></title><description><![CDATA[Kubernetes is often used to manage external-facing applications, so the need for protecting applications from harmful external traffic is nearly universal.]]></description><link>https://traefik.io/blog/securing-your-kubernetes-environment-against-external-traffic-threats/</link><guid isPermaLink="false">Ghost__Post__5ee81ca7292c470045af26fe</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Neil McAllister]]></dc:creator><pubDate>Tue, 16 Jun 2020 14:27:27 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/06/Securing-your-Kubernetes-environment-against-external-traffic-threats-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/06/Securing-your-Kubernetes-environment-against-external-traffic-threats.jpg" class="kg-image" alt="Securing your Kubernetes environment against external traffic threats"/></figure><img src="https://containous.ghost.io/content/images/2020/06/Securing-your-Kubernetes-environment-against-external-traffic-threats-1.jpg" alt="Securing your Kubernetes environment against external traffic threats"/><p>Kubernetes delivers many quality-of-life improvements for software engineering teams out of the box by automating the deployment and lifecycle management of containerized applications. However, security is one area where developers must still be proactive, by identifying threat models and applying appropriate Kubernetes security best practices to address them. </p><p>Given that Kubernetes is often used to manage external-facing applications, the need for protecting applications from harmful external traffic is nearly universal. In this article we’ll review some of the general concerns that developers should keep in mind in this context, and then discuss relevant Kubernetes security approaches.</p><h2 id="top-external-traffic-concerns">Top external traffic concerns</h2><p>When it comes to security issues from external traffic, there are myriad concerns that range from unintentional but detrimental behavior to organized, malevolent attacks.</p><h3 id="unfair-usage">Unfair usage</h3><p>Any application of even moderate complexity will exhibit significant variance in resource usage and execution time of requests. For example, certain operations might trigger backend batch jobs or invoke complicated queries to datastores. Accordingly, the overall load imposed by a specific external client will be a function of the request types it sends and their distribution over time (for example, bursty versus parallel requests). Because of this, it’s possible for a client to unintentionally use an unfair portion of provisioned resources and negatively impact other users.</p><h3 id="misconfigured-clients">Misconfigured clients</h3><p>Particularly for API services, it’s common for incoming external traffic to have been generated by automated systems or client software whose behavior is driven by user-specific configuration settings. Settings that are misconfigured – whether maliciously or unintentionally – can lead to anomalous behavior, which can easily lead to undesirable load on the Kubernetes-managed application.</p><h3 id="malicious-clients">Malicious clients</h3><p>An unfortunate reality for any internet-facing application is that it will inevitably face nefarious attempts to identify and/or exploit potential security vulnerabilities in the software and gain some form of unauthorized access. Such attacks include zero-day exploits and brute-force attempts to penetrate the system, among others. If successful, these attacks can have significant negative consequences beyond application downtime, including data breaches.</p><h3 id="denial-of-service-ddos-and-distributed-denial-of-service-ddos-">Denial-of-service (DDoS) and distributed denial-of-service (DDoS)</h3><p>A malicious attacker may also intentionally try to limit or disrupt the resource availability for legitimate traffic, in what is known as a denial-of-service (DoS) attack. Such attacks often combine several of the previously mentioned elements. In their more sophisticated form, known as distributed denial-of-service (DDoS), they can also be orchestrated such that a distributed and possible dynamic set of clients works together to send malformed or excessive traffic simultaneously.</p><h2 id="mitigation-strategies">Mitigation strategies</h2><p>Having reviewed the top concerns that harmful external traffic creates for applications, let’s look at some approaches to mitigating them. Specifically, by employing an <a href="https://containo.us/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/">Ingress controller for Kubernetes</a>, multiple options become available to consider as part of a comprehensive security strategy.</p><h3 id="ip-allow-deny-lists">IP allow/deny lists</h3><p>One approach to integrating security best practices is to employ network-level mechanisms. Specifically, the IP addresses of external traffic can be used to make binary decisions on whether the traffic should be allowed at all. If applications have a stable set of known clients, a proactive allow list approach in which unknown IP addresses are ignored may be applicable. On the other hand, if valid traffic could come from anywhere, a reactive deny list can be maintained based upon the identification of malicious traffic sources.</p><h3 id="connection-limits">Connection limits</h3><p>Another network-level option is to limit the number of connections that an external client can create, which can help limit the impact of misconfigured clients as well as malicious users. One potential challenge, however, lies in determining an appropriate value to set for the connection limit. Many implementations require a global setting that impacts all sources of traffic. Particularly when imposing connection limits by source IP address, scenarios in which multiple clients may share an IP address – such as NAT, for example – should be considered.</p><h3 id="rate-limiting">Rate limiting</h3><p>Moving up the networking stack, an Ingress controller can be used to enable rate limiting at the request level. These limits gate the number of requests in a given time window (for example, requests per second) and can be enforced in a variety of ways. Common options include setting rate limits based upon client IP address or a value in the HTTP header. Rate limits can also be configured so a maximum request rate is enforced at service hosts.</p><h3 id="limiting-simultaneous-requests">Limiting simultaneous requests</h3><p>As mentioned earlier, request-processing times may vary based on a variety of factors. While rate limits can enforce the number of external requests submitted by a client in a given time frame, the number of concurrent requests being processed may vary significantly depending upon the relative processing time of each type of request. To address this dimension, external traffic can be managed by setting limits so that services don’t become overwhelmed by a large number of simultaneous, resource-intensive requests.</p><h3 id="audit-logging">Audit logging</h3><p>A question that often arises is how operations engineers can determine when the aforementioned mitigation mechanisms should be invoked, as well as their overall effectiveness. For example, it’s preferable to detect DDoS attacks in their earliest stages to minimize disruption to end users. How to spot them when they start? Access logs can be invaluable for this purpose. They are commonly incorporated as part of a broader security information and event management (SIEM) system. When employed with Kubernetes Ingress controllers like Traefik, these logs also make it possible to automate remediation strategies based upon detected external traffic patterns.</p><h2 id="stay-vigilant">Stay vigilant</h2><p>When considering how best to protect workloads from harmful external traffic, the most effective approach will likely require a combination of several of the mechanisms we’ve discussed. But which ones? The need for any one measure may not be immediately apparent, so its utility should be continuously reviewed with the help of data from audit logs. It’s important that applications teams consider the ability of their Kubernetes platform to provide a broad set of mechanisms that can be called upon as security requirements change and evolve. </p><!--kg-card-begin: markdown--><p>Solutions like <a href="https://containo.us/traefikee/">TraefikEE</a> align well with this mindset by providing a rich and robust set of security features for managing external traffic embedded in the <a href="https://containo.us/solutions/kubernetes-ingress/">Kubernetes Ingress controller</a>. Learn more about TraefikEE in <a href="https://info.containo.us/request-demo-traefikee" target="_blank" rel="nofollow">this 5-minute video</a>.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Gradual Migration from Traefik 1.x to 2.x]]></title><description><![CDATA[In this post, I will share a migration strategy that helped me move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback.]]></description><link>https://traefik.io/blog/gradual-migration-from-traefik-1-to-2/</link><guid isPermaLink="false">Ghost__Post__5ec806bb4e2e9a0045ce791f</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Juan Carlos Mejías Rodríguez]]></dc:creator><pubDate>Tue, 09 Jun 2020 05:33:17 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x-1.jpg" alt="Gradual Migration from Traefik 1.x to 2.x"/><p><strong>Guest post by Juan Carlos Mejías, Traefik Ambassador</strong></p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg" class="kg-image" alt="Gradual Migration from Traefik 1.x to 2.x" srcset="https://containous.ghost.io/content/images/size/w600/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 1600w, https://containous.ghost.io/content/images/2020/08/Gradual-Migration-from-Traefik-1.x-to-2.x.jpg 2400w" sizes="(min-width: 1200px) 1200px"/></figure><!--kg-card-begin: markdown--><p>Are you a happy Traefik user? Join the club! I use Traefik as a reverse proxy to manage the ingress of several dozen services in a Docker Swarm cluster, and couldn't be happier with it. Since its introduction in early 2015, Traefik has grown in maturity and popularity (don't take my word, look at <a href="https://star-history.t9t.io/#containous/traefik" target="_blank" rel="nofollow">the project's stargazers over time</a>. When Traefik v2 was released  I couldn't help but think about migrating, but I had one major concern: downtime.</p>
<p>Traefik's documentation explains how to migrate configurations from 1.x format to 2.x format however, as in any system with some degree of complexity, migrating is not just about changing configurations but managing them. You have to make sure everything keeps running smoothly and be prepared to rollback in case something goes wrong -have you heard of Murphy's Law? Also, you probably don't want to migrate the whole system at a time, or you could quickly find yourself trying to put out more fires than you can handle.</p>
<p>In this post, I will share a migration strategy that helped me move to Traefik 2 with very little downtime, one service at a time, with an easy way to rollback. For the sake of clarity and brevity, I will start from a single Traefik instance with two backend services and will keep everything in a single Docker Swarm stack. The same strategy could be used in a clustered Traefik deployment with many more backend services as well. In fact, this scenario is where Traefik shines the brightest.</p>
<h2 id="initialsetup">Initial setup</h2>
<p>Let's start from the following setup, with a Traefik 1 instance as a reverse proxy and two Nginx services, all running on Docker Swarm:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/06/1-diagram1-traefik1-handling-all-routing.png" class="kg-image" alt="Gradual Migration from Traefik 1.x to 2.x"><figcaption>Initial setup. Traefik 1 handling all routing</figcaption></img></figure><!--kg-card-begin: markdown--><p>This configuration can be deployed to the swarm with the following stack definition:</p>
<pre><code class="language-yaml"># docker-compose.yaml

# Version &gt;= 3.3 so configs are available
version: &quot;3.4&quot;

networks:
  traefik-public:
    external: true

configs:
  index1:
    # Contains string &quot;1&quot;
    file: ./index1.html
  index2:
    # Contains string &quot;2&quot;
    file: ./index2.html

services:
  traefik1:
    image: traefik:v1.7
    ports:
      - &quot;80:80&quot;
    volumes:
      # So that Traefik can listen to the Docker events
      - /var/run/docker.sock:/var/run/docker.sock
    command: &gt;
      --docker
      --docker.swarmmode
      --entrypoints='Name:http Address::80'
    networks:
      - traefik-public

  web1:
    image: nginx:1-alpine
    deploy:
      labels:
        - traefik.enable=true
        - traefik.frontend.rule=Host:web1.docker.local
        - traefik.port=80
        - traefik.webservice.frontend.entryPoints=http
    configs:
      - source: index1
        target: /usr/share/nginx/html/index.html
    networks:
      - traefik-public

  web2:
    image: nginx:1-alpine
    deploy:
      labels:
        - traefik.enable=true
        - traefik.frontend.rule=Host:web2.docker.local
        - traefik.port=80
        - traefik.webservice.frontend.entryPoints=http
    configs:
      - source: index2
        target: /usr/share/nginx/html/index.html
    networks:
      - traefik-public
</code></pre>
<p>Files <code>index1.html</code> and <code>index1.html</code> contain strings <code>1</code> and <code>2</code> respectively:</p>
<pre><code class="language-bash">echo 1 &gt; index1.html
echo 2 &gt; index2.html
</code></pre>
<p>With the above configuration, you can now create a Docker Swarm (if you don't already have one), an overlay network for Traefik and deploy the stack:</p>
<pre><code class="language-bash">docker swarm init
docker network create --driver=overlay traefik-public
docker stack deploy -c docker-compose.yaml traefik
</code></pre>
<p>When the stack deployment finishes you will be able to query the defined Nginx services as <code>web1.docker.local</code> and <code>web2.docker.local</code>. In the example below I’m using curl:</p>
<pre><code class="language-bash">curl -H Host:web1.docker.local http://127.0.0.1
# 1
curl -H Host:web1.docker.local http://127.0.0.1
# 2
</code></pre>
<p>It may take a few seconds to start the containers so if you get a <code>404 page not found</code> response just wait and try again.</p>
<h2 id="traefik2withfallbacktotraefik1">Traefik 2 with fallback to Traefik 1</h2>
<p>You now  have a working Traefik 1.x reverse proxy and two backend services. Let's migrate it to 2.x! Next you are going to add a Traefik 2 service which will run alongside and proxy requests to the existing one. Incoming requests will be routed to the Traefik 2 service and if no routes are matched they will then be routed to the  Traefik 1 service.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/06/2-diagram2-traefik2-routing-requests-to-traefik1.png" class="kg-image" alt="Gradual Migration from Traefik 1.x to 2.x"><figcaption>Traefik 2 routing all requests to Traefik 1</figcaption></img></figure><!--kg-card-begin: markdown--><p>Deploy these changes to the stack definition file:</p>
<pre><code class="language-diff"> # docker-compose.yaml

 ...
 configs:
   ...
+  # Dynamic configuration for Traefik 2 (see below)
+  traefik2-providers:
+    file: ./traefik2-providers.yaml

 services:
   traefik1:
     image: traefik:v1.7
-    ports:
-      - &quot;80:80&quot;
   ...
+  traefik2:
+    image: traefik:v2.1
+    ports:
+      # The HTTP port
+      - &quot;80:80&quot;
+    volumes:
+      # So that Traefik can listen to the Docker events
+      - /var/run/docker.sock:/var/run/docker.sock
+    command: &gt;
+      --providers.docker
+      --providers.docker.swarmMode
+      --providers.file.directory=/etc/traefik
+      --providers.file.filename=providers.yaml
+      --entryPoints.http.address=:80
+      --api.insecure
+    configs:
+      - source: traefik2-providers
+        target: /etc/traefik/providers.yaml
+    networks:
+      - traefik-public
</code></pre>
<p>The <code>traefik2-providers.yaml</code> file used in the <code>traefik2-providers</code> config directive for the <code>traefik2</code> service defines a catch-all route that forwards unmatched requests to the <code>traefik1</code> service:</p>
<pre><code class="language-yaml"># traefik2-providers.yaml

http:
  routers:
    # Define a catch-all router that forwards requests to legacy Traefik
    to-traefik1:
      # Catch all domains (regex matches all strings)
      # See https://github.com/google/re2/wiki/Syntax
      rule: &quot;HostRegexp(`{domain:.+}`)&quot;
      # If the rule matches, forward to the traefik1 service (see below)
      service: traefik1
      # Set the lowest priority, so this route is only used as a last resort
      priority: 1

  services:
    # Define how to reach legacy Traefik
    traefik1:
      loadBalancer:
        servers:
          # Legacy Traefik is part of the same stack so,
          # hostname defaults to service name
          - url: http://traefik1
</code></pre>
<p>Redeploy the stack and check everything is still  working as expected:</p>
<pre><code class="language-bash">docker stack deploy -c docker-compose.yaml traefik
# ...
curl -H Host:web1.docker.local http://127.0.0.1
# 1
curl -H Host:web2.docker.local http://127.0.0.1
# 2
</code></pre>
<h2 id="traefik2replacingtraefik1">Traefik 2 replacing Traefik 1</h2>
<p>Next let's set up Traefik 2 to handle requests to <code>web1</code>, as in Image 3:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/06/3-diagram3-traefik2-handling-web1-routing.png" class="kg-image" alt="Gradual Migration from Traefik 1.x to 2.x"><figcaption>Traefik 2 handling web1 service's routing</figcaption></img></figure><!--kg-card-begin: markdown--><p>This setup can be achieved by updating <code>web1</code> service labels to match Traefik 2 format as follows:</p>
<pre><code class="language-yaml">...
services:
  ...
  web1:
    ...
    deploy:
      labels:
        - traefik.enable=true
        - traefik.http.routers.web1.rule=Host(`web1.docker.local`)
        - traefik.http.services.web1.loadbalancer.server.port=80
    ...
</code></pre>
<p>Redeploy the stack and again check everything is still working as expected:</p>
<pre><code class="language-bash">docker stack deploy -c docker-compose.yaml traefik
# ...
curl -H Host:web1.docker.local http://127.0.0.1
# 1
curl -H Host:web2.docker.local http://127.0.0.1
# 2
</code></pre>
<p>Now repeat the process for <code>web2</code> service. If something goes wrong, you just need to revert to a previous working configuration for the affected service, redeploy, and start over. In a real-world scenario with lots of services, migration can take place one service at a time like this, reducing downtime.<br>
When you finish migrating to Traefik 2, take down the Traefik 1 service. You will then end up with this scenario:</br></p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/06/4-diagram4-traefik2-handling-all-routing.png" class="kg-image" alt="Gradual Migration from Traefik 1.x to 2.x"><figcaption>Traefik 2 handling all routing</figcaption></img></figure><!--kg-card-begin: markdown--><h2 id="wrappingup">Wrapping Up</h2>
<p>And that's it! You’ve successfully migrated from <a href="https://containous.ghost.io/traefik/">Traefik</a> 1.x to 2.x one service at a time. This step by step migration strategy comes from the StranglerFigApplication pattern, as <a href="https://martinfowler.com/bliki/StranglerFigApplication.html" target="_blank" rel="nofollow">described by Martin Fowler</a>. As a final note, I would highly recommend putting your configurations under version control as that would make it very easy to roll back changes when needed.</p>
<h3 id="authorsbio">Author's Bio</h3>
<p>Juan Carlos is a lecturer at the <a href="https://www.reduc.edu.cu/">Informatics and Exact Sciences Faculty of the University of Camagüey, Cuba,</a> and also DevOps engineer at the same institution. He has specialized on version control, continuous integration and deployment, Linux, and Docker containers. Since 2015 he has developed, deployed and monitored web applications for the University's IT infrastructure.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Kubernetes Ingress & Service API Demystified]]></title><description><![CDATA[The Ingress Object itself already has a long history with K8s. It is still considered beta, which is kinda surprising for something that has been so long present in K8s. But why is that? And when will that change?]]></description><link>https://traefik.io/blog/kubernetes-ingress-service-api-demystified/</link><guid isPermaLink="false">Ghost__Post__5ec2a072c49e39004576b7ad</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Tue, 02 Jun 2020 14:24:25 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg" class="kg-image" alt="Kubernetes Ingress & Service API Demystified" srcset="https://containous.ghost.io/content/images/size/w600/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 1000w, https://containous.ghost.io/content/images/size/w1600/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 1600w, https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified.jpg 2400w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/10/Kubernetes-Ingress---Service-API-Demystified-1.jpg" alt="Kubernetes Ingress & Service API Demystified"/><p>The Ingress Object itself already has a long history with K8s. It is still considered beta, which is kinda surprising for something that has been so long present in K8s. But why is that? And when will that change?</p><p>With the release of Kubernetes 1.18, some <a href="https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/">improvements</a> have been made to Ingress, which have been overdue for a long time. However, the changes introduced are minor, and some of the issues we’ll be covering in this blog post have gone untackled. In addition to covering the issues mentioned above, we’ll be exploring the new Service API aimed at solving these issues.</p><h2 id="issues">Issues</h2><p>In this blog post we’ll cover some of the long-standing issues with the current state of Ingress in Kubernetes, including these topics:</p><ul><li>Inflexible HTTP routing definitions</li><li>Schema differences across vendors</li><li>Extensibility of Ingress</li></ul><h2 id="inflexible-http-routing-definitions">Inflexible HTTP routing definitions</h2><p>A simple Ingress object example is the following:</p><!--kg-card-begin: markdown--><pre><code>---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: test-ingress
spec:
  rules:
  - http:
      paths:
      - Host: myhost.com
  path: /testpath
        pathType: Prefix
        backend:
serviceName: test
 	servicePort: 80
</code></pre>
<!--kg-card-end: markdown--><p>The above Ingress object will route HTTP requests with the URI  GET <em>http://myhost.com/testpath</em> and forward the request internally to the service called test on port 80. So far, so good.</p><p>The primary focus of an ingress resource is on solving simple HTTP routing cases, similar to the concept of Virtual Hosts with a Path Based routing extension. This leads us to the first issue: How would you configure cases like a redirect?</p><h2 id="schema-differences-across-vendors">Schema differences across vendors</h2><p>Further configuration is usually done through annotations on the Ingress resource. Annotations are like key-value pairs stored in the metadata of an object.</p><!--kg-card-begin: markdown--><pre><code>---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: test-ingress
  nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - http:
      paths:
      - Host: myhost.com
  path: /testpath
        pathType: Prefix
        backend:
serviceName: test
 	servicePort: 80
</code></pre>
<!--kg-card-end: markdown--><p>The above example shows that the Ingress Controller (nginx) would rewrite all requests to / (slash) before forwarding to the backend.</p><p>Consider that the same configuration in Traefik would look like this:</p><!--kg-card-begin: markdown--><pre><code>--- 
apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata: 
  name: rewrite-slash
spec: 
  replacePath: 
    path: /
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: whoami-ingress
  annotations:
    kubernetes.io/ingress.class: traefik              
    traefik.ingress.kubernetes.io/router.middlewares: default-rewrite-slash@kubernetescrd
spec:
  rules:
  - host: whoami.localhost
    http:
      paths:
      - path: /foobar
        backend:
          serviceName: whoami
          servicePort: web

</code></pre>
<!--kg-card-end: markdown--><p>As you can see, it’s totally different! Which brings us to another issue: extensibility. </p><h2 id="extensibility-of-ingress">Extensibility of Ingress</h2><p>Extending Ingress Objects is a requirement and the de-facto standard for that is using annotations. However, annotations often differ between the many different implementations of  Ingress Controllers and it's therefore hard to manage for an end-user.</p><p>This unmanageability also translates back to the providers who must maintain their ingress controller implementation, who are often constrained by the simplicity of the key / value pair approach.</p><h2 id="service-api-aka-ingress-v2">Service API aka Ingress V2</h2><p>Announced at Kubecon NA in 2019 by Google there has been substantial effort in  creating an “Ingress V2” which is now known as the <a href="https://github.com/kubernetes-sigs/service-apis">Service API</a>.</p><p>This specification aims to solve a few problems:</p><ul><li>Provide clean separation and role-based control</li><li>Uplevel the Ingress specification</li><li>Specify standard methods of extending the Ingress specification</li></ul><p>To do so, the specification currently consists of 4 different CRD Ressources:</p><figure class="kg-card kg-image-card"><img src="https://lh4.googleusercontent.com/bVzQquzU0GRBFEZBpOLTIniju6zwytLAlLcRP52swLC2GF4Vqw4855Uu-OQFVZdPG5bZ-C8kg9EfLb5L21JpXegV6wwkOJnXDh5EaY2do5--ouHYeDfUbARTSOdWCBhpv2jXVWUM" class="kg-image" alt="Kubernetes Ingress & Service API Demystified"/></figure><h2 id="gatewayclass">Gatewayclass</h2><p>The GatewayClass is meant to be a Cluster Scoped resource, which is meant to represent a “category” of gateways. It’s similar to the former `ingress.class` annotation or the now included IngressClass resource.</p><p>The expected use-case is to have more than one GatewayClass per Ingress Controller provider. These classes may have a variety of default settings, which are inherited by the cluster-level gateway. Also, this can be used to pass additional configuration down to that gateway. Since it is a cluster scoped resource, it's expected to be managed by the Infrastructure provider.</p><!--kg-card-begin: markdown--><pre><code>---
kind: GatewayClass
metadata:
  name: cluster-gateway
spec:
  controller: &quot;acme.io/gateway-controller&quot;
  parametersRef:
    apiVersion: core/v1
    kind: ConfigMap
    namespace: acme-system
    name: internet-gateway
</code></pre>
<!--kg-card-end: markdown--><h2 id="gateway">Gateway</h2><p>The gateway has a life-cycle which is tied with the infrastructure. For instance, one Gateway could be running an instance of Traefik or one AWS ELB. As already mentioned, it’s linked to a Gateway class for inferring configuration.</p><p>The gateway sets listener bindings (Address, Ports, TLS…) and the routes served by the gateway.</p><!--kg-card-begin: markdown--><pre><code>---
kind: Gateway
name: my-app-gw
namespace: my-app
spec:
  class: from-internet
  listeners:
  - address:
      ip: 1.2.3.4
    protocols: [&quot;http&quot;] # implies port 80.
    routes:
      ...
  - address:
      ip: 1.2.3.4
    protocols: [&quot;https&quot;] # implies port 443
    certificates:
    - name: my-secret
    - apiGroup: certmanager.k8s.io
      kind: Certificate               
      name: lets-encrypt-cert
    routes:
      - route:
        name: http-app-1
        namespace: app-1
        kind: HTTPRoute
</code></pre>
<!--kg-card-end: markdown--><p>It also has some sane default protocols like: http, https, TCP… which map to predefined ports.</p><h2 id="route">Route</h2><p>Last but not least, a route is used to describe a way to handle traffic given protocol level descriptions.</p><p>A route can be of a different ressource (HTTPRoute, TLSRoute, TCPRoute…) and can therefore have different protocol level descriptions taken into consideration for routing. Each of these Protocols have different attributes which could be used for route matching. It can also be used to delegate to other Route Resources in a multi-tenant scenario, for example, where  one team offers a global authentication service where you would want to forward from within your current scope.</p><!--kg-card-begin: markdown--><pre><code>---
kind: HTTPRoute
name: delegate-1
namespace: other-team
rules:
- match:
    http:
      host: bar.com
      path:
        prefix: /store
  action:
    backend:                           
      name: delegate-1                  
      namespace: other-team             
      kind: HTTPRoute
      apiGroup: networking.k8s.io
</code></pre>
<!--kg-card-end: markdown--><p>In the above HTTPRoute example it’s listening for traffic with a host of bar.com and looking for a Pathprefix of /store, which is close to some of the examples we’ve explored on  traditional Ingress but allows for some additional specifics.</p><h2 id="extensibility">Extensibility</h2><p>Taking what we just learned to the next level, the question that arrives now is: “How can we extend that, for example, to implement Rewrites?”</p><p>For that purpose, the specification currently offers three different levels of support:</p><ul><li>Core</li><li>Extended</li><li>Custom</li></ul><p>Core functionality is guaranteed between all solutions respecting a specific set of API’s. Extended is a standardised API, but functionality is not guaranteed between all solutions.</p><p>For special use-cases, which might be vendor specific, there’s a custom layer where the implementation can be custom built to meet specific requirements. Usually, these will end up in CRD’s or custom annotations.</p><h2 id="sumup">SumUp</h2><p>Service API is a new set of forward-looking API’s attempting to solve some issues that have become apparent over the evolving usage of Ingress. However, as it’s a bit more complex and might not solve all the simple use cases Ingress is capable of solving, it’s not meant to replace Ingress but rather provide an alternative for complex use cases.</p><p>Eventually, Traefik itself will support the new Service API spec. In the meantime, we offer support for both native Kubernetes Ingress and have extended support for Ingress through the use of CRDs. Learn more about <a href="https://containous.ghost.io/solutions/kubernetes-ingress/">how we do both and empower developers with flexible and easy to use Kubernetes Ingress</a>.<br/></p>]]></content:encoded></item><item><title><![CDATA[Five ways to control access to your applications on Kubernetes]]></title><description><![CDATA[How should developers implement access control, particularly authentication, within the context of k8s?]]></description><link>https://traefik.io/blog/five-ways-to-control-access-to-your-applications-on-kubernetes/</link><guid isPermaLink="false">Ghost__Post__5ec861094e2e9a0045ce7983</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Kevin Crawley]]></dc:creator><pubDate>Wed, 27 May 2020 05:20:11 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/05/5-ways-to-control-access-to-your-applications-on-Kubernetes-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/05/5-ways-to-control-access-to-your-applications-on-Kubernetes.jpg" class="kg-image" alt="Five ways to control access to your applications on Kubernetes"/></figure><!--kg-card-begin: markdown--><img src="https://containous.ghost.io/content/images/2020/05/5-ways-to-control-access-to-your-applications-on-Kubernetes-1.jpg" alt="Five ways to control access to your applications on Kubernetes"/><p>Development teams have grown adept at leveraging modern programming languages and cloud technologies in a bid to increase their productivity and reduce development cycle times. Given the flexibility of the cloud-native ecosystem, these advancements have also expanded the surface area of security-related issues such as access-control. While many organizations are adopting <a href="https://kubernetes.io/">Kubernetes</a> (K8s) as their platform of choice for deploying and managing containerized applications, a natural question arises: How should developers implement access control, particularly authentication, within the context of k8s? In this article, we’ll explore this question by covering the following topics:</p>
<ol>
<li>Reviewing common methods for authentication</li>
<li>Identifying how some of these methods can be readily integrated with Kubernetes</li>
</ol>
<!--kg-card-end: markdown--><h2 id="common-authentication-approaches">Common authentication approaches</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/05/Common-authentication-approaches@1x.jpg" class="kg-image" alt="Five ways to control access to your applications on Kubernetes"/></figure><!--kg-card-begin: markdown--><h3 id="ldap">LDAP</h3>
<p>Many organizations have historically adopted some form of directory service implementation such as Active Directory (AD) for storing information including user and organizational data. The majority of these systems support the open <a href="https://tools.ietf.org/html/rfc4511" target="_blank" rel="nofollow">Lightweight Directory Access Protocol (LDAP) protocol</a> standard. By integrating with LDAP applications may seamlessly authenticate users within an organization by leveraging the existing user information managed by IT. Moreover, LDAP allows applications to utilize additional information such as groups and policies to enforce access-control. Therefore, integrating with LDAP for both is a reasonable option to consider for line-of-business and internal-facing workloads.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="oauth20">OAuth 2.0</h3>
<p>In the context of third-party web applications, users often find themselves having to log in to many disparate systems where a central user identity service isn’t available. While creating unique accounts for each service is an option, this solution does not scale. The <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="nofollow">OAuth 2.0 protocol</a> is one approach that can help solve this challenge, and it is commonly used as part of authentication flow implementations such as the <a href="https://openid.net/connect/" target="_blank" rel="nofollow">OpenID Connect</a> standard. The main benefit of using OAuth 2.0 is it gives the ability for the user to approve delegated access for applications. This enables users to leverage existing identity providers (such as their Google account) to authenticate themselves, allowing control over the information being shared, with third-party applications.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="jsonwebtokenjwt">JSON Web Token (JWT)</h3>
<p><a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="nofollow">JSON web tokens</a> are an increasingly popular choice for authentication, particularly for APIs. These tokens are composed of <a href="https://base64.guru/standards/base64url" target="_blank" rel="nofollow">Base64URL</a> encoded JSON objects. Specifically, the token is constructed by concatenating a header JSON object, payload JSON object, and signature. The cryptographic signature is calculated using a shared secret or public/private key pair and can be used to authenticate the source of the object. For example, given a shared secret, a JWT signature can be computed using the HS256 (HMAC with SHA-256) algorithm as follows:</p>
<pre><code>signature = HS256(
    Base64URLEncoding(header) + '.' + Base64URLEncoding(payload),
    secret
)
</code></pre>
<p>The final JWT is derived by concatenation of the three components:</p>
<pre><code>Base64URLEncoding(header) + '.' + Base64URLEncoding(payload) + '.' + signature
</code></pre>
<p>It’s worth noting these tokens won’t provide data security as they aren’t encrypted but their straight forward approach can be used by APIs to identify callers. JWTs are a good option when integrating authentication providers with user-facing APIs and inter-service communications, and are often implemented utilizing <a href="https://oauth.net/2/jwt/" target="_blank" rel="nofollow">OAuth 2.0 flows</a>.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="hmac">HMAC</h3>
<p>The JWT example above highlights the use of the <a href="https://tools.ietf.org/html/rfc2104.html" target="_blank" rel="nofollow">HMAC with SHA-256 algorithm</a> when computing the signature of the token header and payload. The use of HMACs can be generalized in that a signature for any payload can be generated using any number of specifications. The JWT is a special case where the payload happens to be a JSON object but the same mechanism can be used with other data to achieve the objective of authenticating a signed message.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="mutualtls">Mutual TLS</h3>
<p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="nofollow">TLS authentication</a> in the context of web applications is fairly ubiquitous these days. The general idea is that certificates are used to authenticate a website (or web service) so the client can be confident that the server is who it claims to be. Mutual TLS extends this model to be bidirectional. Not only does the client authenticate the server identity, but the server confirms the identity of the client so that it may enforce access control and authorization policies. <a href="https://en.wikipedia.org/wiki/Mutual_authentication" target="_blank" rel="nofollow">Mutual TLS</a> is commonly deployed as part of inter-service and business-to-business communications where there are a limited and known set of clients that are designed to access common endpoints.</p>
<!--kg-card-end: markdown--><h2 id="integrating-application-authentication-with-kubernetes">Integrating application authentication with Kubernetes</h2><p>Given our brief review of common authentication approaches, let’s turn to the question of how they can be incorporated when applications are deployed on Kubernetes. As is often the case with K8s, there is a high degree of flexibility to implement a solution that meets the needs of individual organizations. Let’s review a couple of important patterns that can be adopted for most use cases.</p><h3 id="ingress-controllers">Ingress Controllers</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/05/Traefik-Ingress-Controller.jpg" class="kg-image" alt="Five ways to control access to your applications on Kubernetes"/></figure><!--kg-card-begin: markdown--><p>Ingress Controllers are the most common mechanism used today when <a href="https://containous.ghost.io/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/">connecting users to applications in Kubernetes</a>. There are many considerations to make when selecting a specific controller, as each is often implemented differently and based upon different underlying technology. Among the many <a href="https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/">decision criteria when comparing controllers</a>, one must consider how well candidates can support the relevant subset of authentication approaches we’ve highlighted.</p>
<p><a href="https://containous.ghost.io/traefik/">Traefik</a> comes with a built-in <a href="https://docs.traefik.io/middlewares/forwardauth/">ForwardAuth middleware</a> feature that can be used to delegate authentication to an external service. By integrating this capability as part of your K8s Ingress strategy, all services exposed in the traffic flow obtain the benefits of authentication management without incurring the complexity at the individual service layer. <a href="https://containous.ghost.io/traefikee/">TraefikEE</a> simplifies the management of auth providers even further by integrating support for LDAP, OAuth 2.0, JWT, and HMAC all within a unified solution.</p>
<h3 id="authenticationservers">Authentication servers</h3>
<p>The pattern of integrating authentication capabilities through an Ingress Controller can be extended even further by employing dedicated authentication servers into the architecture. <a href="https://github.com/authelia/authelia" target="_blank" rel="nofollow">Authelia</a> is an example of an open-source authentication and authorization server which works with K8s and has been successfully integrated with Ingress technologies such as Traefik. In addition to the mechanisms covered earlier, these function-specific services can provide advanced authentication capabilities such as <a href="https://en.wikipedia.org/wiki/Multi-factor_authentication" target="_blank" rel="nofollow">2FA</a> and <a href="https://en.wikipedia.org/wiki/Single_sign-on" target="_blank" rel="nofollow">SSO</a>.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Controlling application access through authentication is an important consideration in any enterprise scenario, and its importance is only amplified when adopting Kubernetes. By thoughtfully selecting architectural patterns and technologies, users can easily integrate their choice of best-practice authentication approaches with minimal additional effort.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/05/TraefikEE-Ingress-Controller.jpg" class="kg-image" alt="Five ways to control access to your applications on Kubernetes"/></figure><!--kg-card-begin: markdown--><p>There has never been a better time than now to get started with Traefik in Kubernetes. Our <a href="https://github.com/containous/traefik">open-source Traefik edition</a> with the support of a large and active community is available for free and includes support for the most recent advancements in Kubernetes Ingress technology. If you’re an enterprise looking to implement the most popular cloud-native load balancer with commercial support, high-availability, and authentication modules already built-in you should <a href="https://info.containo.us/request-demo-traefikee" target="_blank" rel="nofollow">schedule a demo</a> with our sales team and learn more about how we make networking boring.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Combining Ingress Controllers and External Load Balancers with Kubernetes]]></title><description><![CDATA[The great promise of Kubernetes is the ability to easily deploy and scale containerized applications. How Load Balancers work together with the Ingress Controllers in a Kubernetes architecture?]]></description><link>https://traefik.io/blog/combining-ingress-controllers-and-external-load-balancers-with-kubernetes/</link><guid isPermaLink="false">Ghost__Post__5eb58b45c49e39004576b610</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Kevin Crawley]]></dc:creator><pubDate>Thu, 14 May 2020 05:05:21 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/05/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes-containous-2.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/05/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes.jpg" class="kg-image" alt="Combining Ingress Controllers and External Load Balancers with Kubernetes"/></figure><img src="https://containous.ghost.io/content/images/2020/05/Combining-Ingress-Controllers-and-External-Load-Balancers-with-Kubernetes-containous-2.jpg" alt="Combining Ingress Controllers and External Load Balancers with Kubernetes"/><p>The great promise of <a href="https://kubernetes.io/">Kubernetes</a> (k8s) is the ability to easily deploy and scale containerized applications. By automating the process of allocating and provisioning compute and storage resources for Pods across nodes, k8s reduces the operational complexity of day-to-day operations. However, orchestrating containers alone doesn’t necessarily help engineers meet the connectivity requirements for users. Specifically, a Kubernetes Deployment configures Pods with private IP addresses and precludes incoming traffic over the network. Outside of Kubernetes, operators are typically familiar with deploying external load balancers, either in cloud or physical data center environments, to route traffic to application instances. However, effectively mapping these operational patterns to k8s requires understanding how <a href="https://kubernetes.io/docs/concepts/services-networking/">Load Balancers</a> work together with the <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">Ingress Controllers</a> in a Kubernetes architecture.</p><h2 id="external-load-balancers-and-kubernetes">External load balancers and Kubernetes</h2><h3 id="overview-of-external-lbs-and-k8s">Overview of external LBs and K8s</h3><p>In order to expose application endpoints, Kubernetes networking allows users to explicitly define <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Services</a>. K8s then automates provisioning appropriate networking resources based upon the service type specified. The NodePort service type exposes an allocated port that can be accessed over the network on each node in the k8s cluster. The LoadBalancer service type uses this same mechanism to deploy and configure an external load balancer (often through a cloud-managed API) which forwards traffic to an application using the NodePort. When a request is routed to the configured port on a node, it forwards packets as needed to direct traffic to the destination Pods using kube-proxy.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/05/services_loadbalancer.png" class="kg-image" alt="Combining Ingress Controllers and External Load Balancers with Kubernetes"><figcaption><strong>Fig. a</strong>: External load balancer defined for each application</figcaption></img></figure><p>Given the ability to easily define LoadBalancer services to route incoming traffic from external clients, the story may seemingly sound complete. However, in any real-life scenario, directly using external load balancers for every application <em>(fig. a)</em> that needs external access has significant drawbacks including:</p><ul><li><strong>Cost overheads</strong>: External load balancers, whether cloud-managed or instantiated through physical network appliances on-premises, can be expensive. For k8s clusters with many applications, these costs will quickly add up.</li><li><strong>Operational complexity</strong>: Load balancers require various resources (IP addresses, DNS, certificates, etc.) that can be painful to manage, particularly in highly dynamic environments where there may be transient endpoints for staging and development deployments.</li><li><strong>Monitoring and logging</strong>: Given the importance of external load balancers in the traffic flow, being able to effectively centralize monitoring and logging data is critical. However, this may become challenging in practice when there are multiple load balancers involved.</li></ul><h2 id="the-perfect-marriage-load-balancers-and-ingress-controllers">The perfect marriage: Load balancers and Ingress Controllers</h2><p>It’s clear that external load balancers alone aren’t a practical solution for providing the networking capabilities necessary for a k8s environment. Luckily, the Kubernetes architecture allows users to combine load balancers with an Ingress Controller. The core concepts are as follows: instead of provisioning an external load balancer for every application service that needs external connectivity, users deploy and configure a single load balancer that targets an Ingress Controller. The Ingress Controller serves as a single entrypoint and can then route traffic to multiple applications in the cluster. Key elements of this approach include:</p><ul><li><strong>Ingress Controllers are k8s applications:</strong> While they may seem somewhat magical, it’s useful to keep in mind that Ingress Controllers are nothing more than standard Kubernetes applications instantiated via Pods.</li><li><strong>Ingress Controllers are exposed as a service:</strong> The k8s application that constitutes an Ingress Controller is exposed through a LoadBalancer service type thereby mapping it to an external load balancer.</li><li><strong>Ingress Controllers route to underlying applications using ClusterIPs</strong>: As an intermediary between the external load balancer and applications, the Ingress Controller uses ClusterIP service types to route and balance traffic across application instances based upon operator-provided configurations.</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2020/05/ingress_have_services_too.png" class="kg-image" alt="Combining Ingress Controllers and External Load Balancers with Kubernetes"><figcaption><strong>Fig. b</strong>: Dynamic load balancing through ingress</figcaption></img></figure><p>Injecting the Ingress Controller in the traffic path allows users to gain the benefits of external load balancer capabilities while avoiding the pitfalls of relying upon them exclusively <em>(fig. b)</em>. Indeed, the Kubernetes architecture allows operators to integrate multiple Ingress Controllers, thereby providing a high degree of flexibility to meet specific requirements. This can be a bit overwhelming for those new to Kubernetes networking, so let’s review a few example deployment patterns.</p><h2 id="example-deployment-patterns">Example deployment patterns</h2><h3 id="load-balancer-with-nodeports-and-traffic-forwarding">Load balancer with NodePorts and traffic forwarding</h3><p>As mentioned earlier, a LoadBalancer service type results in an external load balancer that uses NodePorts to reach backend services. Since every node exposes the target port, the load balancer can spread traffic across all of them. However, the underlying Pods may only be running on a subset of the k8s nodes creating the potential need for traffic forwarding. As part of forwarding traffic, the kube-proxy performs source network address translation (SNAT). While this obfuscates the source IP address of requestors, the use of HTTP headers such as X-Forwarded-For (and its standardized variant Forwarded) can be utilized where business requirements require it (e.g. for compliance purposes).</p><h3 id="load-balancer-with-nodeports-and-no-snat">Load balancer with NodePorts and no SNAT</h3><p>To avoid SNAT in the traffic flow, we can modify the previous deployment pattern to force the external load balancer to only target nodes that reflect Pods running the Ingress Controller deployment. Specifically, the externalTrafficPolicy on the LoadBalancer service for the Ingress Controller can be set to Local instead of the default Cluster value. Some potential drawbacks of this pattern, however, include:</p><ul><li><strong>Reduced load-spreading:</strong> Since all traffic is funneled to a subset of nodes, there may be traffic imbalances</li><li><strong>Use of health checks:</strong> The external load balancer uses a health check to determine which nodes to target, and these can result in transient errors (e.g. due to rolling deployments, health check timeouts, etc.)</li></ul><h3 id="multiple-external-lbs-and-ingress-controllers-craft-a-solution-that-meets-your-needs">Multiple external LBs and Ingress Controllers: Craft a solution that meets your needs</h3><p>As a final deployment pattern, we can create advanced configurations consisting of multiple external load balancers each of which map to a different Ingress Controller. Users can select a technology-specific Ingress Controller based upon desired feature capabilities (e.g. NGINX or Traefik), and configure Ingress resources for underlying applications accordingly. <a href="https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/">Examples of potential criteria</a> that may be relevant when comparing candidate controllers include:</p><ul><li><strong>Protocol support</strong>: If your needs extend beyond just HTTP(S) and may require routing TCP/UDP or gRPC, it’s important to recognize that not all controller implementations support the full array of protocols</li><li><strong>Zero-downtime configuration updates</strong>: Not all controllers support configuration updates without incurring downtime</li><li><strong>High availability (HA)</strong>: If you want to avoid your ingress controller becoming a potential single point of failure (SPOF) for external traffic, you should identify controllers that support HA configurations</li><li><strong>Enterprise support</strong>: While many open source controller options are available, not all provide enterprise support options that teams can rely on when needed </li></ul><p>The aspects of previous deployment patterns such as configuring externalTrafficPolicy to allow for load spreading or avoiding SNAT can be incorporated, with each Ingress Controller potentially configured differently. The ability to easily piece together external load balancers and Ingress Controllers in a manner that meets the unique business needs of an organization exemplifies the benefits that the flexibility of k8s networking can provide.</p><p>To learn more, <strong><a href="https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes">check out this video</a></strong> we recorded recently that further explains <strong><a href="https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes">Kubernetes Ingress and the different patterns for external load balancers in k8s</a></strong>.<br/></p>]]></content:encoded></item><item><title><![CDATA[Announcing Maesh 1.2]]></title><description><![CDATA[Maesh 1.2 brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.]]></description><link>https://traefik.io/blog/announcing-maesh-1-2/</link><guid isPermaLink="false">Ghost__Post__5eba1e92c49e39004576b665</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Tue, 12 May 2020 18:51:37 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/05/Announcing-Maesh-1-2-1.jpg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2020/05/Announcing-Maesh-1-2-1.jpg" alt="Announcing Maesh 1.2"/><p class="post-sub-title">Now with support for UDP, reworked ACL, and a more efficient installation!</p><!--kg-card-end: html--><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/05/Announcing-Maesh-1-2.jpg" class="kg-image" alt="Announcing Maesh 1.2"/></figure><p>In early March, we proudly announced the general availability of <a href="https://containous.ghost.io/blog/traefik-maesh-1-1/">Maesh 1.1</a>. Now, less than 3 months later we’re proud to introduce Maesh 1.2, the latest release of our simpler service mesh. This release brings new additions such as UDP support and enhancing our internal architecture to provide more flexibility and performance in large deployments.</p><h2 id="udp-support">UDP Support</h2><p>As you probably know, <a href="https://containous.ghost.io/blog/maesh-1-0-802f4be9a9a7/">Maesh</a> is built on top of <a href="https://containous.ghost.io/traefik/">Traefik</a>, our popular Cloud Native Edge Router. Traefik introduced UDP support with the <a href="https://containous.ghost.io/blog/traefik-2-2-ingress/">release of version 2.2</a> in early March, and  as a result, Maesh is now able to handle <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP connections</a> as well.</p><p>The only thing you need to do is modify your "maesh.containo.us/traffic-type" annotation and set it to <strong>udp</strong>.</p><!--kg-card-begin: markdown--><pre><code>---
apiVersion: v1
kind: Service
metadata: 
  annotations: 
    maesh.containo.us/traffic-type: udp
  labels: 
    app: my-udp-service
  name: udp-service
  namespace: test
spec: 
  ports: 
    - port: 8080
      protocol: UDP
  selector: 
    app: my-udp-service
</code></pre>
<!--kg-card-end: markdown--><p>That’s it! Maesh will now proxy the UDP protocol to that service.</p><h2 id="pull-over-push-configuration">Pull over Push Configuration</h2><p>As a result of the architectural change mentioned above, we were able to improve the way our proxy nodes ingest configuration.</p><p>Prior to this release, the Maesh Controller pushed the current dynamic configuration to the proxy nodes. Of course, this solution was not optimal as it eventually resulted in longer deployment times and became a bottleneck in large clusters.</p><p>We’ve changed the configuration to a pull based system, so instead of waiting for a push, the custom nodes will pull the configuration from the controller.This change improves both performance along with stability, and makes the deployment of configuration not only more efficient but much easier.</p><h2 id="acl-as-a-feature">ACL as a feature</h2><p>Maesh was designed from the ground up to be <a href="https://smi-spec.io/">SMI</a> compliant. Therefore, we initially had a CLI flag to configure Maesh called <strong>--smi</strong>. This would set Maesh into the SMI Mode which made it possible to make use of TrafficSplits or ACL.</p><p>As a side-effect you were unable to use the retry annotation together with SMI because internally the two modes were incompatible.</p><p>To change that, we have reworked how Maesh discovers services. Maesh will now build an internal topology of every deployed service, including *nested TrafficSplits* through the SMI specification.</p><p>Additionally, if you want to use ACL (TrafficTarget in SMI) you may now activate the ACL flag<strong> --acl</strong> similar to how you could activate the SMI flag before. Doing so, will activate the ACL feature on Maesh without impacting the SMI mode.</p><h2 id="multiple-middlewares-per-service">Multiple Middlewares per service</h2><p>Last but not least, we also enhanced the handling of the annotations on your services. It is now possible to combine middlewares, for example the retry-attempts with the rate-limiter to better control your services.</p><!--kg-card-begin: markdown--><pre><code>---
apiVersion: v1
kind: Service
metadata: 
  annotations:
    maesh.containo.us/retry-attempts: 2
    maesh.containo.us/ratelimit-burst: 200
  labels: 
    app: my-udp-service
  name: udp-service
  namespace: test
spec: 
  ports: 
    - port: 8080
      protocol: UDP
  selector: 
    app: my-udp-service
</code></pre>
<!--kg-card-end: markdown--><p>This configuration activates the retry feature and Maesh will simultaneously try to proxy the request twice in case of a network error and activate the rate limiting for that service.</p><h2 id="new-helm-major-version">New Helm Major Version</h2><p>As a result of all the architecture changes mentioned above, we needed to enhance the Major Version of our chart as we had some helm breaking changes. For assistance while upgrading your installation, please see <a href="https://docs.mae.sh/master/migration/helm-chart/">here</a>.</p><h2 id="what-s-next">What’s Next</h2><p>We’re just getting started. Work is underway to implement some of the most requested features into Maesh, including End to End encryption. Of course, this is only made possible by you, an awesome community, which provides us such valuable feedback that we’re able to define an exciting roadmap for a product you’ve helped us build. </p><p>Please don’t stop contributing, either in PR’s or just raising issues. For us it matters a lot. </p><p>Thank you!</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://containous.ghost.io/maesh/">Website</a></li><li><a href="https://docs.mae.sh/">Documentation</a></li><li><a href="https://github.com/containous/maesh">Github</a></li><li><a href="https://community.containo.us/c/maesh">Community Forum</a><br/></li></ul>]]></content:encoded></item><item><title><![CDATA[The Importance of Distributed Tracing and Monitoring in a Microservice Architecture]]></title><description><![CDATA[How do teams diagnose latency between microservices or collate logs from dozens of loosely coupled services, while also ensuring that any logging overhead is kept to a minimum?]]></description><link>https://traefik.io/blog/the-importance-of-distributed-tracing-and-monitoring-in-a-microservice-architecture/</link><guid isPermaLink="false">Ghost__Post__5e9116ed1afff4004456e002</guid><category><![CDATA[Blog]]></category><category><![CDATA[Microservices]]></category><dc:creator><![CDATA[Kevin Crawley]]></dc:creator><pubDate>Tue, 05 May 2020 14:40:44 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/05/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/05/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog.jpg" class="kg-image" alt="The Importance of Distributed Tracing and Monitoring in a Microservice Architecture"/></figure><img src="https://containous.ghost.io/content/images/2020/05/Containous---The-Importance-of-Distributed-Tracing-and-Monitoring-in-a-Microservice-Architecture---Blog-2.jpg" alt="The Importance of Distributed Tracing and Monitoring in a Microservice Architecture"/><p>Microservices have many advantages, such as the ability to independently deploy decoupled services instead of having to deploy an entire monolithic application or scaling out components independently. However, for all their advantages, microservices also introduce complexities that should be understood by teams that choose to implement them. One of those challenges is monitoring application health and tracing traffic flows through a distributed system.</p><p>Often microservices can <em>logically</em> be thought of as a single application, even though internally there may be several services involved in fulfilling requests to the end-user. If each request is routed through a series of services, how do teams trace and troubleshoot issues? Even if the system as a whole is working <em>functionally</em>, perhaps your overall transaction time is unacceptable. How do teams diagnose latency between microservices or collate logs from dozens of loosely coupled services, while also ensuring that any logging overhead is kept to a minimum?</p><h2 id="logging-monitoring-and-tracing">Logging, Monitoring, and Tracing</h2><p>Before we continue, let us disambiguate logging, monitoring, and tracing. These terms are often used interchangeably, but there are some subtle differences.</p><p>Typically, logging is focused on diagnosing errors or providing auditing capabilities at the component (or microservice) level. Logging is also usually reactive in nature and is often the first tool that operators use when troubleshooting service errors or investigating security incidents.</p><p>Monitoring is focused on proactive metrics and thresholds that let operators know how a service is handling its requests. These metrics are usually focused on the underlying infrastructure, such as CPU, Memory, and I/O in addition to the runtime metrics generated by the application itself. These include statistics like heap size, thread count, and memory management (garbage collection).</p><p>Tracing is typically focused on optimization and performance across multiple services. It includes correlating a single “logical request” to multiple physical requests as they propagate through multiple services. While tracing is concerned with each service in a chain, it is usually focused at the application level. There are additional benefits to tracing as a troubleshooting tool since any exception or error is usually captured along with the entire context of a request.</p><p>While logging is important, in this article we will focus on monitoring and tracing since they span multiple services.</p><h2 id="monitoring">Monitoring</h2><p>Monitoring is the process of recording information, or predefined metrics, allowing operators to achieve visibility into their applications state. These metrics help answer questions around resource allocation or to determine if requests are going where they should. This becomes increasingly important when traffic shifting and other advanced routing mechanisms like throttling or circuit breakers are used within microservice applications. Knowing when a request hit a service is important but knowing why it was forwarded to that service can be just as important. Monitoring can also help operators determine when circuit breakers are triggered on or off or which traffic shifting rule was invoked in routing the request. Traefik generates metrics around these types of Key Performance Indicators (KPIs) and exposes that data through various implementations such as Prometheus.</p><h2 id="tracing">Tracing</h2><p>Tracing starts at the entry-point of a request into an application. A trace is started for the request and will have a <a href="https://www.w3.org/TR/trace-context/">unique identifier</a> generated for that request. As traffic flows from service to service, each service adds some information to the trace, like the time the request arrived at the service as well as how long it took to process. This allows open source tools such as <a href="https://www.jaegertracing.io/">Jaeger</a> and <a href="https://www.elastic.co/apm">Elastic APM</a> to visualize the entire call flow.</p><p>How is tracing implemented in a microservices application? In most cases, there are libraries and tools to help instrument the most popular application runtimes and frameworks. You could also code it yourself, intercepting calls and adding headers to downstream requests or using some other mechanism to add metadata to traffic. In addition to these techniques, you can utilize tracing with <a href="https://containous.ghost.io/traefik/">Traefik</a> and <a href="https://containous.ghost.io/maesh/">Maesh</a> to gain additional observability within your application environments.</p><p>Traefik supports tracing via <a href="https://opentracing.io/">OpenTracing</a>, an open standard designed for distributed tracing. You enable tracing via configuration and can also specify which backend you want to utilize: <a href="https://www.jaegertracing.io/">Jaeger</a>, <a href="https://zipkin.io/">Zipkin</a>, or <a href="https://www.datadoghq.com/">DataDog</a>.</p><h2 id="tracing-or-monitoring-or-both">Tracing or Monitoring, or Both?</h2><p>The distinction between monitoring and tracing is often academic. Some teams utilize monitoring and metrics alongside distributed tracing, while other teams prefer to keep tracing and monitoring as separate but complementary concerns. In many cases, the aggregate data provided by tracing generates the information they need to determine when and where to scale out their services.</p><p>Monitoring is typically easier to implement, so teams usually start their diagnostic journey with metrics. Tracing allows a deeper (or wider) view but typically requires more effort to implement because of the requirements in collecting, storing, and analyzing the vast amounts of telemetry which is generated by tracing. Of course, there are vendors such as <a href="https://www.datadoghq.com/">DataDog</a> and <a href="https://www.instana.com/">Instana</a> which can offload most of that work, but those solutions are costly and hard to justify when first starting out.</p><p>Both monitoring and tracing can be used to help detect when individual services are not behaving as they should. Tracing, when properly implemented, will help you not only detect anomalies but give you the information needed to understand what may be causing them. Ultimately, when you are to the point where you need to focus on optimization and improve end-to-end performance, then you’re going to have no choice but to utilize tracing. Tools such as <a href="https://containous.ghost.io/traefik/">Traefik</a> and <a href="https://containous.ghost.io/maesh/">Maesh</a> can be used to introduce distributed tracing without the significant overhead involved with instrumenting every service with open source tools and having to manage all that additional telemetry.</p><h2 id="conclusion">Conclusion</h2><p>Both monitoring and tracing are important to creating stable, reliable, and performant microservice-based applications. Monitoring provides health checks on platform services and critical infrastructure, while tracing allows you to diagnose end-to-end traffic for requests. As applications mature, they typically require both monitoring and tracing for efficient and optimal service management.</p><p>Want to learn more about <strong>microservice architecture best practices</strong>? <a href="https://info.containo.us/request-white-paper-routing-in-the-cloud">Check out this white paper</a> that addresses<strong> production challenges </strong>(including tracing and monitoring) <strong>related to adopting microservices with a cloud-native mindset</strong>.</p>]]></content:encoded></item><item><title><![CDATA[TraefikEE now available through new Red Hat Marketplace]]></title><description><![CDATA[We’re excited to announce that Traefik Enterprise Edition is now available through Red Hat Marketplace, an open cloud marketplace that makes it easier to discover and access certified software for container-based environments in the cloud and on-premises.]]></description><link>https://traefik.io/blog/traefikee-now-available-through-new-red-hat-marketplace/</link><guid isPermaLink="false">Ghost__Post__5ea754911468920044969864</guid><category><![CDATA[Blog]]></category><category><![CDATA[Partners]]></category><dc:creator><![CDATA[Marie Ponseel]]></dc:creator><pubDate>Tue, 28 Apr 2020 13:01:11 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/04/TraefikEE-now-available-through-new-Red-Hat-Marketplace.jpg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2020/04/TraefikEE-now-available-through-new-Red-Hat-Marketplace.jpg" alt="TraefikEE now available through new Red Hat Marketplace"/><p class="post-sub-title">Provides unified and automated network management in dynamic OpenShift environments</p><!--kg-card-end: html--><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/04/RH-Marketplace-Partners-blog-bkg_wLogo.png" class="kg-image" alt="TraefikEE now available through new Red Hat Marketplace"/></figure><p>We’re excited to announce that <a href="https://containous.ghost.io/traefikee/">Traefik Enterprise Edition</a> is now available through <a href="https://marketplace.redhat.com/en-us/products/traefik-enterprise-edition">Red Hat Marketplace</a>, an open cloud marketplace that makes it easier to discover and access certified software for container-based environments in the cloud and on-premises. Traefik Enterprise Edition is the easiest way for organizations with large-scale or mission-critical applications to run container-based architectures at scale everywhere.</p><p>Customers can now benefit from the seamless deployment experience of TraefikEE through Red Hat Marketplace and can take advantage of responsive support, streamlined purchasing and billing, simplified governance, and single-dashboard visibility across clouds.</p><p>Traefik Enterprise Edition, built on top of open-source <a href="https://containous.ghost.io/traefik/">Traefik</a>, natively integrates with Red Hat OpenShift to allow application teams to simplify the complexity of managing dynamic network topologies and resources. With just a few clicks, you can get access to enterprise distributed features with high-performance capabilities enabling you to:</p><ul><li>Load balance any application using any protocol</li><li>Easily scale out to meet production traffic needs</li><li>Add smart routing and fallback policies critical in multi-cloud scenarios</li><li>Better secure services with end-to-end network and application encryption</li><li>Provide real-time tracing, monitoring, and alerts for visibility and control over topology, uptime, and performance</li></ul><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/04/TraefikEE-RedHatMarketplace-1.jpg" class="kg-image" alt="TraefikEE now available through new Red Hat Marketplace"/></figure><p>Built in partnership by Red Hat and IBM, Red Hat Marketplace is designed to meet the unique needs of developers, procurement teams and IT leaders through simplified and streamlined access to popular enterprise software. All solutions available through the marketplace have been tested and certified for <a href="https://www.redhat.com/en/technologies/cloud-computing/openshift">Red Hat OpenShift Container Platform</a>, the industry's most comprehensive enterprise Kubernetes platform, allowing them to run anywhere OpenShift runs. A containers-based approach helps ensure that applications can be run and managed the exact same way, regardless of the underlying cloud infrastructure. This gives companies the flexibility to run their workloads on-premises or in any public or private cloud with improved portability and confidence that their applications and data are protected against vendor lock-in.</p><p>Through the Red Hat Marketplace, we provide our customers with the best multi-cloud experience to run their container-based applications, while giving them the flexibility to deploy TraefikEE in the environment of their choice. Now, enterprises can deploy production-grade Kubernetes environments simply and easily with the peace of mind that their chosen stack will work anywhere and be supported for years to come.</p><p>Going forward, you will be able to find the latest version of TraefikEE in the Red Hat Marketplace, starting with <a href="https://containous.ghost.io/blog/traefik-enterprise-edition-2-1-now-available/">the recently announced TraefikEE v2.1</a> which adds crucial new capabilities with enhanced security options including support for LDAP and three new authentication protocols: JWT, HMAC, and OAuth2 Token Introspection, that can be used to easily improve security for both external and internal traffic. To learn more about TraefikEE, <a href="https://info.containo.us/request-demo-traefikee">watch the demo video</a>.</p><p><em>Red Hat Marketplace and TraefikEE offer a true multi-cloud experience with the support you need for end-to-end solutions in one single platform.</em> Try TraefikEE out at <a href="https://marketplace.redhat.com/en-us/products/traefik-enterprise-edition">marketplace.redhat.com</a>.</p>]]></content:encoded></item><item><title><![CDATA[Connecting Users to Applications with Kubernetes Ingress Controllers]]></title><description><![CDATA[Kubernetes is the de facto standard for teams developing cloud-native applications. In this article, we’ll review one of the most critical aspects of Kubernetes networking: The Ingress Controller.]]></description><link>https://traefik.io/blog/connecting-users-to-applications-with-kubernetes-ingress-controllers/</link><guid isPermaLink="false">Ghost__Post__5e9890445df7fe004475aa62</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Orion Letizi]]></dc:creator><pubDate>Tue, 21 Apr 2020 13:30:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg" class="kg-image" alt="Connecting Users to Applications with Kubernetes Ingress Controllers" srcset="https://containous.ghost.io/content/images/size/w600/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 600w, https://containous.ghost.io/content/images/size/w1000/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 1000w, https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers.jpg 1200w" sizes="(min-width: 720px) 720px"/></figure><img src="https://containous.ghost.io/content/images/2020/10/Connecting-Users-to-Applications-with-Kubernetes-Ingress-Controllers-1.jpg" alt="Connecting Users to Applications with Kubernetes Ingress Controllers"/><p>Containerization technologies such as <a href="https://www.docker.com/">Docker</a> have been rapidly adopted by software teams, and the ensuing ability to easily package application components into reusable parts has given rise to the widespread use of microservices. However, these benefits have come with a price tag as developers are faced with challenges around orchestrating and managing connectivity to the underlying containers in a datacenter. <a href="https://kubernetes.io/">Kubernetes</a> (k8s) is the de facto standard for teams developing cloud-native applications and directly addresses these issues. In this article, we’ll briefly review one of the most critical but perhaps confusing aspects of Kubernetes networking: The Ingress Controller.</p><h2 id="from-pods-to-production">From Pods to Production</h2><p>Let’s start with a typical scenario: A development team is tasked with writing a backend API service for external applications/users. In the early phases of development, an engineer may instantiate a local instance of the containerized implementation on development machines using direct docker invocations or even docker-compose. At some point, though, they’ll want to deploy a version of the service to a shared development or staging cluster in the same manner as the final production configuration. Pods, the fundamental deployable units defined by k8s, and higher-level abstractions such as Deployment resources can help automate lifecycle management of containers during this step, but they don’t address how applications are accessed over the network. Kubernetes provides a dedicated resource abstraction for this purpose.</p><h2 id="exposing-applications-as-k8s-services">Exposing applications as k8s services</h2><p>When deployed within Pods, containers are assigned IP addresses that may change over time due to a variety of lifecycle operations. This immediately poses challenges when other components need to find and establish network connections with them. The Service resource defined as part of Kubernetes networking manages these aspects automatically. Users can define Services that get associated with underlying Pods through selectors and allows them to be accessed through a user-specified service name. Where connections can be established from and how they’re implemented depends upon the Service type configured. The most commonly used service types offered by k8s are:</p><ul><li>ClusterIP</li><li>NodePort</li><li>LoadBalancer</li></ul><h3 id="clusterip-service-type">ClusterIP service type</h3><p>The ClusterIP is enabled by default if no type is defined in the Service resource definition. When invoked, k8s creates a virtual cluster IP address that can be used to connect to the underlying Pods. The caveat, though, is that this IP address is routable only within the cluster itself. ClusterIP services are often used for exposing internal-only application endpoints to each other.</p><h3 id="nodeport-service-type">NodePort service type</h3><p>The NodePort type provides the simplest mechanism for external access to services. Specifically, it opens a specific port (within a k8s configured port range) on every node in the cluster. Underneath, a ClusterIP service is created, and clients that attempt to connect to an exposed NodePort are routed through. While the NodePort service type extends a method to access services from outside of the cluster, it has some drawbacks including:</p><ul><li>Services can only be exposed on ports from a range (30000-32767 by default)</li><li>One port can only be mapped to a single service</li><li>Clients connect through a node and if the corresponding IP of the underlying host / VM changes, they need to be updated accordingly</li></ul><h3 id="loadbalancer-service-type">LoadBalancer service type</h3><p>The LoadBalancer type is often used in cloud environments in order to automate the provisioning of external load balancers outside of the underlying k8s cluster. While this enables external network access and avoids the problem of IP addresses shifting out from underneath clients, the use of LoadBalancer Service types can quickly lead to high costs from the underlying cloud (e.g. GCE or AWS).</p><p>While the three Service types above are viable alternatives for some use cases, when application developers want to expose their services externally without the limitations of NodePort and LoadBalancer types, there’s a better alternative extended by Kubernetes networking.</p><h2 id="k8s-networking-and-the-ingress-resource-abstraction">K8s networking and the Ingress resource abstraction</h2><p>Kubernetes defines a native Ingress resource abstraction that exposes HTTP and HTTPS endpoints and routes traffic based upon rules defined by the user. The Ingress resource is a natural fit when developers and devops engineers want to expose multiple underlying services through a single external endpoint and/or load balancer. The Ingress resource definition allows them to route traffic to defined Service resources based upon, for example, host and/or prefix rules. Therefore, it complements the Service resource capabilities to provide a flexible method for enabling external access. However, defining an Ingress resource on its own doesn’t actually expose services outside Kubernetes since it simply conveys a request for networking configuration.</p><h2 id="the-wizard-behind-the-curtain-ingress-controllers">The wizard behind the curtain: Ingress Controllers</h2><p>Our discussion thus far has helped highlight the need for ingress resources, but it leaves open the question of how corresponding requests are acted upon. The answer comes in the form of Ingress Controllers which are responsible for consuming inbound requests and creating the corresponding routing specifications in a technology-specific manner. Typically, the specific controller installed in a k8s cluster is selected and deployed by operators. There are many potential options available, but a few illustrative examples include:</p><ul><li>AWS ALB - An instance of an Ingress Controller tied to a specific public cloud, it satisfies inbound Ingress resource requests using <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html">AWS Application Load Balancers</a></li><li>NGINX - Implements Ingress resources using the NGINX open source software</li><li>Traefik - A leading open source <a href="https://containous.ghost.io/traefik/">Kubernetes Ingress Controller</a> that makes setting up routes between Kubernetes services and the outside world simple and reliable</li></ul><p>There need not be a strict either / or decision when it comes to <a href="https://containous.ghost.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/">choosing Ingress Controllers</a>, and k8s operators can elect to deploy multiple controllers if desired. The selection process should take into consideration the benefits specific controllers like <a href="https://containous.ghost.io/traefik/">Traefik</a> may provide such as:</p><ul><li>Lets Encrypt support for automated certificate management</li><li>Traffic splitting based upon custom weight definitions</li><li>Flexibly route definitions including support for name and path based routing as well as route prioritization</li><li>Custom resource definitions that provide additional controller-specific enhancements</li></ul><p>By integrating controllers that align with their use cases, development teams can enjoy a variety of capabilities provided by Kubernetes for external access without having to become networking experts.</p><p>Want to learn more about <strong>Kubernetes Ingress</strong>? <a href="https://info.containo.us/webinar-deploying-external-load-balancers-in-kubernetes">Check out this video</a> that describes the <strong>different patterns for deploying external load balancers in Kubernetes.</strong></p>]]></content:encoded></item><item><title><![CDATA[Traefik Enterprise Edition 2.1 Now Available]]></title><description><![CDATA[This release adds crucial new capabilities designed to tame the complexity of managing internal connections, especially with enhanced security options.]]></description><link>https://traefik.io/blog/traefik-enterprise-edition-2-1-now-available/</link><guid isPermaLink="false">Ghost__Post__5e950d861afff4004456e057</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Nicolas Mengin]]></dc:creator><pubDate>Tue, 14 Apr 2020 16:09:23 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/04/TraefikEE2.1-Blog.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2020/04/TraefikEE2.1-Blog.png" alt="Traefik Enterprise Edition 2.1 Now Available"/><p class="post-sub-title">New authentication features for API gateways and more</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/04/TraefikEE2.1-Blog-1.png" class="kg-image" alt="Traefik Enterprise Edition 2.1 Now Available"/></figure><p>After one year of existence, TraefikEE has grown up to add much more value on top of Traefik open source.</p><p>While Traefik open source is laser-focused on being a world-class reverse proxy optimized to manage external incoming connections, this release adds crucial new capabilities designed to tame the complexity of managing internal connections, especially with enhanced security options.</p><p>TraefikEE 2.1 now provides support for three new authentication protocols: JWT, HMAC, and OAuth2 Token Introspection, that can be used to easily secure both external and internal traffic.</p><p>Also included in this release: enhanced cluster management, Traefik 2.2 support, and RedHat OpenShift certification.</p><h2 id="three-flavors-of-authentication">Three flavors of Authentication</h2><p>Deploying a microservice architecture requires managing an infrastructure with many APIs. These APIs are reached by both external and internal systems, and the necessity to secure access to all your APIs takes on fundamental importance.</p><p>TraefikEE has acknowledged this need, firstly by adding the LDAP Middleware, and now by adding JWT, HMAC and oAuth2 Token Introspection.</p><p>No matter what your security needs are, TraefikEE has a middleware that can help!</p><h4 id="first-flavor-jwt">First flavor: JWT</h4><p>JWT is a very popular technology to quickly secure your infrastructure, and TraefikEE now embeds <a href="https://docs.containo.us/middlewares/jwt/">a dedicated middleware</a> to complement your microservice architecture. All it takes is one extra line of configuration!</p><!--kg-card-begin: markdown--><pre><code class="language-yaml">  services:
    whoami:
      image: containous/whoami
      labels:
        # … routing labels...
        - &quot;traefik.http.middlewares.test-jwtAuth.plugin.jwtAuth.source=my-jwt-src&quot; # Authentication Source declared in another place.
</code></pre>
<!--kg-card-end: markdown--><p>And for the icing on the cake, the JWT middleware behavior can be extended to allow operations such as authorization (using claims), and header forwarding.</p><!--kg-card-begin: markdown--><pre><code class="language-yaml">  services:
    whoami:
      image: containous/whoami
      labels:
        # … routing labels...
        - &quot;traefik.http.middlewares.test-jwtAuth.plugin.jwtAuth.source=my-jwt-src&quot; # Authentication Source declared in another place.
        - &quot;traefik.http.middlewares.test-jwtAuth.plugin.jwtAuth.claims=Equals(`team`, `admin`) || Equals(`team`, `dev`)&quot; # Only users from admin and dev teams can reach your services.
</code></pre>
<!--kg-card-end: markdown--><h4 id="second-flavor-oauth2-token-introspection">Second flavor: OAuth2 Token Introspection</h4><p>Now, if you've already deployed an OAuth2 server with a token introspection endpoint, you probably want to leverage it to secure your services.</p><p>Good news then,<a href="https://docs.containo.us/middlewares/oauth-intro/`"> TraefikEE can connect to it </a>and add an authorization layer directly in your routing configuration. Securing a service has never been so easy!</p><!--kg-card-begin: markdown--><pre><code class="language-yaml"># Static Configuration
  authSources:
    oait-src:
      oAuthIntrospection:
        url: http://myoauth2server # OAuth2 server endpoint
        authorizationHeader: Basic XXxxxx # Type of authentication
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-yaml">version: '3.4'
  services:
    whoami:
      image: containous/whoami
      deploy:
        labels:
          # Dynamic Configuration
          # … routing labels...
          - &quot;traefik.http.middlewares.test-oauth-intro.plugin.oAuthIntrospection.source=oait-src”
          - &quot;traefik.http.middlewares.test-oauth-intro.plugin.oAuthIntrospection.claims= Equals(`team`, `admin`) || Equals(`team`, `dev`)&quot; # Only users from admin and dev teams can reach your services.
</code></pre>
<!--kg-card-end: markdown--><h4 id="third-flavor-hmac">Third flavor: HMAC</h4><p>Want to prevent your system from attacks such as man-in-middle, XSS injection, etc.?</p><p>You can enforce your infrastructure security by checking both the integrity and the sender's identity of the incoming requests with the new <a href="https://docs.containo.us/middlewares/hmac/">HMAC middleware</a>.</p><!--kg-card-begin: markdown--><pre><code class="language-yaml"># Static Configuration
authSources:
  my-hmac-src:
    hmac:
      inline: # Declare here the authorized id/keys
        - id: &quot;secret-key&quot;
          key: &quot;traefikee-approved&quot;
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-yaml">version: '3.4'
  services:
    whoami:
      image: containous/whoami
      deploy:
        labels:
          # Dynamic Configuration
          # … routing labels...
          - &quot;traefik.http.middlewares.test-hmac-auth.plugin.hmacauth.source=my-hmac-src&quot;
</code></pre>
<!--kg-card-end: markdown--><h2 id="root-less-image-secured-more-infrastructure">Root-LESS Image, Secured-MORE Infrastructure</h2><p>TraefikEE has always been focused on infrastructure security.</p><p>We’ve used a gRPC MTLS communication between the nodes and we’ve split the responsibilities between controllers and proxies to secure both internal and outgoing cluster connections.</p><p>In TraefikEE v2.1, we’ve added a rootless image to secure your infrastructure against potential vulnerabilities in the Docker daemon, and the container runtime.</p><p>Take advantage of this feature by following <a href="https://docs.containo.us/operating/rootless-image/">the comprehensive guide in the documentation</a>.</p><h2 id="enhanced-cluster-management">Enhanced Cluster Management</h2><p>Many users reported to us that they’ve had to maintain TraefiKEE clusters installed on both their Q&amp;A and Production infrastructures, and they’d like to avoid specifying the cluster name on each command they launched.</p><p>In order to help them, and to improve the user experience, we’ve introduced a few commands into the CLI (teectl) to help <a href="https://docs.containo.us/operating/teectl-cluster-mgt/">manage multiple clusters</a>, and especially, to customize the active cluster. Thus, users can set a cluster as the active one and not provide its name in each command.</p><h2 id="red-hat-openshift-operator-certified">Red Hat OpenShift Operator Certified</h2><p>Like Traefik, TraefikEE eases your Ingress Controller integration regardless of your infrastructure, including Red Hat OpenShift clusters!</p><p>Starting with TraefikEE v2.0, we introduced a Kubernetes Operator to install TraefikEE into OpenShift v4 clusters.</p><p>Today, we are proud to announce that TraefikEE v2.1 is Red Hat OpenShift Operator certified. With this certification, TraefikEE joins the Red Hat software certified partner ecosystem and is readily available through the <a href="https://www.openshift.com/products/container-platform">Red Hat OpenShift Container Platform</a>.</p><p>The TraefikEE Operator is now available in the <a href="https://catalog.redhat.com/software/containers/explore">Red Hat Container Catalog</a>. Via <a href="https://operatorhub.io/operator/traefikee-operator">OperatorHub</a>, you can install and update TraefikEE quickly and seamlessly into any OpenShift cluster.</p><h2 id="what-s-next">What's Next?</h2><p>TraefikEE continues to bring more enterprise specific features. High Availability, distributed services, and enterprise authentication protocols are just a few of the benefits you can get from switching to TraefikEE.</p><p>Take a look at all these features in <a href="https://info.containo.us/request-demo-traefikee">our 5-minute video</a> to learn more about them.</p><p>As always, we are happy to answer your questions, <a href="https://info.containo.us/request-demo-traefikee">and help you find the best solution for your projects</a>.</p><p>If you want to test drive our new features, <a href="https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days">give Traefik Enterprise Edition 2.1 a try today</a>.</p>]]></content:encoded></item><item><title><![CDATA[Announcing Traefik 2.2]]></title><description><![CDATA[Traefik 2.1 adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik since the beginning and is utterly important for us, but also for you, our users. ]]></description><link>https://traefik.io/blog/traefik-2-2-ingress/</link><guid isPermaLink="false">Ghost__Post__5e5cd2ba3727400038a2f958</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Thu, 26 Mar 2020 12:58:01 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/04/Traefik2.2Blog.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2020/04/Traefik2.2Blog.png" alt="Announcing Traefik 2.2"/><p class="post-sub-title">With Enhanced Ingress support and more!</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/03/Traefik2.2-blog.png" class="kg-image" alt="Announcing Traefik 2.2"/></figure><p>After releasing 2.1 in December, we are excited to announce a new release. This one adds couple of long awaited features, but also brings simplicity in certain areas. Simplicity has always been a key feature of Traefik since the beginning and is utterly important for us, but also for you, our users. Our goal is to keep constantly improving the user experience by making the handling of Traefik even more easy, that you can focus on your real issues. </p><h3 id="enhanced-ingress-support">Enhanced Ingress Support</h3><p>As announced with the 2.1 release, this release is focusing on user experience. For that reason, we brought back extended Ingress Support. Prior to Traefik v2.2, plain Kubernetes Ingress Objects were only supported without annotations. As our community told us, they have a valuable use-case where they want to run Traefik as a simple Ingress Controller, and don't want to fully commit to the IngressRoute in order to stay better included with the Kubernetes ecosystem. For that reason, we’re supporting Ingress Objects with a sub-set of annotations again.</p><pre><code class="language-yaml">kind: Ingress
apiVersion: networking.k8s.io/v1beta1
metadata:
  name: foo
  namespace: bar
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: web, websecure
    traefik.ingress.kubernetes.io/router.middlewares: redirect-http@kuberntes-crd
    external-dns.alpha.kubernetes.io/hostname: *.mycompany.org
spec:
  rules:
  - host: foo.com
    http:
      paths:
      - path: /bar
        backend:
          serviceName: service1
          servicePort: 80</code></pre><p>Additionally, not all the behavior we want to be configurable for our users fit into the idea of an Ingress, therefore we're also supporting a subset of annotations on Service Objects to fill the gap.</p><pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: service1
  namespace: bar
  annotations: traefik.ingress.kubernetes.io/service.sticky: "true"
spec:
  type: ClusterIP
  ports:
  - port: 80
    name: http</code></pre><p>A list of all annotations (Ingress and Service) can be found here <a href="https://docs.traefik.io/master/routing/providers/kubernetes-ingress/">https://docs.traefik.io/master/routing/providers/kubernetes-ingress/</a></p><h2 id="entrypoint-redirection-and-default-router-configuration">Entrypoint Redirection And Default Router Configuration</h2><p>Traefik 2.x is really powerful, given the reworked architecture allowing us to operate from Layer 4 and above. Additionally, the new concept of routers, middlewares and services allows for more flexibility. As a result, you told us that the configuration ended up being a bit too verbose, and that you're missing some sort of redirects on Entrypoints, as we had something similar with Traefik 1.x.</p><p>For that reason, we introduced the concepts of Entrypoint redirects, and default router configuration.</p><p>With that release, it's possible to configure redirects bound to an Entrypoint through the static configuration. Additionally, you can also set defaults for the other areas a router can handle.</p><pre><code class="language-yaml">http:
    redirections:
        entryPoint:
          to: foobar
          scheme: foobar
    middlewares:
      - foobar
      - foobar
    tls:
      options: foobar
      certResolver: foobar
      domains:
        - main: foobar
          sans:
          - foobar
          - foobar
        - main: foobar
          sans:
          - foobar
          - foobar</code></pre><p>Traefik will then create a default router, which will handle the configured redirects for you. For everything starting with <strong>middlewares</strong>, the default values will be copied automatically to all the routers you create.</p><h2 id="key-value-stores">Key Value Stores</h2><p>Another long awaited feature have been the addition of Key Value Stores as a dynamic configuration provider in Traefik v2.Not only have former stores are re-added again (such as e.g. etcd or Consul), but new ones such as Redis have been added providing more supported platforms.</p><h2 id="udp">UDP</h2><p>Support for TCP is one of the major changes from Traefik Version to Version 2. Now, with the new release we're also adding support for UDP! The only requirement is enabling an Entrypoint to be UDP based and that’s it.</p><pre><code class="language-yaml">[entryPoints]
  [entryPoints.udp]
    address = ":8093/udp"
  [entryPoints.http]
    address = ":8093" # same as ":8093/tcp"</code></pre><p>For now, we don't have any routing rules, as TLS is not supported currently (so there is no HostSNI), and there is no PathPrefix notion since there are no requests at the transport layer level. However, that’s not preventing you from load balancing your UDP services. That only means that you need to have one dedicated Entrypoint per UDP service you want to load balance.</p><h2 id="elastic-apm-tracer">Elastic APM Tracer</h2><p>Elastic APM is a well known solution in the ecosystem. It's the <a href="https://www.elastic.co/de/apm">APM solution provided by Elastic</a>. Starting now, it's a supported Tracing backend for Traefik as well thanks to a community contribution. Just configure it, and you'll have your traces transferred to that system. </p><h2 id="web-ui-enhancement">Web UI Enhancement</h2><p>Last but not least, there have been a couple of modifications to the Web UI. Now not only will you be able to see your UDP services, but we’ve had a great community contribution to add a dark theme also!</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2020/03/image.png" class="kg-image" alt="Announcing Traefik 2.2"/></figure><h2 id="what-s-next">What's next?</h2><p>As we said with the previous release, focusing on improving the user experience is our goal. Implementing advanced Ingress support on Kubernetes and providing a way to configure defaults on an Entrypoint was one of our first steps. However, there are still things to be done which will be part of the upcoming release(s). Not only on improving the user experience but also on providing additional features. For that please keep raising your voice in the <a href="https://github.com/containous/traefik/issues">issue tracker</a>, on the <a href="https://community.containo.us/">community forum</a>, or better—<a href="https://github.com/containous/traefik/pulls">pull request</a> your way into making Traefik a better tool for everyone.</p>]]></content:encoded></item><item><title><![CDATA[Leading travel platform simplifies network management by deploying Traefik as preferred reverse proxy]]></title><description><![CDATA[Covering all aspects of traveling, hotels, flights, car rental, and vacation homes, this world leading travel company’s platform is managed by an infrastructure team that counts over one thousand engineers. ]]></description><link>https://traefik.io/blog/leading-travel-platform-simplifies-network-management-by-deploying-traefik-as-preferred-reverse-proxy/</link><guid isPermaLink="false">Ghost__Post__5e70260319908e0038512ce1</guid><category><![CDATA[Blog]]></category><category><![CDATA[Case Studies]]></category><dc:creator><![CDATA[Marie Ponseel]]></dc:creator><pubDate>Wed, 18 Mar 2020 14:49:14 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/04/LeadingTravelPlatformCaseStudy-Blog.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/03/Leading-Travel-Platform-Simplifies-Network-Management-by-Deploying-Traefik-as-Preferred-Reverse-Proxy.png" class="kg-image" alt="Leading travel platform simplifies network management by deploying Traefik as preferred reverse proxy"/></figure><h2 id="overview">Overview</h2><img src="https://containous.ghost.io/content/images/2020/04/LeadingTravelPlatformCaseStudy-Blog.png" alt="Leading travel platform simplifies network management by deploying Traefik as preferred reverse proxy"/><p>Covering all aspects of traveling, hotels, flights, car rental, and vacation homes, this world leading travel company’s platform is managed by an infrastructure team that counts over one thousand engineers. This infrastructure engineering team supports an expansive brand portfolio, ensuring transactions are always up and running smoothly, a monumental task given the sheer scale of their business. Given the diversity of applications across their brands, the group delicately supports a wide range of networking solutions and programming languages throughout the organization.</p><h2 id="challenge">Challenge </h2><p>Like many other large companies, this leading travel company’s broad range of applications had requirements for specific tools and platforms, such as various containerization solutions. As a result, the team managed a multitude of container platforms, each having a unique networking configuration and runtime to operate. This made management of these environments very difficult and time consuming because each network change needed to be applied one-by-one for each and every environment (i.e. Amazon ECS and Kubernetes, Mesos and Marathon, etc). <br/></p><p>The team set out to find a proxy solution flexible enough to work across multiple platforms such as Consul, Mesos, and Kubernetes, while integrating natively with each platform’s unique discovery mechanisms and information models. What they needed was a single reverse proxy solution to standardize and consolidate the existing disparate solutions to reduce operational overhead<em>, s</em>implify new deployments, and minimize human errors during configuration changes. Given the company’s size, the “perfect” solution would need to meet specific requirements around massive scalability, ease and speed of deployment, and function efficiently in highly-dynamic containerized environments.<br/></p><h2 id="solution">Solution</h2><p>The leading travel company’s infrastructure team stumbled onto Traefik while evaluating and testing different solutions in the networking landscape of the containerized world. <br/></p><p>Traefik offers the ability for engineering teams to plug in multiple data sources, such as Mesos, Marathon, Consul, etc, all with the use of a single tool. Traefik’s wide array of pluggable providers connects to any compatible data source, presenting a unified and consistent platform for traffic routing. This feature appealed greatly to the engineering team and encouraged a closer look.<br/></p><p>Traefik is a lean implementation, written in Go, and a single binary which makes it easy to deploy. Traefik offers extensive configuration options, suitable for any application scenario and scale. With advanced routing capabilities, Traefik was one of the only solutions capable of easily configuring multiple advanced routes per service and running custom configuration templates. Ultimately, the engineering team chose Traefik for its simplicity and ease of maintenance and configuration.<br/></p><p>By standardizing on Traefik as their reverse proxy of choice across all environments, the engineering team saved countless hours by simplifying network operation management.<br/></p><p>The company is also committed to the values of open source, supporting and encouraging open source throughout the organization. As an open source project, Traefik bolsters their commitment to consume and contribute to open source software as part of the greater community. They found engagement with the Traefik developer community to be responsive, receptive and collaborative, something important to them as well.<br/></p><h2 id="bottom-line">Bottom Line</h2><p>This leading travel company’s selection of Traefik as their preferred reverse proxy solution, enables them to achieve increased delivery speed at scale, even in the rapidly and ever-evolving container ecosystem.<br/></p><p>In spite of their vigorous requirements tested throughout the evaluation process, Traefik easily passed with flying colors, proving its ability to handle the most demanding workloads in high traffic environments. The team is experiencing greater simplicity managing large scale containerized infrastructure while enhancing ease of maintenance by delivering features critical to this unique environment.<br/></p><p>The engineering team happily recommends Traefik to other organizations facing the same challenges.<br/></p><blockquote><em>“Traefik pretty much supports itself. There isn’t much support that we require from outside. Things just work. I absolutely recommend Traefik.”</em></blockquote><h2 id="what-s-next"><br>What’s Next?</br></h2><ul><li>Get started with <a href="https://containous.ghost.io/traefik/" rel="noopener nofollow">Traefik</a> today</li><li>Ready for production deployments? <a href="https://containous.ghost.io/traefikee/">Discover Traefik Enterprise Edition</a>, and <a href="https://info.containo.us/request-demo-traefikee" rel="noopener nofollow">request your demo</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Announcing Maesh 1.1]]></title><description><![CDATA[A few months have passed since the release of Maesh General Availability. During that time we’ve received feedback from you, the community, about use cases you’d like to adopt Maesh for, and we’ve addressed them with this release.]]></description><link>https://traefik.io/blog/traefik-maesh-1-1/</link><guid isPermaLink="false">Ghost__Post__5e5e2d1c3727400038a2fa13</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Mon, 09 Mar 2020 18:42:45 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/04/Maesh1.1-Blog.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2020/04/Maesh1.1-Blog.png" alt="Announcing Maesh 1.1"/><p class="post-sub-title">With Helm Version 3 support and more!</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/03/Blog-Post-1.png" class="kg-image" alt="Announcing Maesh 1.1"/></figure><p>During KubeCon North America 2019 in San Diego, we proudly announced the General Availability for Maesh. Since then, roughly three months have passed. During that time we’ve received feedback from you, the community, about use cases you’d like to adopt Maesh for, and we’ve addressed them with this release.</p><h2 id="helm-version-3-support">Helm Version 3 Support</h2><p>As of November 2019, Helm 3 has been released to the public. Maesh's Helm chart is now Helm v3 compatible, to benefit from all the changes in the internal architecture of Helm v3. As the internal architecture of Helm 3 changed enormously, sadly the change causes breaks, so the current chart is not deployable anymore with Helm 2.</p><p>For more information about Helm 3, <a href="https://helm.sh/blog/helm-3-released/">please check that link</a>.</p><h2 id="application-namespace-support">Application Namespace Support</h2><p>One request we received was to install Maesh along with your other services in the same namespace, instead of having Maesh need to run in its own namespace. With that new release, we're now supporting that scenario. You can now easily install Maesh in the same namespace as your applications which allows for greater flexibility and easier management, especially in multi-tenant Kubernetes clusters. However, of course it's also still supported to install it in a separate namespace and share it between all your applications.</p><h2 id="performance-improvement">Performance Improvement</h2><p>As our Maesh controllers job is to configure the underlying Traefik pods, it needs to make use of the Kubernetes API to get the current state and create a proper configuration. With that release, we reworked the internal architecture of the controller to make use of listers instead of plain API queries. As listers are making use of a local cache, this is a huge performance improvement. Lookups are now made to that cache in milliseconds compared to live HTTP calls, thus reducing the load on your Kubernetes API as well.</p><h2 id="improved-metrics-support">Improved metrics support</h2><p>Version 1.1 brings support for two new metric backends. Starting now,<a href="https://www.influxdata.com/"> InfluxDB</a> and<a href="https://github.com/statsd/statsd"> StatsD</a> can be configured to receive metrics from Maesh. The possible configuration options are best visible in the Helm chart.<a href="https://github.com/dtomcej/maesh/blob/v1.1/helm/chart/maesh/values.yaml"> https://github.com/containous/maesh/blob/v1.1/helm/chart/maesh/values.yaml</a></p><h2 id="traefik-upgrade-to-2-1">Traefik Upgrade to 2.1</h2><p>Last but not least we also upgraded the underlying Traefik that Maesh uses to create the service mesh to the current version of 2.1 to stay up to date and benefits from the improvements that is bringing on its own. The full changelog for Traefik 2.1 can be read here<a href="https://containous.ghost.io/blog/traefik-2-1-in-the-wild/"> https://containo.us/blog/traefik-2-1-in-the-wild/</a></p><h2 id="what-s-next">What’s Next</h2><p>Once again, we are thankful for the multitude of contributors that went straight ahead and added Maesh to their development clusters. You provided us with invaluable and early feedback and made this release possible.</p><p>But, it’s just the beginning! Keep telling us what you like, giving us thoughts and ideas, and keep (or start) contributing! Pull requests and Issues are the best way to support the product and make it your own.</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://containous.ghost.io/maesh/">Website</a></li><li><a href="https://docs.mae.sh/">Documentation</a></li><li><a href="https://github.com/containous/maesh">Github</a></li><li><a href="https://community.containo.us/c/maesh">Community Forum</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Traefik Enterprise Edition 2]]></title><description><![CDATA[Four months after we launched Traefik V2.0, we're happy to announce that the Enterprise Edition is now available and brings its load of dedicated features!]]></description><link>https://traefik.io/blog/traefik-enterprise-edition-2/</link><guid isPermaLink="false">Ghost__Post__5e3999aecf5e3c00386bad49</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Nicolas Mengin]]></dc:creator><pubDate>Wed, 05 Feb 2020 18:24:20 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/04/TraefikEE2.0-Blog.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2020/04/TraefikEE2.0-Blog.png" alt="Traefik Enterprise Edition 2"/><p class="post-sub-title">Twice The High Availability, Scalability, and Security</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2020/02/Containous-TraefikEE-2-0-1.png" class="kg-image" alt="Traefik Enterprise Edition 2"/></figure><p>Four months after we launched <a href="https://containous.ghost.io/blog/traefik-2-0-6531ec5196c2/">Traefik v2.0</a>, we're happy to announce that the <a href="https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days">Enterprise Edition is now available</a>, and it is loaded with Enterprise specific features!</p><p>On top of enabling our users to leverage the <a href="https://containous.ghost.io/blog/traefik-2-1-in-the-wild/">2.1 feature set</a> (TCP routing, middleware, canary, mirroring, enhanced rule syntax, etc.), the Enterprise Edition keeps helping our customers to set up highly available, scalable, and distributed systems.</p><h2 id="what-s-in-traefikee-2-0"><strong>What's in TraefikEE 2.0?</strong></h2><h3 id="improved-high-availability">Improved High Availability</h3><p>One of the core values behind Traefik Enterprise Edition is to secure our customers' infrastructure with a highly available solution. Behind the scenes, this is achieved through the Raft consensus algorithm that allows recovery from component failure.</p><p>But we know from experience, that in some extreme scenarios which combine heavy network latency, multiple failures, and scheduled operations, the quorum of normal state can be lost.</p><p>For this very reason, with TraefikEE 2.0 we've improved the resilience to a temporary quorum loss, and we've introduced a mechanism to enable the cluster to recover – without any downtime – from a single working instance of the controllers, and all it takes is <a href="https://docs.containo.us/operating/disaster-recovery/">a single command line</a>.</p><h3 id="ldap-authentication"><strong>LDAP Authentication</strong></h3><p>Deploying APIs on your cluster often comes with the necessity to manage credentials, either for your business partners or for your teams. And the more APIs you deploy, the more you engage in microservice architectures, the more API management becomes part of your workflow.</p><p>With TraefikEE, we've introduced a way to simplify and centralize authentication with the ability <a href="https://docs.containo.us/middlewares/ldap/">to connect with an LDAP server</a>.</p><p>Declare users, groups, and credentials in your directory, then have TraefikEE deal with authorization on your behalf.</p><p>In the following example, we're connecting TraefikEE to our LDAP server. Then we attach a rule to our service so that only users from the authorized group (with the group id <strong>500</strong>) can use our API.</p><!--kg-card-begin: markdown--><pre><code class="language-yaml"># Static Configuration
authSources:
  mySource:
    ldap:
      url: ldap://ldap.server.addr:389
</code></pre>
<pre><code class="language-yaml">version: '3.4'
services:
  whoami:
    image: containous/whoami
    deploy:
      labels:
        # Dynamic Configuration
        - &quot;traefik.http.routers.whoami.rule=Path(`/whoami`)&quot;
        - &quot;traefik.http.routers.whoami.service=whoami&quot;
        - &quot;traefik.http.services.whoami.loadbalancer.server.port=80&quot;
        - &quot;traefik.http.routers.whoami.middlewares=mymiddleware&quot;
        - &quot;traefik.http.middlewares.mymiddleware.plugin.ldapauth.source=mySource&quot;
        - &quot;traefik.http.middlewares.mymiddleware.plugin.ldapauth.baseDN=dc=example,dc=org&quot;
        - &quot;traefik.http.middlewares.mymiddleware.plugin.ldapAuth.searchFilter=(&amp;(objectClass=inetOrgPerson)(gidNumber=500)(uid=%s))&quot;
</code></pre>
<!--kg-card-end: markdown--><h2 id="customization-made-easy">Customization Made Easy</h2><p>The premise with TraefikEE is that you can setup a cluster of Traefik in one single command line, saving you hours of configuration decisions. But since no infrastructure is the same, some users needed a way to customize many aspects of their architecture during installation.</p><p>TraefikEE 2.0 still comes with a default setup command and it's now possible to generate a pre-configured manifest before the actual installation. With this manifest, users are able to see every available configuration option and tweak every parameter.</p><p>Of course, each manifest is specific to the orchestrator, whether you use <a href="https://docs.containo.us/installing/swarm/">Swarm</a> or <a href="https://docs.containo.us/installing/kubernetes/">Kubernetes</a>.</p><h2 id="dynamic-tls-certificates-management">Dynamic TLS Certificates Management</h2><p>TraefikEE has always been fully <a href="https://docs.containo.us/operating/acme/">integrated with Let’s Encrypt</a>, which has enabled many users to automate certificate generation throughout their cluster.</p><p>But operating a cluster with many applications also means you have to deal with other certificates, whether in-house or bought separately. For such situations, TraefikEE comes with <a href="https://docs.containo.us/operating/tls/">a command line to deploy them dynamically</a>.</p><p>In the following example, we’re adding a <em>whoami.example.com</em> certificate to the cluster.</p><!--kg-card-begin: markdown--><pre><code class="language-bash">$ teectl create tls-cert --cert=mycrt.pem --key=mykey.prem
$ teectl get tls-cert
ID     CN                  SANs  NOT AFTER             STORE    DEFAULT
u7vxw  whoami.example.com        2022-01-22T15:27:25Z  default  false
</code></pre>
<!--kg-card-end: markdown--><h3 id="cli-2-0"><strong>CLI 2.0</strong></h3><p>Operating a Traefik cluster means being able to operate, configure, re-configure, stop and start proxies at will, wherever they are hosted in your infrastructure -- and TraefikEE embeds a CLI (<a href="https://docs.containo.us/references/cli/teectl/">teectl</a>) for this purpose.</p><p>We saw the command line growing to become the main user interface for administrators, and decided it was time to tweak its grammar for more consistency.</p><p>Now (like in Kubernetes), you’ll create, get or delete resources to and from your TraefikEE cluster, like in the previous TLS example.</p><h3 id="redesigned-web-ui"><strong>Redesigned Web UI</strong></h3><p>Inspired by Traefik, the Web UI allows users to have an overview of their cluster's health with just a glance.</p><figure class="kg-card kg-image-card"><img src="https://lh5.googleusercontent.com/ZlLHtYOEgYPOVH-y6BNyG71wYM482AD2RgJRDFnjru0g7MhiXk-Kni8J9LnfagtRmpBzWtsQw8ZERXI2RGAmw8X9_Jo3ElU1KazcPXKvBJBaomqJqIsps-EAFfhl9DTkG1xBzaSh" class="kg-image" alt="Traefik Enterprise Edition 2"/></figure><p>The welcome page contains all the main information. It's the starting point from which you’ll access all the cluster details.</p><figure class="kg-card kg-image-card"><img src="https://lh5.googleusercontent.com/i_uFx15lA7CuEE9mL4JF0tekprysRoqYjh8sdDIyMg7tgg8qhmXgmVe7ovv90cC3f1G-vcZQ62rESuou6W8LNNuPnJ1WbqiRt857KdDJZGIEppBgON7bliBtrXXgHmRrmoKaJ3nj" class="kg-image" alt="Traefik Enterprise Edition 2"/></figure><h2 id="what-s-next"><strong>What's Next?</strong></h2><p>As you can see, TraefikEE not only adds a clustering system on top of Traefik, but it contains additional features designed for enterprise and a CLI to operate the cluster.</p><p>There are many benefits you can get from switching to TraefikEE, and the best is that you can test it for yourself and <a href="https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days">request a free trial license on our website</a> (and to make it simple, the TraefikEE configuration is fully compatible with your existing Traefik configuration).</p><p>And if you still have questions or need help finding a tailored option for your infrastructure, we’ll be happy to discuss it with you, and to <a href="https://info.containo.us/request-demo-traefikee">help you find the best solution for your use case</a>.</p><p><a href="https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days">Try it today</a>, and be sure that we'll continue to pack TraefikEE with new features driven by companies' needs... to make networking boring!</p>]]></content:encoded></item><item><title><![CDATA[Traefik 2.1]]></title><description><![CDATA[Releases keep coming, but this one feels unique to us because this is our very first release since Traefik 2.0, and we've learned a lot! ]]></description><link>https://traefik.io/blog/traefik-2-1-in-the-wild/</link><guid isPermaLink="false">Ghost__Post__5def57371efbbd0038ef55ec</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Thu, 12 Dec 2019 13:03:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/04/Traefik2.1-Blog.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2020/04/Traefik2.1-Blog.png" alt="Traefik 2.1"/><p class="post-sub-title">2.X in the Wild</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/12/traefik-cantal-flat.png" class="kg-image" alt="Traefik 2.1"/></figure><p>Releases keep coming, but this one feels unique to us because this is our very first release since Traefik 2.0, and we've learned a lot! </p><p>We all know it, <em>you</em> all know it: Traefik 2.0 consisted in a fest of new features: TCP, middleware, rule syntax, YAML support, CRDs, WebUI, canary, mirroring, provider namespaces, new documentation, and many other inconspicuous changes that will help us building the product we love towards greater heights.</p><p>All this was accompanied by tools to help the community seamlessly make the transition: We developed a <a href="https://github.com/containous/traefik-migration-tool">migration tool</a>,  launched a <a href="https://community.containo.us/">community forum</a> to foster good communication and support, wrote new tutorials to help people have a <a href="https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/">fresh start with Traefik</a> (including <a href="https://containous.ghost.io/blog/traefik-2-tls-101-23b4fbee81f1/">details about new TLS options</a>), and of course we added a <a href="https://docs.traefik.io/migration/v1-to-v2/">migration guide in our documentation</a>. </p><p>Thanks to the (immense) feedback we got from the community, we know we can do <em>even</em> better, and we were given some pointers in the right direction.</p><p>But before we talk about what we've learned and how we'll leverage this knowledge, let's talk about the changes introduced in 2.1. </p><h2 id="consul-catalog-is-back-">Consul Catalog Is Back!</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/consul-catalog.png" class="kg-image" alt="Traefik 2.1"/></figure><p>Great news for Consul Catalog fans, Traefik 2.1 brings it back in the list of <a href="https://docs.traefik.io/v2.1/providers/overview/#supported-providers">supported providers</a>! (But stay on hold because I know for sure that <a href="https://github.com/containous/traefik/pull/5899">others will follow suit</a>.)</p><h2 id="improving-the-crd">Improving the CRD</h2><h3 id="stickiness">Stickiness</h3><p>The stickiness option is the ability for a load balancer to keep using the same target for a client once it has been sent to one. This option is now available for our CRD users!</p><pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: myName
  namespace: myNamespace
spec:
  entryPoints:
  - web
  routes:
  - kind: Rule
    match: Host(`some-domain`)
    services:
    - kind: Service
      name: myService
      namespace: myNamespace
      port: 80
      sticky:
        cookie: {} # Once a pod is selected for a client, it will stay the same for future calls</code></pre><h3 id="service-load-balancing-mirroring">Service Load Balancing &amp; Mirroring</h3><p>Introduced in 2.0, service load balancing and mirroring were previously exclusively configurable using the <a href="https://docs.traefik.io/v2.0/providers/file/">file provider</a>. With 2.1 and the introduction of the <code>TraefikService</code> object, we leveraged Traefik's CRD to enable such configuration in Kubernetes, and here is a first example with mirroring:</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/image-18.png" class="kg-image" alt="Traefik 2.1"/></figure><pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: my-route-to-mirroring
  namespace: default

spec:
  entryPoints:
    - web
  routes:
  - match: Host(`some-domain`) &amp;&amp; PathPrefix(`/some/path`)
    kind: Rule
    services:
    - name: mirroring-example #targets the mirroring-example service
      namespace: default
      kind: TraefikService # we want to target the TraefikService we've declared (and not a K8S service named mirroring-example)
---
apiVersion: traefik.containo.us/v1alpha1
kind: TraefikService
metadata:
  name: mirroring-example
  namespace: default
spec:
  mirroring:
    name: v1 #sends 100% of the requests to the K8S service "v1" ...
    mirrors:
      - name: v2 # ... and sends a copy of 10% of the requests to v2
        percent: 10
        port: 80</code></pre><p>For our second example, let's see how we could use service load balancing to do canary deployments:</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/image-19.png" class="kg-image" alt="Traefik 2.1"/></figure><pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: my-route-to-canary
  namespace: default
spec:
  entryPoints:
    - web
  routes:
  - match: Host(`some-domain`) &amp;&amp; PathPrefix(`/some/path`)
    kind: Rule
    services:
    - name: mirror1
      namespace: default
      kind: TraefikService
---
apiVersion: traefik.containo.us/v1alpha1
kind: TraefikService
metadata:
  name: canary-example
  namespace: default

spec:
  weighted:
    services:
      - name: v1
        weight: 80
        port: 80
      - name: v2
        weight: 20
        port: 80</code></pre><p>We can now change the weight for each service (v1 and v2) at will!</p><h3 id="mixing-regular-kubernetes-services-with-traefikservices">Mixing Regular (Kubernetes) Services with TraefikServices</h3><p>When you define a target (with the <code>name</code> attribute) for your <code>IngressRoute</code>, by default, it targets a regular <code>Service</code>. If you want to target the new <code>TraefikService</code> objects, you just specify the <code>kind</code> attribute. What's great with this system is that you can chain and combine them at will, creating intricate patterns depending on your needs.</p><p>Below is an example that leverages both services and <code>TraefikServices</code>, and that uses mirroring and service load balancing at the same time!</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/canary-and-mirroring.png" class="kg-image" alt="Traefik 2.1"/></figure><pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: route-to-mirroring
  namespace: default
spec:
  entryPoints:
    - web
  routes:
  - match: Host(`some-domain`) &amp;&amp; PathPrefix(`/some/path`)
    kind: Rule
    services:
    - name: mirroring-example
      namespace: default
      kind: TraefikService
---
apiVersion: traefik.containo.us/v1alpha1
kind: TraefikService
metadata:
  name: mirroring-example
  namespace: default
spec:
  mirroring:
    name: canary-example
    kind: TraefikService
    mirrors:
      - name: service-mirror
        percent: 20
        port: 80
---
apiVersion: traefik.containo.us/v1alpha1
kind: TraefikService
metadata:
  name: canary-example
  namespace: default
spec:
  weighted:
    services:
      - name: v1
        port: 80
        weight: 80
      - name: v2
        weight: 20
        port: 80</code></pre><h3 id="note-on-updating-the-crd-for-2-1">Note on Updating the CRD for 2.1</h3><p>While updating an installation to v2.1, it is required to apply the new CRD and to enhance the existing <code>ClusterRole</code>definition. You will find out how in the <a href="https://docs.traefik.io/migration/v2/">following guide</a>.</p><h2 id="more-control-on-internal-routing">More Control On Internal Routing</h2><p>In 2.0, we've made changes to make sure people would be able to properly secure some critical services offered by Traefik, like the API and the Dashboard (you can see an example in our <a href="https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/">Traefik &amp; Docker 101 article</a>).</p><p>Pursuing the ability to configure internal services further while always giving users more control, the 2.1 dashboard now shows the internal routers and services involved.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/12/Screenshot_2019-12-10-Traefik.png" class="kg-image" alt="Traefik 2.1"><figcaption>Shows the internal services for the API and the Dashboard</figcaption></img></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/12/Screenshot_2019-12-10-Traefik-1-.png" class="kg-image" alt="Traefik 2.1"><figcaption>Shows the internal routers leading to the internal API and Dashboard services (when users don't explicitly configure them)</figcaption></img></figure><p>We also jumped on the opportunity to add other configurable services to the list, namely <code>rest@internal</code>, <code>ping@internal</code>, and <code>prometheus@internal</code>. </p><hr><h2 id="migrating-to-2-x-made-easy">Migrating to 2.X Made Easy</h2><p>With so many new options to customize Traefik to your every need, we understand that some people can be a bit lost when migrating to 2.x, especially since Traefik is the kind of software that you run and forget (because it works nights and days without any other intervention from its users).</p><blockquote>We have been working really hard to make this migration a matter of minutes.</blockquote><p>So, if you're thinking about migrating but haven't jumped on the task yet, we want to point you in the right direction:</p><ul><li><a href="https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/">This guide</a> helps you truly understand how Traefik 2 works on a Docker setup and will show you that 5 minutes are enough to have a good grasp of what you can do with it.</li><li>If you're looking for information about how to configure HTTPS / TLS, <a href="https://containous.ghost.io/blog/traefik-2-tls-101-23b4fbee81f1/">we have you covered with this guide</a>!</li><li>If you don't want to lose time converting your Ingress objects in Kubernetes (who would want that?), we've developed a <a href="https://github.com/containous/traefik-migration-tool">migration tool</a> that will handle it for you.</li><li>Same goes with your <code>traefik.toml</code> file: the <a href="https://github.com/containous/traefik-migration-tool">migration tool</a> can convert it for you.</li><li>Oh, and the <a href="https://github.com/containous/traefik-migration-tool">migration tool</a> can also convert your <code>acme.json</code> certificate file.</li><li>And always feel free to engage conversation in our <a href="https://community.containo.us">community forum</a>, we read <em>everything</em> and do our best to provide answers when we can.</li></ul><hr><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/2-year-warranty.jpg" class="kg-image" alt="Traefik 2.1"/></figure><h2 id="supporting-the-1-x-branch-for-two-years-">Supporting the 1.X Branch for Two Years!</h2><p>Our community matters, and we don't want our users to feel rushed to migrate to version 2. We prefer seeing people slowly falling in love with the new tools Traefik has to offer and migrate. For this reason, we've decided to extend the support of the 1.X version until the end of 2021. </p><p>That's right: you have <strong>two years</strong> ahead of you before you need to make the leap! (And we believe you'll find benefits in migrating to 2.X <em>way</em> <em>before</em> that.)</p><hr><h2 id="next-focusing-on-the-user-experience">Next? Focusing on the User Experience</h2><p>In the introduction, we've stated that we received (and are still receiving) a lot of feedback about 2.0. And let me tell you:</p><blockquote>We listen</blockquote><p>Apart from bringing extra features in the next release (like UDP, HTTP/3, Key-Value Stores, and the list goes on ...), we want to focus this release on the user experience.</p><p>Now that we've seen people massively use Traefik 2, we decided it's time to work on making powerful features simpler to configure, or at least ... less verbose. </p><p>So, let's work together on making it happen! Come and raise your voice in the <a href="https://github.com/containous/traefik/issues">issue tracker</a>, on the <a href="https://community.containo.us">community forum</a>, or better—<a href="https://github.com/containous/traefik/pulls">pull request</a> your way into making Traefik a better tool for everyone.</p><p>See you around, and happy Traefik!</p></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Maesh 1.0]]></title><description><![CDATA[Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic.]]></description><link>https://traefik.io/blog/maesh-1-0-802f4be9a9a7/</link><guid isPermaLink="false">Ghost__Post__5dd68f68b6de2b00381d3f6b</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Thu, 21 Nov 2019 13:21:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/maesh-1.0.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/maesh-1.0.png" alt="Maesh 1.0"/><p class="post-sub-title">Simpler Service Mesh, Now Production Ready</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/1_iap46n1HJlw_lNotg3MtzA.png" class="kg-image" alt="Maesh 1.0"/></figure><p>Three months ago (in September 2019) we were <a href="https://containous.ghost.io/blog/announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29/">proud to unleash Maesh</a>, the simpler service mesh. With so many tools already available on the market, we couldn’t wait to see how the community would react to our vision of the concept.</p><p>The answer is — incredibly well. In less than a month, Maesh had gathered a community of people that adopted it right from the start on their development cluster. These brave early adopters provided us with invaluable insights about various cluster configurations and shed light on possible improvements. We listened the best we could, helped them contribute to the project, fixed what had to be fixed, and we’re now contemplating the result of this common effort — <strong><strong>Maesh 1.0</strong></strong></p><h2 id="what-is-maesh">What is Maesh?</h2><p>Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic. Maesh is designed from the ground up to be straightforward, easy to install, and easy to use.</p><p>Built on top of Traefik, Maesh is a simple, yet full-featured service mesh. It fits as your de-facto service mesh in your Kubernetes cluster and supports the latest Service Mesh Interface specification (<a href="https://smi-spec.io/" rel="noopener">SMI</a>) that facilitates integration with pre-existing solutions. Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.</p><p>Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. Not using sidecars means that Maesh does not modify your Kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-20.png" class="kg-image" alt="Maesh 1.0"/></figure><h2 id="what-s-new-since-the-alpha">What’s New since the Alpha?</h2><h3 id="performance-improvements">Performance Improvements</h3><p>Based on feedback, we started to rework the inner architecture of Maesh to improve performance and stability. In particular, we made the Maesh controller stateless (again) and refactored the internal architecture used to refresh the configuration. As a result Maesh reacts faster and is more resilient to changes. To make it easier to customize, <a href="https://github.com/containous/maesh/blob/master/helm/chart/maesh/values.yaml" rel="noopener">plenty of options</a> are now configurable (namespaces, the cluster domain, …).</p><h3 id="gke-support">GKE Support</h3><p>Many of our early adopters tried to install Maesh (alpha) on GKE with no success. The reason was that Maesh relied on CoreDNS to opt-in into the usage of the internal mesh and that GKE doesn’t embed it.</p><p>As a result and to support GKE and distributions that do not ship with CoreDNS, we’ve added support for kube-dns.</p><p>For Maesh 1.0, we’ve tested many distributions but couldn’t test every one of them. If your favorite appears to be unsupported, please raise your voice and help us fixing that!</p><h3 id="support-for-the-smi-tcproute">Support for the SMI TCPRoute</h3><p>Maesh supported the SMI HTTP part from the beginning, and now supports the TCP portion as well. (Bellow is an example of an SMI TCPRoute.)</p><pre><code class="language-yaml">kind: TrafficTarget
apiVersion: access.smi-spec.io/v1alpha1
metadata:
  name: api-service-target
  namespace: default
destination:
  kind: ServiceAccount
  name: api-service
  namespace: default
specs:
- kind: TCPRoute
  name: my-tcp-route
sources:
- kind: ServiceAccount
  name: my-other-service
  namespace: default
---
apiVersion: specs.smi-spec.io/v1alpha1
kind: TCPRoute
metadata:
  name: my-tcp-route</code></pre><!--kg-card-begin: markdown--><pre><code>kind: TrafficTarget
apiVersion: access.smi-spec.io/v1alpha1
metadata:
  name: api-service-target
  namespace: default
destination:
  kind: ServiceAccount
  name: api-service
  namespace: default
specs:
- kind: TCPRoute
  name: my-tcp-route
sources:
- kind: ServiceAccount
  name: my-other-service
  namespace: default
---
apiVersion: specs.smi-spec.io/v1alpha1
kind: TCPRoute
metadata:
  name: my-tcp-route
</code></pre>
<!--kg-card-end: markdown--><hr><h2 id="what-s-next">What’s Next</h2><p>Once again, we are thankful for the multitude of contributors that went straight ahead and added Maesh to their development clusters. You provided us with invaluable and early feedback and made this release possible.</p><p>But it’s just the beginning! Keep telling us what you like, giving us thoughts and ideas, and keep (or start) contributing! Pull requests and Issues are the best way to support the product and make it your own.</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://containous.ghost.io/maesh/">Website</a></li><li><a href="https://docs.mae.sh/">Documentation</a></li><li><a href="https://github.com/containous/maesh" rel="noopener">Github</a></li><li><a href="https://community.containo.us/c/maesh" rel="noopener">Community Forum</a></li></ul></hr>]]></content:encoded></item><item><title><![CDATA[Traefik 2 & TLS 101]]></title><description><![CDATA[You have an HTTP service exposed through Traefik, and you want Traefik to deal with the HTTPS burden (TLS termination)...]]></description><link>https://traefik.io/blog/traefik-2-tls-101-23b4fbee81f1/</link><guid isPermaLink="false">Ghost__Post__5dcdfa6f2345360038abe218</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Thu, 14 Nov 2019 08:07:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/Traefik-2---TLS-101-x-Docker---Blog-Post-@2x-2.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/Traefik-2---TLS-101-x-Docker---Blog-Post-@2x-2.png" alt="Traefik 2 & TLS 101"/><p class="post-sub-title">HTTPS (& TCP over TLS) for everyone!</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-103.png" class="kg-image" alt="Traefik 2 & TLS 101"/></figure><p>There are hundreds of reasons why I love being a developer (besides memories of sleepless nights trying to fix a video game that nobody except myself would ever play).</p><p>Being a developer gives you superpowers — you can solve any kind of problems. Yes, especially if they don’t involve real-life practical situations.</p><p>But these superpowers are sometimes hindered by tedious configuration work that expects you to master <em><em>yet another</em></em> arcane language assembled with heaps of words you’ve never seen before. Such a barrier can be encountered when dealing with HTTPS and its certificates.</p><p>Luckily for us, Traefik tends to lower this kind of hurdle and makes sure that there are easy ways of securely connecting your developments to the outside world.</p><h2 id="the-goal-for-today">The Goal for Today</h2><p>The challenge we’ll accept is the following — You have an HTTP service exposed through Traefik, and you want Traefik to deal with the HTTPS burden (TLS termination), leaving your pristine service unspoiled by mundane technical details.</p><p>We’ll assume you have a basic understanding of Traefik on Docker and that you’re familiar with its configuration (if not, it’s time to read <a href="https://containous.ghost.io/blog/traefik-2-0-docker-101-fc2893944b9d/">Traefik 2 &amp; Docker 101</a>).</p><p>During this article, we’ll use my pet demo docker-compose file: it enables the docker provider and launches a <code>my-app</code> application that allows us to test any request.</p><pre><code class="language-yaml">version: "3"
services:
  traefik:
    image: "traefik:v2.0"
    command:
      - --entrypoints.web.address=:80
      - --providers.docker=true
    ports:
      - "80:80"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
  
  my-app:
    image: containous/whoami:v1.3.0</code></pre><h2 id="getting-things-ready">Getting Things Ready</h2><p>First things first, let’s make sure our setup can handle HTTPS traffic on the default port (<code>:443</code>), and that Traefik listens to this port thanks to an <a href="https://docs.traefik.io/routing/entrypoints/" rel="noopener nofollow">entrypoint</a> we’ll name <code>web-secure</code>.</p><pre><code class="language-yaml">version: "3"
services:
  traefik:
    image: "traefik:v2.0"
    command:
      - --entrypoints.web.address=:80
      - --entrypoints.web-secure.address=:443 #Declares the web-secure entrypoint in Traefik
      - --providers.docker=true
    ports:
      - "80:80"
      - "443:443" #Docker sends requests on port 443 to Traefik on port 443
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
  
  my-app:
    image: containous/whoami:v1.3.0</code></pre><p>To avoid confusion, let’s state the obvious — We haven’t yet configured anything but enabled requests on 443 to be handled by Traffic. So, no certificate management yet!</p><h2 id="general-concepts">General Concepts</h2><p>Ultimately, in Traefik, you configure HTTPS on the <a href="https://docs.traefik.io/routing/routers/" rel="noopener nofollow">router</a> level. While defining routes, you decide whether they are HTTP routes or HTTPS routes (by default, they are HTTP routes).</p><p>First, let’s expose our <code>my-app</code> service on HTTP so that it handles requests on domain <code>example.com</code>.</p><pre><code class="language-yaml">version: "3"

services:
  # ...
  my-app:
    image: containous/whoami:v1.3.0
    labels:
      - "traefik.http.routers.my-app.rule=Host(`example.com`)"</code></pre><p>And now, see what it takes to make this route HTTPS only!</p><pre><code class="language-yaml">version: "3"

services:
  # ...
  my-app:
    image: containous/whoami:v1.3.0
    labels:
      - "traefik.http.routers.my-app.rule=Host(`example.com`)"
      - "traefik.http.routers.my-app.tls=true"</code></pre><p>There, by adding the <code>tls</code> option to the route, we’ve made it HTTPS.</p><p>The only unanswered question left is, “Where does Traefik get its certificates from?” And the answer is, “Either from a collection of certificates you own and have configured or from a fully automatic mechanism that gets them for you.”</p><p>Let’s see these solutions in action!</p><hr><h2 id="option-1-certificates-you-own">Option 1 — Certificates You Own</h2><p>The least magical of the two options involves creating a configuration file.</p><p>Say you already own a certificate for a domain (or a collection of certificates for different domains) and that you are then the proud holder of files to claim your ownership of the said domain.</p><p>To have Traefik make a claim on your behalf, you’ll have to give it access to the certificate files. Let’s do this.</p><h3 id="add-a-configuration-file-for-certificates">Add a Configuration File for Certificates<br/></h3><pre><code class="language-yaml">version: "3"

services:
  traefik:
    image: "traefik:v2.0"
    command:
      - --entrypoints.web.address=:80
      - --entrypoints.web-secure.address=:443
      - --providers.docker=true
      - --providers.file.directory=/configuration/
      - --providers.file.watch=true
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "/home/username/traefik/configuration/:/configuration/"</code></pre><p>Traefik runs with many providers beyond Docker (i.e., <a href="https://docs.traefik.io/providers/kubernetes-crd/" rel="noopener nofollow">Kubernetes</a>, <a href="https://docs.traefik.io/providers/rancher/" rel="noopener nofollow">Rancher</a>, <a href="https://docs.traefik.io/providers/marathon/" rel="noopener nofollow">Marathon</a>), and here we chose to add plain old configuration files (<code>--providers.file</code>) in the <code>configuration/</code> directory (and we’ll automatically reload changes with <code>--providers.file.watch=true</code>). We’ll use a configuration file to declare our certificates.</p><h3 id="add-the-certificates-to-the-configuration-file">Add the Certificates to the Configuration File</h3><pre><code class="language-toml"># in files/certificates.toml

[[tls.certificates]] #first certificate
   certFile = “/path/to/example-com.cert” 
   keyFile = “/path/to/example-com.key”

[[tls.certificates]] #second certificate
   certFile = “/path/to/other.cert” 
   keyFile = “/path/to/other.key”
   
# and so on</code></pre><p>Now that we have our TOML configuration file available (thanks to the enabled file provider), we can fill in certificates in the <code>[[tls.certificates]]</code>section.</p><h3 id="enjoy-">Enjoy!</h3><p>This is all there is to do. When dealing with an HTTPS route, Traefik goes through your default certificate store to find a matching certificate.</p><h3 id="specifying-a-default-certificate">Specifying a Default Certificate?</h3><p>If no valid certificate is found, Traefik serves a default auto-signed certificate. But if needed, you can customize the default certificate like so:</p><pre><code class="language-toml">[tls.stores]
  [tls.stores.default]
   [tls.stores.default.defaultCertificate] 
     certFile = “path/to/cert.crt” 
     keyFile = “path/to/cert.key”</code></pre><h3 id="additional-thoughts">Additional Thoughts</h3><p>Even though the configuration is straightforward, it is your responsibility, as the administrator, to configure / renew your certificates when they expire. If you don’t like such constraints, keep reading!</p><hr><h2 id="option-2-dynamic-automatic-certificates">Option 2 — Dynamic / Automatic Certificates</h2><p>Having to manage (buy/install/renew) your certificates is a process you might <em><em>not</em></em> enjoy (I don’t). If so, you’ll be interested in the automatic certificate generation embedded in Traefik (thanks to Let’s Encrypt).</p><p>Long story short, you can start Traefik with no other configuration than your Let’s Encrypt account, and Traefik automatically negotiates (get/renew/configure) certificates for you — No extra step.</p><h3 id="certificate-resolvers">Certificate Resolvers</h3><p>We saw that you can configure a router to use TLS<br>(<code>--traefik.http.routers.router-name.tls=true</code>). <br>As a consequence, we saw that Traefik would go through your certificate list to find a suitable match for the domain at hand (and if not would use a default certificate).</br></br></p><p>For automatic certificate generation, you can add a <em><em>certificate resolver</em></em> to your TLS options. A certificate resolver is responsible for retrieving certificates.</p><p>Here, let’s define a certificate resolver that works with your Let’s Encrypt account!</p><pre><code class="language-yaml">services:
  traefik:
    image: "traefik:v2.0"
    command:
      - --entrypoints.websecure.address=:443
      # ...
      - --certificatesresolvers.le.acme.email=my@email.com
      - --certificatesresolvers.le.acme.storage=/acme.json
      - --certificatesresolvers.le.acme.tlschallenge=true
      # ...</code></pre><p>As you can read, we defined a certificate resolver named <code>le</code> of type <code>acme</code>. Then, we provided an email (your Let’s Encrypt account), the storage file (for certificates it retrieves), and <a href="https://docs.traefik.io/https/acme/#the-different-acme-challenges" rel="noopener nofollow">the challenge for certificate negotiation</a>(here <code>tlschallenge</code>, just because it’s the most concise configuration option for the sake of the example).</p><p>From now on, Traefik is fully equipped to generate certificates for you!</p><h3 id="using-the-certificate-resolver">Using the Certificate Resolver</h3><p>If you remember correctly (I’m sure you do!), we enabled TLS on our router like so:</p><pre><code class="language-yaml">version: "3"

services:
  # ...
  my-app:
    image: containous/whoami:v1.3.0
    labels:
      - "traefik.http.routers.my-app.rule=Host(`example.com`)"
      - "traefik.http.routers.my-app.tls=true"</code></pre><p>Now, to enable our certificate resolver and have it automatically generate certificates (when needed), we’ll add it to the TLS configuration, like so:</p><pre><code class="language-yaml">version: "3"

services:
  # ...
  my-app:
    image: containous/whoami:v1.3.0
    labels:
      - "traefik.http.routers.my-app.rule=Host(`example.com`)"
      - "traefik.http.routers.my-app.tls=true"
      - "traefik.http.routers.my-app.tls.certresolver=le"</code></pre><p>Now, if your certificate store doesn’t yet have a valid certificate for <code>example.com</code>, the <code>le</code> certificate resolver will transparently negotiate one for you — it’s that simple.</p><h3 id="multiple-certificate-resolvers">Multiple Certificate Resolvers?</h3><p>With certificate resolvers, you can configure different challenges.</p><p>Below is an example that shows how to configure two CertResolvers that leverage Let’s Encrypt, one using the <a href="https://docs.traefik.io/https/acme/#dnschallenge" rel="noopener nofollow">dnsChallenge</a>, the other using the <a href="https://docs.traefik.io/https/acme/#tlschallenge" rel="noopener nofollow">tlsChallenge</a>.</p><pre><code class="language-toml">[certificatesResolvers.resolver-digital-ocean.acme]
  # ... 
  [certificatesResolvers.resolver-digital-ocean.acme.dnsChallenge]
    provider = "digitalocean"
    delayBeforeCheck = 0

[certificatesResolvers.tls-challenge-resolver.acme]
  # ...
  [certificatesResolvers.tls-challenge-resolver.acme.tlsChallenge]</code></pre><p>Later on, you’ll be able to use one or the other on your routers.</p><pre><code class="language-toml"># in routers.toml

[http.routers]
  [http.routers.https-route]
    rule = "Host(`my.domain`)"
    [http.routers.https-route.tls]
      certResolver = "resolver-digital-ocean"

[http.routers.https-route-2]
    rule = "Host(`other.domain`)"
    [http.routers.https-route-2.tls]
      certResolver = "tls-challenge-resolver"</code></pre><p>In the above example (that uses the file provider), we’ve asked Traefik to generate certificates for <code>my.domain</code> using the dnsChallenge (with digital ocean) and to generate certificates for <code>other.domain</code> using the TLSChallenge.</p><p>And you’ve guessed it already — Traefik supports DNS challenge for different DNS providers, <em><em>at the same time</em></em>!<br/></p><hr><h2 id="wildcard-and-let-s-encrypt">Wildcard and Let’s Encrypt?</h2><p>Instead of generating a certificate for each subdomain, you can choose to generate wildcard certificates!</p><pre><code class="language-toml">[http.routers]
  [http.routers.router-example]
    rule = "Host(`something.my.domain`)"
    [http.routers.router-example.tls]
      certResolver = "my-resolver"
      [[http.routers.router-example.tls.domains]]
        main = "my.domain"
        sans = "*.my.domain"</code></pre><p>In the above example, we’ve configured Traefik to generate a wildcard certificate for <code>*.my.domain</code>.</p><p>If we had omitted the <code>.tls.domains</code> section, Traefik would have used the host (here <code>something.my.domain</code>) defined in the <code>Host</code> rule to generate a certificate.</p><hr><h2 id="what-about-tcp-tls">What About TCP &amp; TLS?</h2><p>If you want to configure TLS with TCP, then good news: nothing changes, you’ll configure the same <code>tls</code> option, but this time on your <code>tcp</code> router.</p><pre><code class="language-yaml">version: "3"

services:
  # ...
  my-tcp-app:
    image: containous/whoamitcp:v1.0.0
    labels:
      - "traefik.tcp.routers.my-tcp-app.rule=HostSNI(`tcp-example.com`)"
      - "traefik.tcp.routers.my-tcp-app.tls=true"</code></pre><hr><h2 id="what-about-pass-through">What About Pass-Through?</h2><p>Sometimes your services handle TLS by themselves. In such cases, Traefik mustn’t terminate the TLS connection but forward the request “as is” to these services. To configure this passthrough, you’ll need to configure a TCP router (even if your service handles HTTPS).</p><pre><code class="language-yaml">version: "3"

services:
  # ...
  my-tcp-app:
    image: containous/whoamitcp:v1.0.0
    labels:
      - "traefik.tcp.routers.my-tcp-app.rule=HostSNI(`tcp-example.com`)"
      - "traefik.tcp.routers.my-tcp-app.tls.passthrough=true"</code></pre><hr><h2 id="questions-where-to-go-next">Questions? Where to Go Next?</h2><p>Hopefully, this article sheds light on how to configure Traefik 2 with TLS.</p><p>If there are missing use cases or still unanswered questions, let me know in the comments or on the <a href="https://community.containo.us/c/traefik/traefik-v2" rel="noopener nofollow">community forum</a>!</p><p>In the meantime — Happy Traefik!</p></hr></hr></hr></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[eBay Classifieds Group chooses Traefik to achieve load balancing at scale]]></title><description><![CDATA[eBay Classifieds Group is a global collection of local brands that aim to create connected commerce, enabled by people, supported by technology and open for everyone. ]]></description><link>https://traefik.io/blog/ebay-classifieds-group-chooses-traefik-to-achieve-load-balancing-at-scale-f1332fcc9fbb/</link><guid isPermaLink="false">Ghost__Post__5dcdfe132345360038abe28c</guid><category><![CDATA[Blog]]></category><category><![CDATA[Case Studies]]></category><dc:creator><![CDATA[Marie Ponseel]]></dc:creator><pubDate>Wed, 13 Nov 2019 08:23:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/Blog-Post_eBay-Study@2x-1.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-104.png" class="kg-image" alt="eBay Classifieds Group chooses Traefik to achieve load balancing at scale"/></figure><h2 id="about-ebay-classifieds-group">About eBay Classifieds Group</h2><img src="https://containous.ghost.io/content/images/2019/11/Blog-Post_eBay-Study@2x-1.png" alt="eBay Classifieds Group chooses Traefik to achieve load balancing at scale"/><p>eBay Classifieds Group is a global collection of local brands that aim to create connected commerce, enabled by people, supported by technology and open for everyone. Our sites in 14 countries help people find whatever they’re looking for in their local communities — whether it’s a job, an apartment, a sofa, a car, a concert ticket, financial services or new friends. Every connection made or item found makes a difference by creating a world where people share more and waste less. People who want to trade visit our sites because they’re fun, easy to use and built on trust.</p><h2 id="overview">Overview</h2><p>Wim Fournier, Site Reliability Engineer at eBay Classifieds Group (eCG), is part of a team who manages the infrastructure platform for the classifieds platforms. eCG Benelux’s platform supports over 12 million unique monthly users, and 15 million live listings, with unique requirements to handle peak traffic daily. There is no “off-peak” day for eBay Classifieds Group’s Benelux platforms — 100% uptime is a must. On a weekly basis hundreds of improvements are released to constantly make trading on the platform easier, effortless and most of all fun.</p><p>Wim’s team’s mission is to help development teams become self sufficient and make their jobs easier. They create tools to simplify infrastructure provisioning, deploy applications seamlessly, and manage configurations easily. Ultimately, they are in charge of building and maintaining all internal infrastructure platforms in order to offer end-users a good and consistent experience.</p><h2 id="challenge">Challenge</h2><p>The challenge is to provide excellent online service accessible by anyone from anywhere, with the best trading experience for each and every customer. Wim’s team specifically is chartered to deliver a platform that is capable of handling traffic peaks and scale according to demand, ensuring that the marketplace is always available when anybody wants to buy or sell anything.</p><p>The platform is a containerized set of microservices, deployed to the cloud, to take advantage of the scalability and availability offered by cloud resources. This platform is quite large, hosting and managing hundreds of microservices.</p><p>Routing and load balancing in a dynamic and complex environment was a real challenge for Wim’s team. Their original approach consisted of Fabio as a traditional load balancer, in conjunction with a hardware load balancer, and Nomad as their orchestrator. This setup did not scale anymore to meet the routing and configuration flexibility they needed, leading them to explore other edge routing solutions.</p><p>Wim’s team needed a solution that could easily handle routing external and internal traffic flow with no bottlenecks or scalability issues, while enabling them to easily configure multiple advanced routes per service.</p><blockquote><em><em>“We needed an advanced load balancer and an API Gateway for advanced routing to control traffic flow with flexible configuration and automation capabilities. This complexity makes it difficult to find a good load balancer. A load balancer per domain was not enough for us.”</em></em></blockquote><h2 id="solution">Solution</h2><p>Wim’s teams platform strategy is to make things as simple as possible and to have as few components as possible.</p><p>The team researched and conducted an extensive evaluation across a wide range of competitive software-based products in the market. Traditional solutions for routing and load balancing are very configuration based, and lacked the ability to handle the complexity of a dynamic and advanced configuration system. Meanwhile, many of the new, modern alternative products are either great at load balancing (TLS management, Websocket, HTTP2…), or as an API gateway (Advanced HTTP routing, canary, observability…), but rarely do both effectively.</p><p>eCG found Traefik was very well suited to natively support its requirements. Traefik offers an all-in-one product that is easy to use, configure and scales perfectly for the volume of traffic eCG Benelux sees on a daily basis. Traefik also integrates with core technologies eCG is using across the company, such as Docker for containers, Nomad for orchestration, and Consul for service configuration management.</p><blockquote><em><em>“We were looking for both a load balancer and an API Gateway that is easy to configure, scale, and secure.”</em></em></blockquote><p>eCG uses Traefik for load balancing and as an API Gateway to route external and internal traffic. Traefik is today deployed across various platforms.</p><p>Wim’s team has hundreds of services running behind the API Gateway. Since deploying Traefik nearly a year ago, they have achieved zero downtime while handling traffic peak of 22k requests per second. In terms of configuration, Traefik’s ability to react to their dynamic environment by automatically configuring itself accelerates and simplifies deployments without having manually touch or configure anything.</p><p>eCG favors open source software for its infrastructure because it gives them the ability to change the product if needed. The fact that they are not locked-in with any vendor and can contribute to open source software is very important for Wim’s team. Traefik open source software gives eCG full access to the source code and the opportunity to implement changes if needed.</p><blockquote><em><em>“Traefik gives us flexibility and avoid any vendor lock-in.”</em></em></blockquote><h2 id="bottom-line">Bottom Line</h2><p>Wim’s team has been able to improve development velocity and operational efficiency with Traefik by saving their team hours of work on configuration tasks, while achieving 24x7 availability across the entire Benelux.</p><h2 id="what-s-next">What’s Next?</h2><ul><li>Get started with <a href="https://containous.ghost.io/traefik/" rel="noopener nofollow">Traefik</a> today</li><li>Ready for production deployments? <a href="https://containous.ghost.io/traefikee/" rel="noopener nofollow">Discover TraefikEE</a>, and <a href="https://info.containo.us/request-demo-traefikee" rel="noopener nofollow">request your demo</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Traefik and Docker: A Discussion with Docker Captain, Bret Fisher]]></title><description><![CDATA[During the past summer, we had an interesting discussion about Traefik andDocker with Bret Fisher, the creator of “Docker Mastery” and part of theDocker Captain program.]]></description><link>https://traefik.io/blog/traefik-and-docker-a-discussion-with-docker-captain-bret-fisher-7f0b9a54ff88/</link><guid isPermaLink="false">Ghost__Post__5dce00062345360038abe2aa</guid><category><![CDATA[Blog]]></category><category><![CDATA[Community]]></category><dc:creator><![CDATA[Damien Duportal]]></dc:creator><pubDate>Tue, 22 Oct 2019 08:31:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/Traefik-and-Bret-Fisher-1.jpg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/Traefik-and-Bret-Fisher-1.jpg" alt="Traefik and Docker: A Discussion with Docker Captain, Bret Fisher"/><p class="post-sub-title">Bret Fisher is the creator of “Docker Mastery” and part of the Docker Captain program.</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/Traefik-and-Bret-Fisher-1-1.jpg" class="kg-image" alt="Traefik and Docker: A Discussion with Docker Captain, Bret Fisher"/></figure><p>During the past summer, we had an interesting discussion about<a href="https://containous.ghost.io/traefik/"> Traefik</a> and <a href="https://events.docker.com/events/details/docker-san-francisco-presents-traefik-v20-in-docker-containerd-updates/" rel="noopener nofollow">Docker</a> with Bret Fisher, the creator of “<a href="https://www.bretfisher.com/courses/" rel="noopener nofollow">Docker Mastery</a>” and part of the <a href="https://www.docker.com/community/captains" rel="noopener nofollow">Docker Captain</a> program.</p><p>We’d like to share our discussion with you. Read on to learn more about Bret, and his experience using Traefik and Docker.</p><hr><p><strong><strong>Containous: Hi Bret, could you introduce yourself to our community?</strong></strong></p><p><em><em>Bret: </em></em>Hi, I’m<a href="https://twitter.com/BretFisher" rel="noopener nofollow"> Bret Fisher</a>, a freelance DevOps and Docker consultant, focused on containers. I’m also a Docker Captain. My time is split between teaching, helping students, answering questions.</p><blockquote><em>I’m driven by having fun while helping people.</em></blockquote><p><strong><strong>Containous: Could you explain what is a “Docker Captain”?</strong></strong></p><p><em><em>Bret: </em></em>The “Docker Captain” program is from Docker Inc.. A Docker Captain is like a Microsoft MVP. You cannot work for Docker Inc., should be an expert on docker tools and <strong><strong>share</strong></strong> your love for containers often. It also gives you access to pre-release Docker software.</p><p><strong><strong>Containous: How did you get into Traefik?</strong></strong></p><p><em><em>Bret: </em></em>Because of Docker Swarm mode. Even though Kubernetes has become the most popular orchestrator, Docker Swarm still solves a lot of problems for many team. I was searching for an easy “Ingress” for Docker Swarm and Traefik was recommended by a fellow Docker Captain.</p><blockquote><em>I liked Traefik because of the Let’s Encrypt support out-of-the box and because “It just works”.</em></blockquote><p><strong><strong>Containous: Where do you use Traefik?</strong></strong></p><p><em><em>Bret: </em></em>I’m using it on my own website at<a href="https://www.bretfisher.com/" rel="noopener nofollow"> https://www.bretfisher.com/</a>. This website runs on Docker Swarm with Traefik. I also recommended Traefik to my customers, and in my talks and workshops. A lot of my 120,000 students have ended up using Traefik.</p><p><strong><strong>Containous: Let’s talk a bit about container security. Are you running Traefik as the user “root”?</strong></strong></p><p><em><em>Bret: </em></em>Is it the default ? (Laugh). I’m using the official Docker image so I guess “yes,” if it is the default user in that container Image.</p><p><strong><strong>Containous: Do you see any compensation measure for this?</strong></strong></p><p><em><em>Bret: </em></em>First of all, I have a <a href="https://github.com/BretFisher/ama/issues/17" rel="noopener nofollow">list of general container security activities</a> that I follow and recommend others check out. It follows an order of “easiest steps with biggest benefits first” so you don’t spend time on hard security changes that have little overall improvement in your security posture. In addition, consider running Traefik’s container in<a href="https://docs.docker.com/engine/reference/commandline/run/#mount-volume--v---read-only" rel="noopener nofollow"> “read-only” mode</a>. This mode forbids any writing on the filesystem (unless you explicitly define a volume on an explicit path.). This first step avoids some (but not all!) common tasks as installing packages or downloading scripts in case of a bad actor gaining file system control in the container. Also, you could enable the feature “user namespaces” in the Docker Engine config, to map the root user of containers to an unprivileged user of the host machines, which I’m a big fan of.</p><p>Running a Traefik container as a non privileged user to avoid being “root” might create two challenges:</p><ul><li>Listening on ports below 1024: the range of ports [0–1024] are privileged and thus require special capabilities. Either you can bind to port &gt; 1024, or ensure you are able to grant the Linux Capability <code>CAP_NET_BIND_SERVICE </code>to Traefik.</li><li>Docker socket membership: the socket file in /var/run/docker.sock is owned by the root user, and a group named docker. The unprivileged user of Traefik must be part of the group docker to allow access to the Docker API.</li></ul><p><strong><strong>Containous: Speaking about the Docker socket, do you run Traefik on Swarm Manager Nodes?</strong></strong></p><p><em><em>Bret: </em></em>It’s not mandatory. The point is — you can always forward the Docker socket through TCP instead of using a bind-mount of <code>/var/run/docker.sock</code>. If you forward the socket in TCP inside and encrypted Docker network, then it removes the “run on manager” constraint for Traefik.</p><p>Please note that overlay networks optional encryption is not performed by Docker Swarm itself, but rather the Linux kernel (IPSec), ensuring low-level security.</p><p>Also, it’s worthwhile to add an intermediate proxy to control requests through the TCP-forwarded Docker socket, allowing read-only requests to the API.</p><p>I have an <a href="https://github.com/BretFisher/dogvscat/blob/master/stack-proxy-global.yml" rel="noopener nofollow">example Swarm stack YAML of this setup here</a>.</p><p>With all of these, running Traefik on the host network of worker nodes, with an overlay network for backends is totally doable.</p><p><strong><strong>Containous: Are you using the Traefik dashboard? If yes, what is your point of view on the security of this feature?</strong></strong></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/0-kb8q6VKOvrvofb36.png" class="kg-image" alt="Traefik and Docker: A Discussion with Docker Captain, Bret Fisher"><figcaption><strong><strong>Traefik v2 Dashboard</strong></strong></figcaption></img></figure><p><em><em>Bret: </em></em>Yes. I’m using the Traefik dashboard. I tend to configure the dashboard with an IP whitelist, and not exposed on a public network or on the default port.</p><p>Publicly exposing an admin dashboard keeps happening: just look at situations such as the<a href="https://redlock.io/blog/cryptojacking-tesla" rel="noopener nofollow"> Kubernetes dashboard hack at Tesla</a>.</p><p>I’m a huge fan of “secure by default” tools, and I wished more tools were like Docker and Swarm in this way. Over my 25 years in tech helping many companies with infrastructure, I’ve learned that if authentication and encryption are optional, many won’t do it.</p><p><strong><strong>Containous: Do you have a recommendation about using the “default” Docker image for Traefik based on “scratch” versus the “Linux Alpine” image? Why?</strong></strong></p><p><em><em>Bret: </em></em>As a rule of thumb, I would avoid “scratch” (or <a href="https://github.com/GoogleContainerTools/distroless" rel="noopener nofollow">distroless</a>) images until everyone in the pipeline is able to know how to operate it. Size is not important unless you’re operating an IoT business. Compared to the pain and suffering of “no tools,” using “scratch” doesn’t feel a good trade-off unless you have specialists on board. The image “scratch” feels like a “Golang developers” habit, but when it comes to the Ops team it’s another topic: What about not being able to <code>docker exec</code> or <code>kubectl cp</code>?</p><p>Hopefully, the <a href="https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/" rel="noopener nofollow">Kubernetes ephemeral containers</a> feature will help make this possible for more people.</p><p>As a rule of thumb, for container newcomers, they need to learn by doing. In this case, I wouldn’t use “scratch” here to keep the learning curve smooth.</p><p>I also share this opinion about the host OS. Too many people try to use a “Container OS” too early in their organisational learning. It tends to add lots of risk without a big productivity boost. Stick with your traditional Linux distribution until you’ve had significant production Docker usage.</p><p><strong><strong>Containous: What is your recommendation for the load balancer part outside Swarm? To create an external load balancer pointing to nodes, using DNS, or something else? And, why?</strong></strong></p><p><em><em>Bret: </em></em>The expected answer is “It’s complicated” or ”It depends” (laugh).</p><p>Most companies already have their own solution for load balancing, including cloud load balancers and datacenter hardware load balancers. Then they point their load balancer to the Docker Swarm nodes and rely on Traefik for providing the application layer load balancing inside the cluster. Pro Tip: Don’t point LB’s to all your Swarm nodes. Pick 2–3 worker nodes and make those the ingress points, which will make troubleshooting and load easier to manage.</p><p>However, about the “DNS round robin” solution, I refer to it as the “poor person’s LB”, because of the small amount of time required to make it work. It’s simple when the client is a web browser, but as you cannot control the “client”, that’s where the limit is drawn (DNS caching, no retry patterns, etc.). Another limit: as soon as showing HTTP 503 errors is an issue, there is no “retry pattern” expected from web browsers (even though Traefik could do that). It’s the recommended solution in my course “Solo DevOps” where the context is “only one person in charge of the DevOps tasks, with so many tools involved”. Once you have an external load balancer solution, it’s likely best to stick with that in all but the smallest projects.</p><p>As a general rule, ask yourselves: “During the time it goes down, do you lose money? If yes, then go for load balancing with health checks.”</p><blockquote><em>Try both solutions for education purposes. It’s really valuable.</em></blockquote><p><strong><strong>Containous: Have you tried the new<a href="https://containous.ghost.io/blog/traefik-2-0-6531ec5196c2/"> Traefik v2.0</a>?</strong></strong></p><p><em><em>Bret: </em></em>Not yet, but it made quite some noise in the Docker Captain channel. It might be the fact that they are “Golang people,” but it looks neat.</p><p><strong><strong>Containous: Is there something you would like to tell the Traefik community?</strong></strong></p><p><em><em>Bret: </em></em>Traefik is a really nice tool because everything is configurable from the command line when starting in a container (using CMD). TOML files are fine, but it’s great to have the option to skip that and configure it dynamically at runtime.</p><p>Also, everything is streamlined for the container world, with a linear learning curve: configuration management is not mandatory even for rich features such as Let’s Encrypt.</p><p><strong><strong>Containous: Thanks a lot for these insights Bret! Happy to have this exchange. Let’s meet again for a live session next time!</strong></strong></p></hr>]]></content:encoded></item><item><title><![CDATA[Traefik Enterprise Edition 1.2 is out!]]></title><description><![CDATA[Today, we’re happy to announce the availability of TraefikEE 1.2. This minor version was driven by customers feedback, and keeps improving...]]></description><link>https://traefik.io/blog/traefik-enterprise-edition-1-2-is-out-2ba37e22983c/</link><guid isPermaLink="false">Ghost__Post__5dcc44711127150038885824</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Brendan LE GLAUNEC]]></dc:creator><pubDate>Tue, 15 Oct 2019 20:57:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/traefikee-v1.2.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/traefikee-v1.2.png" alt="Traefik Enterprise Edition 1.2 is out!"/><p class="post-sub-title">With OpenShift compatibility, more distributed features, improved operations, and more.</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-105.png" class="kg-image" alt="Traefik Enterprise Edition 1.2 is out!"/></figure><p>Today, we’re happy to announce the availability of TraefikEE 1.2. This minor version was driven by customers feedback, and keeps improving clustering features while adding support for more platforms.</p><blockquote>Traefik Enterprise Edition is a platform built on top of Traefik, designed for business-critical deployments. It adds clustering features to satisfy the needs of enterprise customers.</blockquote><h2 id="openshift-compatibility">OpenShift Compatibility</h2><p>Because Traefik has always been about compatibility with every platform, TraefikEE follows the same path and is now <a href="https://www.openshift.com/learn/what-is-openshift" rel="noopener nofollow">OpenShift</a> ready! We’re also actively working with RedHat on the certification process.</p><p>With this new step, we keep giving our customers more choices for their infrastructure.</p><h2 id="distributed-features">Distributed features</h2><p>Thanks to its clustered architecture, TraefikEE allowed us to provide distributed rate limiting, and 1.2 introduces distributed connection limiting.</p><p>The goal of these distributed features is to keep the configuration simple, yet scalable. Whatever the number of data planes you’ve deployed, the configuration stays the same — even with hundreds of Traefik instances on your cluster, your backend will only receive the given number of simultaneous requests.</p><h2 id="operations">Operations</h2><h3 id="acme">ACME</h3><p>A small tweak that makes administrators’ day easier, the <code>traefikee</code> and <code>traefikeectl</code> CLIs now allow users to list the certificates within their clusters, and they’re also able to add ACME accounts directly from TraefikEE backup files.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-1.png" class="kg-image" alt="Traefik Enterprise Edition 1.2 is out!"/></figure><h3 id="installation-on-dockeree">Installation on DockerEE</h3><p>The whole installation of TraefikEE can now be done using the <code>traefikeectl</code> tool, as opposed to having to <a href="https://docs.containo.us/installing/advanced/swarm-compose/n-cn/" rel="noopener nofollow">manually deploy compose files</a> in the version 1.1. This makes it much more convenient as well as much faster to install. Take a look at the documentation for <a href="https://docs.containo.us/integrating/dockeree/" rel="noopener nofollow">more information on DockerEE installs</a>.</p><h2 id="what-s-next">What’s next?</h2><p>The next logical step will be to integrate Traefik 2.0 into TraefikEE and bring with it every feature… and hopefully much more!</p><h2 id="try-it-now-">Try it now!</h2><p>Get a <a href="https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days" rel="noopener nofollow">free one month trial</a> right now, and install TraefikEE on your favorite environment by following the <a href="https://docs.containo.us/v1.2/" rel="noopener nofollow">installation guides</a>.</p>]]></content:encoded></item><item><title><![CDATA[13 Key Considerations When Selecting an Ingress Controller for Kubernetes]]></title><description><![CDATA[Ingresses are critical to any successful Kubernetes (k8s) deployment. So how do you choose the right Ingress Controller? ]]></description><link>https://traefik.io/blog/13-key-considerations-when-selecting-an-ingress-controller-for-kubernetes-d3e5d98ed8b7/</link><guid isPermaLink="false">Ghost__Post__5dd548aeec5ed3003878884c</guid><category><![CDATA[Blog]]></category><category><![CDATA[Kubernetes]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Tue, 08 Oct 2019 14:11:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/13-keys-considerations-ingress.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-106.png" class="kg-image" alt="13 Key Considerations When Selecting an Ingress Controller for Kubernetes"/></figure><h2 id="evaluating-ingress-controllers">Evaluating Ingress Controllers</h2><img src="https://containous.ghost.io/content/images/2019/11/13-keys-considerations-ingress.png" alt="13 Key Considerations When Selecting an Ingress Controller for Kubernetes"/><p>Ingresses are critical to any successful Kubernetes (k8s) deployment. Ingresses allow you to define how external (and/or internal) traffic is routed to services within your cluster. The Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener">documentation</a> states that:</p><blockquote><em><em>“An Ingress can be configured to give Services externally-reachable URLs, load balance traffic, terminate SSL / TLS, and offer name based virtual hosting.”</em></em></blockquote><p>However, Ingresses themselves don’t do anything — they’re just <em><em>metadata</em></em>. The heavy lifting is performed by <em><em>Ingress Controllers</em></em>. An Ingress without an Ingress Controller won’t do anything. There’s one more catch: while there are a number of system controllers (like ReplicaSet Controller, Endpoints Controller, Namespace Controller and others) that are managed by the Kubernetes control plane, Ingress Controllers are not automatically started with a cluster — you have to install, configure and manage your own Ingress Controllers.</p><p>It’s also possible to have multiple Ingress Controllers in the same cluster. You can divide the “routing space” by using Ingress class annotations, so that each Ingress knows which Ingress Controller should be handling it. You could end up using a combination of Ingress Controllers for different scenarios within the same cluster. For example, you may have one Ingress Controller for handling external traffic coming in to the cluster including bindings to SSL certificates, and have another internal Ingress Controller with no SSL binding that handles in-cluster traffic.</p><p>There are scores of Ingress Controllers to choose from. The Kubernetes documentation has a list of popular Ingress Controllers <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#additional-controllers" rel="noopener">here</a>.</p><p>These controllers have varied feature sets and varying levels of community or commercial support. Some are “pure” edge routers, while others have features more akin to service meshes.</p><h2 id="selecting-the-right-ingress-controller">Selecting the Right Ingress Controller</h2><p>So how do you choose the right Ingress Controller? There are several criteria that are important to consider when doing so. In this post we’re not going to do a feature comparison between specific Ingress Controllers, since there are many head-to-head comparisons on the internet already, and because there are so many Ingress Controllers. Rather, we’re going to discuss what features you should be weighing when selecting an Ingress Controller.</p><h3 id="1-traffic-protocol">1/ Traffic Protocol</h3><p>Are you just routing HTTP(S), HTTP/2 or websockets? Do you want to route TCP/UDP or gRPC? Not all Ingress Controllers support all these protocols, so you’ll have to check which protocols an Ingress Controller supports.</p><h3 id="2-dynamic-configuration-updates">2/ Dynamic Configuration Updates</h3><p>Do you require zero-downtime configuration changes — often called “hitless reloads”? Some Ingress Controllers require downtime in order to update configuration, while others update dynamically without downtime.</p><h3 id="3-resiliency">3/ Resiliency</h3><p>Do you need rate limiting, retries or circuit breakers at the edge, or have you built this functionality into your services yourself? Some Ingress Controllers support these features, which means you won’t have to code them yourself.</p><h3 id="4-external-load-balancer-integration">4/ External Load Balancer Integration</h3><p>Are you integrating with an external, managed cloud-based load balancer? Make sure the Ingress Controller you select integrates well with your external load balancer in order to reduce work and management for your networking team.</p><h3 id="5-service-mesh">5/ Service Mesh</h3><p>Ingress Controllers can be configured to handle external traffic (traffic originating outside the cluster) or internal traffic or both. If you need to observe or trace internal traffic, you may need a special breed of Ingress Controller — a Service Mesh. Kubernetes provides standards for Service Meshes through the SMI Specification for interoperability. If you do require a Service Mesh, make sure you pick the right tool for the right job. Ingress Controllers and Service Meshes are not mutually exclusive.</p><h3 id="6-api-gateway">6/ API Gateway</h3><p>Do you need an Ingress Controller or an API gateway, or something that does both? Typically API gateways integrate business logic, while edge routers are typically business agnostic. For example, API Gateways let you monitor traffic per customer, or measure transactions for billing purposes. If you require business logic at the edge, you should probably look at an API gateway instead of an Ingress Controller. Just as with Service Meshes, Ingress Controller and API gateways are not mutually exclusive.</p><h3 id="7-high-availability">7/ High Availability</h3><p>Can you afford downtime when a server restarts for either planned or unplanned maintenance? If so, you need high availability for your Ingress Controller. Not all Ingress Controllers support high availability.</p><h3 id="8-load-balancing-algorithms">8/ Load Balancing Algorithms</h3><p>What sort of algorithm-based routing do you need? Most Ingress Controllers support Round Robin, but if you want Least Connection so that the load on your services is taken into account, you’ll need an Ingress Controller that supports more advanced load balancing algorithms.</p><h3 id="9-advanced-traffic-shifting">9/ Advanced Traffic Shifting</h3><p>Do you need to perform canary testing (shifting a percentage of traffic to different services for progressive exposure)? Load balancing lets you spread the load of a service, but not all load balancers can split traffic using more sophisticated rules. If you’re testing in production using techniques like canary testing, make sure the Ingress Controller you select supports traffic shifting.</p><h3 id="10-resources-constraints">10/ Resources Constraints</h3><p>Are you cost sensitive as far as resources in your cluster are concerned? Ingress Controllers can be resource intensive, so if you are cost sensitive, you’re going to be better off with a light-weight Ingress Controller. Some Ingress Controllers support scaling up and down, while others do not.</p><h3 id="11-monitoring">11/ Monitoring</h3><p>Do you need to integrate with existing metrics and log collection systems? Some Ingress Controllers offer limited monitoring and logging and may not support your specific monitoring and logging tooling.</p><h3 id="12-support">12/ Support</h3><p>Do you need enterprise support? Open source Ingress Controllers are easy on the check book, but what happens when you need support in the middle of the night? Remember, some open source Ingress Controllers offer enterprise support plans.</p><h3 id="13-ecosystem">13/ Ecosystem</h3><p>Make sure the Ingress Controller you are considering has support in the Kubernetes partner ecosystem.</p><h2 id="conclusion">Conclusion</h2><p>As you can see, there are many factors that require thought before you can select the right Ingress Controller for your clusters. Don’t just select a hype-driven, popular option — be deliberate about your requirements and then evaluate Ingress Controllers according to the criteria we’ve listed. If you do, you’ll have made an informed decision about a very important part of your infrastructure!</p><!--kg-card-begin: markdown--><p><a href="https://info.containo.us/request-white-paper-routing-in-the-cloud"><img src="https://containous.ghost.io/content/images/2019/12/request-white-paper-routing-in-the-cloud.png" alt="13 Key Considerations When Selecting an Ingress Controller for Kubernetes"/></a></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Traefik 2.0 & Docker 101]]></title><description><![CDATA[Docker friends — Welcome!
Today we decided to dedicate some time to walk you through the 2.0 changes using practical & common scenarios.]]></description><link>https://traefik.io/blog/traefik-2-0-docker-101-fc2893944b9d/</link><guid isPermaLink="false">Ghost__Post__5dd550aeec5ed3003878892e</guid><category><![CDATA[Blog]]></category><category><![CDATA[Docker]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Tue, 01 Oct 2019 14:37:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/traefik-2-101-docker.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/traefik-2-101-docker.png" alt="Traefik 2.0 & Docker 101"/><p class="post-sub-title">Tips & Tricks the Documentation Doesn’t Tell You</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-109.png" class="kg-image" alt="Traefik 2.0 & Docker 101"/></figure><p>Docker friends — Welcome!</p><p>Today we decided to dedicate some time to walk you through the 2.0 changes using practical &amp; common scenarios. Hopefully, after having read this article, you’ll understand every concept there is to know, and you’ll keep learning by yourself, discovering tips &amp; tricks to share with the community.</p><p>Before we go further, I’ll assume for this article that you already have a docker setup using Traefik 2.0. Since I like to use docker-compose files for basic demonstrations, I’ll use the following base compose file:</p><figure class="kg-card kg-code-card"><pre><code class="language-yaml">version: "3.3"

services:
  traefik:
    image: "traefik:v2.0.0"
    command:
      - --entrypoints.web.address=:80
      - --providers.docker=true
    ports:
      - "80:80"
      - "8080:8080"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
  
  my-app:
    image: containous/whoami:v1.3.0</code></pre><figcaption><a href="https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-01.yml" rel="noopener">Full compose file available there.</a></figcaption></figure><p><em><em>Nothing fancy, we declare an </em></em><a href="https://docs.traefik.io/v2.0/routing/entrypoints/" rel="noopener"><em><em>entrypoint</em></em></a><em><em> (</em></em><code><em><em>web</em></em></code><em><em> for port </em></em><code><em><em>80</em></em></code><em><em>), enable the docker </em></em><a href="https://docs.traefik.io/v2.0/providers/overview/" rel="noopener"><em><em>provider</em></em></a><em><em>, attach our traefik container to the needed ports and make sure we can listen to Docker thought the socket. We also have an application </em></em><code><em><em>my-app</em></em></code><em><em> we’ll expose later.</em></em></p><p><strong><strong>Side Note</strong></strong>: You can get the examples from our repository if you want to play with them. (Yes, we know how dangerous it can be to copy/paste some YAML :-))</p><p>Now that we’re all set, let’s start!</p><hr><h2 id="let-s-enable-the-dashboard-">Let’s Enable the Dashboard!</h2><p>Because we all enjoy seeing what we’re doing, we’ll first enable Traefik’s Dashboard in <em><em>development</em></em> mode, and all we need to do is add <em><em>one</em></em> argument to the Traefik command itself.</p><figure class="kg-card kg-code-card"><pre><code class="language-yaml">services:
  traefik:
    image: "traefik:v2.0.0"
    command:
      - --entrypoints.web.address=:80
      - --providers.docker
      - --api.insecure # Don't do that in production
#   ...</code></pre><figcaption><a href="https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-02.yml" rel="noopener">Full compose file available there.</a></figcaption></figure><p>There we are! By adding <code>--api.insecure</code> we’ve enabled the API along with the dashboard. But beware, in this first step, we’ve enabled the insecure development mode — Don’t do that in production!</p><p>Of course, we’ll see at the end of the article how to enable a secured dashboard, but for now, you can enjoy and see it on localhost:8080/dashboard/</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-11.png" class="kg-image" alt="Traefik 2.0 & Docker 101"/></figure><hr><h2 id="my-application-handles-requests-on-example-com">My Application Handles Requests on "example.com"</h2><p>If you only need to route requests to <code>my-app</code> based on the host, then attach <em><em>one</em></em> label to your container — That’s it!</p><figure class="kg-card kg-code-card"><pre><code class="language-yaml">services:
  my-app:
    image: containous/whoami:v1.3.0
    labels:
      - traefik.http.routers.my-app.rule=Host(`example.com`)</code></pre><figcaption><a href="https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-03.yml" rel="noopener">Full compose file available there.</a></figcaption></figure><h3 id="quick-explanation">Quick Explanation</h3><p>In English, this label means, “Hey Traefik! (<code>traefik.</code>) This HTTP router (<code>http.routers.</code>) I call my-app (<code>my-app.</code>) must catch requests to example.com (<code>rule=Host(`example.com`)</code>).”</p><h3 id="more-details-optional-read-">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href="https://docs.traefik.io/v2.0/routing/routers/" rel="noopener">Routers</a>. Routers define the routes that connect your services to the requests, and you use <a href="https://docs.traefik.io/v2.0/routing/routers/#rule" rel="noopener">rules</a> to define <em><em>what</em></em> makes the connection. This is the reason why you see <code>routers</code> in the label, as well as <code>rule</code>.</p><p>Traefik 2.0 also introduces TCP support (in addition to the existing HTTP support). Since Traefik supports both protocols, it wants to know what kind of protocol you’re interested in, which explains the <code>http</code> keyword in the label.</p><hr><h2 id="my-application-listens-on-a-specific-port">My Application Listens on a Specific Port</h2><p>What happens if your application listens on a different port than the default <code>:80</code>? Let’s say it listens on <code>:8082</code>. We’ll build on the previous example and add (again) <em><em>one</em></em> label.</p><figure class="kg-card kg-code-card"><pre><code class="language-yaml">services:
  my-service:
    image: containous/whoami:v1.3.0
    command:
      - --port=8082 # Our service listens on 8082
    labels:
      - traefik.http.routers.my-app.rule=Host(`example.com`)
      - traefik.http.services.my-app.loadbalancer.server.port=8082</code></pre><figcaption><a href="https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-04.yml" rel="noopener">Full compose file available there.</a></figcaption></figure><h3 id="quick-explanation-1">Quick Explanation</h3><p>In English, this label means, “Hey Traefik! (<code>traefik.</code>) This HTTP service (<code>http.services.</code>) I call my-app (<code>my-app.</code>) will load balance incoming requests between servers (<code>.server</code>) that listen on port 8082 (<code>.port=8082</code>).”</p><h3 id="more-details-optional-read--1">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href="https://docs.traefik.io/v2.0/routing/services/" rel="noopener">Services</a>. Services are the <em><em>targets</em></em> for the routes. They usually define how to reach your programs in your cluster. Services can have different types. The most common one is the <a href="https://docs.traefik.io/v2.0/routing/services/#servers-load-balancer" rel="noopener">LoadBalancer</a> type. The LoadBalancer type is a round robin between all the available instances (called <code>server</code>). By default, Traefik considers that your program is available on the port exposed by the Dockerfile of your program, but you can change that by explicitly defining the port.</p><p>Since we specify only one service in the example, there is no need to define the target of the previously defined router explicitly.</p><p>Side Note: The<code>—-port=8082</code> command is specific to our <code>whoami</code> application and has nothing to do with Traefik. It tells <code>whoami</code> to start listening on 8082, so we can simulate our use case.</p><hr><h2 id="i-need-basicauth-or-any-piece-of-middleware-">I Need BasicAuth (Or Any Piece of Middleware)</h2><p>Once Traefik has found a match for the request, it can process it before forwarding it to the service. In the following example, we’ll add a BasicAuth mechanism for our route. This is done with <em><em>two</em></em> additional labels.</p><figure class="kg-card kg-code-card"><pre><code class="language-yaml">services:
  my-svc:
    image: containous/whoami:v1.3.0
    labels:
      - traefik.http.routers.my-app.rule=Host(`example.com`)
      - traefik.http.routers.my-app.middlewares=auth
      - traefik.http.middlewares.auth.basicauth.users=test:xxx</code></pre><figcaption><a href="https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-05.yml" rel="noopener">Full compose file available there.</a></figcaption></figure><h3 id="quick-explanation-2">Quick Explanation</h3><p>In English, the first label means, “Hey Traefik! (<code>traefik.</code>) My HTTP router I called my-app, remember? (<code>http.routers.my-app.</code>) I’d like to attach to it a piece of middleware named auth (<code>.middlewares=auth</code>).”</p><p>Of course, since we haven’t yet declared the <code>auth</code> middleware, we need to be a bit more explicit, so the second label means, “Hey Traefik! (<code>traefik.</code>) Let’s talk about an HTTP middleware (<code>http.middlewares.</code>) I call auth (<code>auth.</code>). It’s a BasicAuth middleware (<code>basicauth.</code>). Since you probably need users to know who can do what, here is the users list (<code>.users=test:xxx</code>).”</p><h3 id="more-details-optional-read--2">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href="https://docs.traefik.io/v2.0/middlewares/overview/" rel="noopener">Middleware</a>. Middleware is a way to define behaviors and tweak the incoming request before forwarding it to the service. Since they act before the request is forwarded, they are attached to Routers. You can define middleware and reuse them as many times as you like (this is why you need to name them, in the example <code>auth</code>). There are many kinds of middleware, and <a href="https://docs.traefik.io/v2.0/middlewares/basicauth/" rel="noopener">BasicAuth</a> is one of them. Each middleware has a different set of parameters to define their behaviors (in the example, we define the users list).</p><hr><h2 id="i-need-https">I Need HTTPS</h2><p>With Traefik, enabling automatic certificate generation is a matter of <em><em>4 lines of configuration, </em></em>and enabling HTTPS on your routes is a matter of<em><em> 2 lines of configuration</em></em>.</p><p><strong><strong>1 — Enabling Automatic Certificate Generation</strong></strong></p><p>We’ll introduce a little tip here — Since Traefik is launched as a container, we’ll attach labels to it for common configuration options. (What is specific to other containers will, of course, stay on other containers, we’re not messy people!)</p><figure class="kg-card kg-code-card"><pre><code class="language-yaml">services:
  traefik:
    image: "traefik:v2.0.0"
    command:
      - --entrypoints.websecure.address=:443
      # ...
      - --certificatesresolvers.le.acme.email=my@email.com
      - --certificatesresolvers.le.acme.storage=/acme.json
      - --certificatesresolvers.le.acme.tlschallenge=true
      # ...
    ports:
      # ...
      - "443:443"</code></pre><figcaption><a href="https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml" rel="noopener">Full compose file available there.</a></figcaption></figure><h3 id="quick-explanation-3">Quick Explanation</h3><p>We’ve seen already the first command line given to Traefik. In English, it means, “I have an entrypoint (<code>entrypoints.</code>) I call websecure (<code>websecure.</code>) that uses port 443 (<code>.address=:443</code>).” And since Traefik now listens to 443, we need to tell Docker that it should bind external port 443 to our service’s port 443 (<code>"443:443"</code>).</p><p>Now, the others are a bit trickier, but nothing crazy if you’ve had time to drink your coffee/tea. The first says, “I’d like a mechanism to generate certificates for me (<code>certificatesresolvers.</code>) that I’ll call le (<code>le.</code>). It’s an acme resolver (<code>acme.</code>), my account there is <code>my@email.com</code> (<code>email=my@email.com</code>).” (Disclaimer: not my real email address, don’t try it.)</p><p>The second says, “This mechanism named <code>le</code> I told you about, the acme stuff (<code>certificatesresolvers.le.acme.</code>), it will save the certificates in the file <code>/acme.json </code>(<code>storage=/acme.json</code>).”</p><p>And the third is our inner geek speaking, “Since this <code>le</code> mechanism I defined before (<code>certificatesresolvers.le.acme.</code>) supports different challenges for certificate generation, I’ll choose … the TLS challenge (<code>tlschallenge=true</code>).”</p><p>That was a bit more text than usual, but here we are: we have a fully functional mechanism to generate/renew certificates for us!</p><h3 id="more-details-optional-read--3">More Details (Optional Read)</h3><p>Traefik 2.0 introduces the notion of <a href="https://docs.traefik.io/v2.0/https/acme/" rel="noopener">CertificatesResolvers</a>. Certificates resolvers are a system that handles certificate generation/renewal/disposal for you. They detect the hosts you’ve defined for your routers and get the matching certificates.</p><p>Currently, certificates resolvers leverage <a href="https://letsencrypt.org/" rel="noopener">Let’s Encrypt</a> to get certificates, and expect you to configure your account (which is basically your email address). In order to prove Let’s Encrypt that you’re the owner of the domains you’ll request certificates for, LE will give Traefik a challenge. There are multiple possible challenges, and we chose in the example the TLSChallenge. In the documentation, you’ll find a description for each <a href="https://docs.traefik.io/v2.0/https/acme/#the-different-acme-challenges" rel="noopener">other challenges</a> (<a href="https://docs.traefik.io/v2.0/https/acme/#dnschallenge" rel="noopener">dnsChallenge</a> and <a href="https://docs.traefik.io/v2.0/https/acme/#httpchallenge" rel="noopener">httpChallenge</a>).</p><p>Know that advanced users can define multiple CertificatesResolvers using different challenges, and that they can use them to generate wildcards … but that’s a story we’ll talk about later :-)</p><p><strong><strong>2 — Enabling Automatic Certificate Generation</strong></strong></p><p>Now that we have a mechanism to generate certificates for us, let’s leverage it to enable HTTPS on our route. We’ll only need <em><em>two</em></em> labels!</p><figure class="kg-card kg-code-card"><pre><code class="language-yaml">my-app:
    image: containous/whoami:v1.3.0
    labels:
      - traefik.http.routers.my-app.rule=Host(`example.com`)
      - traefik.http.routers.my-app.middlewares=auth
      - traefik.http.routers.my-app.tls.certresolver=le
      - traefik.http.routers.my-app.entrypoints=websecure</code></pre><figcaption><a href="https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-06.yml" rel="noopener">Full compose file available there.</a></figcaption></figure><h3 id="quick-explanation-4">Quick Explanation</h3><p>In English, the first label means, “Hey Traefik! (<code>traefik.</code>) My HTTP router (<code>http.routers.</code>) I call <em><em>my-app</em></em> (<code>my-app.</code>) uses TLS and the CertificateResolver named le (<code>certresolver=le</code>).”</p><p>And the second says, “Traefik! (<code>traefik.</code>) this router, you know? (<code>http.routers.my-app</code>) It will only listen to the <em><em>entrypoint</em></em> I call <em><em>websecure </em></em>(<code>entrypoints=websecure</code>).”</p><h3 id="more-details-optional-read--4">More Details (Optional Read)</h3><p>Traefik 2.0 allows you to define TLS termination <a href="https://docs.traefik.io/v2.0/routing/routers/#tls" rel="noopener">directly on your routers</a>!</p><p>Also, by default, routers listen to every known <em><em>entrypoints</em></em>. In our example, we wanted Traefik to limit the use of https on port <code>443</code>, which is the reason why we told the router to listen only to <em><em>websecure</em></em> (defined to port 443 with <code>entrypoints.websecure.address=:443</code>)</p><hr><h2 id="i-want-https-redirection-">I Want HTTPS Redirection!</h2><p>Now that we have HTTPS routes, let’s redirect every non-https requests to their https equivalent. For that, we’ll reuse the previous trick and add just <em><em>4 labels</em></em> to declare a redirect middleware and a catch-all router for unsecured routes.</p><figure class="kg-card kg-code-card"><pre><code class="language-yaml">services:
  traefik:
    image: "traefik:v2.0.0"
    # ...
    labels:
      # ...
      
      # middleware redirect
      - "traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https"
      
      # global redirect to https
      - "traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`)"
      - "traefik.http.routers.redirs.entrypoints=web"
      - "traefik.http.routers.redirs.middlewares=redirect-to-https"</code></pre><figcaption><a href="https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-07.yml" rel="noopener">Full compose file available there.</a></figcaption></figure><h3 id="quick-explanation-5">Quick Explanation</h3><p>In English, the first label means, “Hey Traefik! (<code>traefik.</code>) let’s declare an HTTP middleware (<code>http.middlewares.</code>) we’ll call redirect-to-https (<code>redirect-to-https.</code>). It’s a <a href="https://docs.traefik.io/v2.0/middlewares/redirectscheme/" rel="noopener">RedirectScheme</a> middleware (<code>redirectscheme.</code>) that will force the scheme to https (<code>scheme=https</code>).”</p><p>Then, let’s see the router part, “Hey Traefik! (you know the drill) (<code>traefik.</code>) I have an HTTP router (<code>http.routers.</code>) I’ll call redirs (<code>redirs.</code>) that will match requests on any host (<code>rule=hostregexp(`{host:.+}`)</code>) Yes sir! I’m insane and will catch everything, that’s how greedy I am.”</p><p>Then, we add, “Hey Traefik! (<code>traefik.</code>) I was kidding … the <em><em>redirs</em></em> HTTP router (<code>http.routers.redirs.</code>) won’t catch everything but just requests on port 80 (<code>entrypoints=web</code>).”</p><p>Finally, we’ll add the redirect middleware to the router. “Traefik? (<code>traefik.</code>) On the <em><em>redirs</em></em> HTTP router (<code>http.routers.redirs.</code>) we’ll add the <em><em>redirect-to-https</em></em> middleware (<code>middlewares=redirect-to-https</code>).”</p><h3 id="more-details-optional-read--5">More Details (Optional Read)</h3><p>By now, we’ve seen everything there is to know, so no additional details to learn about :-)</p><hr><h2 id="compiling-everything-for-a-secured-dashboard-">Compiling Everything for a Secured Dashboard!</h2><p>Now that we’ve manipulated every important notion (Entrypoints, Routers, Middleware, Services, CertificatesResolvers &amp; TLS), we can combine them to obtain a secured Dashboard!</p><figure class="kg-card kg-code-card"><pre><code class="language-yaml">version: "3.3"

services:
  traefik:
    image: "traefik:v2.0.0"
    command:
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --providers.docker
      - --api
      - --certificatesresolvers.le.acme.email=your@email.com
      - --certificatesresolvers.le.acme.storage=/acme.json
      - --certificatesresolvers.le.acme.tlschallenge=true
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "./acme.json:/acme.json"
    labels:
      # Dashboard
      - "traefik.http.routers.traefik.rule=Host(`api.example.com`)"
      - "traefik.http.routers.traefik.service=api@internal"
      - "traefik.http.routers.traefik.middlewares=admin"
      - "traefik.http.routers.traefik.tls.certresolver=le"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.middlewares.admin.basicauth.users=admin:xxx"

      # ...</code></pre><figcaption><a href="https://github.com/containous/blog-posts/blob/master/2019_09_10-101_docker/docker-compose-09.yml" rel="noopener">Full compose file available there.</a></figcaption></figure><h3 id="quick-explanation-6">Quick Explanation</h3><p>First, we remove the insecure api (specifying <code>--api</code> instead of <code>--api.insecure</code>).</p><p>Then, we tell Traefik (<code>traefik.</code>) to add an HTTP router called traefik (<code>http.routers.traefik.</code>) catching requests on <em><em>api.example.com</em></em> (<code>rule=Host(`api.example.com`)</code>).</p><p>This router (<code>traefik.http.routers.traefik.</code>) will forward requests to a service called api@internal (<code>service=api@internal</code>), uses a middleware named admin (<code>middlewares=admin</code>), and uses tls (<code>tls=true</code>) with a certresolver called <em><em>le</em></em> (<code>tls.certresolver=le</code>).</p><p>Finally, we declare the admin middleware (<code>traefik.http.middlewares.admin.basicauth.users=admin:xxx</code>).</p><h3 id="more-details-optional-read--6">More Details (Optional Read)</h3><p>The only subtle thing to know is that when you enable the api (in default mode, it creates an internal service called <code>api@internal</code> (It’s then up to you to properly secure it).</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-12.png" class="kg-image" alt="Traefik 2.0 & Docker 101"/></figure><hr><h2 id="questions-where-to-go-next">Questions? Where to Go Next?</h2><p>Hopefully, we’ve gone through important questions you’ll have when dealing with Traefik 2.0 in a Docker setup, and we hope this article brings many answers.</p><p>If you want to keep the conversation going, let us know on the <a href="https://community.containo.us/c/traefik/traefik-v2" rel="noopener">community forum</a>!</p><p>In the meantime — Happy Traefik!</p></hr></hr></hr></hr></hr></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Easy Ingress Management on the Edge with K3s lightweight Kubernetes and Traefik]]></title><description><![CDATA[K3s, by Rancher, is the best way to have a lightweight, fully CNCF conformant Kubernetes cluster. Traefik is a cloud-native dynamic reverse proxy. Its purpose...]]></description><link>https://traefik.io/blog/easy-ingress-management-on-the-edge-with-k3s-lightweight-kubernetes-and-traefik-9d51c4ecacce/</link><guid isPermaLink="false">Ghost__Post__5dd54a8eec5ed3003878887c</guid><category><![CDATA[Blog]]></category><category><![CDATA[Partners]]></category><dc:creator><![CDATA[Manuel Zapf]]></dc:creator><pubDate>Wed, 18 Sep 2019 14:16:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/k3s-banner.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/k3s-banner.png" alt="Easy Ingress Management on the Edge with K3s lightweight Kubernetes and Traefik"/><p class="post-sub-title">K3s and Traefik are partnering to speed up cloud native applications deployment.</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-107.png" class="kg-image" alt="Easy Ingress Management on the Edge with K3s lightweight Kubernetes and Traefik"/></figure><p><a href="http://k3s.io/" rel="noopener">K3s</a>, by Rancher, is the best way to have a lightweight, fully CNCF conformant Kubernetes cluster running on diverse infrastructures, including possible IoT appliances such as Raspberry Pis.</p><p>K3s starts in seconds thanks to its light weight nature. As it adds some components to the cluster automatically, k3s is very easy to use and therefore very accessible for new users. One of these components is Traefik, which is deployed in a k3s cluster as the default Ingress Controller.</p><p><a href="https://containous.ghost.io/traefik/">Traefik</a> is a cloud-native dynamic reverse proxy. Its purpose is to route incoming requests to all your services deployed on your platform. Traefik is able to observe different container technologies such as Docker or Kubernetes to auto-configure itself.</p><p><a href="https://rancher.com/blog/2019/ingress-on-the-edge-with-k3s-and-traefik" rel="noopener">Click to continue reading…</a></p>]]></content:encoded></item><item><title><![CDATA[Traefik 2.0]]></title><description><![CDATA[When we started our journey toward 2.0, we had high expectations (since you had high expectations), and huddled around the whiteboard...]]></description><link>https://traefik.io/blog/traefik-2-0-6531ec5196c2/</link><guid isPermaLink="false">Ghost__Post__5dd54affec5ed3003878888c</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Tue, 17 Sep 2019 14:28:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2020/04/Traefik2.0-Blog.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2020/04/Traefik2.0-Blog.png" alt="Traefik 2.0"/><p class="post-sub-title">The Wait Is Over!</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-108.png" class="kg-image" alt="Traefik 2.0"/></figure><p>When we started our journey toward 2.0, we had high expectations (since <em><em>you</em></em> had high expectations), and huddled around the whiteboard.</p><p>We designed Version 2 as if there were no constraints: we forgot our codebase, put aside technical challenges, and developed a new configuration structure that would welcome everything we had ever dreamed of for Traefik.</p><blockquote>We forgot what was impossible so we could build it!</blockquote><p>A year later, we proudly present to you Traefik 2.0. Make sure you grab your cup of coffee/cup of tea before going further because this is probably the biggest new features list we’ve ever had to write!</p><hr><h2 id="tcp-support-with-sni-routing-multi-protocol-ports">TCP Support with SNI Routing &amp; Multi-Protocol Ports</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-4.png" class="kg-image" alt="Traefik 2.0"/></figure><p>We talked about this flagship feature in the <a href="https://containous.ghost.io/blog/back-to-traefik-2-0-2f9aa17be305/">2.0 alpha announcement</a>, but since it was <a href="https://github.com/containous/traefik/issues/10" rel="noopener">feature request #10</a>, we thought we would dedicate some time to discussing this key element in a world of new possibilities.</p><p>Let’s see a sample configuration — using the <em><em>newly supported </em></em><strong><strong><em><em>YAML</em></em></strong></strong><em><em> format</em></em> — that routes requests to a database:</p><pre><code class="language-yaml">tcp:
  routers:
    to-database:
      entrypoints:
      - database-entrypoint
      rule: HostSNI(`*`)
      service: database-service
  services:     
    database-service:
      loadBalancer:
        servers:
        - address: xx.xx.xx.xx:xx</code></pre><p>In the example above, every request ending on <code>database-entrypoint</code> will be routed to our <code>database-service</code>.</p><blockquote>Over TLS, Traefik routes TCP <br>requests based on the SNI</br></blockquote><p>In the following example, <a href="https://containous.ghost.io/traefik/">Traefik</a> routes requests to two databases based on the SNI (<em><em>Server Name Indication</em></em>):</p><pre><code class="language-yaml">tcp:
  routers:
    to-db-1:
      entrypoints:
      - web-secure
      rule: "HostSNI(`db1.domain`)"
      service: "db1"
      tls: {} 
    to-db-2:
      entrypoints:
      - web-secure
      rule: "HostSNI(`db2.domain`)"
      service: "db2"
      tls: {}</code></pre><blockquote>HTTP &amp; TCP on the same port?<br>Yes, there is Traefik for that!</br></blockquote><p>If you ever want to have the same <em><em>entrypoint</em></em> get both HTTP and TCP requests, know that Traefik will handle it perfectly!</p><pre><code class="language-yaml">tcp:
  routers:
    to-db-1:
      entrypoints:
      - web-secure
      rule: "HostSNI(`db1.domain`)"
      service: "db-1"
      tls: {}
http:
  routers:
    to-db1-dashboard:
      entrypoints:
      - web-secure
      rule: "Host(`dashboard.db1.domain`)"
      service: "db1-dashboard"
      tls: {}</code></pre><p>In the above example, HTTP requests on <code>dashboard.db1.domain</code> will be routed to the database dashboard service, and TCP requests on <code>db1.domain</code> will be routed to the database.</p><h2 id="fully-customize-your-routes-with-middleware">Fully Customize Your Routes with Middleware</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-5.png" class="kg-image" alt="Traefik 2.0"/></figure><p>Traefik 2.0 introduces <a href="https://docs.traefik.io/middlewares/overview/">middleware</a>: a common banner for features that tweak requests before/after routing them to their destinations.</p><blockquote>You can declare Middleware and reuse them on as <br>many routers as you like.</br></blockquote><p>Want to see how to configure them? Let’s declare a <a href="https://docs.traefik.io/middlewares/basicauth/">BasicAuth middleware</a> to control access to our service! (this time using TOML)</p><pre><code class="language-toml"># Declaring a basicauth middleware with two users
[http.middlewares.test-auth.basicAuth]
  users = ["user1:hashed", "user2:hashed"]

# Applying the middleware to our router
[http.routers.my-router.to-service]
  rule = "host(`my-protected.domain`)"
  middlewares = ["test-auth"]
  service = "service1"</code></pre><blockquote>A Chain to Bind Them All</blockquote><p>If you have a classic combination you often use together, you can declare <a href="https://docs.traefik.io/middlewares/chain/">chains</a>, and reuse them over and over. What’s even better for our Kubernetes users, you can use Traefik’s new CRD (Custom Resource Definition) for a crystal clear configuration that doesn’t involve intricate annotations. (You can find more information on the <a href="https://docs.traefik.io/providers/kubernetes-crd/#traefik-ingressroute-definition">IngressRoute object</a> in our documentation.)</p><pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: test
  namespace: default
spec:
  entryPoints:
    - web
  routes:
    - match: Host(`mydomain`)
      kind: Rule
      services:
        - name: whoami
          port: 80
      middlewares:
        - name: secured
---
apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: secured
spec:
  chain:
    middlewares:
    - name: https-only
    - name: known-ips
    - name: auth-users
---
apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: auth-users
spec:
  basicAuth:
    secret: secretUsers #yes! Compatible with K8S secrets
---
apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: https-only
spec:
  redirectScheme:
    scheme: https
---
apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: known-ips
spec:
  ipWhiteList:
    sourceRange:
    - 192.168.1.7
    - 127.0.0.1/32</code></pre><p>At release, Traefik comes with many <a href="https://docs.traefik.io/middlewares/overview/">pieces of middleware</a>: <a href="https://docs.traefik.io/middlewares/replacepath/">path manipulation</a>, <a href="https://docs.traefik.io/middlewares/forwardauth/">several authentication mechanisms</a>, <a href="https://docs.traefik.io/middlewares/buffering/">buffering</a>, <a href="https://docs.traefik.io/middlewares/circuitbreaker/">circuit breaker</a>, <a href="https://docs.traefik.io/middlewares/retry/">retry</a>, <a href="https://docs.traefik.io/middlewares/compress/">compression</a>, <a href="https://docs.traefik.io/middlewares/errorpages/">error handling</a>, <a href="https://docs.traefik.io/middlewares/headers/">headers</a>, <a href="https://docs.traefik.io/middlewares/ipwhitelist/">IP whitelisting</a>, <a href="https://docs.traefik.io/middlewares/ratelimit/">rate limiting</a>, <a href="https://docs.traefik.io/middlewares/redirectscheme/">redirections</a>, and more.</p><p>Also, we’ve re-architectured the code to make it easier for contributors to provide additional pieces of middleware, and I’m sure we’ll find a way to do <a href="https://github.com/containous/yaegi" rel="noopener">even better</a>.</p><h2 id="a-new-dashboard-webui">A New Dashboard &amp; WebUI</h2><p>Our goal with the new WebUI was to show users what was happening on their cluster at a glance. We also wanted to display what features they can enable.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-6.png" class="kg-image" alt="Traefik 2.0"/></figure><p>Since the flow has changed, we wanted to display every path that leads to services, with every configuration option.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-7.png" class="kg-image" alt="Traefik 2.0"/></figure><h2 id="canary-deployments-with-service-load-balancers">Canary Deployments with Service Load Balancers</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-8.png" class="kg-image" alt="Traefik 2.0"/></figure><p>Another <a href="https://github.com/containous/traefik/issues/1164" rel="noopener">long-awaited feature</a> — canary deployments, A/B testing — makes its way into Traefik 2.0 in the form of Service Load Balancers.</p><p>Service Load Balancers can be seen as virtual services that are responsible for forwarding the request to the actual services.</p><p>Let’s take a classic scenario where you have an existing route to an API:</p><pre><code class="language-yaml">http:
  routers:
    my-route:
      rule: "Host(`my.domain`)"
      service: my-api-v1
  services:
    my-api-v1:
      loadBalancer:
        servers:
        - url: "http://private-ip-server-1/"</code></pre><p>Now you want to deploy a new version of this service, but would like to deploy it progressively, let’s say approximately a third of the requests. What you’ll do is deploy the new service, with its own ID (here it’s<code>my-api-v2</code>).</p><pre><code class="language-yaml">http:
  services:
    my-api-v2:
      loadBalancer:
        servers:
        - url: "http://private-ip-server-2/"</code></pre><p>Then, instead of pointing directly to this new version, you’ll first define a Service Load Balancer (in the example <code>canary-api</code>) and define the proportion for each version (with the <code>weight</code> option).</p><pre><code class="language-yaml">http:
  services:
    canary-api:
      weighted:
        services:
        - name: my-api-v1
          weight: 3
        - name: my-api-v2
          weight: 1</code></pre><p>Finally, point to this <code>canary-api</code> service from your router.</p><pre><code class="language-yaml">http:
  routers:
    my-route:
      rule: "Host(`my.domain`)"
      service: canary-api</code></pre><p>Later, you’ll be able to update the weight without having to redeploy your <em><em>actual</em></em> services. You’ll also be able to scale them without any impact on the canary deployment itself.</p><h2 id="mirroring-with-service-load-balancers">Mirroring with Service Load Balancers</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-9.png" class="kg-image" alt="Traefik 2.0"/></figure><p>Canary deployments aren’t the only tricks available in the service family. Traefik 2.0 introduces Mirroring Services — a way to <a href="https://github.com/containous/traefik/issues/2989" rel="noopener">duplicate the incoming request</a> and send it to different services at the same time. The mirror will get a given percentage of requests, and its answers will be ignored.</p><pre><code class="language-toml">[http.services.mirrored-api]
    [http.services.mirrored-api.mirroring]
      service = "api"
    [[http.services.mirrored-api.mirroring.mirrors]]
      name = "api-v2"
      percent = 10

[http.services.api]
    [http.services.api.loadBalancer]
      [[http.services.api.loadBalancer.servers]]
        url = "http://private-ip-server-1/"

[http.services.api-v2]
    [http.services.api-v2.loadBalancer]
      [[http.services.api-v2.loadBalancer.servers]]
        url = "http://private-ip-server-2/"</code></pre><p>In the above example, we’re sending 10% of the requests to the mirror.</p><h2 id="and-much-much-more-">And Much, Much More!</h2><p>Traefik 2.0 introduces a syntax (<code>@provider</code>) to allow users to declare elements (middleware, services, routers) in a provider and to reference them from an other one. It provides an easier way to configure <a href="https://docs.traefik.io/middlewares/headers/#cors-headers">CORS headers</a>, embeds a redesigned <a href="https://docs.traefik.io/providers/overview/#restrict-the-scope-of-service-discovery">constraint management</a> to better control services you want to expose, and improves the default rule generation for a quick and easy way to define routes for containers.</p><p>On top of <a href="https://docs.traefik.io/operations/api/">many enhancements</a>, the API now embeds status information for your middleware, services, routers, and reports errors to help you identify and fix problems.</p><p>The polished configuration options ensure that configuring Traefik is always achieved the same way whether expressed with TOML, YAML, labels, or keys, and the <a href="https://docs.traefik.io/">revamped documentation</a> includes examples for every syntax.</p><p>You can define TLS termination separately on each router, configure TLS passthrough, use the new <code>CertResolver</code> to benefit from different challenges for certificate generation (yes, it’s now multiple-DNS-providers-proof!), and dynamically generate wildcard certificates.</p><p>Router rules now use a go-like syntax with <a href="https://docs.traefik.io/routing/routers/#rule">operators and parenthesis</a> for powerful and readable combinations.</p><p>The list goes on and on with bug fixes and other significant tweaks!</p><hr><h2 id="migrating-from-1-x">Migrating From 1.x</h2><p>With so many new features, bug fixes, and enhancements, Traefik 2.0 might ask you to re-think the way you used to route your requests. In order to facilitate the transition and help you leverage the power of these new options, we initiated a <a href="https://docs.traefik.io/migration/v1-to-v2/" rel="noopener">migration guide</a> that goes through every change we made.</p><p>For our <a href="https://kubernetes.io/" rel="noopener">Kubernetes</a> user-base, we’ve also written a <a href="https://github.com/containous/traefik-migration-tool" rel="noopener">migration tool</a> to help you convert your Ingress objects to the new IngressRoute format. (This migration tool will also help all users convert their <code>acme.json</code> file.)</p><p>All this is designed for the thousands of people already using Traefik.</p><hr><h2 id="behind-the-curtain">Behind the Curtain</h2><p>Traefik 2.0 is not the only thing that has improved! By the time we released 2.0, we launched <a href="https://containous.ghost.io/traefikee/" rel="noopener">TraefikEE</a>, <a href="https://github.com/containous/yaegi" rel="noopener">Yaegi</a>, <a href="https://containous.ghost.io/maesh/">Maesh</a>, and you can bet we’ll keep going further. We also constantly monitor our processes and tools. We’ve launched a <a href="https://community.containo.us/" rel="noopener">Community Forum</a> to foster better communication amongst users, introduced a monthly journal, and scheduled <a href="https://containous.ghost.io/events/">Traefik Online Meetups</a> to promote the community talent.</p><hr><h2 id="next-steps">Next Steps</h2><p>More than anything, this release shows the importance of the community. <a href="https://github.com/containous/traefik/issues/10" rel="noopener">Every</a> <a href="https://github.com/containous/traefik/issues/2999" rel="noopener">feature</a> <a href="https://github.com/containous/traefik/issues/7" rel="noopener">that</a> <a href="https://github.com/containous/traefik/issues/727" rel="noopener">has</a> <a href="https://github.com/containous/traefik/issues/895" rel="noopener">been</a> <a href="https://github.com/containous/traefik/issues/1164" rel="noopener">discussed</a> <a href="https://github.com/containous/traefik/issues/160" rel="noopener">today</a> <a href="https://github.com/containous/traefik/issues/2989" rel="noopener">was born</a> <a href="https://github.com/containous/traefik/issues/914" rel="noopener">from</a> <a href="https://github.com/containous/traefik/issues/2653" rel="noopener">a</a> <a href="https://github.com/containous/traefik/issues/966" rel="noopener">user</a> <a href="https://github.com/containous/traefik/issues/3378" rel="noopener">asking for a new feature</a>, <a href="https://github.com/containous/traefik/issues/4069" rel="noopener">reporting a bug</a>, <a href="https://github.com/containous/traefik/issues/3868" rel="noopener">or just asking</a> <a href="https://github.com/containous/traefik/issues/2773" rel="noopener">for “better.”</a></p><p>Traefik 1.X has been downloaded more than a <strong><strong>billion</strong></strong> times, and we hope to double that number with Traefik 2.X.</p><blockquote>❤️ Thank you for your support!❤️</blockquote><p>… and keep raising your voice for the (many) version(s) to come!</p><p>P.S. — Stay tuned! There is so much to show you with this new version that our developer team is preparing an Online Meetup for you. :-)</p><hr><h2 id="useful-links">Useful Links</h2><ul><li>Traefik <a href="https://docs.traefik.io/">documentation</a>, <a href="https://containous.ghost.io/traefik/">website</a> &amp; <a href="https://github.com/containous/traefik" rel="noopener">Github page</a></li><li>Containous <a href="https://containous.ghost.io/" rel="noopener">website</a></li><li><a href="https://community.containo.us/" rel="noopener">Community forum</a></li></ul></hr></hr></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Announcing Maesh, a Lightweight and Simpler Service Mesh Made by the Traefik Team]]></title><description><![CDATA[We are proud to introduce Maesh, Containous’ new service mesh designed from the ground up to be straightforward, easy to install and easy to use...]]></description><link>https://traefik.io/blog/announcing-maesh-a-lightweight-and-simpler-service-mesh-made-by-the-traefik-team-cb866edc6f29/</link><guid isPermaLink="false">Ghost__Post__5dd54eefec5ed30038788910</guid><category><![CDATA[Blog]]></category><category><![CDATA[Announcements]]></category><dc:creator><![CDATA[Damien Duportal]]></dc:creator><pubDate>Wed, 04 Sep 2019 14:36:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/maesh.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-110.png" class="kg-image" alt="Announcing Maesh, a Lightweight and Simpler Service Mesh Made by the Traefik Team"/></figure><img src="https://containous.ghost.io/content/images/2019/11/maesh.png" alt="Announcing Maesh, a Lightweight and Simpler Service Mesh Made by the Traefik Team"/><p>We are proud to introduce <a href="https://containous.ghost.io/maesh/">Maesh</a>, Containous’ new service mesh designed from the ground up to be straightforward, easy to install and easy to use. Maesh allows for visibility and management of the traffic that flows inside your Kubernetes cluster, which is just as important as the ingress and egress traffic.</p><p>Built on top of Traefik, Maesh is a simple, yet full-featured service mesh. It is container-native and fits as your de-facto service mesh in your Kubernetes cluster. It supports the latest Service Mesh Interface specification (<a href="https://smi-spec.io/" rel="noopener">SMI</a>) that facilitates integration with pre-existing solutions. Moreover, Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.</p><h2 id="non-invasive-service-mesh">Non-Invasive Service Mesh</h2><p>Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Maesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Maesh does not modify your Kubernetes objects, and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-10.png" class="kg-image" alt="Announcing Maesh, a Lightweight and Simpler Service Mesh Made by the Traefik Team"><figcaption>Maesh Architecture</figcaption></img></figure><h2 id="relies-on-kubernetes-dns">Relies on Kubernetes DNS</h2><p>Maesh leverages the CoreDNS platform installed by default in Kubernetes. It allows users to use the Maesh endpoints (instead of the standard Kubernetes service endpoints) to benefit from its feature set — no sidecars! Maesh endpoints run side-by-side with user services: you choose whether you use them or not (opt-in). This gives more confidence, since users know that they are able to test, and revert back to the user services: they should be happy with the result.</p><p>Also, the updates to CoreDNS made during the installation of Maesh is minimal and non-invasive, and is easily removable.</p><h2 id="multiple-network-layers">Multiple Network Layers</h2><p>Maesh can run in both TCP and HTTP mode</p><ul><li>In HTTP mode, Maesh leverages Traefik’s feature set to enable rich routing on virtual-host, path, headers, cookies.</li><li>Using TCP mode allows a seamless and easy integration with SNI routing support.</li></ul><p>Use both modes at the same time within the same cluster, and is configurable via annotations on services.</p><h2 id="built-on-top-of-traefik">Built on Top of Traefik</h2><p>Maesh builds on top of <a href="https://containous.ghost.io/traefik/">Traefik</a>, the leading reverse proxy for routing, and provides every feature users would expect: OpenTracing, load balancing for HTTP, gRPC, WebSocket, TCP, rich routing rules, retries and fail-overs, not to mention access controls, rate limits, and circuit breakers.</p><h2 id="easy-to-install-easy-to-use">Easy to Install; Easy to Use</h2><p>Installing Maesh to your cluster is easy: install the Helm chart, as there are no helper applications, no CRDs to install, and no new vocabulary for users to learn. If users understand how pods and services work, then Maesh will be easy to understand and use.</p><p>Let’s get started by installing Maesh using the following commands:</p><pre><code class="language-shell">helm repo add maesh https://containous.github.io/maesh/charts
helm repo update
helm install --name=maesh --namespace=maesh maesh/maesh</code></pre><p>Maesh is now ready to use in your cluster, and you’re one annotation away from using it on any running application:</p><pre><code class="language-shell">kubectl annotate service \
    web-application maesh.containo.us/traffic-type=http</code></pre><p>Is your application using a TCP communication protocol (which is not HTTP)? It is also supported:</p><pre><code class="language-shell">kubectl annotate service mongo-database \
    maesh.containo.us/traffic-type=tcp</code></pre><p>That’s how easy it is to install and use Maesh!</p><h2 id="what-s-next">What’s Next</h2><p>Because Maesh is open source, we would love the community’s input as to which features are important to you, so that we can prioritise the top requests.</p><p>We welcome community contributions and love when they are faster than us to provide additional features! Pull requests are the best way to support the product and make it your own.</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://containous.ghost.io/maesh/">Website</a></li><li><a href="https://docs.mae.sh/">Documentation</a></li><li><a href="https://github.com/containous/maesh" rel="noopener">Github</a></li><li><a href="https://community.containo.us/c/maesh" rel="noopener">Community Forum</a></li></ul>]]></content:encoded></item><item><title><![CDATA[From Zero to Hero in Minutes with Konvoy’s Built-In Traefik for Kubernetes]]></title><description><![CDATA[Konvoy, from D2iQ, provides a complete out-of-the-box experience of production-ready Kubernetes.
It is a tool for provisioning pure Kubernetes clusters...]]></description><link>https://traefik.io/blog/from-zero-to-hero-in-minutes-with-konvoys-built-in-traefik-for-kubernetes-11577fdeeb14/</link><guid isPermaLink="false">Ghost__Post__5dd553eaec5ed30038788992</guid><category><![CDATA[Blog]]></category><category><![CDATA[Partners]]></category><dc:creator><![CDATA[Damien Duportal]]></dc:creator><pubDate>Thu, 08 Aug 2019 14:55:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/d2iq.jpeg" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-111.png" class="kg-image" alt="From Zero to Hero in Minutes with Konvoy’s Built-In Traefik for Kubernetes"/></figure><img src="https://containous.ghost.io/content/images/2019/11/d2iq.jpeg" alt="From Zero to Hero in Minutes with Konvoy’s Built-In Traefik for Kubernetes"/><p><a href="https://d2iq.com/solutions/ksphere/konvoy" rel="noopener">Konvoy</a>, from D2iQ, provides a complete out-of-the-box experience of production-ready Kubernetes.</p><p>It is a tool for provisioning pure Kubernetes clusters, based on a set of Cloud Native Computing Foundation (CNCF) and community-contributed components. This Kubernetes distribution provides a set of pre-installed components to get you started immediately.</p><p>We’re delighted to announce that <a href="https://containous.ghost.io/traefik/">Traefik</a>, the popular open source cloud native edge router, integrates with Konvoy.</p><p><a href="https://d2iq.com/blog/from-zero-to-hero-in-minutes-with-konvoy-s-built-in-traefik-for-kubernetes" rel="noopener">Click to continue reading…</a></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-13.png" class="kg-image" alt="From Zero to Hero in Minutes with Konvoy’s Built-In Traefik for Kubernetes"><figcaption>Welcome To Konvoy Ops Dashboard: Traefik is already there!</figcaption></img></figure>]]></content:encoded></item><item><title><![CDATA[Announcing Yaegi]]></title><description><![CDATA[Yaegi, Yet Another Go Interpreter, is an open source project to bring executableGo scripts, embedded plugins on top of the Go runtime...]]></description><link>https://traefik.io/blog/announcing-yaegi-263a1e2d070a/</link><guid isPermaLink="false">Ghost__Post__5dd5560dec5ed300387889f5</guid><category><![CDATA[Blog]]></category><category><![CDATA[Announcements]]></category><dc:creator><![CDATA[Marc Vertes]]></dc:creator><pubDate>Wed, 24 Jul 2019 15:04:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/yaegi.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/yaegi.png" alt="Announcing Yaegi"/><p class="post-sub-title">Yet Another Go Interpreter</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-112.png" class="kg-image" alt="Announcing Yaegi"/></figure><p>In this post, we present <a href="https://github.com/containous/yaegi/" rel="noopener">Yaegi</a>, Yet Another Go Interpreter, with the E standing for Elegant, Embedded, Easy, or whatever you prefer.</p><p>Yaegi is an open source project developed by Containous, (the company behind <a href="https://containous.ghost.io/traefik/">Traefik</a> and <a href="https://containous.ghost.io/traefikee/" rel="noopener">TraefikEE</a>), to bring executable <a href="https://golang.org/" rel="noopener">Go</a> scripts, embedded plugins, interactive shells, and instant prototyping on top of the Go runtime. Yaegi project is hosted on <a href="https://github.com/containous/yaegi" rel="noopener">GitHub</a>.</p><h2 id="motivation">Motivation</h2><p>Despite being static and strongly typed, Go feels like a dynamic language. The standard library even provides the Go parser used by the compiler and the reflection system to interact dynamically with the runtime. So why not just take the last logical step and finally build a complete Go interpreter?</p><p>Programming languages for high level scripting and for low level implementation are usually different. This time, with Go, we have an opportunity to unify both. Imagine all the C/C++/Java fast libraries for Python being written in Python instead. That’s what Yaegi is for Go (or, the reverse). No burden due to syntax switch, no need to rewrite or modify slow code to make it fast, and full access to goroutines, channels, type safety, etc. at script level.</p><h2 id="goals-and-priorities">Goals and Priorities</h2><ul><li>Simplicity: <code>New()</code>, <code>Eval()</code> and <code>Use()</code> is the only API. No external dependencies besides the standard Go library.</li><li>Standard: the interpreter supports 100% of the <a href="https://golang.org/ref/spec" rel="noopener">Go Specification</a>.</li><li>Robustness: preserve type safety and runtime integrity: <code>unsafe</code> and <code>syscall</code>packages are not used nor exposed by default. Security over performance.</li><li>Interoperability: scripts can “import” pre-compiled runtime packages, but also compiled code can “import” script packages during execution. See usage examples below for more details.</li></ul><h2 id="using-yaegi">Using Yaegi</h2><h3 id="as-a-command-line-interpreter">As a Command-Line Interpreter</h3><p>The Yaegi executable can interpret Go files or run an interactive Read-Eval-Print-Loop:</p><pre><code class="language-shell">$ yaegi
&gt; 1 + 2
3
&gt; import "fmt"
&gt; fmt.Println("Hello World")
Hello World
&gt;</code></pre><p>Yaegi works like <code>go run</code> (but faster). It also enables executable Go scripts (starting with <code>#!</code>). Yaegi provides a full Go environment with a complete standard library in a single standalone executable.</p><h3 id="as-an-embedded-interpreter">As an Embedded Interpreter</h3><p>In the following example, an interpreter is created with <code>New()</code> and then it evaluates Go code using <code>Eval()</code>. Nothing surprising here.</p><pre><code class="language-go">package main

import (
    "github.com/containous/yaegi/interp"
    "github.com/containous/yaegi/stdlib"
)

func main() {
    i := interp.New(interp.Options{})
    i.Use(stdlib.Symbols)
    i.Eval(`import "fmt"`)
    i.Eval(`fmt.Println("hello")`)
}</code></pre><p>This example demonstrates the ability to use executable pre-compiled symbols in the interpreter. Thanks to the statement <code>i.Use(stdlib.Symbols)</code>, the interpreted <code>import "fmt"</code>will load the <code>fmt</code> package from the executable itself (wrapped in <code>reflect.Values</code>) instead of trying to parse source files.</p><p>Yaegi also provides the <code>goexports</code> command to build the binary wrapper of any package from its source. This is the command we used to generate all stdlib wrappers provided by default.</p><h3 id="as-a-dynamic-extension-framework">As a Dynamic Extension Framework</h3><p>The program is compiled ahead of time, except for the function <code>bar()</code> that is interpreted from a script. The import process involves the following steps:</p><ol><li>use of <code>i.Eval(src)</code> to internally compile the script package in the context of the interpreter</li><li>use of <code>v,_ := i.Eval("<em><em>foo.Bar</em></em>")</code> to get the symbol that we want to use as a <code>reflect.Value </code>(please forgive me for the missing error handling)</li><li>application of <code>Interface()</code>method and type assertion to convert the <code>reflect.Value</code> into a usable Go typed function</li></ol><pre><code class="language-go">package main

import "github.com/containous/yaegi/interp"

const src = `package foo
func Bar(s string) string { return s + "-Foo" }`

func main() {
    i := interp.New(interp.Options{})
    i.Eval(src)
    v, _ := i.Eval("foo.Bar")
    bar := v.Interface().(func(string) string)
    
    r := bar("Kung")
    println(r)
    // Output:
    // Kung-Foo
}</code></pre><h2 id="what-about-performance">What about Performance?</h2><p>Interpreters are quite common in domains like gaming or science. But could Yaegi also be usable as a plugin engine in the context of distributed systems?</p><p>To answer that, we have benchmarked the use of <a href="https://github.com/nytimes/gziphandler" rel="noopener">gziphandler</a>, a middleware for compressing HTTP responses. Gziphandler provides interface methods implementing compression for the HTTP server in the standard library. This demonstrates an interpreted dynamic processing inserted into a statically compiled server program, with a direct impact on latency and throughput.</p><p>In one case, gziphandler is compiled and used directly as a callback passed to <code>http.Handle()</code>. In the other, the interpreted version of gziphandler is used.</p><pre><code class="language-text">Benchmark      old ns/op   new ns/op    delta
Compress-8     769088      817632       +6.31%</code></pre><p>We measured less than 10% of overhead for the interpreted version of gziphandler compared to the compiled version, which is to us an acceptable cost for to the benefits of dynamically extending foour server.</p><p>One important factor is that the gzip compression itself is provided by the standard lib, already compiled, and exposed to the interpreter by <code>Use()</code>.</p><p>Interpreters work best at providing the glue language and offloading CPU intensive computations to optimized compiled libraries. With Go and Yaegi, this can be achieved simply and almost transparently.</p><h2 id="conclusion">Conclusion</h2><p>We are announcing Yaegi, a Go interpreter. It’s a young project and as such, far from perfect. Yaegi is open source and needs your feedback and contributions. We hope to make it as useful as possible for the Go community and beyond. This is only the beginning. At Containous, we are focused on solving practical problems through innovative solutions. Stay tuned for upcoming announcements about both Yaegi and Containous.</p><p>Join us at <a href="https://github.com/containous/yaegi" rel="noopener">github.com/containous/yaegi</a>.</p><p>I want to thank <a href="https://containous.ghost.io/" rel="noopener">Containous</a>, <a href="https://twitter.com/emilevauge" rel="noopener">Emile Vauge</a>, <a href="https://twitter.com/ludnadez" rel="noopener">Ludovic Fernandez</a>, <a href="https://twitter.com/lejatorn" rel="noopener">Mathieu Lonjaret</a> who coined the name, <a href="https://www.linkedin.com/in/pierre-keersbulik-198107117" rel="noopener">Peka</a> for the awesome logo, and many other colleagues for their support.</p>]]></content:encoded></item><item><title><![CDATA[Can We Trust GitHub Stars?]]></title><description><![CDATA[GitHub stars are an essential growth factor for many open source projects, but they can easily be from bot accounts. How can we trust GitHub stars again?]]></description><link>https://traefik.io/blog/can-we-trust-github-stars-e8aa8b6b0baa/</link><guid isPermaLink="false">Ghost__Post__5dd55551ec5ed300387889cc</guid><category><![CDATA[Blog]]></category><category><![CDATA[Community]]></category><dc:creator><![CDATA[Brendan LE GLAUNEC]]></dc:creator><pubDate>Tue, 16 Jul 2019 15:01:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/1-Tswt2xxYYgoCa0kE-Wirfg.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/1-Tswt2xxYYgoCa0kE-Wirfg.png" alt="Can We Trust GitHub Stars?"/><p class="post-sub-title">GitHub stars are an essential growth factor for many open source projects, but they can easily be from bot accounts. How can we trust GitHub stars again?</p><!--kg-card-end: html--><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-14.png" class="kg-image" alt="Can We Trust GitHub Stars?"/></figure><p>For Open Source GitHub projects, stars are a primordial metric. Of course, there are ways to abuse this system, as you might have heard recently. As an open source company, we want our<strong><strong> community’s legitimacy</strong></strong> to be transparent, and we want to help the open source community do the same for other projects.</p><p>In the past, there have been many occurrences of people abusing the GitHub API:</p><ul><li><a href="https://github.com/andrewsyc/github-follow-bot" rel="noopener">Gaining followers quickly</a> by making their account follow thousands of other people, hoping for them to follow back</li><li>Faking their GitHub contributions to make themselves look like outstanding open source developers</li><li><a href="https://redmonk.com/jgovernor/2017/10/24/so-where-all-the-github-link-farms-at-astro-turfing-in-software-development/" rel="noopener">Automatically creating bot accounts</a> to star repositories and virtually increase their popularity (Examples: <a href="https://github.com/ffujiawei/auto-stars/blob/master/auto_stars.py" rel="noopener">here</a> and <a href="https://www.zdnet.com/article/researchers-uncover-ring-of-github-accounts-promoting-300-backdoored-apps/" rel="noopener">here</a> among others)</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-15.png" class="kg-image" alt="Can We Trust GitHub Stars?"><figcaption>starbot is an automated bot account creator which starred repositories (has been taken down)</figcaption></img></figure><p>GitHub has taken down several of the repositories responsible for such abuses, but not all of them. The main reason why it was so simple to write those bots was that creating GitHub accounts did not used to require any kind of verification, not even a confirmation link via email.</p><p>While GitHub recently changed that by including a <strong><strong>verification system</strong></strong> during account creation, it turns out that the challenge can be switched to an audio challenge, which is significantly weaker than the standard one. Also, many of the bot accounts created for the last few years are still there, from before the introduction of the verification procedures.</p><p>This means that some repositories might have used simple bot creation scripts in the past, or might be currently using more advanced ones, able to bypass the verification system. This has serious implications, because of the <strong><strong>impact of GitHub stars</strong></strong> on today’s open source ecosystem.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-16.png" class="kg-image" alt="Can We Trust GitHub Stars?"/></figure><p>The fastest growing repositories in terms of stars are put on the <a href="https://github.com/trending" rel="noopener">trending page</a>, sent in the <a href="https://github.com/trending/go?since=daily" rel="noopener">GitHub daily mailing list</a> to thousands of users, are shown more frequently in the <a href="https://github.com/explore" rel="noopener">Explore</a> tab, and attract more attention in general. It’s also a very well known phenomenon that many startups tend to use technologies based on how many stars they have, as it’s usually a good indicator of the size of the community behind a project.</p><p>That’s why we decided to start a side-project, called <a href="https://github.com/Ullaakut/astronomer" rel="noopener">Astronomer</a>, as a reference to analyzing GitHub stars and fighting against <a href="https://en.wikipedia.org/wiki/Astroturfing" rel="noopener">astro-turfing</a>.</p><p>It’s an open source tool which leverages the GitHub API to <strong><strong>scan GitHub stargazers</strong></strong> and <strong><strong>compute an overall trust level</strong></strong> for the repository, based on multiple statistics found within the stargazers. Using Astronomer can help the open source community prove the authenticity of their communities, and stop accusing each other based on gut feelings.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/astronomer.gif" class="kg-image" alt="Can We Trust GitHub Stars?"><figcaption>Astronomer, scanning itself</figcaption></img></figure><p>Astronomer can also give more detailed statistics for an in-depth look at a community. It computes <strong><strong>many factors</strong></strong> upon which it determines the trust level:</p><ul><li>Weighted contributions (older contributions being worth more trust)</li><li>Private contributions (having the lowest weight when computing overall trust)</li><li>Independent factors for different types of public contributions (Issues created, Pull Requests created, Code reviews, etc.) which helps mitigate the impact potential bots which would have tons of fake code contributions.</li><li>Account age (older accounts being worth more trust)</li><li>Amount of owned repositories</li><li>Every 5th percentile of the weighted contribution score, from <code>5</code> to <code>95</code></li></ul><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-18.png" class="kg-image" alt="Can We Trust GitHub Stars?"/></figure><p>It scans two sets of stargazers: the first 200 users to have starred the project (since they are the most likely to be bots), and random stargazers. It computes two trust reports and combines them into its final trust report.</p><p>Astronomer then sends the trust reports that it generates to the <a href="https://github.com/Ullaakut/astrolab" rel="noopener">Astrolab</a> server, which serves GitHub badges for the repositories that were scanned by the community. If you want to generate a badge for your repository, all you need is to <code>docker run</code> astronomer right now and it will generate it for you.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-19.png" class="kg-image" alt="Can We Trust GitHub Stars?"/></figure><p>As expected, the results of scanning Traefik are very positive, since its community tends to contribute to many open source repositories. At the bottom of an Astronomer report, the generated GitHub badge URL is displayed, ready to be inserted in the repository’s readme file.</p><p>The next step for Astronomer will be to provide a web application to view detailed reports for all scanned repositories.</p><p>We sincerely hope that this tool will <strong><strong>help the open source community</strong></strong> overall, and that it will help in reducing the tension between competing open source projects by removing the source of doubt in their communities and their legitimacies.</p>]]></content:encoded></item><item><title><![CDATA[Announcing TraefikEE v1.1]]></title><description><![CDATA[Traefik Enterprise Edition is a platform built on top of Traefik. Version 1.1 offers Automatic Certificate Management, Distributed Features, and Enhanced...]]></description><link>https://traefik.io/blog/announcing-traefikee-v1-1-1338e9b7cd79/</link><guid isPermaLink="false">Ghost__Post__5dd55473ec5ed300387889a5</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Brendan LE GLAUNEC]]></dc:creator><pubDate>Thu, 11 Jul 2019 14:57:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/traefikee-v1.1.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/traefikee-v1.1.png" alt="Announcing TraefikEE v1.1"/><p class="post-sub-title">Offers Automatic Certificate Management, Distributed Features, and Enhanced Support for DockerEE</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-full"><img src="https://containous.ghost.io/content/images/2019/11/image-113.png" class="kg-image" alt="Announcing TraefikEE v1.1"/></figure><p>It’s been two months since the <a href="https://containous.ghost.io/blog/announcing-general-availability-of-traefik-enterprise-edition-9c9aad363ce/">general availability</a> of the 1.0 version of Traefik Enterprise Edition. Encouraged by its successful launch, and propelled by the immense feedback we received from customers, the team started to work on 1.1 right away.</p><blockquote><a href="https://containous.ghost.io/traefikee/" rel="noopener">Traefik Enterprise Edition</a> is a new platform built on top of <a href="https://containous.ghost.io/traefik/">Traefik</a>, the popular open-source cloud-native edge router, designed for business-critical deployments. It adds clustering features to satisfy the needs of enterprise customers. See it in action in the <a href="https://info.containo.us/request-demo-traefikee">video demonstration</a>!</blockquote><p>So, let’s see what’s new in this 1.1 for TraefikEE <em><em>and</em></em> <code>traefikeectl</code>, its control tool!</p><h2 id="acme-account-certificate-management">ACME Account &amp; Certificate Management</h2><p>Designed for users that already leverage Let’s Encrypt and its automatic certificate management, TraefikEE 1.1 allows you to seamlessly import your certificates right into the cluster.</p><pre><code class="language-shell">traefikeectl acme-add-certificate \
	--certfile="cert.pem" \
	--keyfile="key.pem" \
	--accountname="my account"</code></pre><p>In the process, it is now possible to manage ACME accounts within your TraefikEE cluster using the <code>traefikee</code> and <code>traefikeectl</code> binaries: ask TraefikEE to create ACME accounts, or to import your existing accounts.</p><pre><code class="language-shell"># Adds your me@containo.us account to your TraefikEE cluster!
traefikeectl acme-add-account \
  --use \
  --caserver="https://caserver" \
  --email="me@containo.us" \
  --name="my account" 
  --privatekey="key.pem"
  --uri="https://registration_uri.com”</code></pre><p>Want to learn more about these features, just check out the <a href="https://docs.containo.us/operating/acme/">operating guide</a> about TraefikEE 1.1.</p><h2 id="distributed-rate-limiting">Distributed Rate Limiting</h2><p>TraefikEE makes autoscaling easy: deploy more data nodes as the number of incoming requests grows. Before 1.1, when you configured rate limiting for your underlying services, each node had its own rate limiting. In 1.1, the control plane makes sure the rate limiting is distributed within the cluster.</p><p>TraefikEE intercepts the rate limiting configuration and inject its own distributed rate limiting middleware into Traefik.</p><p>The best part? The configuration remains <strong><strong>exactly the same</strong></strong>!</p><pre><code class="language-yaml">---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: myservice
  namespace: traefikee
  labels:
    app: myservice
  annotations:
    traefik.ingress.kubernetes.io/rate-limit: |
      extractorfunc: client.ip
      rateset:
        bar:
          period: 10s
          average: 10000
          burst: 10000</code></pre><p>This service for example, has a cluster-wide rate limit set to 10,000 requests per client IP within 10 seconds.</p><h2 id="network-automatic-discovery">Network Automatic Discovery</h2><p>Some users were leveraging <a href="https://github.com/docker/swarm" rel="noopener">Docker Swarm</a> network capabilities to improve security on their cluster, making sure each service used its own network.</p><p>Before 1.1, they had no choice but to attach another network to their services so that Traefik could reach them (and properly route the requests), or to attach the new networks to TraefikEE itself. Since Traefik has always been about dynamic configuration, we weren’t satisfied with this situation.</p><p>In 1.1, TraefikEE (thanks to its redesigned architecture) is now able to discover the new networks and to reach them automatically.</p><p>It means that you are now able to add new applications from different Docker networks — and TraefikEE will dynamically update the data plane to join those networks.</p><p>You can turn this feature on during installation time!</p><pre><code class="language-shell">traefikeectl install \
  --swarm \
  --swarm.networkautodiscovery \
  --licensekey="$TRAEFIKEE_LICENSE_KEY"</code></pre><h2 id="docker-enterprise-edition">Docker Enterprise Edition</h2><figure class="kg-card kg-image-card"><img src="https://miro.medium.com/proxy/1*YhmLMOeN6VJwGNqv-H_SiQ.jpeg" class="kg-image" alt="Announcing TraefikEE v1.1"/></figure><p>TraefikEE is <a href="https://containous.ghost.io/blog/traefikee-now-dockeree-certified-d926bf7255a4/">Docker certified</a>! It means that it has been tested and is supported by Docker Enterprise — It complies with Docker best practices guidelines, has proven provenance, and has been scanned for security vulnerabilities.</p><p>Before 1.1, TraefikEE needed to install its control plane on the docker manager nodes, which could be a limitation.</p><p>Good news, TraefikEE 1.1 can now be deployed on the worker nodes (and don’t even need any manager node to fully operate).</p><p>On top of that, it now uses the UCP connector with enhanced security and proper credentials.</p><h2 id="what-s-next">What’s Next?</h2><p>With TraefikEE 1.1, we’re very proud to have helped our customers take full benefit of Traefik and find ways to make sure every detail was taken care of.</p><p>In 1.2 (yes, there will be a 1.2 before the next big step!) we will keep improving the user experience to make sure that managing a TraefikEE cluster is as simple as managing a single instance of Traefik, with extra benefits tailored for the enterprise.</p><h2 id="try-it-now-">Try it now!</h2><p>Get a <a href="https://containous.ghost.io/traefikee/" rel="noopener">free one month trial</a> right now, and install TraefikEE on your favorite environment by following the <a href="https://docs.containo.us/">installation guides</a>.</p><p>And if you want to learn more and see a live demo of TraefikEE 1.1, <a href="https://info.containo.us/request-demo-traefikee">request a demo</a> today.</p>]]></content:encoded></item><item><title><![CDATA[Announcing the Containous Community Forum!]]></title><description><![CDATA[We’re thrilled to announce the launch of our community forum aimed at connecting and supporting our community.]]></description><link>https://traefik.io/blog/announcing-the-containous-community-forum-d7828e220680/</link><guid isPermaLink="false">Ghost__Post__5dd6923fb6de2b00381d3f86</guid><category><![CDATA[Blog]]></category><category><![CDATA[Community]]></category><dc:creator><![CDATA[Marie Ponseel]]></dc:creator><pubDate>Tue, 25 Jun 2019 13:33:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/forum.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-114.png" class="kg-image" alt="Announcing the Containous Community Forum!"/></figure><img src="https://containous.ghost.io/content/images/2019/11/forum.png" alt="Announcing the Containous Community Forum!"/><p>We’re thrilled to announce the launch of <a href="https://community.containo.us/" rel="noopener">our community forum</a> aimed at connecting and supporting our community.</p><h2 id="why-a-community-forum"><strong>Why a Community Forum?</strong></h2><p><a href="https://containous.ghost.io/traefik/">Traefik</a> is a community of thousands of people around the world who are working with, and using Traefik on a daily basis. Until today, conversations have been taking place on our Slack channel. But as the community grows, and users of Traefik continue to engage, we’re seeing an increased set of commonly asked questions more and more frequently. In hopes of providing a more efficient way to help both new and experienced members, we are launching an open forum where anyone can post questions and search for any specific topic to find answers from relevant past conversations.</p><p>With the forum, we also want to consolidate a dedicated base of knowledge for everything Traefik-related for our community. Whether you are a beginner or an advanced user of Traefik, we hope the forum will serve as a valuable resource for all your Traefik needs.</p><h2 id="what-will-i-find-in-there"><strong>What will I find in there?</strong></h2><p>If you are looking to get more involved and connected with our community, here’s what you’ll find on <a href="https://community.containo.us/" rel="noopener"><strong><strong>community.containo.us</strong></strong></a>:</p><ul><li>Connect with Traefik users from all around the world</li><li>Easily ask questions and get answers on any technical topics related to Traefik</li><li>Share your experience and help other members</li><li>Connect with the core Traefik team, Traefik maintainers, and Traefik contributors</li></ul><h2 id="sign-up-and-get-started-"><strong>Sign up and get started!</strong></h2><p>The forum is built using the popular Discourse platform. Creating an account is super easy — just authenticate via email, or with your Github account.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-21.png" class="kg-image" alt="Announcing the Containous Community Forum!"/></figure><p>Once you’re on the forum homepage, topics are classified by categories. The categories are listed on the left side with the most recently asked topics on the right side.</p><p>You’ll be able to search for a topic, a post, or anything using the magnifying glass on the top right corner.</p><p>And if you don’t find the answer you’re looking for, you can add a new post by clicking on the “New Topic” button. From here, you only need to select a category, write a title, and your description. We encourage you to be as specific as possible, and to give as much information as possible so that others may have an easier time answering your question.</p><p>While the community forum is brand new (and, therefore still pretty empty), you are officially invited to start using the forums for all support questions and discussions today!</p><p>The forum is moderated by Traefik contributors, but if you’d like to participate in answering questions, feel free to do so. This community forum is open and free to everyone, so please <a href="https://community.containo.us/" rel="noopener"><strong><strong>join us</strong></strong></a>!</p><h2 id="we-d-love-to-hear-your-feedback-"><strong>We’d love to hear your feedback!</strong></h2><p>If you have any suggestions or comments on how we could improve the forum, feel free to contact us, we’d love to hear from you!</p><p>We look forward to seeing you <a href="https://community.containo.us/" rel="noopener">in the forum</a>!</p>]]></content:encoded></item><item><title><![CDATA[How to Pronounce Traefik?]]></title><description><![CDATA[How to Pronounce Traefik?
The Answer to the infamous question, “How do you pronounce Traefik?” lies in the Question...]]></description><link>https://traefik.io/blog/how-to-pronounce-traefik-d06696a3f026/</link><guid isPermaLink="false">Ghost__Post__5dd69298b6de2b00381d3f96</guid><category><![CDATA[Blog]]></category><category><![CDATA[Company]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Tue, 18 Jun 2019 13:35:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/traefik-pron.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/traefik-pron.jpeg" alt="How to Pronounce Traefik?"/><p class="post-sub-title">The Answer Lies in the Question</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-full"><img src="https://containous.ghost.io/content/images/2019/11/image-116.png" class="kg-image" alt="How to Pronounce Traefik?"/></figure><p>If you’re here reading (at last!) the official answer to the infamous question, “How do you pronounce Traefik?”, then chances are you’re a Traefik user who has had passionate debates with your colleagues around this weird looking character <code>æ</code> which shares the lines between an <code>a</code> and an <code>e</code>. (And chances are you already chose a distinct way to pronounce “Træfik” that avoids confusion when talking about how you handle traffic in Traefik … but that’s a different story.)</p><h3 id="danish-norwegian-icelandic-or-faroese">Danish, Norwegian, Icelandic, or Faroese?</h3><p>Of course, if you speak Danish, Norwegian, Icelandic, or Faroese, then you’re familiar with the <code>æsc</code> grapheme. If so, you’re probably ready to bet a coffee on the answer.<strong><strong> </strong></strong>On the other hand<strong><strong>, </strong></strong>the question still lingering in your mind has drifted to, “Why did they use the Danish character in Traefik? Are they Danish?”</p><h3 id="french">French?</h3><p>If you’re French, you know for sure that this ligature looks like the <code><em><em>e coulé</em></em></code> (a pun for children to remember that the “<em><em>e is in the o”</em></em> … <code>o</code> sounds like “water” in French … so “<em><em>e coulé”</em></em> literally translates to, “<em><em>sunken e”</em></em>).</p><p>But even if you’ve seen this syntax trick in words like “cœur” (<em><em>heart</em></em>), “œuf” (<em><em>eggs</em></em>), “sœur” (<em><em>sister</em></em>), or “œuvre” (<em><em>work</em></em>), you can’t find a single word with the same ligature involving an<code>a</code> and an <code>e</code> (and even if you’d find one eventually, you wouldn’t put it in your <em><em>curriculum vitæ</em></em> anyways).</p><h3 id="english">English?</h3><p>If you’re a native English speaker, you know for sure that there are no such letter combinations in English (OK … apart from phœnix, but a gopher is not even close to having wings … until you remember that there are other ætherical creatures … that there was a Cæsar æra … and that it won’t take you æons before you can find other examples … so the <code>æ</code> in Traefik might not be “just an æsthetic choice”).</p><h3 id="non-native-english-speakers">Non-native English speakers?</h3><p>Traefik, as an <a href="https://github.com/containous/traefik" rel="noopener">open-source project</a>, is the result of many people working together. <a href="https://containo.us/" rel="noopener">Containous</a>, as a distributed company, has employees all over the world (and <a href="https://containo.us/careers/" rel="noopener">we’re hiring</a>!). So the blunt answer could also be, “We pronounce Traefik the best we can.”</p><h3 id="so-many-languages-">So many languages …</h3><p>So no, this ligature in Traefik has nothing to do with the etymology of the word. This ligature is the result of the very question, “How do you pronounce Traefik?”</p><p>To answer this question, we’ll use the <em><em>International Phonetic Alphabet (IPA)</em></em> and will write:</p><blockquote><em><em>You pronounce Traefik like the regular word <a href="https://dictionary.cambridge.org/dictionary/english/traffic" rel="noopener">Traffic</a> (<strong><strong>/ˈtræfɪk/</strong></strong>)</em></em></blockquote><p>While designing the logo, we’ve just been sloppy and got rid of the stress <code>ˈ</code> and since French people are not able to make a proper <code>ɪ</code><strong> </strong>sound, we replaced it with an <code>i</code>.</p><h3 id="now-you-know-">Now you know!</h3><p>Even though the official answer is out, we still hope to see many Traefik users approaching us and asking us the same question over and over again, “How do you pronounce Traefik?” simply because it’s the only thing they haven’t figured out from the documentation.</p>]]></content:encoded></item><item><title><![CDATA[With Great Community …]]></title><description><![CDATA[Recently, we were made aware that some users had misconfigured instances of Traefik, which could have exposed sensitive data...]]></description><link>https://traefik.io/blog/with-great-community-2b9d97485eb8/</link><guid isPermaLink="false">Ghost__Post__5dd6a17eb6de2b00381d3fa8</guid><category><![CDATA[Blog]]></category><category><![CDATA[Community]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Wed, 05 Jun 2019 14:38:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/great-community.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/great-community.jpeg" alt="With Great Community …"/><p class="post-sub-title">… Comes Great Responsibility</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-full"><img src="https://containous.ghost.io/content/images/2019/11/image-117.png" class="kg-image" alt="With Great Community …"/></figure><p>There is not a single day when we aren’t proud of our community and inspired by the many people using Traefik. One of our greatest accomplishments with Traefik is its simplicity: making it possible for everyone to run microservices architecture with ease.</p><p>But, with so many people using Traefik, we realized that it’s not only important to make sure that best practices are well documented, but that the time has come to think about ways to <em><em>enforce</em></em> best practices.</p><p>Recently, we were made aware that some users had misconfigured instances of Traefik, which could have exposed sensitive data: Traefik embeds a dashboard that lets administrators see the existing routes (and, their parameters). And, if this dashboard (and its APIs) was enabled and was made public (no protection, and accessible from the outside), then potential attackers would have been able to access sensitive configuration data.</p><p>In both cases, we released a fix as quickly as possible, and made a CVE (<a href="https://www.cvedetails.com/cve/CVE-2019-12452/" rel="noopener">CVE-2019–12452</a>, <a href="https://www.cvedetails.com/cve/CVE-2018-15598/" rel="noopener">CVE-2018–15598</a>) to disclose the information.</p><blockquote>“Even though we don’t like stumbling onto security issues, running an open-source project means being open and transparent about what’s happening.”</blockquote><h2 id="am-i-impacted-by-this-cve">Am I Impacted by This CVE?</h2><p>You are impacted if you meet all the following criteria:</p><ul><li>Running Traefik v1.7.11 or older,</li><li><strong><strong>And,</strong></strong> the API is enabled (either with the directive <code>[api]</code> in <code>traefik.toml</code>, with the command line flag <code>--api</code>, or with the <em><em>deprecated</em></em> directive <code>[web]</code> in <code>traefik.toml</code>),</li><li><strong><strong>And,</strong></strong> the API is not secured with authentication (but should be, see the <a href="https://docs.traefik.io">documentation</a>),</li><li><strong><strong>And,</strong></strong> the API is exposed on a non trusted network.</li></ul><p>In this case, we recommend you to do the following:</p><ul><li>Update to the latest stable version of Traefik (<a href="https://github.com/containous/traefik/releases/tag/v1.7.12" rel="noopener">1.7.12</a>),</li><li><em><em>Not</em></em> expose the API/Dashboard (or, to disable it),</li><li><a href="https://docs.traefik.io/operations/api/">Configure the authentication</a> if you need the API/Dashboard to be accessible.</li></ul><h2 id="combining-user-experience-with-security">Combining User Experience with Security</h2><p>Having a user-friendly dashboard is one of the praised features of Traefik, but it’s our responsibility to make sure people can’t misconfigure it in a potentially harmful way.</p><p>We’ve <a href="https://github.com/containous/traefik/issues/4934" rel="noopener">started a discussion here</a> to find better ways to let our users enjoy a full-featured dashboard, but in a way that enforces security, and that doesn’t enable this feature unless using proper credentials.</p><p>In the meantime, once again, never <em><em>ever</em></em> expose your Traefik dashboard/API to the outside with no protection.</p><hr><p>We also want to use this opportunity to tell our users enabling the access log option to remember to <em><em>filter/redact </em></em>sensitive data. Please, validate your configuration and make sure you don’t log sensible data.</p><pre><code class="language-toml"># example of how to keep / redact / drop data from the logs
[accessLog.fields.headers]
      defaultMode = "keep"
      [accessLog.fields.headers.names]
        "User-Agent" = "redact"
        "Authorization" = "drop"
        "Content-Type" = "keep"
        # ...</code></pre><p><em><em>(Thanks goes to </em></em><a href="https://github.com/captn3m0" rel="noopener"><em><em>captn3m0</em></em></a><em><em> for making sure we added this reminder about logs.)</em></em></p><hr><h2 id="references">References</h2><ul><li>CVE: <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12452" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12452</a></li><li>Traefik Release with the fix: <a href="https://github.com/containous/traefik/releases/tag/v1.7.12" rel="noopener">https://github.com/containous/traefik/releases/tag/v1.7.12</a></li><li>Traefik’s Documentation for Securing the API/Dashboard: <a href="https://docs.traefik.io/operations/api/">https://docs.traefik.io/operations/api/</a></li><li>Announcement on Traefik’s Security Mailing List: <a href="https://groups.google.com/a/traefik.io/forum/#!topic/security/Hez9dsOFCA4" rel="noopener">https://groups.google.com/a/traefik.io/forum/#!topic/security/Hez9dsOFCA4</a></li><li>Discussion about the Dashboard/API features and security: <a href="https://github.com/containous/traefik/issues/4934" rel="noopener">https://github.com/containous/traefik/issues/4934</a></li></ul></hr></hr>]]></content:encoded></item><item><title><![CDATA[Canary Releases with Traefik on GKE at HolidayCheck]]></title><description><![CDATA[In this post, I would like to introduce you into how Traefik helped us shape our cloud ecosystem at HolidayCheck...]]></description><link>https://traefik.io/blog/canary-releases-with-traefik-on-gke-at-holidaycheck-d3c0928f1e02/</link><guid isPermaLink="false">Ghost__Post__5dd6a3a8b6de2b00381d3fbf</guid><category><![CDATA[Blog]]></category><category><![CDATA[Case Studies]]></category><dc:creator><![CDATA[Traefik Labs]]></dc:creator><pubDate>Tue, 21 May 2019 14:47:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/canary.jpeg" medium="image"/><content:encoded><![CDATA[<img src="https://containous.ghost.io/content/images/2019/12/canary.jpeg" alt="Canary Releases with Traefik on GKE at HolidayCheck"/><p>In this post, I would like to introduce you into how <a href="https://containous.ghost.io/traefik/">Traefik</a> helped us shape our cloud ecosystem at <a href="https://www.holidaycheckgroup.com/?lang=en" rel="noopener">HolidayCheck</a>. In particular, I will give a brief in-depth introduction on how we implemented our canary release process for our microservice architecture with Traefik on Google Kubernetes Engine (GKE).</p><h2 id="about-holidaycheck">About HolidayCheck</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-22.png" class="kg-image" alt="Canary Releases with Traefik on GKE at HolidayCheck"/></figure><p>HolidayCheck AG operates the biggest independent hotel review and booking portal in the German-speaking area. Our vision is to become the most Urlauber*-friendly company in the world! Our business portfolio has full package (flight, hotel, insurance), hotel-only, and cruise offerings. In addition to that, we are a platform which shares hotel reviews and pictures.</p><ul><li><em><em>Urlauber: German term for holidaymaker, vacationer</em></em></li></ul><h2 id="background">Background</h2><p>Our teams strive to keep a high level of urgency for delivery. Therefore they maintain their delivery pipelines themselves. An inquiry across our continuous delivery (CD) pipelines showed that our teams use one of the following designs:</p><ul><li><em><em>Production follows Staging</em></em>: This is the most classic design among all. It prevails in services with older staged workflows where changes are tested in an isolated staging environment without real user traffic.</li><li><em><em>Production with Feature Flags</em></em>: This workflow is in place for a constant high pace of changes, especially with UX impact.</li><li><em><em>Production with A/B Tests</em></em>: Another variation of the last design is to keep multiple versions of the system online (e.g., A and B version) and split user traffic manually by an operator.</li></ul><p>Although all three designs have a positive impact on our release quality already, they are still very tedious to operate or widen the human error vector. To minimize toil and human errors, we introduced another complementary release strategy — canary releases.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-23.png" class="kg-image" alt="Canary Releases with Traefik on GKE at HolidayCheck"/></figure><h2 id="canary-releases-our-design">Canary Releases: Our Design</h2><p>In short canary releases is an automation extension for our CD pipelines to compare a new release (<em><em>the canary group</em></em>) against the previous version. Ideally, the old deployment (<em><em>the main group</em></em>) is not touched by this operation. Instead, a new deployment with the old configuration, <em><em>the control group</em></em>, is created at the same time as the canary.</p><p>Our design is based upon a strict set of decisions:</p><ol><li>User traffic needs to be split across the main deployment and the other two groups, whereas canary and control need an equal traffic share to keep comparisons sane.</li><li>The CD pipeline needs a data source (e.g., metrics, logs, etc.) to evaluate the canary soundness in comparison to the control instance. The decisions can vary from shifting more traffic to the canary/control group, take canary down or replace the current main with the canary.</li><li>The three instance groups need to operate independently from each other in isolation.</li></ol><h2 id="enter-traefik-splitting">Enter Traefik Splitting</h2><p>One of the significant benefits to using Traefik is that we can rely on building on low-entry barrier features. Although our platform is hosted on GKE, we still need to tailor features according to our use cases. Canary releases being one of them requires us to split traffic across deployments.</p><p>Traefik being our single proxy to route traffic to our deployments, has a built-in feature to split traffic across deployment groups through a single Ingress. Therefore a canary deployment can be accomplished with the following Ingress specification:</p><pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    traefik.ingress.kubernetes.io/service-weights: |
      my-service: 60%
      my-service-canary: 20%
      my-service-control: 20%
  name: my-service
spec:
  rules:
  - http:
      paths:
      - backend:
          serviceName: my-service
          servicePort: 80
        path: /
      - backend:
          serviceName: my-service-canary
          servicePort: 80
        path: /
      - backend:
          serviceName: my-service-control
          servicePort: 80
        path: /</code></pre><h2 id="our-canary-workflow">Our Canary Workflow</h2><p>Despite that traffic splitting is a cornerstone to enable canary releases, it is not sufficient. We still need to handle our canary deployments on GKE automatically. Our CDs should be able to automatically make one of the following decisions by comparing the canary with the control group:</p><ol><li>Split more traffic from the main group to the canary and control groups.</li><li>Demote the canary and control groups because of an unacceptable error rate and shift full traffic back to the main group.</li><li>Promote the canary group to become the new main group and remove the control and old main groups.</li></ol><p>Furthermore, before traffic splitting we need to provide resources for our canary and control deployments. On the one hand, this ensures that an appropriate replica count exists to handle the traffic. On the other hand, traffic splitting can only happen from a third-party inside Kubernetes that can observe the replica count of the canary and control deployments.</p><p>In short, the above CD decisions are accomplished by sending updates for the canary and control deployments to the Kubernetes API server. A separate canary controller handles the rest.</p><h2 id="the-canary-controller">The Canary Controller</h2><p>After sending the updates to Kubernetes the deployments of the canary and control groups, as well as the Ingress object, will be reconciled by a canary controller. The controller is responsible for the following actions:</p><ul><li><em><em>Scale the canary and control deployments</em></em>:<br>The number of replicas for the canary and control deployments is based on the traffic share</br></li></ul><pre><code>canaryReplicas = controlGroupReplicas =
  ceil(appReplicas * canaryTrafficPercent / 100)</code></pre><ul><li><em><em>Enable the canary and control deployments:</em></em> This means to identify the Ingress object of the main deployment and add the service weights annotation for each deployment.</li><li><em><em>Disable the canary and control deployments:</em></em> In case of promotion/demotion of the canary release, the controller removes the service weights from the Ingress object.</li></ul><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-24.png" class="kg-image" alt="Canary Releases with Traefik on GKE at HolidayCheck"/></figure><h2 id="a-canary-release-from-kubernetes-perspective">A Canary Release from Kubernetes Perspective</h2><p>If you are using Kubernetes, a simple deployment can contain multiple annotations to express use case specific information. Thus, our CD pipelines communicate each action by updating the annotations of the required deployment specifications. These annotations declare the requested state of our canary release, which in turn is reconciled by the canary controller.</p><p>Our canary release implementation requires the following annotations to express the state, as well as the Traefik service weight per deployment:</p><ul><li><code>holidaycheck.com/canary-active: bool</code>: Represents the current state of the canary release in each canary and control deployment.</li><li><code>holidaycheck.com/canary-percent: float</code>: Represents the service weight which should be applied for each the canary and control deployment.</li></ul><p>Let’s say we have a service <code>my-service</code> at version <code>v1.6</code>:</p><pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: my-service
  namespace: my-namespace
spec:
  replicas: 10
  template:
      name: my-service
    spec:
      automountServiceAccountToken: false
      containers:
      - image: our-registry/my-service:v1.6
        imagePullPolicy: IfNotPresent</code></pre><p>We want to evaluate a newer version <code>v1.7</code> of this service with a canary release, e.g.:</p><pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  annotations:
    holidaycheck.com/canary-active: "false"
    holidaycheck.com/canary-percent: "20.0"
  name: my-service-canary
  namespace: my-namespace
spec:
  replicas: 1
  template:
    metadata:
      name: my-service-canary
    spec:
      containers:
      - image: our-registry/my-service:v1.7</code></pre><p>Accordingly, a control deployment will be an almost identical copy of the main deployment specification. The only addition here is the extra annotations, e.g.:</p><pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  annotations:
    holidaycheck.com/canary-active: "false"
    holidaycheck.com/canary-percent: "20.0"
  name: my-service-control
  namespace: my-namespace
spec:
  replicas: 1
  template:
    metadata:
      name: my-service-control
    spec:
      containers:
      - image: our-registry/my-service:v1.6</code></pre><p>Next, the canary controller will reconcile the state of our three deployments to adhere to our replica count specification. Therefore splitting 20% of our traffic from a deployment with ten replicas results in canary and control deployments with two replicas each.</p><p>Finally, the controller will translate the canary annotation <code>canary-percent</code> for each deployment to the appropriate Traefik service weights annotation in the Ingress object. Also the <code>canary-active</code> will be set to <code>true</code> for the canary and control deployments:</p><pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    traefik.ingress.kubernetes.io/service-weights: |
      my-service: 60%
      my-service-control: 20%
      my-service-canary: 20%
  name: my-service</code></pre><p><em><em>Note: To minimize toil creating the above specifications, our teams use a small CLI tool that generates and applies those for them to Kubernetes.</em></em></p><h2 id="challenges">Challenges</h2><p>One challenge remains, namely how to separate Traefik backend metrics per endpoint. The current Traefik <code>v1.7</code>implementation does not provide a distinction of metrics per backend endpoint. However, you can circumvent this issue by relying on application level metrics, which can be separated by custom labels for the canary, control, and main group accordingly.</p><h2 id="conclusion">Conclusion</h2><p>I hope this article has been helpful and will help you to tailor your canary release workflow for your platform based on Traefik’s excellent features.</p><p>In summary, we met our main goal to build a slim solution for canary releases with Traefik without introducing the complexity of a full service mesh.</p><p>The above implementation is based on:</p><ul><li>Traefik v1.7</li><li>Kubernetes v1.12</li></ul>]]></content:encoded></item><item><title><![CDATA[TraefikEE, Now Docker Certified!]]></title><description><![CDATA[TraefikEE is a production-grade, distributed, and highly available routing solution, and today we’re proud to announce that it is certified as such...]]></description><link>https://traefik.io/blog/traefikee-now-dockeree-certified-d926bf7255a4/</link><guid isPermaLink="false">Ghost__Post__5dd6a50ab6de2b00381d3ff2</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Michael Matur]]></dc:creator><pubDate>Tue, 30 Apr 2019 14:53:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/traefikee-certified.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/traefikee-certified.jpeg" alt="TraefikEE, Now Docker Certified!"/><p class="post-sub-title">Ready for the Future</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/12/image.png" class="kg-image" alt="TraefikEE, Now Docker Certified!"/></figure><p>Building business critical solutions often requires more than leveraging the best tools available — it requires partners to rely on.</p><p>Traefik, as one of the most acclaimed open source edge routers, benefits from a vibrant and supportive community. With the enterprise edition, not only did we add business-centric features to improve user experience, security, availability, and scalability. Additionally, we also made premium support a reality.</p><p>TraefikEE is a production-grade, distributed, and highly available routing solution, and today we’re proud to announce that it is <a href="https://store.docker.com/_/traefikee" rel="noopener">certified as such</a>!</p><p><strong><strong>What Does it Mean?</strong></strong></p><p>TraefikEE has been tested and is supported by Docker Enterprise. It complies with Docker best practices guidelines, has proven provenance, and has been scanned for security vulnerabilities.</p><h2 id="see-it-in-action-">See It in Action!</h2><figure class="kg-card kg-embed-card"><iframe width="480" height="270" src="https://www.youtube.com/embed/joOuUy1ZD7E?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""/></figure><h2 id="test-it-">Test It!</h2><blockquote><em><em><strong><strong>Note</strong></strong>: If you don’t have your license key yet, request <a href="https://traefik.io/traefik-enterprise">your free trial</a> on our website and download <a href="https://docs.containo.us/installing/teectl-cli/">traefikeectl</a>.</em></em></blockquote><h3 id="installation">Installation</h3><p>Here is a Swarm One Line Installation:</p><pre><code class="language-bash">traefikeectl install \
  --swarm \
  --dashboard \
  --licensekey="${TRAEFIKEE_LICENSE_KEY}" \
  --clustername=traefikee-swarm</code></pre><blockquote><em><em>You can learn more about the command-line options used on the <code>traefikeectl install</code> <a href="https://docs.containo.us/installing/teectl-cli/">Reference Guide</a></em></em></blockquote><h3 id="configuration">Configuration</h3><p>Manage the cluster with <code>traefikeectl</code>:<em><em> </em></em></p><pre><code class="language-bash">traefikeectl list-nodes --clustername=traefikee-swarm

traefikeectl backup --clustername=traefikee-swarm

# ...
</code></pre><p><br>Deploy a customized routing configuration to create the Traefik entrypoints:</br></p><pre><code class="language-bash">traefikeectl deploy --clustername=traefikee-swarm \
 	--docker.swarmmode \
 	--entryPoints='Name:http Address::80' \
 	--entryPoints='Name:https Address::443 TLS' \
 	--defaultentrypoints=https,http</code></pre><blockquote><em><em><strong><strong>Note:</strong></strong> TraefikEE uses the `80` and `443` ports internally, hence these values for the entrypoints.</em></em></blockquote><h3 id="deploy-a-demo-application">Deploy a Demo Application</h3><p>You can deploy applications in Docker Swarm using labels:</p><pre><code class="language-yaml">version: '3.4'
networks:
  traefikee_net:
    external: true
services:
  whoami:
    image: containous/whoami
  deploy:
    mode: replicated
    replicas: 2
    labels:
      - "traefik.enable=true"
      - "traefik.frontend.rule=Host:your.cluster.dns.org"
      - "traefik.port=80"
      - "traefik.backend=whoami"
  networks:
    - traefikee_net</code></pre><blockquote><em><em><strong><strong>Note</strong></strong>: In the above example, <code>your.cluster.dns.org</code> is the DNS to reach your cluster.</em></em></blockquote><p>Deploy the application with the following command:</p><pre><code class="language-bash">docker stack deploy whoami --compose-file=./whoami-stack.yaml</code></pre><p>With <code><em><em>docker service ls</em></em></code>, check that the application deployment status is `2/2` replicas ready. Then you can verify that your requests are routed by TraefikEE to the <code><em><em>whoami</em></em></code> application!</p><pre><code class="language-bash">curl http://your.cluster.dns.org</code></pre><blockquote><em><em><strong><strong>Note</strong></strong>: Once checked, you can of course cleanup the <code><em>whoami</em></code> application with <code><em>docker stack rm whoami</em></code><em>.</em></em></em></blockquote><hr><h2 id="want-to-go-further">Want to Go Further?</h2><p>The TraefikEE image is available on the <a href="https://store.docker.com/_/traefikee" rel="noopener">Docker store</a> with <a href="https://store.docker.com/_/traefikee/plans/e4082b3e-9d65-425b-a21f-5f1b7b156f2e?tab=instructions" rel="noopener">detailed setup instructions</a>. Don’t hesitate to give it a<a href="https://traefik.io/traefik-enterprise"> try for free</a>!</p><blockquote>Huge thanks goes to <a href="https://twitter.com/networkstatic" rel="noopener">Brent Salisbury</a> for his help during the Docker certification process.</blockquote></hr>]]></content:encoded></item><item><title><![CDATA[Announcing General Availability of Traefik Enterprise Edition]]></title><description><![CDATA[Containous Inc, the company behind Traefik, is proud to announce the general availability of Traefik Enterprise Edition, a new platform built on top of...]]></description><link>https://traefik.io/blog/announcing-general-availability-of-traefik-enterprise-edition-9c9aad363ce/</link><guid isPermaLink="false">Ghost__Post__5dd6a624b6de2b00381d402a</guid><category><![CDATA[Blog]]></category><category><![CDATA[Announcements]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Thu, 18 Apr 2019 14:58:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/traefikee-1.0.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/traefikee-1.0.png" alt="Announcing General Availability of Traefik Enterprise Edition"/><p class="post-sub-title">Traefik Made Distributed</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/12/image-1.png" class="kg-image" alt="Announcing General Availability of Traefik Enterprise Edition"/></figure><p><a href="https://containous.ghost.io/" rel="noopener"><em><em>Containous Inc</em></em></a>, the company behind the popular open source cloud native edge router, <em><em><a href="https://containous.ghost.io/traefik/">Traefik</a></em></em>, is proud to announce the general availability of Traefik Enterprise Edition, a new platform built on top of <em><em>Traefik</em></em>, designed for business-critical deployments.</p><p>In just three years, <em><em>Traefik</em></em>, the Cloud Native Edge Router, has become a key player in microservices infrastructures. With more than 21,000 stars on Github and 650,000,000 downloads on DockerHub, <em><em>Traefik</em></em> is widely used by major companies in their production environments.</p><p>In the latter part of 2018, Containous released <a href="https://containous.ghost.io/blog/introducing-traefik-enterprise-edition-83b78d09efeb/">the early access of TraefikEE</a> to a select group of users, allowing them to refine the software. Today, Containous is proud to announce that TraefikEE has reached the <strong><strong>1.0</strong></strong> milestone, and is <strong><strong>ready for production</strong></strong>.</p><h2 id="overview">Overview</h2><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-25.png" class="kg-image" alt="Announcing General Availability of Traefik Enterprise Edition"/></figure><p><em><em>TraefikEE</em></em> is built on top of <em><em>Traefik</em></em> and adds clustering features to satisfy the needs of enterprise customers. All <em><em>Traefik</em></em> concepts apply to <em><em>TraefikEE</em></em>, so if you’re already a <em><em>Traefik</em></em> user, you’re in familiar territory.</p><p>It runs on the edge of your platform to route the traffic to your applications, and is composed of two elements:</p><ul><li><strong><strong>The data plane</strong></strong>: horizontally scalable nodes, which forwards ingress traffic to your services</li><li><strong><strong>The control plane</strong></strong>: distributed nodes, implementing the raft consensus, which watch your platform and its services, store topology changes, and reconfigure the data plane to adapt ingress routing dynamically</li></ul><p>A <em><em>TraefikEE</em></em> cluster natively supports raft consensus between control nodes to safely store and replicate configurations. No external Key-Value Store nor third-party tool needed.</p><p>This distributed architecture is the cornerstone of <em><em>TraefikEE</em></em>’s strengths: natively <strong><strong>highly available</strong></strong>, <strong><strong>scalable</strong></strong> and <strong><strong>secure</strong></strong>.</p><p>Here is a 5 minute introduction video of <em><em>TraefikEE</em></em>:</p><figure class="kg-card kg-embed-card"><iframe width="480" height="270" src="https://www.youtube.com/embed/znFQLLGCB3U?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""/></figure><h2 id="quickstart">Quickstart</h2><p>Start your free trial with TraefikEE today. Visit our website at <a href="https://containous.ghost.io/traefikee/">https://containo.us/traefikee</a>, and get your trial license key in less than a minute!</p><p>Our <a href="https://docs.containo.us/" rel="noopener">documentation</a> and our awesome CLI will help you bootstrap a TraefikEE cluster within a second. You can even <a href="https://info.containo.us/request-demo-traefikeehttps://info.containo.us/request-demo-traefikee">request a demo</a> on our website to set up a session with the core team.</p><p>Don’t hesitate to <a href="https://info.containo.us/contact-sales">talk to our sales team</a>, they will find the best way to help your company deploying a powerful edge routing solution.</p><h2 id="traefik-stays-open">Traefik Stays Open</h2><p><em><em>TraefikEE</em></em> is built on top of <em><em>Traefik</em></em>, that means that Traefik continues to evolve and will stay open source. Nothing changes! We are firm believers in open source, and <em><em>Traefik</em></em> will continue to be our main priority and a community-driven project. We are working on significant changes to Traefik, and <a href="https://containous.ghost.io/blog/back-to-traefik-2-0-2f9aa17be305/">recently have shared details</a> on the <em><em>Traefik</em></em> 2.0 roadmap and released <a href="https://github.com/containous/traefik/releases/tag/v2.0.0-alpha4" rel="noopener">the first alphas</a>. We won’t lie saying it’s going to be huge.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-26.png" class="kg-image" alt="Announcing General Availability of Traefik Enterprise Edition"/></figure><h2 id="about-containous">About Containous</h2><p>Containous is the company that supports the development of Traefik, the popular open source cloud native edge router. Traefik is widely used around the globe with over 650 million downloads. Containous brings the future of software architecture by offering the most powerful tools to ease the deployment of your modern IT environments.</p><p>Find out more about Containous at <a href="https://containous.ghost.io/">containo.us</a> and follow <a href="https://twitter.com/containous" rel="noopener">@containous</a> on Twitter.</p><p>With this new product, Containous continues to innovate and define new ways to access microservice platforms, pushing the limits of automation and scalability.</p>]]></content:encoded></item><item><title><![CDATA[Back to Traefik 2.0, the Online Meetup]]></title><description><![CDATA[Just after the Traefik 2.0 announcement, we aired an Online Meetup to talk about our treasured features...]]></description><link>https://traefik.io/blog/back-to-traefik-2-0-the-online-meet-up-4e4b6411fbfa/</link><guid isPermaLink="false">Ghost__Post__5dd6b329b6de2b00381d4043</guid><category><![CDATA[Blog]]></category><category><![CDATA[Community]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Mon, 01 Apr 2019 15:54:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/back-traefik-2.0-meetup.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/back-traefik-2.0-meetup.png" alt="Back to Traefik 2.0, the Online Meetup"/><p class="post-sub-title">Now Available on YouTube!</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-full"><img src="https://containous.ghost.io/content/images/2019/12/image-5.png" class="kg-image" alt="Back to Traefik 2.0, the Online Meetup"/></figure><p>What a week, everyone! Just after the <a href="https://containous.ghost.io/blog/back-to-traefik-2-0-2f9aa17be305/https://containo.us/blog/back-to-traefik-2-0-2f9aa17be305/">Traefik 2.0 announcement</a>, driven by the relentless enthusiasm of our Head of Community (who did quite <em><em>the</em></em> show introducing the team), we aired an Online Meetup to talk about our treasured features in the next iteration of our favorite reverse-proxy/edge-router.</p><p>I know this is a question we haven’t been asked (but, we’ll answer it anyway) — Yes, we (the developer team) were a bit nervous. Because, even though we often talk to the community <em><em>In Real Life,</em></em> we were unfamiliar with the <em><em>we-don’t-see-you-while-we-talk</em></em> format of the online Meetup. And, here is another answer to a question you didn’t ask, but, again, we’ll answer — Yes, we enjoyed this moment with you, and would do it again.</p><p>Chances are you’re here for the video only, and <em><em>not</em></em> the story behind the movie, so let’s proceed!</p><figure class="kg-card kg-embed-card kg-card-hascaption"><iframe width="480" height="270" src="https://www.youtube.com/embed/s8qYWPC6YdI?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""/><figcaption>The slides are <a href="https://docs.google.com/presentation/d/e/2PACX-1vS3_WzHd4vOA7pqzFL1YTIom-_t9OrvmKwV3_GuBvqQeWV1jfxFml18M2miCpinL2PP-od5kv1NaN-m/pub?start=false&amp;loop=true&amp;delayms=3000" rel="noopener">available here</a>, and code for the demos is available <a href="https://github.com/containous/slides/tree/online-meetup-v2/demo/v2-tcp" rel="noopener">on Github</a>.</figcaption></figure><h2 id="-qa-time-excerpts-">“Q&amp;A Time (Excerpts)”</h2><h3 id="about-tcp-and-udp-">About TCP (and UDP)</h3><blockquote><em><em>Can the TCP entry point use <a href="https://letsencrypt.org/" rel="noopener">Let’s Encrypt</a>? Could you have HTTP and TCP endpoints using the same hostname? Is it ready for UDP?</em></em></blockquote><p>We loved bringing TCP support to <a href="https://containous.ghost.io/traefik/">Traefik</a>, and we wanted it to come along with features our users would expect — one of them being Let’s Encrypt support (so yes, TCP in Traefik supports Let’s Encrypt for automatic certificates, like with HTTP).</p><p>We also wanted Traefik to be able to route TCP and <a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/">HTTP requests</a> on the same entry points, which was quite a challenge. This was made possible with a simple trick — the use of the SNI in TLS connections. But this comes with a limitation: you won’t be able to route both HTTP and TCP requests on the <em><em>same</em></em> <code>host+port</code> combination. If for the <em><em>same domain</em></em> you’d like to route TCP and HTTP requests, we encourage you to use two different ports.</p><p>TCP was made possible by the re-architectured core. This new core also enables us to bring UDP support, and even if it is not written yet, it’s a matter of weeks before it’s out.</p><h3 id="about-middleware">About Middleware</h3><blockquote><em><em>Do middleware always applied from left to right? Can a service be a middleware Can custom middlewares be created? Can we use middlewares on TCP endpoints? Can we use middleware on the response? Is middleware for ingress only?</em></em></blockquote><p>So <a href="https://docs.traefik.io/middlewares/overview/">middleware</a> is a concept we introduced to enable you to fine-tune the life cycle of the requests. They will often act <em><em>before</em></em> the request is forwarded to the <a href="https://docs.traefik.io/routing/services/">services</a>, and can also operate on the response you get from the services (like the <a href="https://docs.traefik.io/middlewares/headers/">headers</a> middleware does). Pieces of middleware are applied from left to right on the request, and from right to left on the response. Since you define the order, and since you can define as many <a href="https://docs.traefik.io/middlewares/chain/">chains</a> or attach as many pieces of middleware to your <a href="https://docs.traefik.io/routing/routers/">routers</a> as you want, you have total control. There are currently no available middleware for TCP routers, but it’s something we’re looking into (if you have ideas, let us know!). And regarding custom middleware, even though we know our user base is looking for it, it won’t fit in the 2.0 scope (which is already big!).</p><h3 id="about-kv-stores-distributed-let-s-encrypt">About KV Stores &amp; Distributed Let’s Encrypt</h3><blockquote><em><em>Current (pre-2.0) traefik can store ACME certificates in a file or a KV store. The latter helps with running a cluster of traefik, but the storage is restricted to 512kb of certificate information when using Consul. Will this improve? (storing in a key per certificate instead of a single key for all, for example)</em></em></blockquote><p>While working on 2.0, we decided it was time to rework this part. Sticking with the Unix Philosophy, “Make each program do one thing well,” Traefik is getting back to be a good old single-instance pure data plane. At the same time, clustering has been redesigned from scratch using a production-proven rock-solid raft-based implementation, shipped with Traefik Enterprise Edition (<a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/">see how</a>). Distributed features (like Let’s Encrypt) can now rely on this advanced cluster technology for these use cases. But hey! You can still use multiple Traefik instances with your favorite KV store, we only removed the unstable and experimental part :)</p><h3 id="about-the-final-release">About the Final Release</h3><blockquote><em><em>When will the final 2.0 be available?</em></em></blockquote><p>Short answer: When it’s ready!</p><p>Real answer: We wish we could tell. Even though we can estimate how much time we will need to develop the <a href="https://github.com/containous/traefik/projects/3" rel="noopener">missing features</a>, we don’t know fore sure how much feedback you’ll provide, or how many features contributors will be tackling (and, as Damien pointed out — we’re ready to help any [new/returning/existing] contributors eager to participate in the project!). Anyways, all we can say is, “stay tuned for updates!”</p><h3 id="about-other-things-">About Other Things…</h3><p>You’ll find other (more specific) questions (and answers) <a href="https://gist.github.com/dduportal/13874113cf5fa1d0901655e3367c31e5" rel="noopener">here</a>!</p><hr><h2 id="don-t-miss-the-next-meet-ups-">Don’t Miss the Next Meet-Ups!</h2><p>If you enjoyed the meet-up and would like to be notified of upcoming online events and receive the videos from our previous sessions, <a href="http://eepurl.com/gfN5Aj" rel="noopener">sign up here</a>!</p></hr>]]></content:encoded></item><item><title><![CDATA[Back to Traefik 2.0]]></title><description><![CDATA[Today, we’re announcing Traefik 2.0 alpha, the edge router built with the future in mind.
The new core is here, help us finalize...]]></description><link>https://traefik.io/blog/back-to-traefik-2-0-2f9aa17be305/</link><guid isPermaLink="false">Ghost__Post__5dd6b3d9b6de2b00381d405f</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Tue, 19 Mar 2019 15:57:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/back-traefik-2.0.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/back-traefik-2.0.png" alt="Back to Traefik 2.0"/><p class="post-sub-title">Gigawatts of Routing Power</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-full"><img src="https://containous.ghost.io/content/images/2019/12/image-6.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>Back in 2015, a revolution was under way. We were moving from manual, handcrafted infrastructures, to container-based, industrial, and human-free platforms. In those dark ages of orchestration, edge traffic was remarkably difficult to manage. On one side, we had traditional reverse-proxies that were built for static infrastructures, on the other side, we were building dynamic clusters made to deploy and manage thousands of microservices. The idea of having a simple and automatic edge router, all in one binary, was appealing, but also idealistic. The foundation of <a href="https://containous.ghost.io/traefik/">Traefik</a> was laid that year, paving the way to building a project with strong values: <em><em>simplicity of configuration</em></em>, <em><em>modern features</em></em>, and <em><em>open to the community</em></em>. A few years later, the project has reached <a href="https://github.com/containous/traefik" rel="noopener">21k stars on Github</a>, and more than 600 millions downloads. <em><em>Insane</em></em>.</p><p>Since then, the ecosystem around containers has changed a lot: Docker has become a de-facto standard, and Kubernetes has shown itself to be the clear winner in the battle for the best orchestration platform. Because of this, the <a href="https://landscape.cncf.io/" rel="noopener">CNCF landscape</a> has exploded, with hundreds of components to choose from.</p><blockquote>The time has come to work on something new for Traefik.</blockquote><p>For several months, the maintainer team has been working on a deep refactoring of the codebase to provide the firm foundations for the next iteration of Traefik, and we are ready to share this vision with you.</p><p>Today, we’re announcing Traefik 2.0 alpha, the edge router built with the future in mind.</p><p>The new core is here, help us finalize Traefik with the features you want!</p><hr><h2 id="we-want-features-">We Want Features!</h2><p>Let’s see what we have in store.</p><h3 id="vocabulary-clarification">Vocabulary Clarification</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-27.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>Not a feature per se, but we still wanted to make it easier for newcomers to understand the core concepts at work in Traefik. We wanted every word to have a clear and unique meaning throughout the code and documentation.</p><p>Welcome p<em><em>roviders</em></em>, e<em><em>ntrypoints</em></em>, r<em><em>outers</em></em>, m<em><em>iddleware</em></em>, and s<em><em>ervices</em></em>.</p><ul><li><em><em>Providers</em></em> are the cluster technologies you already use (Kubernetes, Docker, Consul, Mesos, Rancher…). Traefik uses your provider’s API to discover the routes to your services.</li><li><em><em>Entrypoints</em></em>, in their most basic forms, are the open ports where requests will land.</li><li><em><em>Services</em></em> represent the software hosted on your infrastructure. Traefik knows how to deal with multiple instances of your programs (currently supporting multiple load balancing capabilities), and use the s<em><em>ervices</em></em> configuration to determine how to reach the actual program.</li><li><em><em>Routers</em></em> connect incoming requests to your s<em><em>ervices. </em></em>They<em><em> </em></em>hold<em><em> </em></em>the rules that decide which service handles the request.</li><li>Finally, pieces of <em><em><a href="https://docs.traefik.io/middlewares/overview/">middleware</a> </em></em>are components that may update the request before it is handled by a service. Out of the box, Traefik comes with middleware to manage authentication, rate limiting, circuit breaker, whitelisting, buffering, and so on.</li></ul><h3 id="configuration-structure">Configuration Structure</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-28.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>Despite our best efforts, and because so many features have been added to Traefik since its first launch, we needed to polish things up and make sure every configuration option belonged in its place.</p><p>Here, it was a menial job that needed to be done, and we’ll spare you the details.</p><h2 id="let-us-be-clear-we-want-actual-features-">Let Us Be Clear … We Want ACTUAL Features!</h2><p>So, let’s remove the mystery, since we’ve teased you enough. Here are the features we’ve added!</p><h3 id="tcp-support-">TCP Support!</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-29.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>That’s right! It’s time to say goodbye to <a href="https://github.com/containous/traefik/issues/10" rel="noopener">Issue #10</a>!</p><p>Yes, three years later, after <a href="https://github.com/containous/traefik/pull/4587" rel="noopener">a lot of work</a> (<a href="https://github.com/containous/traefik/issues/10#issuecomment-142835077" rel="noopener">as foretold</a>), and a lot of discussions, <a href="https://docs.traefik.io/routing/routers/#configuring-tcp-routers">Traefik now fully supports the TCP protocol</a>.</p><p>Want to see an example? Let’s use the File Provider, and redirect every request on port<code>27010</code> to your database service!</p><pre><code class="language-toml">[entrypoints]
   [entrypoints.web]
      address = ":80"

[entrypoints.mongo-port]
      address = ":27017"

[tcp] # YAY!
   [tcp.routers]
      [tcp.routers.everything-to-mongo]
         entrypoints = ["mongo-port"]
         rule = "HostSNI(`*`)" # Catches every request       
         service = "database"</code></pre><p>The best part? Traefik supports routing based on <a href="https://en.wikipedia.org/wiki/Server_Name_Indication" rel="noopener">SNIs</a>!</p><pre><code class="language-toml">[entrypoints]
   [entrypoints.web]
      address = ":80"

[entrypoints.mongo-port]
      address = ":27017"

[tcp] # YAY!
   [tcp.routers]
      [tcp.routers.to-db-1]
         entrypoints = ["mongo-port"]
         rule = "HostSNI(`db-1.domain`)"       
         service = "db-1"
         [tcp.routers.to-db-1.tls] # The route is for TLS requests only
      
      [tcp.routers.to-db-2]
         entrypoints = ["mongo-port"]
         rule = "HostSNI(`db-2.domain`)"       
         service = "db-2"
         [tcp.routers.to-db-2.tls] # The route is for TLS requests only</code></pre><p>What’s even better? Traefik can go crazy, and support <em><em>both</em></em> HTTP <em><em>and</em></em> TCP on the <em><em>same</em></em> port.</p><blockquote>Yes, multiple protocols on the same entrypoint!</blockquote><pre><code class="language-toml">[entrypoints]
   [entrypoints.the-one]
      address = ":443"

[tcp]
   [tcp.routers]
      [tcp.routers.to-db-1]
         rule = "HostSNI(`db-1.domain`)"       
         service = "db-1"
         [tcp.routers.to-db-1.tls] # The route is for TLS requests only

[http]
   [http.routers]
      [http.routers.my-api]
         rule = "Host(`api.domain`)"       
         service = "my-api"</code></pre><p>In its first alpha version, Traefik only enables TCP routes in the File Provider, but stay tuned because it will (very) soon be available for other providers!</p><h3 id="middleware-to-update-the-requests">Middleware to Update the Requests</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-30.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>Many features used to be magically embedded in Traefik, with room for customization but no option for fine-tuning.</p><p>Middlewares fill the gap and give you the possibility to enable/configure any feature you’d like, per router if you wish.</p><p>Middlewares are components that act on the request before it is actually forwarded to the services, and can even decide to <em><em>not</em></em> forward the request if a required condition isn’t met.</p><p>At release, Traefik comes with the following middlewares: <a href="https://docs.traefik.io/middlewares/addprefix/">AddPrefix</a> (to add a prefix to the request path), <a href="https://docs.traefik.io/middlewares/basicauth/">BasicAuth</a> &amp; <a href="https://docs.traefik.io/middlewares/digestauth/">DigestAuth</a>, <a href="https://docs.traefik.io/middlewares/forwardauth/">ForwardAuth</a> (to delegate authentication to a third-party service), <a href="https://docs.traefik.io/middlewares/buffering/">Buffering</a>, <a href="https://docs.traefik.io/middlewares/chain/">Chain</a> (to define reusable sets of middlewares), <a href="https://docs.traefik.io/middlewares/circuitbreaker/">CircuitBreaker</a> (to avoid calling broken services), <a href="https://docs.traefik.io/middlewares/compress/">Compress</a>, <a href="https://docs.traefik.io/middlewares/errorpages/">Errors</a> (to provide custom error pages), <a href="https://docs.traefik.io/middlewares/headers/">Headers</a>, <a href="https://docs.traefik.io/middlewares/ipwhitelist/">IpWhitelist</a>, MaxConn (to limit the number of simultaneous connections to a service), <a href="https://docs.traefik.io/middlewares/passtlsclientcert/">PassTLSClientCert</a>, <a href="https://docs.traefik.io/middlewares/ratelimit/">RateLimit</a> (to limit the number of requests to a service within a given period of time), <a href="https://docs.traefik.io/middlewares/redirectregex/">RedirectRegex</a> and <a href="https://docs.traefik.io/middlewares/redirectscheme/">RedirectScheme</a>, and <a href="https://docs.traefik.io/middlewares/replacepath/">ReplacePath</a> (to update the query path before forwarding it to the service).</p><p>And more importantly, we’ve re-architectured the code to make it easier to provide additional middlewares in the near future.</p><h3 id="kubernetes-crd">Kubernetes &amp; CRD</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-31.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>In the past two years, the community has been discussing (a lot) around “better ingress,” and looking at our previous Kubernetes provider, we agreed that there was room for improvement. With v2, it became obvious that if we wanted to let our Kubernetes fans benefit from every feature (like TCP and middleware) without being swarmed by a clutter of annotations, we had to propose an alternative.</p><p>Among the alternatives, <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener">CRD</a>s are more and more popular since they solve shortcomings of the ingress specification. Inspired by what Heptio did in Contour with IngressRoute, we extended the specification to implement every Traefik feature.</p><p>We firmly believe that a consensus can emerge from those proposals and lead to the next Ingress specification in Kubernetes.</p><p>Below is an example of this specification.</p><pre><code class="language-yaml">apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: test.crd
  namespace: default
spec:
  entrypoints:
    - web
    - web-secure
  routes:
    - match: Host(`traefik.io`) &amp;&amp; PathPrefix(`/foo`)
      kind: Rule
      services:
        - name: whoami1
          port: 80
          strategy: RoundRobin
      middlewares:
        - name: stripprefix
        - name: addprefix
          namespace: foo
    - match: Host(`containo.us`) &amp;&amp; Method(`POST`)
      kind: Rule
      services:
        - name: whoami2
          port: 80
  tls:
    secretName: supersecret</code></pre><h3 id="new-expressive-routing-rule-syntax">New Expressive Routing Rule Syntax</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-32.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>Traefik now supports an expressive syntax to define the router rules, with <code>and</code>, <code>or</code>, and <code>parenthesis</code>!</p><p>The available <a href="https://docs.traefik.io/routing/routers/#rule">matchers</a> being <code>Headers</code>, <code>HeadersRegexp</code>, <code>Host</code>, <code>HostRegexp</code>, <code>Method</code>, <code>Path</code>, <code>PathPrefix</code>, and <code>Query</code>.</p><p>Since TCP is a whole different world, for now, it only supports a dedicated matcher: <code>HostSNI</code>.</p><p>Want to see examples?</p><pre><code class="language-toml">rule = (Host(`api.domain`) &amp;&amp; PathPrefix(`/v2`)) 
  || Host(`api-v2.domain`)

rule = (Method(`DELETE`) || (Method(`POST`) 
  &amp;&amp; Query(`action`, `delete`))) &amp;&amp; Host('api.domain')</code></pre><h3 id="cross-provider-support">Cross-Provider Support</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-33.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>Traefik has always been compatible with multiple providers, which is one of its greater strengths: whatever your infrastructure is, from bare metal to orchestrators and clusters, Traefik just works!</p><p>But with v2, we’ve gone a little further and allowed users to declare elements (middlewares, services, routers) in a provider, and to use them from a different one.</p><p>Let’s take a look at the following example, that declares an authentication middleware in a configuration file (the File Provider), which is being used from a Docker label (the Docker Provider).</p><pre><code class="language-toml"># somewhere in a configuration file for the file provider
[http.middlewares.my-users.basicauth]
   users = ["test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/", 
            "test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0"]</code></pre><hr><pre><code class="language-yaml"># somewhere in a docker compose file

your-container:
    image: your-docker-image
    
    labels:
      - "traefik.http.routers.my-router.middlewares=file.my-users"</code></pre><p>And of course, you could declare a router in a provider that points to services declared by another.</p><h3 id="tls-termination-per-route">TLS Termination per Route</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-34.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>While adding TCP support to Traefik, we had to re-think almost everything, starting with the e<em><em>ntrypoint</em></em> itself — the very door to your cluster.</p><p>Our first idea was to dedicate e<em><em>ntrypoints</em></em> (and as a consequence port numbers) to a type of “protocol.” Unfortunately, in some cases, especially when people used Traefik to route requests for multiple clusters, we deemed it too restrictive. As a consequence, we allowed multiple protocols per e<em><em>ntrypoint</em></em>.</p><p>Then, as debates were still going on, we kept looking for ways to better control how users would configure TLS <em><em>termination</em></em> or <em><em>passthrough. </em></em>The idea of enabling TLS on the <em><em>Router</em></em> level won the brainstorming, and then passed the tests of proof of concept (we have <a href="https://github.com/juliens" rel="noopener">quite a fan</a> of proof of concept branches on the team, to the point it has almost become a meme).</p><p>Here is an example with three routers listening on the same e<em><em>ntrypoint</em></em>, the first router terminates TLS connections (on HTTPS), the second router terminates TLS connections (on TCP), and the third router passes through, leaving the details of the TLS connection to be handled by the s<em><em>ervice </em></em>itself.</p><pre><code class="language-toml">[entrypoints]
   [entrypoints.web-secure]
      address = ":443"

[http]
   [http.routers.to-service-1]
      rule = "Host(`domain-1`)"
      service = "service-1"
      [http.routers.to-service-1.tls]
         # terminates the tls connection and sends clear data
         # to service 1

[tcp]
   [tcp.routers.to-service-2]
      rule = "HostSNI(`domain-2`)"
      service = "service-2"
      [tcp.routers.to-service-2.tls]
         # terminates the tls connection and sends clear data
         # to service 2

[tcp.routers.to-service-3]
      rule = "HostSNI(`domain-3`)"
      service = "service-3"
      [tcp.routers.to-service-3.tls]
         passthrough = true # sends encrypted data "as is" to service-3</code></pre><h3 id="labels-key-value-configuration-tags-">Labels, Key-Value Configuration, Tags, …</h3><p>A small tweak on the surface, but quite an impact in the code, we’ve re-written the configuration parser. This new system ensures that every option in Traefik has the same path, whether expressed in TOML <code>[something.that.is.here]</code>, a label attached to a container <code>something.that.is.there</code>, a key (as in key-value store) <code>something/that/is/somewhere</code>, or anything that might be available in the future.</p><h3 id="revamped-documentation">Revamped Documentation</h3><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-35.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>We’ve updated the <a href="https://docs.traefik.io/">documentation</a> structure to help new users quickly understand how to use and configure Traefik. At the same time, we came up with an outline that mirrored the configuration structure, making it easier for expert users to learn more about specific configuration details.</p><hr><h2 id="the-road-to-the-final-version">The Road to the Final Version</h2><p>Yes, more (<em><em>much</em></em> more) is on the way, but we were so eager to share the work that we couldn’t wait a minute longer than we already did.</p><blockquote>New WebUI, remaining providers, metrics, UDP, YAML, TLS stores &amp; options, canary, more documentation — everything is possible.</blockquote><p>Apart from re-enabling other providers (alpha comes with file, Docker, and k8s only), and enabling TCP for all of them (currently file only), the roadmap is full of features.</p><p>First, the most visible one, a contributor is actively working on a revamped WebUI, and from the mockups we saw, it looks <em><em>very</em></em> promising. We expect this new UI to help you navigate seamlessly through hundreds of routes.</p><p>Second, we’re working on improvements for TLS configuration, with stores and options, which will deserve its own explanation.</p><p>Third, now that we have tried our hand on a new protocol, well, we might as well add others (like UDP).</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-36.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p>If you want to discuss or even help us implementing these features, please join us on the <a href="https://community.containo.us/">community forum</a> or on <a href="https://github.com/containous/traefik" rel="noopener">Github</a>, the maintainer team is always open to your contributions.</p><p>But the options don’t stop there — Traefik is a community-driven project, and we never know what is going to happen! We can’t wait to see what you’ll do with this new architecture.</p><hr><h2 id="to-be-continued-">To be continued…</h2><blockquote>The community is at the center of our attention.</blockquote><p>We’ve scheduled <a href="https://containous.ghost.io/resources/the-traefik-2-0-online-meetup-100-community-driven/">an online meet-up</a> where the maintainer team will exclusively talk about Traefik v2.0! If you were looking for an opportunity to ask questions or see a live demo, here it is.</p><p>Probably the most important, we <em><em>need</em></em> your feedback. Tell us what you think, voice your opinion! The alpha stage is the perfect timing to include disruptive changes. Go crazy with pull requests, tests, and ideas.</p><p>And finally, of course, our goal is to release the final as soon as possible!</p><blockquote>We hope you enjoy Traefik as much as we enjoy building it with you!</blockquote><hr><p>Grab the <a href="https://github.com/containous/traefik/releases/tag/v2.0.0-alpha1" rel="noopener">latest binaries</a> for Linux, Windows, and Mac on Github or get the official Docker image!</p><pre><code class="language-shell">docker pull traefik:v2.0.0-alpha1 (or 2.0.0-alpha1, v2.0, 2.0, faisselle)
docker pull traefik:v2.0.0-alpha1-alpine
docker pull traefik:v2.0.0-alpha1-nanoserver</code></pre><p>The documentation can be found <a href="https://docs.traefik.io/">here</a> and the <em><em>huge</em></em> changelog is <a href="https://github.com/containous/traefik/blob/master/CHANGELOG.md#v200-alpha1-2019-03-18" rel="noopener">here</a>.</p><hr><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-37.png" class="kg-image" alt="Back to Traefik 2.0"/></figure><p><em><em>Thank you </em></em><a href="https://medium.com/u/520ac88c453e?source=post_page-----2f9aa17be305----------------------" rel="noopener"><em><em>Gérald Croës</em></em></a><em><em> for your major contribution on this blog post and congrats to all the team members that have been working so hard on this alpha release 👏</em></em></p></hr></hr></hr></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[The Journey to Traefik Enterprise Edition: Smooth Operations]]></title><description><![CDATA[Welcome to the fifth step of our journey towards Traefik Enterprise Edition.
This post focuses on the experience of operating TraefikEE...]]></description><link>https://traefik.io/blog/the-journey-to-traefik-enterprise-edition-smooth-operations-2591bb7ff1fe/</link><guid isPermaLink="false">Ghost__Post__5dd7badbf1db6f0038c74299</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Damien Duportal]]></dc:creator><pubDate>Mon, 18 Mar 2019 10:39:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/smooth-ops.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/image-7.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Smooth Operations"/></figure><img src="https://containous.ghost.io/content/images/2019/11/smooth-ops.png" alt="The Journey to Traefik Enterprise Edition: Smooth Operations"/><p>Welcome to the fifth step of our journey towards <a href="https://containous.ghost.io/traefikee/">Traefik Enterprise Edition</a>.</p><p>This post focuses on the experience of operating TraefikEE using the <code>traefikeectl</code> command line. You should already feel at ease with TraefikEE’s one-line installation and concepts. If you are not, then you can check the previous posts of the “Journey to TraefikEE:”</p><ul><li><em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/">Join the“Early Access” Program</a></em></em></li><li><em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/">Product Evaluation</a></em></em></li><li><em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/">High Availability</a></em></em></li><li><em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/">HTTPS for Everyone</a></em></em></li></ul><p>Today, we’ll focus on <code>traefikeectl</code>, the command-line tool used to install, configure and operate all your TraefikEE installations, in a lean and repeatable way, independently of your platform.</p><h2 id="one-command-line-to-rule-them-all">One Command-Line to Rule Them All</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-38.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Smooth Operations"/></figure><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I used Traefik because it’s really simple to use. I’m interested by TraefikEE for its high availability features. But distributed systems are really hard. How to deal with this intrinsic complexity?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Let us introduce <code><em>traefikeectl</em></code> (also known as “TraefikEE-cuddle”), the command-line tool which abstracts most of this complexity.</em></em></blockquote><p>TraefikEE is designed from the ground up to be platform agnostic. From installation to any operation, the workflow is the same on each platform.</p><p>All the operations are managed by the command line <code>traefikeectl</code> following this workflow, whichever platform you are using:</p><ul><li><strong><strong>Install Phase:</strong></strong> Installs a TraefikEE cluster (with <code>traefikeectl install</code> or manually),</li><li><strong><strong>Connect Phase: </strong></strong>Make your local <code>traefikeectl</code> aware of an existing TraefikEE cluster allowing multi-cluster management,</li><li><strong><strong>Deploy Phase:</strong></strong> Deploy a “routing configuration” to this TraefikEE instance.</li></ul><h2 id="install-phase">Install Phase</h2><h3 id="platform-specific">Platform-Specific</h3><p>Do you remember the <a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/">“One Line Installation for Kubernetes”</a> from previous posts (and the <a href="https://docs.containo.us">related documentation</a>)?</p><pre><code class="language-shell">traefikeectl install \
  --licensekey="$(cat /keybase/.../traefikee-license)" \
  --dashboard \
  --kubernetes
  # ...</code></pre><p>What if you want to install on a Docker Swarm cluster instead?</p><p>Well, the answer is to use the flag <code>—-swarm</code> instead of <code>--kubernetes</code> , as described on the “One Line Installation guide for Swarm”:</p><pre><code class="language-shell">traefikeectl install \
  --licensekey="$(cat /keybase/.../traefikee-license)" \
  --dashboard \
  --swarm
  # ...</code></pre><p>Each “agnostic” feature is then provided by the command<code>traefikeectl</code> when required, as <code>--kubernetes.namespace</code> or <code>--swarm.networkname</code> .</p><h3 id="customize-installation">Customize Installation</h3><p>We’ll now dig on how to customize installation for Kubernetes.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> We are not able to use <code><em>traefikeectl</em></code> for installation in our Kubernetes cluster, because the default configuration does not fit our needs.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> The <code><em>install</em></code> command of <code><em>traefikeectl</em></code> allows you to customize installation. With Kubernetes, you can provide a YAML file to specify custom values.</em></em></blockquote><p>Following the reference values from the documentation, let’s consider that you want to specify the following elements during the installation:</p><ul><li>A custom URL for accessing the dashboard, as <code>http(s)://private.mycompany.org/traefikee</code>,</li><li>Limiting the resources used for each node to <code>2Gb</code> of memory and <code>2 CPUs</code> (See the article “<a href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/" rel="noopener">Managing Compute Resources for Containers</a>” Kubernetes Documentation for reference).</li></ul><p>Before installation, create the following YAML file to specify these values:</p><pre><code class="language-yaml">## File "traefikee-values.yaml"

# Expose dashboard at http(s)://private.mycompany.org/traefikee
dashboard:
  host: "private.mycompany.org"
  path: "/traefikee"

# Restrict resources usage for each TraefikEE node
resources:
  cpus: "2"
  memory: "2G"</code></pre><p>You can now proceed to the “One Line Installation”, by adding the flag <code>--kubernetes.helmvaluespath</code> to use the YAML value file:</p><pre><code class="language-shell">traefikeectl install --kubernetes \
  --licensekey=XXXXXXX \
  --dashboard \
  --kubernetes.helmvaluespath=./traefikee-values.yaml</code></pre><p>As no one is perfect, <code>traefikeectl</code> might not provide some specific settings required for your platform to work correctly. In this case, you still can “<a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/#patching-resources" rel="noopener">patch</a>” , <a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/#editing-resources" rel="noopener">“edit”</a> or even <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#annotate" rel="noopener">“annotate”</a> the Kubernetes resources created by <code>traefikee install</code>.</p><h2 id="connect-phase">Connect Phase</h2><p>The next step is to ensure that your <code>traefikeectl</code> command has knowledge of the cluster you want to operate.</p><blockquote><em><em>Please note that this step is not required if you used a “One Line Installation” with <code>traefikeectl install</code>, as it is automatically done.</em></em></blockquote><p>The scenario is the following:</p><ul><li>A TraefikEE cluster, designated as<code>traefikee-staging</code>, is running on your remote Kubernetes platform, in the namespace <code>traefikee-ingress</code>,</li><li>You want to set up an administration machine (your computer, a freshly onboarded team member, etc.) to operate this cluster,</li><li>This machine is already configured to reach the Kubernetes cluster.</li></ul><p>The connect phase is easy:</p><pre><code class="language-shell">traefikeectl connect --clustername=traefikee-staging \
  --kubernetes \
  --kubernetes.namespace=traefikee-ingress</code></pre><p>That’s all: <code>traefikeectl</code> is now aware of this cluster and can operate it:</p><pre><code class="language-shell">
traefikeectl list-nodes

traefikeectl logs

# ...</code></pre><p>Under the hood, <code>traefikeectl</code> stored the cluster connection information in a TOML file named after the cluster name. These files are located in <code>${TRAEFIKEE_HOME}</code>, which defaults to the directory <code>${HOME}/.config/traefikee</code> (<a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html" rel="noopener">XDG_CONFIG folder</a>).</p><blockquote><em><em>Please note that if you do not provide the option <code>--clustername</code> , the default value <code>traefikee</code> is used.</em></em></blockquote><p>It means that you can manage multiple TraefikEE clusters from the same <code>traefikeectl</code>, so you are free to split per environment (staging/production, or event external/internal, etc.).</p><h2 id="deploy-phase">Deploy Phase</h2><p>The last step of the workflow is to deploy a “routing configuration”.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> We followed the previous blog post, and we were able to install TraefikEE on our platform. Now, we want to enable HTTPS and Metrics collection with <a href="https://prometheus.io/" rel="noopener">Prometheus</a>. Do we have to install the cluster again to update the configuration as we did for Traefik?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Fortunately, you don’t have to reinstall the cluster. Unlike Traefik, TraefikEE lets you update the configuration at runtime.</em></em></blockquote><p>Let’s say that you want to set up TraefikEE with the following routing configuration:</p><ul><li>Enable TLS termination on the port 443 (defining a new “entrypoint” named <code>https</code>),</li><li>Auto-generate TLS certificates using Let’s Encrypt for this new <code>https</code> “entrypoint” . The host names for these certificates are determined from the backend applications (either Ingresses on Kubernetes or labels on Docker Swarm),</li><li>Enable the Prometheus metric exporter,</li><li>Enable redirection from <code>http</code> to <code>https</code> for any incoming request.</li></ul><p>With Traefik, you would have passed the following options (and restarted Traefik to apply the configuration):</p><pre><code class="language-shell">## Traefik Configuration References:
# Entrypoints: https://docs.traefik.io/configuration/entrypoints/
# Metrics: https://docs.traefik.io/configuration/metrics/
# ACME/Let's Encrypt: https://docs.traefik.io/configuration/acme/

traefik --kubernetes \
  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \
  --entryPoints='Name:https Address::443 TLS' \
  --defaultentrypoints=https,http \
  --acme.entryPoint=https \
  --acme.email=damien@containo.us \
  --acme.tlsChallenge \
  --acme.onHostRule=true \
  --metrics.prometheus</code></pre><p>With TraefikEE, the same configuration is passed to the <code>traefikeectl deploy</code> command. It’s sent to the TraefikEE control plane through the traefikeectl API, stored on the TraefikEE Control Plane and then applied to <strong><strong>all</strong></strong> the TraefikEE Data Nodes (which are hot-reloaded).</p><pre><code class="language-shell">traefikeectl deploy --kubernetes \
  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \
  --entryPoints='Name:https Address::443 TLS' \
  --defaultentrypoints=https,http \
  --acme.entryPoint=https \
  --acme.email=damien@containo.us \
  --acme.tlsChallenge \
  --acme.onHostRule=true \
  --metrics.prometheus</code></pre><p>If you prefer using TOML file instead of command-line flags:</p><pre><code class="language-toml"># File "traefik.toml"

defaultEntryPoints = ["https","http"]

[entryPoints]
  [entryPoints.http]
  address = ":80"
    [entryPoints.http.redirect]
    entryPoint = "https"
  [entryPoints.https]
  address = ":443"
  [entryPoints.https.tls]

[kubernetes]

[acme]
email = "damien@containo.us"
storage = "acme.json"
entryPoint = "https"
onHostRule = true
[acme.tlsChallenge]</code></pre><pre><code class="language-shell">traefikeectl deploy --configfile=./traefik.toml</code></pre><hr><p>That’s all for today: we installed a customized cluster, connected a remote machine to operate with <code>traefikeectl</code>, and deployed the same configuration as the one you could have used for Traefik, but without taking down the cluster, and without loosing any requests!</p><p>You can learn more about the <code>traefikeectl</code> command line on <a href="https://docs.containo.us/installing/teectl-cli/">the reference documentation</a>.</p></hr>]]></content:encoded></item><item><title><![CDATA[The Journey to Traefik Enterprise Edition: HTTPS for Everyone]]></title><description><![CDATA[Welcome to the fourth step of our journey towards Traefik Enterprise Edition.
Today, we’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS by default...]]></description><link>https://traefik.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/</link><guid isPermaLink="false">Ghost__Post__5dd7bc8af1db6f0038c742d5</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Damien Duportal]]></dc:creator><pubDate>Mon, 25 Feb 2019 10:45:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/ee-tls-le.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/image-8.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: HTTPS for Everyone"/></figure><img src="https://containous.ghost.io/content/images/2019/11/ee-tls-le.png" alt="The Journey to Traefik Enterprise Edition: HTTPS for Everyone"/><p>Welcome to the fourth step of our journey towards <a href="https://containous.ghost.io/traefikee/">Traefik Enterprise Edition</a>.</p><p>Before jumping in, you should check the previous posts:</p><ul><li><em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/">Join the“Early Access” Program</a></em></em></li><li><em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/">Product Evaluation</a></em></em></li><li><em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/">High Availability</a></em></em></li></ul><p>Today, we’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS by default, for your application.</p><h2 id="create-a-kubernetes-cluster-with-kops">Create a Kubernetes Cluster with kops</h2><p>Following the same steps as <a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/">the previous blog post (“Create a cluster with kops”)</a>, start a kops cluster with one Kubernetes manager and three Kubernetes nodes:</p><pre><code class="language-shell">$ export NAME=traefikee-demo.containous.cloud
$ export KOPS_STATE_STORE=s3://&lt;YOUR BUCKET&gt;
$ export ROUTE53_ZONE_ID=&lt;ROUTE53_ZONE_ID&gt;
$ export NB_MASTER_NODE=1
$ export NB_WORKER_NODE=3

$ kops create cluster \
    --zones us-east-1a \
    --dns-zone="${ROUTE53_ZONE_ID}" \
    --node-size="t2.large" \
    --master-count="${NB_MASTER_NODE}" \
    --node-count="${NB_WORKER_NODE}" \
    --yes \
    "${NAME}"</code></pre><p>After a few minutes, your cluster is started with four Kubernetes nodes:</p><pre><code class="language-shell">$ kubectl get nodes
NAME                            STATUS   ROLES    AGE   VERSION
ip-172-20-34-251.ec2.internal   Ready    node     2m    v1.11.6
ip-172-20-49-209.ec2.internal   Ready    node     2m    v1.11.6
ip-172-20-53-165.ec2.internal   Ready    node     2m    v1.11.6
ip-172-20-56-217.ec2.internal   Ready    master   3m    v1.11.6</code></pre><h2 id="pick-a-public-domain-name">Pick a Public Domain Name</h2><p>In the previous blog post, we used <a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/">a domain name generated by Amazon Web Services</a> as the main entry point to reach our platform.</p><p>You cannot use this “generated” public hostname, because Let’s Encrypt has a “forbidden domains list.” Some domains are considered too risky, and any request for issuing certificates under these domains is automatically refused. <a href="https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2" rel="noopener">It’s the case with domains in </a><code><a href="https://community.letsencrypt.org/t/policy-forbids-issuing-for-name-on-amazon-ec2-domain/12692/2" rel="noopener">*.amazonaws.com</a>.</code></p><p>To solve this challenge, let’s pick a custom public domain name. Any domain or sub-domain (like <code>test.company.org</code> ) can be used. You have to be able to create DNS records of type <code>CNAME</code> on this domain.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I don’t want to pay for a domain used for evaluating a product. Maybe later if it goes further, but not now.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> You can get free DNS using <a href="http://www.dot.tk/en/index.html?lang=en" rel="noopener">Dot-T-K</a>, or even cheap ones using <a href="https://www.namecheap.com/" rel="noopener">NameCheap</a>.</em></em></blockquote><p>For the next steps, we’ll pick the domain <code>demo.containo.us</code> .</p><h2 id="install-traefikee">Install TraefikEE</h2><p>Then, install a simple TraefikEE cluster, without dashboard, as we did on <a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/">the previous blog post</a>:</p><pre><code class="language-shell">$ traefikeectl install \
  --licensekey="$(cat /keybase/…/traefikee-license)" \
  --kubernetes
...

✔ Installation successful</code></pre><p>Once the installation succeeded, verify that the TraefikEE cluster is composed of six nodes, three control nodes and three data nodes, as expected:</p><pre><code class="language-shell">$ traefikeectl list-nodes
...
Name                                 Role
----                                 ----
traefikee-control-node-0             CONTROL NODE
data-node-traefikee-data-node-9ndbp  DATA NODE
data-node-traefikee-data-node-vqgzr  DATA NODE
traefikee-control-node-1             CONTROL NODE
traefikee-control-node-2             CONTROL NODE (Current Leader)
data-node-traefikee-data-node-5w66x  DATA NODE</code></pre><h2 id="configure-the-domain-dns-records">Configure the Domain DNS Records</h2><p>The next step is to create a <code>CNAME</code> DNS record, on the public domain name, pointing to the Load Balancer’s hostname, created during TraefikEE’s installation.</p><p>Get the load balancer’s public hostname with the following command (field EXTERNAL-IP):</p><pre><code class="language-shell">$ kubectl get svc -n traefikee traefikee-lb
NAME          TYPE         EXTERNAL-IP
traefikee-lb  LoadBalancer a16ff-456.us-east-1.elb.amazonaws.com</code></pre><p>Then, create the DNS CNAME record to this hostname (choose a short TTL):</p><pre><code class="language-shell">IN  CNAME  demo.containo.us a16ff-456.us-east-1.elb.amazonaws.com</code></pre><p>The DNS propagation takes some time, due to the “TTL”. Verify that your computer can resolve the DNS name with tools as<code>dig</code> , <code>drill</code>or <code>nslookup</code> :</p><pre><code class="language-shell">$ dig CNAME demo.containo.us
...
;; QUESTION SECTION:
;demo.containo.us.       IN      CNAME

;; ANSWER SECTION:
demo.containo.us. 60     IN      CNAME   a16ff-456.us-east-1.elb.amazonaws.com.

;; Query time: 38 msec
;; SERVER: 212.224.255.252#53(212.224.255.252)
;; WHEN: Wed Feb 06 11:21:25 CET 2019
;; MSG SIZE  rcvd: 136</code></pre><h2 id="configure-traefikee-for-https">Configure TraefikEE for HTTPS</h2><p>Then, we configure TraefikEE to enable HTTPS and Let’s Encrypt for certificate on HTTPS. The configuration is the same as Traefik’s (check <a href="https://docs.traefik.io">Traefik's documentation</a> for more details):</p><pre><code class="language-shell">### Configure 2 entrypoints for https and https
  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \
  --entryPoints='Name:https Address::443 TLS' \
  --defaultentrypoints=https,http \
  
### Enable ACME protocol for the HTTPS entry point
  --acme.entryPoint=https \
  
### Set up ACME protocol for Let's Encrypt TLS-APLN-01 Challenge
  --acme.email=damien@containo.us \
  --acme.tlsChallenge \
  
### Tell Traefik to get certificate's hostname from backend's rules
  --acme.onHostRule=true</code></pre><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> When using Traefik with Let’s Encrypt, I often get certificates requests failures because of <a href="https://letsencrypt.org/docs/rate-limits/" rel="noopener">the rate limit on Let’s Encrypt side</a>.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Traefik allows to test your HTTPS configuration with <a href="https://letsencrypt.org/docs/staging-environment/" rel="noopener">the “staging” environment</a>, without rate limiting, but with untrusted certificates . It’s useful to validate configuration before switching to “production” certificates. Add the flag <code>--acme.caServer='https://acme-staging-v02.api.letsencrypt.org/directory<em>'</em></code><em> to the configuration.</em></em></em><br><em><em><em>Be careful! You cannot change the caServer unless you reinstall TraefikEE.</em></em></em></br></blockquote><p>The main difference from using Traefik here, is that TraefikEE is a distributed system, so you need to specify the configuration <strong><strong>after</strong></strong> TraefikEE’s installation.</p><p>The <code>traefikeectl</code> tool provides a command named <code>deploy</code> to send any routing configuration to the TraefikEE cluster. You can read more on this topic on the <a href="https://docs.containo.us">reference documentation for routing configurations</a>.</p><p>Now, let’s deploy the following configuration to the TraefikEE cluster and that’s all!</p><pre><code class="language-shell">traefikeectl deploy --kubernetes \
  --entryPoints='Name:http Address::80 Redirect.EntryPoint:https' \
  --entryPoints='Name:https Address::443 TLS' \
  --defaultentrypoints=https,http \
  --acme.entryPoint=https \
  --acme.email=damien@containo.us \
  --acme.tlsChallenge \
  --acme.onHostRule=true</code></pre><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Why is there a <code>—-kubernetes</code> flag in this configuration?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> This flag tells TraefikEE to watch for any Kubernetes Ingress. It’s the same directive as the one in Traefik.</em></em></blockquote><h2 id="deploy-an-application">Deploy an Application</h2><p>As we previously did on the post, “A Tour of TraefikEE”, we deploy a test application based on <a href="https://github.com/containous/whoami" rel="noopener">https://github.com/containous/whoami</a>.</p><p>You can reuse the same YAML file, but you have to change the directive <code>host</code> in the ingress, and map it to your public domain name. I’m using the following one-line shell command for this:</p><pre><code class="language-shell">$ curl --location --silent --show-error https://bit.ly/2WE5XFk \
  | sed 's/localhost/demo.damienduportal.org/g' \
  | kubectl apply -f -

deployment.extensions/whoami created
ingress.extensions/whoami created
service/whoami created</code></pre><p>You can check that Kubernetes is using the right domain name by checking the ingress “whoami”:</p><pre><code class="language-shell">$ kubectl get ingress whoami --namespace=traefikee
NAME     HOSTS                     ADDRESS   PORTS   AGE
whoami   demo.damienduportal.org             80      9m</code></pre><p>The page https://demo.damienduportal.org/whoami is now, (after a few seconds, required for issuing certificates), securely served over HTTPS, with a valid certificate, issued by Let’s Encrypt:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-39.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: HTTPS for Everyone"><figcaption>Green Lock for Everyone</figcaption></img></figure><blockquote><em><em>If you try to access http://demo.damienduportal.org/whoami, then you are redirected to https://demo.damienduportal.org/whoami as expected.</em></em></blockquote><p>That’s all for today, you are ready to use HTTPS on your applications!<br>You can now clean your kops cluster with:</br></p><pre><code class="language-shell">kops delete cluster --name="${NAME}"</code></pre><hr><p>On the next post, “The Journey to Traefik Enterprise Edition: Smooth Operations,” we’ll focus on how to configure and operate TraefikEE remotely with the <code>traefikeectl</code> command line.</p></hr>]]></content:encoded></item><item><title><![CDATA[Getting to Know Vincent Pineau]]></title><description><![CDATA[We recently welcomed new leadership to the Containous team. His name is Vincent Pineau, a tech veteran who has...]]></description><link>https://traefik.io/blog/getting-to-know-vincent-pineau-25b75bda1019/</link><guid isPermaLink="false">Ghost__Post__5dd7c250f1db6f0038c7430f</guid><category><![CDATA[Blog]]></category><category><![CDATA[Company]]></category><dc:creator><![CDATA[Patricia Dugan ]]></dc:creator><pubDate>Wed, 20 Feb 2019 11:11:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/vincent.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/12/vincent.png" alt="Getting to Know Vincent Pineau"/><p class="post-sub-title">An Interview with New Leadership at Containous</p><!--kg-card-end: html--><p>We recently welcomed new leadership to the <a href="https://containous.ghost.io/" rel="noopener">Containous</a> team. His name is <a href="https://www.linkedin.com/in/vincent-pineau-143898/" rel="noopener">Vincent Pineau</a>, a tech veteran who has successfully lead two companies to the win. One, Talend, the third French company to make it to the NASDAQ, and the second, Influans, a company recently acquired. Vincent joined our small and dedicated leadership team as CCO, standing alongside <a href="https://twitter.com/emilevauge" rel="noopener">Emile Vauge</a>, founder and CEO of Containous, and the <em><em>inventor</em></em> of <a href="https://containous.ghost.io/traefik/">Traefik</a>, a <em><em>world class, cloud native edge router.</em></em></p><p>Vincent and I have a highly collaborative relationship around my marketing efforts. Here, I ask him questions to better understand his vision for the company, and how he’ll lead us to becoming globally recognized, and <em><em>trusted for our brand, products and customer service</em></em>. Please read on.</p><hr><h2 id="the-interview">The Interview</h2><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-40.png" class="kg-image" alt="Getting to Know Vincent Pineau"><figcaption>Vincent Pineau, Chief Customer Officer, Containous</figcaption></img></figure><p><strong><strong>Patricia: </strong></strong>What is your title at Containous, and function does this role play?</p><p><strong><strong>Vincent: </strong></strong>I am the new “CCO,” which stands for <em><em>Chief Customer Officer</em></em>, although titles aren’t very important to us. More meaningful than a title is a person’s focus. My focus is to extend Containous from the amazing open source company that it is, to an open source business. I am responsible for putting together and to oversee, the appropriate programs and services to grow the business. I will enable our expansion, from a customer support, sales and marketing standpoint.</p><p><strong><strong>Patricia: </strong></strong>What does such an expansion look like?</p><p><strong><strong>Vincent: </strong></strong>First, we will continue to develop products which are easy and relevant to the quickly evolving IT infrastructure world. Then, we’ll hone in on what our customers, and the open source community needs to drive the most value out of our products. Commercial support, expertise consulting, advanced training, specific “enterprise grade” capabilities, those are the key variables that I’ve seen leveraged in the past to build sustainable open source companies…which is exactly what Containous will become.</p><p><strong><strong>Patricia: </strong></strong>Wait. So. What’s your background?</p><p><strong><strong>Vincent: </strong></strong>As a quick study, I was part of the founding team that grew one company to an IPO on the NASDAQ, and co-founder of another company which was acquired late 2018. To give you the full story, we have to go back a little bit and explain my journey in tech. I had my first computer when I was 10. You know my age, so that takes us back a while.</p><p><strong><strong>Patricia:</strong></strong> Do I know your age? I don’t.</p><p><strong><strong>Vincent: </strong></strong>I just turned 50 in January. I had a computer in ’79, and I was probably one of the first dozen in the area of Lyon to have a computer. As a curious kid, I started tinkering with computers. I came to have several of them and then as a teenager, had to choose a major. After some deliberation, I chose to focus on mechanics.</p><p>The computers, everything IT related, became a passion, but I earned my major in mechanical engineering. The team at my first job figured out very quickly that my value was in IT, not acting as a mechanical engineer. Eventually, I became the IT Director there. I implemented an ERP solution, and was quickly hired by the vendor to become a consultant.</p><p>That’s when I discovered the “vendor” side, which quickly brought me to the U.S. After about a decade working for traditional enterprise vendors, I was introduced to a French <em><em>open source company</em></em>, Talend, and given the opportunity to launch it globally. That meant taking an open source company which was having a fair amount of organic traction, acting as an evangelist, and bringing attention to the company, with the goal of turning existing users into customers.</p><p>That journey started in 2007, when commercial open source was still being established in the U.S.</p><p>During that time frame, I spent a lot of time explaining to customers the advantages of open source.</p><blockquote>I don’t believe in open source being at odds with proprietary software. Generally, I believe that open source is superior, because it is the result of a community driven focus.</blockquote><p>You benefit from lots of brains — which brings stability, an edge in creativity, an edge in time to market. Those elements together are superior.</p><p><strong><strong>Patricia: </strong></strong>What does the future hold for Traefik?</p><p><strong><strong>Vincent:</strong></strong> I see wonderful opportunities here. When I was with Talend, we had a similar opportunity with similar challenges. We started as a small team in France, with a small amount of funding. We became serious about bringing the product to market, and my charter was to raise awareness to a global marketplace, not just Europe.</p><p>We have a similar story with Containous, in that it has substantial organic growth and humble beginnings. Now, we going for the gold by dedicating more developer, marketing and community resources to growing the company. We will bring not just Traefik open source edition more visibility, but expose the value of <a href="https://containous.ghost.io/traefikee/" rel="noopener">Traefik Enterprise Edition</a> to a worldwide audience.</p><p>I am excited to create an <em><em>evolution.</em></em> Containous is a mind blowing company with a thoroughness that the team is proving through the development of high quality software.</p><blockquote>We will show <em>why</em> we’re worth getting to know.</blockquote><p>We are creating a technical evolution, beginning with Traefik and Traefik Enterprise Edition. I’m excited to lead us into creating it.</p><hr><p>For those interested in <a href="https://containous.ghost.io/traefikee/" rel="noopener">free early access to Traefik Enterprise Edition,</a> and to those already using Traefik in production who wish to share your stories, please email me: patricia at containo.us.</p><p>Thank you.</p></hr></hr>]]></content:encoded></item><item><title><![CDATA[The Journey to Traefik Enterprise Edition: High Availability]]></title><description><![CDATA[Welcome to the third step of our journey towards Traefik Enterprise Edition . Let’s evaluate TraefikEE’s high availability feature with...]]></description><link>https://traefik.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/</link><guid isPermaLink="false">Ghost__Post__5dd7c361f1db6f0038c74326</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Damien Duportal]]></dc:creator><pubDate>Mon, 28 Jan 2019 11:15:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/ee-ha.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/image-9.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: High Availability"/></figure><img src="https://containous.ghost.io/content/images/2019/11/ee-ha.png" alt="The Journey to Traefik Enterprise Edition: High Availability"/><p>Welcome to the third step of our journey towards<a href="https://containous.ghost.io/traefikee/"> Traefik Enterprise Edition</a> .</p><p>After the two first posts <em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/https://containo.us/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/">Join the“Early Access” Program</a></em></em>, and <em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/">Product Evaluation</a></em></em>), let’s get real and evaluate TraefikEE’s high availability feature.</p><p>The previous post described how to install TraefikEE on a local machine, which is not a realistic environment. Today, we’ll use a Kubernetes multi-node cluster deployed in Amazon EC2 as a more realistic platform for running TraefikEE.</p><h2 id="creating-a-kubernetes-cluster-with-kops">Creating a Kubernetes Cluster with kops</h2><p>The first step is to get a multi-node Kubernetes cluster up and running somewhere in the cloud.</p><p><code>kops</code> (aka. “Kubernetes Operations”) is a tool provided by the Kubernetes community. It provides a command line to create and manage Kubernetes clusters on cloud infrastructures as <a href="https://aws.amazon.com/ec2/" rel="noopener">Amazon EC2</a>, <a href="https://cloud.google.com/compute/?hl=fr" rel="noopener">Google Compute Engine</a> or <a href="https://www.digitalocean.com/" rel="noopener">Digital Ocean</a>.</p><p>Using the kops tutorial for AWS, we have the following requirements set up:</p><ul><li>The <code>aws</code> command line tool installed</li><li>AWS API access credentials loaded (<a href="https://github.com/mmatur/aws-mfa" rel="noopener">check this project</a> from <a href="https://medium.com/u/c01753d22e74?source=post_page-----7421718be2d8----------------------" rel="noopener">Michael MATUR</a> if you need MFA)</li><li>The <code>kops</code> command line tool installed</li><li>One of the 3 DNS scenarios configured</li><li>An AWS S3 bucket created to store kops configuration</li></ul><p>We can create a Kubernetes cluster with 3 masters and 6 worker nodes. The worker nodes are a <a href="https://aws.amazon.com/ec2/instance-types/t2/" rel="noopener">t2.large</a> types, with 2 CPUs and 8 Gb memory each:</p><pre><code class="language-shell">$ export NAME=traefikee-demo.containous.cloud
$ export KOPS_STATE_STORE=s3://&lt;YOUR BUCKET&gt;
$ export ROUTE53_ZONE_ID=&lt;ROUTE53_ZONE_ID&gt;

$ kops create cluster \
  --zones us-east-1a \
  --dns-zone="${ROUTE53_ZONE_ID}" \
  --node-size="t2.large" \
  --master-count=3 \
  --node-count=6 \
"${NAME}"</code></pre><p>Once the cluster is created, validate its state with <code>kops</code>, and verify the access to the Kubernetes API with the <code>kubectl</code>:</p><pre><code class="language-shell">$ kops validate cluster --name="${NAME}"
Validating cluster traefikee-demo.containous.cloud
...

Your cluster traefikee-demo.containous.cloud is ready

$ kubectl get nodes
NAME STATUS ROLES AGE VERSION
ip-172–20–33–152.ec2.internal Ready node 1d v1.11.6
ip-172–20–37–195.ec2.internal Ready master 1d v1.11.6
ip-172–20–38–193.ec2.internal Ready node 1d v1.11.6
ip-172–20–42–46.ec2.internal Ready master 1d v1.11.6
ip-172–20–44–104.ec2.internal Ready node 1d v1.11.6
ip-172–20–52–184.ec2.internal Ready node 1d v1.11.6
ip-172–20–60–90.ec2.internal Ready node 1d v1.11.6
ip-172–20–61–254.ec2.internal Ready node 1d v1.11.6
ip-172–20–62–134.ec2.internal Ready master 1d v1.11.6</code></pre><p>We can now proceed to install TraefikEE on this cluster.</p><h2 id="traefikee-installation">TraefikEE Installation</h2><p>We expect that the command line <code>traefikeectl</code> command is already installed on your machine. If you haven’t done it yet, check the "Install traefikeectl" section of the <a href="https://docs.containo.us">Installation Guide</a>.</p><pre><code class="language-shell">$ traefikeectl version
Version: v1.0.0-beta17
Codename: Gewurztraminer
Go version: go1.11.4
Built: 2019-01-22_10:12:50AM
OS/Arch: darwin/amd64</code></pre><p>Next step: installation of TraefikEE in one line, using <code>traefikeectl</code>, as covered on <a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/">the previous blog post</a>.</p><blockquote><em><em>Don’t forget it takes some time to download all the required resources</em></em></blockquote><pre><code class="language-shell">$ traefikeectl install \
  --licensekey="$(cat /keybase/…/traefikee-license)" \
  --dashboard \
  --kubernetes

# ...

You can access the dashboard with the following credentials:

Username: admin
Password: 384bae9a1fe11670

✔ Installation successful</code></pre><blockquote>Don’t forget to write down the password for later.</blockquote><p>Congratulations, your TraefikEE cluster is installed locally! The last step is to check the topology of the TraefikEE cluster:</p><pre><code class="language-shell">$ traefikeectl list-nodes
Name                                 Role
----                                 ----
data-node-traefikee-data-node-864tl  DATA NODE
data-node-traefikee-data-node-jptsq  DATA NODE
data-node-traefikee-data-node-rn4x8  DATA NODE
traefikee-control-node-1             CONTROL NODE
data-node-traefikee-data-node-l6x2s  DATA NODE
data-node-traefikee-data-node-wmm6n  DATA NODE
data-node-traefikee-data-node-h2pgb  DATA NODE
traefikee-control-node-2             CONTROL NODE (Current Leader)
traefikee-control-node-0             CONTROL NODE</code></pre><p>As expected we have:</p><ul><li>A Control Plane composed of <strong><strong>3</strong></strong> nodes, which is the default</li><li>A Data Plane composed of <strong><strong>6</strong></strong> nodes, which is <a href="https://docs.containo.us/installing/teectl-cli/">the default behavior (see the flag “ — datanodes”)</a> . TraefikEE sets up 1 data node per worker node of the Kubernetes cluster. It uses a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="noopener">Kubernetes Daemon Set</a> under the hood.</li></ul><h2 id="accessing-the-web-dashboard">Accessing the Web Dashboard</h2><p>On the previous post, we used the <code>kubectl port-forward</code> command to access the dashboard by <a href="https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/" rel="noopener">forwarding a port locally</a>.</p><p>As this Kubernetes cluster is available from the outside, we want to use a public hostname to access it instead, so the end users can access your applications from anywhere.</p><p>Using the command line <code>kubectl</code>, fetch the public hostname of the Amazon Elastic Load-Balancer allocated during the installation (column <code>EXTERNAL-IP</code>):</p><pre><code class="language-shell">$ kubectl get svc -n traefikee traefikee-lb

NAME          TYPE         EXTERNAL-IP
traefikee-lb  LoadBalancer a277b89-820.us-east-1.elb.amazonaws.com</code></pre><p>You can now access the dashboard on the URL <code>http://&lt;EXTERNAL-IP&gt;/dashboard/</code> .</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-41.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: High Availability"><figcaption>All your nodes are belong to us</figcaption></img></figure><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> My Kubernetes Cluster does not show any EXTERNAL-IP. How can I reach the dashboard (and applications)?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Most of Kubernetes providers propose out of the box implementation for the <a href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer" rel="noopener">Service of type “LoadBalancer”</a>. If it is not your case, take a look at <a href="https://metallb.universe.tf/" rel="noopener">https://metallb.universe.tf/</a>.</em></em></blockquote><h2 id="deploy-an-application">Deploy an Application</h2><p>As we did on the previous post, we deploy an application based on <a href="https://github.com/containous/whoami" rel="noopener">https://github.com/containous/whoami</a>. </p><pre><code class="language-shell">$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/0ff70f9ae50d7930a9fa6c06bdc15253c81b8af4/whoami.yaml</code></pre><p>The dashboard updates itself once the application is deployed:</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-42.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: High Availability"/></figure><p>You can now reach the application at the URL <code>http://&lt;EXTERNAL-IP&gt;/whoami</code> :</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-43.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: High Availability"/></figure><h2 id="high-availability">High Availability</h2><p>What happens if one of the 6 worker node goes down by accident or for <a href="https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/" rel="noopener">maintenance</a>?</p><ul><li>1 of the 6 data nodes goes down (or is rescheduled). The load balancer forwards the traffic to the 5 remaining nodes: no request are lost!</li><li>If 1 of the control nodes was running on this worker node, the remaining nodes elect a new leader and take care of the configuration, until the node comes up.</li></ul><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Aren’t the control node part of a Raft cluster? If yes, then what happens if only 2 control nodes are up?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> The workload handled by the failed node is distributed to the 2 others, so the cluster does not loose data and continues to work as expected. However if the failed node does not comes back, then you are not tolerant to another failure. You can run a TraefikEE of 5 control nodes to be fault tolerant to 2 failures. You can get more information on the TraefikEE documentation or chek how the Raft consensus work <a href="http://thesecretlivesofdata.com/raft/" rel="noopener">here</a>.</em></em></blockquote><p>To demonstrate this high-availability behavior, we will:</p><ul><li>Run a load test on the “<em><em>whoami</em></em>” application served by TraefikEE</li><li>Restart 1 of the 6 Kubernetes worker node</li><li>Verify that no requests are lost</li><li>Validate that the cluster comes back in an healthy state once the Kubernetes worker node is restarted</li></ul><h2 id="load-testing-the-whoami-application">Load Testing the whoami Application</h2><p>We’ll use “slapper” (<a href="https://github.com/ikruglov/slapper" rel="noopener">https://github.com/ikruglov/slapper</a>), a go command line providing a real-time view of the load test in the console.</p><pre><code class="language-shell"># You need go - https://golang.org/dl/

$ go get -u github.com/ikruglov/slapper
...

$ which slapper
"${GOPATH}/bin/slapper"</code></pre><p>Slapper requires a “<a href="https://github.com/ikruglov/slapper#targets-syntax" rel="noopener">target file</a>” which is a text file describing the load-testing scenario. Our load-testing scenario is simple: we want to emit HTTP GET requests to the URL of the <em><em>whoami</em></em> application.</p><pre><code class="language-shell">$ cat whoami.target
GET http://a277bd4f21fde11e9b5150ea2ab8b589-823458350.us-east-1.elb.amazonaws.com/whoami</code></pre><p>Let’s start the load testing for 30s, with 50 requests per seconds, and with an adapted scale (with an example output):</p><pre><code class="language-shell">$ slapper -targets ./whoami.target -minY 100ms -maxY 800ms -timeout 30s -rate 50

sent: 198    in-flight: 6  rate:   50/50 RPS responses: [200]: 192

100-101 ms: [     0/     0]
101-102 ms: [     0/     0]
102-103 ms: [     0/     0]
103-105 ms: [     0/     0]
105-106 ms: [     0/     0]
106-108 ms: [    13/     0] **************************
108-110 ms: [   112/     0] ************************************
110-113 ms: [    40/     0] ****************************************
113-115 ms: [    10/     0] ********************
115-118 ms: [     3/     0] ******
118-121 ms: [     4/     0] ********
121-125 ms: [     2/     0] ****
125-129 ms: [     0/     0]
129-133 ms: [     0/     0]
133-138 ms: [     0/     0]
138-144 ms: [     0/     0]
144-150 ms: [     0/     0]
...
800+ ms: [     0/     0]</code></pre><h2 id="reboot-a-worker-node">Reboot a Worker Node</h2><p>Using the <code>aws</code> and <code>kubectl</code>command lines, we get the EC2 instance ID of a worker node, and restart it:</p><pre><code class="language-shell"># Select one of the 6 Kubernetes nodes
$ kubectl get nodes
NAME STATUS ROLES AGE VERSION
...
ip-172–20–38–193.ec2.internal Ready node 1d v1.11.6
...

# Get the EC2 instance ID
$ aws ec2 describe-instances --filters "Name=private-dns-name,Values=ip-172-20-38-193.ec2.internal" | grep InstanceId
"InstanceId": "i-0fdc6a4f95908a2ba",

# Restart the instance
$ aws ec2 reboot-instances --instance-ids=i-0fdc6a4f95908a2ba</code></pre><p>The Dashboard immediately reports that a control node and a data node are unhealthy ( <code>traefikee-control-node-0</code> and <code>data-node-traefikee-wmm6n</code> in this case):</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-44.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: High Availability"/></figure><h2 id="validate-high-availability">Validate High Availability</h2><p>If you check back the load testing, you can see that no requests have been lost or in error. You might see, however, a punctual growth on the response time (+- 100ms):</p><pre><code class="language-shell">sent: 25736  in-flight: 2 rate:   50/50 RPS responses: [200]: 25734</code></pre><p>As soon as the EC2 instance has restarted, all the failed nodes (Kubernetes and TraefikEE) are going back online:</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-45.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: High Availability"><figcaption>TraefikEE cluster back to nominal state</figcaption></img></figure><p>Check this video of a the load test running with a worker node randomly killed:</p><figure class="kg-card kg-embed-card"><iframe width="480" height="270" src="https://www.youtube.com/embed/ghYsR5CuNiQ?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""/></figure><p>That’s all for today! We demonstrated the high availability feature of TraefikEE. Oh, and don’t forget to clean your cluster:</p><pre><code class="language-shell">kops delete cluster --name="${NAME}"</code></pre><hr><p>On the next post “<a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-https-for-everyone-90a36b33600/">The Journey to Traefik Enterprise Edition: HTTPS for everyone</a>”, we’ll focus on how to use TraefikEE with Let’s Encrypt to get HTTPS by default.</p></hr>]]></content:encoded></item><item><title><![CDATA[The Journey to Traefik Enterprise Edition: Product Evaluation]]></title><description><![CDATA[Welcome to the second post of our journey towards Traefik Enterprise Edition . Let’s continue our journey by quickly evaluating the product on your local machine...]]></description><link>https://traefik.io/blog/the-journey-to-traefik-enterprise-edition-product-evaluation-4828508cbc8/</link><guid isPermaLink="false">Ghost__Post__5dd7e6ebf1db6f0038c7437f</guid><category><![CDATA[Blog]]></category><category><![CDATA[How To]]></category><dc:creator><![CDATA[Damien Duportal]]></dc:creator><pubDate>Tue, 22 Jan 2019 13:47:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/ee-evaluation.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/12/image-10.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Product Evaluation"/></figure><img src="https://containous.ghost.io/content/images/2019/11/ee-evaluation.png" alt="The Journey to Traefik Enterprise Edition: Product Evaluation"/><p>Welcome to the second post of our journey towards <a href="https://containous.ghost.io/traefikee/">Traefik Enterprise Edition</a> .</p><p>After our first step (<em><em><a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/">Join the“Early Access” Program</a></em></em>), let’s continue by doing a quick evaluation the product on your local machine.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> But, the shiny website says that it is a <strong><strong>distributed</strong></strong> version. How can we assess this on a single machine?</em></em></blockquote><blockquote><em><em><strong><strong>(Another voice in the background):</strong></strong> A developer machine is <strong><strong>not</strong></strong> a production environment!</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> These assertions are 100% right dear users! Following the core principles of Traefik, we want to keep things simple and start by getting TraefikEE up and running on a “testing system”. Don’t worry: next steps of the journey are coming, to cover other topics from high availability, to installation on production systems.</em></em></blockquote><h2 id="traefikee-installation">TraefikEE Installation</h2><p>The next step of the journey is to install TraefikEE: Let’s follow the provided <a href="https://docs.containo.us/">documentation</a>!</p><p><strong><strong><em><em>“TraefikEE-Cuddle”</em></em></strong></strong></p><p>The “<a href="https://docs.containo.us/getting-started/">Getting Started with Installation</a>” page recommends to use the command line <code>traefikeectl</code> and guides you on installing this command:</p><pre><code class="language-shell">$ curl -sSL -o /usr/local/bin/traefikeectl https://get-the-link-for-your-operating-system/traefikeectl

$ shasum -a256 /usr/local/bin/traefikeectl # Check against the SHA256 checksums for your release

$ chmod a+x /usr/local/bin/traefikeectl # Make it executable

$ traefikeectl version
Version:      v1.0.0-beta16
Codename:     Gewurztraminer
Go version:   go1.11.4
Built:        2019-01-21_06:00:54PM
OS/Arch:      darwin/amd64</code></pre><p><strong><strong><em><em>Kubernetes Time!</em></em></strong></strong></p><p>TraefikEE can be installed on different platforms but, this example uses <a href="https://kubernetes.io/" rel="noopener">Kubernetes</a>.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I don’t know Kubernetes</em></em><br><em><em><strong><strong>Containous:</strong></strong> You don’t have to for this evaluation. But you can learn it from <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" rel="noopener">https://kubernetes.io/docs/tutorials/kubernetes-basics/</a></em></em></br></blockquote><p>A Kubernetes installation is required. Don’t worry, we are not <a href="https://en.wiktionary.org/wiki/yak_shaving" rel="noopener">yak shaving</a> to select where and how install Kubernetes.</p><p>Instead we’ll use the awesome <a href="https://github.com/kubernetes-sigs/kind" rel="noopener">“KinD” (Kubernetes inside Docker)</a> tool providing a disposable Kubernetes locally.</p><blockquote><em><em>(From <a href="https://github.com/kubernetes-sigs/kind" rel="noopener">https://github.com/kubernetes-sigs/kind</a></em>), <em><code><em>kind</em></code> is a tool for running local Kubernetes clusters using Docker container "nodes".</em></em><br><em><em><code><em>kind</em></code> is primarily designed for testing Kubernetes 1.11+, initially targeting the conformance tests.</em> <em>If you have <a href="https://golang.org/" rel="noopener">Go</a> and <a href="https://www.docker.com/" rel="noopener">Docker</a> installed <code><em>go get sigs.k8s.io/kind &amp;&amp; kind create cluster</em></code> is all you need</em></em></br></blockquote><p>Install your Kubernetes cluster for the evaluation:</p><pre><code class="language-shell">$ kind create cluster --name=traefikee
Creating cluster 'kind-traefikee' ...
✓ Ensuring node image (kindest/node:v1.12.3) 🖼
✓ [kind-traefikee-control-plane] Creating node container 📦
✓ [kind-traefikee-control-plane] Fixing mounts 🗻
✓ [kind-traefikee-control-plane] Starting systemd 🖥
✓ [kind-traefikee-control-plane] Waiting for docker to be ready 🐋
✓ [kind-traefikee-control-plane] Starting Kubernetes (this may take a minute) ☸

Cluster creation complete. You can now use the cluster with:
export KUBECONFIG="$(kind get kubeconfig-path --name="traefikee")"
kubectl cluster-info

$ export KUBECONFIG="$(kind get kubeconfig-path --name="traefikee")"

$ kubectl cluster-info
Kubernetes master is running at https://localhost:55243

# We have a Kubernetes cluster ready to use!</code></pre><p><em><em>Please note that any local Kubernetes installation passing the conformance tests can be used for the evaluation (as Docker4Mac or Docker4Windows).</em></em></p><p><strong><strong><em><em>TrafikEE Installation</em></em></strong></strong></p><p>Following the <a href="https://docs.containo.us">official documentation</a>, you may install TraefikEE in one line, using <code>traefikeectl</code> . It might take a few minute to download all the required resources:</p><pre><code class="language-shell">$ traefikeectl install \
  --licensekey="$(cat /keybase/.../traefikee-license)" \
  --dashboard \
  --kubernetes
...

You can access the dashboard with the following credentials:

Username: admin
Password: 4087abf2354666d9

✔ Installation successful</code></pre><p>Congratulations, your TraefikEE cluster is installed locally!</p><h2 id="a-tour-of-traefikee">A Tour of TraefikEE</h2><p>TraefikEE is installed, now what?</p><p>First, we have to open access from your web-browser to the cluster:</p><pre><code class="language-shell"># Forward TraefikEE data plane's port 80 to your localhost:8000
kubectl port-forward -n traefikee "$(kubectl get pod -n traefikee | awk '{print $1}' | grep data-node)" 8000:80 &amp;</code></pre><p>TraefikEE is now exposed on your machine on the following URL: http://localhost:8000 .</p><blockquote><em><em>On a production-grade Kubernetes installation, you would use your external Load Balancer’s public hostname and port.</em></em></blockquote><p><strong><strong><em><em>Web Dashboard</em></em></strong></strong></p><p>Let’s start the tour with the Web Dashboard, which is enabled because we used the flag<code>--dashboard</code> during the installation.</p><p>Open the URL http://localhost:8000 and authenticate with the username and password credentials from the <code>traefikeectl install</code> command’s output from earlier.</p><blockquote><em><em>In this example, the username is <code><em>admin</em></code> and the password is <code><em>d4087abf2354666d9dsds</em></code>. These credentials are generated automatically during the installation.</em></em></blockquote><p>You can see the default section named “Providers” which shows you the TraefikEE’s routing configuration, generated from Kubernetes:</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-46.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Product Evaluation"><figcaption>Looks like Traefik’s WebUI</figcaption></img></figure><p>Using the top bar, navigate to the “Metrics” section to get an overview of the incoming request’s metrics.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Traefik also provides a “Metrics” page, what is the value of this one?</em></em><br><em><em><strong><strong>Containous:</strong></strong> It’s the same, except that metrics are aggregated from all the data plane’s nodes.</em></em></br></blockquote><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-47.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Product Evaluation"><figcaption>Look, someone forgot its password and got HTTP/401 responses</figcaption></img></figure><p>It’s time to get an overview of the cluster. Browse to the “Cluster” section to check that you have a Control Plane of 3 nodes, and a Data Plane of 1 node.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Wait, isn’t TraefikEE distributed? Why only 1 node in the data plane?</em></em><br><em><em><strong><strong>Containous:</strong></strong> By default, there is 1 “TraefikEE Data Node” per Kubernetes node. We are using a single-node Kubernetes hence 1 data node. Wait for the next blog to learn more about the distribution.</em></em></br></blockquote><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-48.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Product Evaluation"><figcaption>It’s a nice cluster that you have there</figcaption></img></figure><p><strong><strong><em><em>Operations with traefikeectl</em></em></strong></strong></p><p>Next step of this tour is the “Smooth Operations” feature. We know that Engineers love automation. So we made a command line, <code>traefikeectl</code>to automate all the operations on your TraefikEE clusters.</p><p>You already tasted <code>traefikeectl</code>. Let’s do another example of operation by listing all the cluster’s nodes with <code>traefikeectl</code>:</p><pre><code class="language-shell">$ traefikeectl list-nodes

Name                                 Role
----                                 ----
data-node-traefikee-data-node-5fplw  DATA NODE
traefikee-control-node-0             CONTROL NODE (Current Leader)
traefikee-control-node-2             CONTROL NODE
traefikee-control-node-1             CONTROL NODE</code></pre><p>The next section shows another example, but you can already check the <code>traefikeectl</code> ‘s <a href="https://docs.containo.us/installing/teectl-cli/">Command Line Reference Documentation</a> to learn more about the operations features.</p><p><strong><strong><em><em>Deploy an application</em></em></strong></strong></p><p>TraefikEE is an edge router, which main goal is to route incoming request into your applications.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> Did you just say “applications”? But there are no applications deployed into this Kubernetes, only TraefikEE.</em></em><br><em><em><strong><strong>Containous:</strong></strong> Patience, there is an example below. But let that sink in: Isn’t the Dashboard an application with incoming traffic?</em></em></br></blockquote><p>Let’s deploy an example application. It’s an HTTP web service, based on github.com/containous/whoami, which responds an HTML page with the headers of your request.</p><pre><code class="language-shell">$ kubectl apply -f https://gist.githubusercontent.com/dduportal/ad5e68ffcd9e39c65bdf4af7224304a0/raw/8b87143b084c612f86d66f587df7c058c7fa1aa0/whoami.yaml</code></pre><p>Check the dashboard again. After a few seconds, the routing configuration for the application “whoami” is automatically picked by TraefikEE from Kubernetes: a frontend and 2 associated backends (the 2 replicas).</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-49.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Product Evaluation"/></figure><p>The application is reachable at the URL localhost:8000/whoami. As the “whoami” application is scaled to 2 instances, try to reload the page multiple time to see the field “Hostname” changing, due to the Load Balancing.</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-50.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Product Evaluation"><figcaption>Such Web, Much Text</figcaption></img></figure><hr><p>That’s all for today and this first quick tour. On the next post “<a href="https://containous.ghost.io/blog/the-journey-to-traefik-enterprise-edition-high-availability-7421718be2d8/">The Journey to Traefik Enterprise Edition: High Availability</a>”, we’ll cover the distributed features of TraefikEE.</p></hr>]]></content:encoded></item><item><title><![CDATA[The Journey to Traefik Enterprise Edition: Join the Free “Early Access” Program]]></title><description><![CDATA[Welcome to the first post of our journey with Traefik Enterprise Edition!
This post guides you through the first steps of your TraefikEE discovery journey...]]></description><link>https://traefik.io/blog/the-journey-to-traefik-enterprise-edition-join-the-early-access-program-b73e07d62f30/</link><guid isPermaLink="false">Ghost__Post__5dd7e9cff1db6f0038c743f4</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Damien Duportal]]></dc:creator><pubDate>Mon, 14 Jan 2019 13:59:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/ee.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/image-11.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Join the Free “Early Access” Program"/></figure><img src="https://containous.ghost.io/content/images/2019/11/ee.png" alt="The Journey to Traefik Enterprise Edition: Join the Free “Early Access” Program"/><p>Welcome to the first post of our journey with <a href="https://containous.ghost.io/traefikee/">Traefik Enterprise Edition</a>!</p><p>TraefikEE (Enterprise Edition) is available <a href="https://info.containo.us/get-traefik-enterprise-edition-free-for-30-days">here</a> for free.</p><p>This post guides you through the first steps of your TraefikEE discovery journey: From requesting the “early access” to obtaining your license key and getting started.</p><h2 id="traefikee-traefik-for-the-enterprise-world">TraefikEE: Traefik, for the Enterprise World</h2><p>Introduced during KubeCon US 2018 (<a href="https://containous.ghost.io/blog/introducing-traefik-enterprise-edition-83b78d09efeb/">check out the “Introducing Traefik Enterprise Edition” blog post</a>), TraefikEE is built on top of Traefik and adds clustering features to satisfy the needs of Enterprise customers. All Traefik concepts apply to TraefikEE, so if you already are a Traefik user, you’re in familiar territory.</p><p>TraefikEE runs on the edge of your platform to route the traffic to your applications.</p><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-51.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Join the Free “Early Access” Program"><figcaption>Global Architecture of Traefik Enterprise Edition</figcaption></img></figure><p>TraefikEE is composed of two planes:</p><ul><li>The <strong><strong>data plane</strong></strong>: horizontally scalable nodes, which forward ingress traffic to your services</li><li>The <strong><strong>control plane</strong></strong>: distributed nodes, implementing <a href="http://thesecretlivesofdata.com/raft/" rel="noopener">the raft consensus</a>, which watch your platform and its services, stores topology changes, and reconfigure the data plane to adapt ingress routing dynamically</li></ul><p>This distributed architecture is the cornerstone of TraefikEE’s strengths: natively <strong><strong>highly available</strong></strong>, <strong><strong>scalable</strong></strong>, and <strong><strong>secure</strong></strong>.</p><h2 id="support-account-and-license">Support Account and License</h2><p>The journey begins by visiting the TraefikEE website at <a href="https://containous.ghost.io/traefikee/">https://containo.us/traefikee</a>, and opting in to the program by clicking the “Free Trial” form.</p><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I’ve been told it is free. Why should I give you my personal information?</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> We need a way to communicate together, so the form creates a “Support Account” for you in our ticketing system. So you can raise requests if you get any issue with TraefikEE, and we can send you information about update.</em></em></blockquote><p>Once you’ve filled out the form, look for a “Welcome to Containous” e-mail sent from <a href="mailto:support@containous.zendesk.com" rel="noopener">support@containous.zendesk.com</a> in your mail’s inbox (or, possibly junk folder). Click on the link it contains to validate your account. You will be prompted to set a (strong) password: <a href="https://xkcd.com/936/" rel="noopener">you know the story</a>.</p><p>Once your account is validated with a (strong) password, the system will generate a TraefikEE license and send you an e-mail entitled “Your license key” (it may take a couple minutes) which will contain instructions.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-53.png" class="kg-image" alt="The Journey to Traefik Enterprise Edition: Join the Free “Early Access” Program"><figcaption>Knock, knock, you got an email!</figcaption></img></figure><blockquote><em><em><strong><strong>(A voice in the background):</strong></strong> I never received the email. It’s probably tagged as spam by my organization’s mail system.</em></em></blockquote><blockquote><em><em><strong><strong>Containous:</strong></strong> Instead of the email, you can also browse the customer portal at</em> </em><a href="https://containous.zendesk.com/hc/en-us/restricted?return_to=https%3A%2F%2Fcontainous.zendesk.com%2Fhc%2Fen-us">https://support.containo.us/</a><em><em>, select the button “Check my existing requests / License” and open the request named “Your license key”.</em></em></blockquote><p>Get your license and put it somewhere “secure” (e.g. an encrypted system). For this post series, we store the license in a file, encrypted into a <a href="https://keybase.io/" rel="noopener">Keybase.io</a> volume:</p><pre><code class="language-shell">$ cat /keybase/private/dduportal/traefikee-license
xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></pre><p>That’s all folks, you can <a href="https://docs.containo.us/">get started with the installation from the documentation</a>.</p><p>On the next post “The Journey to Traefik Enterprise Edition: Product Evaluation”, we will install TraefikEE on your machine and take a tour of its features.</p>]]></content:encoded></item><item><title><![CDATA[Introducing Traefik Enterprise Edition]]></title><description><![CDATA[Containous, the company behind Traefik, is announcing Traefik Enterprise Edition, a new platform built on top of Traefik, designed for business-critical deployments.]]></description><link>https://traefik.io/blog/introducing-traefik-enterprise-edition-83b78d09efeb/</link><guid isPermaLink="false">Ghost__Post__5dd7ea61f1db6f0038c74413</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Tue, 11 Dec 2018 14:02:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/ee-1.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/ee-1.png" alt="Introducing Traefik Enterprise Edition"/><p class="post-sub-title">We Made It Distributed</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/12/image-12.png" class="kg-image" alt="Introducing Traefik Enterprise Edition"/></figure><p><em><em><a href="https://containous.ghost.io/">Containous</a></em></em>, the company behind <em><em><a href="https://containous.ghost.io/traefik/">Traefik</a></em></em>, is announcing Traefik Enterprise Edition — <em><em>TraefikEE</em></em> — a new platform built on top of <em><em>Traefik</em></em>, designed for business-critical deployments.</p><p>In just three years, <em><em>Traefik</em></em>, the Cloud Native Edge Router, has become a key player in microservices infrastructures. With more than 19,000 stars on Github and 400,000,000 downloads on DockerHub, <em><em>Traefik</em></em> is widely used by major companies in their production environments.</p><p>Today, we are proud to announce that <em><em>TraefikEE</em></em>, our new commercial product, has reached public beta. <em><em>TraefikEE</em></em> allows you to deploy distributed Traefik instances across your infrastructure, providing a scalable and reliable edge routing platform. Split into a control plane and a data plane, <em><em>Traefik</em></em> cluster nodes are easily deployed and operated using the <em><em>TraefikEE</em></em> CLI. Implementing the Raft consensus, <em><em>TraefikEE</em></em> can safely store and replicate configurations and TLS certificates across the nodes.</p><p>Let’s take a look at how <em><em>TraefikEE</em></em> works.</p><h2 id="traefikee-overview">TraefikEE — Overview</h2><figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-54.png" class="kg-image" alt="Introducing Traefik Enterprise Edition"><figcaption>TraefikEE Architecture</figcaption></img></figure><p><em><em>TraefikEE</em></em> is built on top of <em><em>Traefik</em></em> and adds clustering features to satisfy the needs of Enterprise customers. All <em><em>Traefik</em></em> concepts apply to <em><em>TraefikEE</em></em>, so if you’re already a <em><em>Traefik</em></em> user, you’re in familiar territory.</p><p>It runs on the edge of your platform to route the traffic to your applications, and is composed of two elements:</p><ul><li><strong><strong>The data plane</strong></strong>: horizontally scalable nodes, which forward ingress traffic to your services</li><li><strong><strong>The control plane</strong></strong>: distributed nodes, implementing the raft consensus, which watch your platform and its services, stores topology changes, and reconfigure the data plane to adapt ingress routing dynamically</li></ul><p>A <em><em>TraefikEE</em></em> cluster natively supports raft consensus between control nodes to safely store and replicate configurations. No external Key-Value Store nor third-party tool needed.</p><p>This distributed architecture is the cornerstone of <em><em>TraefikEE</em></em>’s strengths: natively <strong><strong>highly available</strong></strong>, <strong><strong>scalable</strong></strong> and <strong><strong>secure</strong></strong>.</p><h2 id="highly-available">Highly Available</h2><figure class="kg-card kg-embed-card"><iframe width="480" height="270" src="https://www.youtube.com/embed/bsl05RVuMtM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""/></figure><p>The control plane is a key component of <em><em>TraefikEE</em></em>. It is responsible for storing all cluster data, including events, TLS certificates, and <em><em>Traefik </em></em>configuration. It is also in charge of connecting to the orchestrator to generate the data plane routing configuration.</p><p>Since it is such a critical part of your system,<em><em> TraefikEE</em></em> is designed from the ground up to be fault tolerant: the control plane runs natively in cluster mode without any extra configuration or external Key Value Store. It ensures your data is always available and safe by using an internal distributed store, implemented with raft.</p><h2 id="scalable">Scalable</h2><figure class="kg-card kg-embed-card"><iframe width="480" height="270" src="https://www.youtube.com/embed/YNKMcussMrM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""/></figure><p>The data plane is in charge of forwarding the incoming requests to the applications. It has been designed to scale horizontally at a glance in order to face irregular network loads.</p><p><em><em>TraefikEE</em></em> handles high loads in a blink: just add more nodes to the data plane to handle the additional requests. When the peak is gone, shrink the number of nodes to save resources. Of course, this process can be done automatically using auto-scaling tools.</p><h2 id="secure">Secure</h2><figure class="kg-card kg-embed-card"><iframe width="480" height="270" src="https://www.youtube.com/embed/rPAcKSiidUo?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""/></figure><p>By splitting responsibilities between two components, <em><em>TraefikEE</em></em> follows the principle of “Separation of Concerns.”</p><p>To ensure that sensitive information only runs on a closed and safe environment, the control plane is not exposed to the outside. As a result, any malicious action from external traffic will stay stuck in the data plane and your platform will stay safe.</p><p>Moreover, <em><em>TraefikEE</em></em> only relies on encrypted communications between nodes, to add an extra layer of security.</p><h2 id="smooth-operations">Smooth Operations</h2><p>Installing and managing a raft based application is usually a painful experience. Since <em><em>Traefik</em></em> was made popular thanks to its usability and refreshing user experience, we have extended those benefits to TraefikEE.</p><p>For this reason, <em><em>TraefikEE</em></em> comes with an additional CLI that manages to deploy and operate a cluster with several nodes in only one command line. Currently, Kubernetes and Docker Swarm Mode are supported. More platforms will be added soon. Teams will love to use this time-saving tool, <em><em>traefikeectl</em></em> (pronounced “traefikee-cuddle”).</p><p><em><em>TraefikEE</em></em> comes with a dashboard to visualize your cluster nodes configuration and status, in addition to aggregated data plane metrics.</p><p>Commercial support is bundled with TraefikEE. The Traefik engineering team immediately investigates and resolves any critical issues which may arise.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/11/image-55.png" class="kg-image" alt="Introducing Traefik Enterprise Edition"/></figure><h2 id="early-access">Early Access</h2><p>TraefikEE is available in early access starting today. The registration process is as simple and automated as possible, so don’t fear endless registration forms nor crowded waiting queues before trying it out. Visit our website at <a href="https://containous.ghost.io/traefikee/">https://containo.us/traefikee</a> and get your license key in less than a minute!</p><h2 id="traefik-stays-open">Traefik Stays Open</h2><p><em><em>TraefikEE</em></em> is built on top of <em><em>Traefik</em></em>, that means that Traefik continues to evolve and will stay open source. Nothing changes! We are firm believers in open source, and <em><em>Traefik</em></em> will continue to be our main priority and a community-driven project. We are working on significant changes to Traefik, and <a href="https://containous.ghost.io/blog/traefik-spoiler-season-episode-1-3dbcb1f5d8b9/">recently have shared details</a> on what we have been doing so far. Please stay tuned for full disclosure.</p><h2 id="about-containous">About Containous</h2><p>Containous is the company that supports the development of Traefik. We provide professional services to ensure businesses get the most out of the solution.</p><p>With this new product, Containous continues to innovate and define new ways to access microservice platforms, pushing the limits of automation and scalability.</p>]]></content:encoded></item><item><title><![CDATA[Traefik — Spoiler Season — Episode 1]]></title><description><![CDATA[Hi everyone! Today is a very special day: we’re here to talk about changes. Yes, the changes we’ve been playing around with, the changes we talked about in...]]></description><link>https://traefik.io/blog/traefik-spoiler-season-episode-1-3dbcb1f5d8b9/</link><guid isPermaLink="false">Ghost__Post__5dd7eb67f1db6f0038c74435</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Mon, 19 Nov 2018 14:06:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/wip-traefik.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/wip-traefik.png" alt="Traefik — Spoiler Season — Episode 1"/><p class="post-sub-title">The Story of the Configuration Structure</p><!--kg-card-end: html--><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/12/image-13.png" class="kg-image" alt="Traefik — Spoiler Season — Episode 1"/></figure><p>Hi everyone! Today is a very special day: we’re here to talk about changes.</p><p>Yes, <em><em>the</em></em> changes we’ve been playing around with, the changes we talked about in <a href="https://containous.ghost.io/blog/traefik-1-7-yet-another-slice-of-awesomeness-2a9c99737889/">the latest release note</a>, the changes we’re looking forward to bringing to the next version of Traefik.</p><p>But like in every spoiler undertaking, we won’t disclose everything (where would be the fun in that?).</p><p>Today we’re going to discuss the configuration <em><em>structure —</em></em> the infamous <code>entrypoints</code>, <code>frontends</code>, and <code>backends</code> and how they interact together<em><em>.</em></em></p><hr><p><strong><strong><em><em>Note:</em></em></strong></strong><em><em> In the article, we’ll use the </em></em><code><em><em>file</em></em></code><em><em> provider to talk about the changes. This provider best exposes the structure of the configuration and is the foundation for the other label / annotation-driven providers. Of course, everything that applies to the </em></em><code><em><em>file</em></em></code><em><em> provider should apply to the label/annotation based providers.</em></em></p><p><strong><strong>Note 2:</strong></strong> In this article, we’ll assume that you’re a knowledgeable Traefik enthusiast.</p><p><strong><strong>Note 3:</strong></strong> Nope, no note 3, I’m good, let’s move on.</p><hr><h2 id="it-all-started-with-">It All Started with…</h2><p>To this day, Traefik’s configuration is quite simple and accounts for a great part of its success.</p><p><code>Entrypoints</code> accept the incoming requests (for the most part: ports &amp; certificate management), <code>frontends</code> analyze the requests to determine what should handle them, and <code>backends</code> are responsible for forwarding the requests to your system (your both beloved and hated microservices).</p><p>Since everyone loves diagrams (at least I do), below is the magic happening.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-56.png" class="kg-image" alt="Traefik — Spoiler Season — Episode 1"/></figure><p>This architecture works like a charm because you can configure everything you need, from authentication to redirects, to circuit breaker mechanisms, to retry mechanisms, to custom errors, to HTTPS, to load-balancing, to whatever you need. And better, it works with many providers (k8s, docker, AWS, mesos, …).</p><p>But … (always a but) … sometimes people were confused about where to configure these options. Other times, people were confused because some options were magically applied in a predetermined order they could not easily change (and no, hacking our way into the bowels of Traefik is not literally easy).</p><p>Because so many options were added since Traefik’s initial launch, we’re in a situation where the magic comes along with a cost: things are less obvious than before, and it becomes a problem when you need to fine-tune the routing for specific requests.</p><p>Also, since we’re complaining about the configuration, I have to say that I hate to repeat myself — which was sometimes a problem when (for example) I wanted to put the same auth mechanism on several frontends (but not every one of them).</p><h2 id="-and-it-will-become">… And It Will Become</h2><p>So we took a step back, gave it some thought, and came up with our first proposal … What if we wrote…</p><p><code>Entrypoints</code> accept the incoming requests, <code>routers</code> analyze the requests to determine what should handle them, and <code>services</code> are responsible for handling the requests and ultimately forwarding them to your system (your both beloved and hated microservices).</p><blockquote><em><em><em>Déjà vu?</em></em></em></blockquote><p>See? <em><em>SO</em></em> different! It’s even more obvious in the following diagram.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-57.png" class="kg-image" alt="Traefik — Spoiler Season — Episode 1"/></figure><h3 id="are-you-kidding">Are You Kidding?</h3><p>Well, we’re not.</p><p>At first sight, apart from the vocabulary update, we agree that nothing has <em><em>obviously</em></em> changed: same sequence of operations.</p><p>What really changed is what’s happening <em><em>inside</em></em>.</p><h3 id="middleware-the-almost-newcomer">Middleware — The (Almost) Newcomer</h3><p>If you look closely to the new diagram, you’ll notice that <em><em>something</em></em> is missing, and then you’ll realize that this <em><em>something</em></em> is quite important.</p><p>You can pause here, go back to the diagram and keep reading once you’ve figured it out, but for the impatient amongst us, here it is: In the diagram, <em><em>nothing</em></em> updates the request, <em><em>nothing</em></em> checks the credentials, <em><em>nothing</em></em> tweaks the path or the domain. In the diagram, a whole block of features is missing.</p><p>But how come this crucial element isn’t shouting its absence from the diagram? It’s simply because the configuration for these updates/tweaks/behaviors used to be spread across the existing components (<code>entrypoints</code>, <code>frontends</code>, and <code>backends</code>).</p><p>Soon, they will be configured in dedicated pieces of <code>middleware</code> and referred to from <code>entrypoints</code>, <code>routers</code>, and <code>services</code>. What’s more important — <em><em>You</em></em> will decide how, when, and in which order.</p><blockquote><em><em>Yes, you will have full control.</em></em></blockquote><h2 id="before-after-the-tl-dr-you-re-looking-for-">Before / After (The TL;DR you’re looking for)</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-58.png" class="kg-image" alt="Traefik — Spoiler Season — Episode 1"/></figure><h2 id="we-want-examples-">We Want Examples!</h2><p>That’s a legitimate request — let’s start with a super basic example with a frontend, a backend, and no additional fluff.</p><blockquote>A frontend (router), a backend (service), and no additional fluff</blockquote><h3 id="before">before</h3><pre><code class="language-toml">[frontends]
   [frontends.my-frontend]
      entrypoint = ["http"]
      backend = my-backend
      [frontend.my-frontend.routes.route1]
         rule = "Host:myhost.com"

[backends]
   [backends.my-backend]
      [backends.my-backend1.servers]          
         [backends.backend1.servers.server-1]
            url = "http://xx.xx.xx.xx"</code></pre><h3 id="after">after</h3><pre><code class="language-toml">[routers]
   [routers.my-router]
      entrypoint = ["http"]
      rule = "Host:myhost.com"
      service = my-service

[services]
   [services.my-service.load-balancer]
      [[services.my-services.load-balancer.servers]]
         url = "http://xx.xx.xx.xx"</code></pre><p>Apart from the vocabulary difference, this one brings nothing new to the table. (Yes, I’ll behave <em><em>as if</em></em> there was no additional <code>.load-balancer</code> type for the service because this will be for another episode.)</p><p>If we wanted to have another server, of course, we would write:</p><pre><code class="language-toml">[routers]
   [routers.my-router]
      entrypoint = ["http"]
      rule = "Host:myhost.com"
      service = my-service

[services]
   [services.my-service.load-balancer]
      [[services.my-services.load-balancer.servers]]
         url = "http://xx.xx.xx.xx"
      [[services.my-services.load-balancer.servers]]
         url = "http://xx.xx.xx.xx"</code></pre><blockquote>Now, let’s add basic authentication!</blockquote><h3 id="before-1">before</h3><pre><code class="language-toml">[frontends]
   [frontends.my-frontend]
      entrypoint = ["http"]
      backend = my-backend
      [frontend.my-frontend.routes.route1]
         rule = "Host:myhost.com"
      [frontend.my-frontend.auth]
         [frontend.my-frontend.auth.basic]
            users = ["admin:xxx","super-admin:xxx",]

[backends]
   [backends.my-backend]
      [backends.my-backend1.servers]          
         [backends.backend1.servers.server-1]
            url = "http://xx.xx.xx.xx"</code></pre><h3 id="after-1">after</h3><pre><code class="language-toml">[routers]
   [routers.my-router]
      entrypoint = ["http"]
      rule = "Host:myhost.com"
      middlewares = ["admins-only"]
      service = my-service

[middlewares]
   [middlewares.admins-only.basicauth]
      users = ["admin:xxx","super-admin:xxx",]

[services]
   [services.my-service.load-balancer]
      [[services.my-services.load-balancer.servers]]
         url = "http://xx.xx.xx.xx"</code></pre><p>The basic authentication middleware is no longer configured inside the router but in a dedicated middleware section. The good news, besides readability, is that you can now reuse the same middleware in a different router, along with other middlewares.</p><pre><code class="language-toml">[routers]
   [routers.my-router]
      entrypoint = ["http"]
      rule = "Host:myhost.com"
      middlewares = ["admins-only"]
      service = my-service
   
   [routers.my-other-router]
      entrypoint = ["http"]
      rule = "Host:myhost2.com"
      middlewares = ["admins-only", "retry-std"]
      service = my-service

[middlewares]
   [middlewares.admins-only.basicauth]
      users = ["admin:xxx","super-admin:xxx",]
   [middlewares.retry-std.retry]
      attempts = 2

[services]
   [services.my-service.load-balancer]
      [[services.my-services.load-balancer.servers]]
         url = "http://xx.xx.xx.xx"</code></pre><p>Also, another benefit you probably have noticed — you can now have many separate configurations for some features (like retry) and choose the one that fits for your routers.</p><p>Behind the scenes, many other things have already changed (not yet obvious), but we’d like to tease with more episodes!</p><p>Besides, we’ve decided to show you one “work in progress” feature at a time — this gives time to listen to your feedback!</p><hr><p>Traefik is a project driven by the community! We are more grateful than ever for your feedback on the project. We’ve reached <strong><strong>18k+ stars</strong></strong> on Github, and the product has been downloaded more than <strong><strong>350 million</strong></strong> times!</p><hr><p>Join us on <a href="https://github.com/containous/traefik" rel="noopener">GitHub</a>, <a href="https://twitter.com/traefik" rel="noopener">Twitter</a>, on the <a href="https://community.containo.us">Community Forum</a>, or in the comments below so we can hear your voice!</p></hr></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Spread the Love!]]></title><description><![CDATA[Hi everyone! I hope you’re enjoying Traefik as much as we enjoy building it with you.
Today, while browsing the web...]]></description><link>https://traefik.io/blog/spread-the-love-ba5a40aa72e7/</link><guid isPermaLink="false">Ghost__Post__5dd7ec91f1db6f0038c74462</guid><category><![CDATA[Blog]]></category><category><![CDATA[Community]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Mon, 29 Oct 2018 14:11:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/traefik-stickers.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/traefik-stickers.jpeg" alt="Spread the Love!"/><p class="post-sub-title">And Say It with Stickers :-)</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-full kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/12/image-14.png" class="kg-image" alt="Spread the Love!"><figcaption>Our Beloved Gopher</figcaption></img></figure><p>Hi everyone! I hope you’re enjoying <a href="https://containous.ghost.io/traefik/">Traefik</a> as much as we enjoy building it with you.</p><p>Today, while browsing the web (even though I had better things to do), I realized how many of you have shown love by giving <a href="https://events.docker.com/events/details/docker-blacksburg-presents-container-orchestration-migrating-to-the-cloud-using-docker-and-traefik#/" rel="noopener">talks</a> (or by writing <a href="https://medium.com/@yanick.witschi/automated-kubernetes-deployments-with-gitlab-helm-and-traefik-4e54bec47dcf" rel="noopener">blog posts</a>) which show how you leverage Traefik to enable dazzling architectures.</p><p>Then, as I was staring into space (thinking about how that cat video would have been much cooler with a gopher), I saw my colleagues’ laptops … covered with stickers … and it clicked.</p><blockquote>We should help our fans spread the word with swag to distribute!</blockquote><p>Yes, I know that it’s not as mind blowing as the new features we’ll soon talk about, but it’s a start, right?</p><p>So, if you’re a Traefik fan (which makes us <em><em>your</em></em> fans!), and since the gopher in our logo is adorable (not to say utterly, hypnotically handsome), perhaps you’d like some stickers to distribute to your audience at your talks! — They are a “nice to have” we developers enjoy 😉</p><p>If you’d like us to send you some stickers, please fill out <a href="https://docs.google.com/forms/d/e/1FAIpQLSfzLUboLnb5sajJfoYNT34Jiqe_4f71kE0DsUqloWZdaC6UWg/viewform?usp=sf_link" rel="noopener">this form</a> and we will ship some to you right away. The form will ask you all the necessary details we need to help you promote the event. (And give you swag!)</p><p>We are so proud to spread the word with you — Thank you for contributing and sharing the value of Traefik.</p><!--kg-card-begin: markdown--><p><a href="https://docs.google.com/forms/d/e/1FAIpQLSfzLUboLnb5sajJfoYNT34Jiqe_4f71kE0DsUqloWZdaC6UWg/viewform?usp=sf_link"><img src="https://containous.ghost.io/content/images/2019/11/iwantswag.png" alt="Spread the Love!"/></a></p>
<!--kg-card-end: markdown--><blockquote>You can use the form to show us your best blog posts too … our favorites will get their swag!</blockquote><hr><p>Also, since we’re talking about… talking about Traefik (did that make sense?), there is one more thing I want to mention. We’re looking for <em><em>you,</em></em> a talented developer advocate eager to join an incredible team. Check out the role here: <a href="https://containous.ghost.io/careers/">Developer Advocate @ Containous</a>.</p><p>And if you’re interested, well, you know what you have to do. (Apply!)</p></hr>]]></content:encoded></item><item><title><![CDATA[Traefik 1.7 — Yet Another Slice of Awesomeness]]></title><description><![CDATA[Releases keep rolling! After three months of development and five release candidates, we are proud to announce the release of Traefik 1.7, codename “maroilles”.
]]></description><link>https://traefik.io/blog/traefik-1-7-yet-another-slice-of-awesomeness-2a9c99737889/</link><guid isPermaLink="false">Ghost__Post__5dcdb7431127150038885858</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Tue, 25 Sep 2018 08:00:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/Traefik1-7-1.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/12/image-15.png" class="kg-image" alt="Traefik 1.7 — Yet Another Slice of Awesomeness"><figcaption>Traefik <a href="https://en.wikipedia.org/wiki/Maroilles_cheese" rel="noopener">Maroilles</a></figcaption></img></figure><img src="https://containous.ghost.io/content/images/2019/11/Traefik1-7-1.png" alt="Traefik 1.7 — Yet Another Slice of Awesomeness"/><p>Releases keep rolling! After three months of development and five release candidates, we are proud to announce the release of Traefik <em><em>1.7</em></em>, codename “<a href="https://en.wikipedia.org/wiki/Maroilles_cheese" rel="noopener nofollow"><em><em>maroilles</em></em></a><em><em>”</em></em>.</p><p>We’ve merged <a href="https://github.com/containous/traefik/milestone/9?closed=1" rel="noopener nofollow">more pull requests than ever</a> from our ever-growing community of contributors that has reached more than 300 individuals. Thanks go to every one of you; we are in awe before your enthusiasm at improving Traefik.</p><p>The full changelog is available <a href="https://github.com/containous/traefik/releases/tag/v1.7.0" rel="noopener nofollow">here</a>, but we wanted to highlight our favorite features.</p><h2 id="let-s-encrypt-the-new-tls-challenge-in-town">Let’s Encrypt &amp; The New TLS Challenge in Town</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/letsEncrypt.png" class="kg-image" alt="Traefik 1.7 — Yet Another Slice of Awesomeness"/></figure><p>Let’s Encrypt integration is one of the most praised features of Traefik, so when Let’s Encrypt faced the <a href="https://community.letsencrypt.org/t/2018-01-09-issue-with-tls-sni-01-and-shared-hosting-infrastructure/49996" rel="noopener nofollow">TLS-SNI-01 challenge incident</a>, some of our users were left with few (yet satisfactory) alternatives. But when <a href="https://community.letsencrypt.org/t/tls-alpn-validation-method/63814" rel="noopener nofollow">they introduced the TLS ALPN Challenge</a>, <a href="https://github.com/ldez" rel="noopener nofollow">Ludovic Fernandez</a> was pleased to make it available right away so the community could once again pick a TLS based challenge.</p><!--kg-card-begin: markdown--><pre><code>[acme] 
   # … 
   entryPoint = &quot;https&quot; 
   [acme.tlsChallenge] #enables the TLS ALPN Challenge
</code></pre>
<!--kg-card-end: markdown--><p>One of the advantage of TLS based challenges? They only require port 443 to be open.</p><h2 id="a-docker-image-for-windows">A Docker Image for Windows</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/DockerImageForWindows.png" class="kg-image" alt="Traefik 1.7 — Yet Another Slice of Awesomeness"/></figure><p>Because we didn’t want to let down our Windows user base, Traefik now has its official <a href="https://hub.docker.com/_/traefik/" rel="noopener nofollow">Windows Docker image</a>!</p><p>That’s correct: no more tinkering with custom builds, you’ll get your Traefik instance right out of the box on your Windows Server infrastructure.</p><p>For compatibility reasons, our image is currently based on Windows <code>nanoserver-sac2016</code>, but rest assured that more recent nano server images are on their way.</p><p>Our thanks go to <a href="https://github.com/StefanScherer" rel="noopener nofollow">Stefan Scherer</a> who harnessed his expertise to make this happen, and to <a href="https://github.com/dduportal" rel="noopener nofollow">Damien Duportal</a> who fearlessly dove into the subject.</p><h2 id="h2c-support">H2C Support</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/HTTP2.png" class="kg-image" alt="Traefik 1.7 — Yet Another Slice of Awesomeness"/></figure><p><a href="https://github.com/Juliens" rel="noopener nofollow">Julien Salleyron</a> would explain it better than I do, but basically, H2C is a way to do HTTP2 <em><em>without</em></em> certificates.</p><blockquote><em><em>Wait … why is that useful?</em></em></blockquote><p>Well, when you have lots of gRPC services on your infrastructure (that by default use TLS), <em><em>not</em></em> having to handle a certificate for each service is a simplification you will probably welcome.</p><p>This is why Traefik now supports incoming H2C requests, either by upgrading HTTP1 connections or dealing with “Prior Knowledge” requests.</p><p>You can also tell Traefik that your backend servers support H2C (using the <code>traefik.protocol=h2c</code> label or the relevant option for your provider), in which case Traefik will send HTTP2 requests (with prior knowledge) to them.</p><p>To make things even better, Traefik accepts <em><em>both</em></em> H2C requests <em><em>and</em></em> HTTP1 requests on the <em><em>same</em></em> entrypoint (port). No need to separate your workload.</p><h2 id="aws-fargate">AWS Fargate</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/AWSFargate.png" class="kg-image" alt="Traefik 1.7 — Yet Another Slice of Awesomeness"/></figure><p>Released worldwide earlier this year, Amazon has deployed AWS Fargate — <em><em>a compute engine for Amazon ECS that allows you to run containers without having to manage servers or clusters.</em></em></p><p>As always, you can count on Traefik to support your favorite cluster technology! In case you decide to run mixed clusters with EC2 and Fargate components, Traefik will seamlessly detect them and work with them with no additional efforts on your part (since <a href="https://github.com/mmatur" rel="noopener nofollow">Michael Matur</a> already did the job).</p><h2 id="auth-in-frontends">Auth in Frontends</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/AuthInFrontends.jpeg" class="kg-image" alt="Traefik 1.7 — Yet Another Slice of Awesomeness"/></figure><p>You can now configure authentication on the frontend layer, which provides fine-grain control on what needs to be secured.</p><p>Thanks go to <a href="https://github.com/Zatte" rel="noopener nofollow">Zatte</a> who provided the feature for the Kubernetes provider (and the idea itself).</p><p>Excerpts from the documentation for the file provider:</p><!--kg-card-begin: markdown--><pre><code>[frontends.myfrontend.auth]
   headerField = &quot;X-WebAuth-User&quot;
 
   [frontends.myfrontend.auth.basic] 
      users = [ &quot;test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/&quot;,
                &quot;test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0&quot;,]
</code></pre>
<!--kg-card-end: markdown--><p>You can also check the new authentication options available for the K8S Ingress provider to get a better idea of what’s possible.</p><h2 id="security">Security</h2><p>Traefik has become a critical component for many, and we want Traefik to be safe for everyone. To help us ensure that, even though these actions are not “per se” new features, we have created a new security mailing list (<a href="https://groups.google.com/a/traefik.io/forum/#!forum/security" rel="noopener nofollow">security+subscribe@traefik.io</a>) you can subscribe to. We will use this mailing list in case there is a security issue that requires your attention.</p><p>Another significant step toward making Traefik as safe as possible is the new form you can use to <a href="https://security.traefik.io/" rel="noopener nofollow">report a vulnerability</a> you might discover. By using this form, you will alert us first and give us the opportunity to fix a potential problem before it impacts others in a negative way.</p><p>We really appreciate your help on this sensitive topic.</p><h2 id="and-much-much-more-">And Much, Much More…</h2><p><a href="https://github.com/dtomcej" rel="noopener nofollow">Daniel Tomcej</a> improved the TLS handshake, <a href="https://github.com/andrewstucki" rel="noopener nofollow">Andrew Stucki</a> added constraints support on ECS <em><em>and</em></em> allowed the binding of ECS container port, <a href="https://github.com/marenzo" rel="noopener nofollow">Michael Arenzon</a> added support for stale reads from Consul catalog, <a href="https://github.com/SniperCZE" rel="noopener nofollow">Ondrej Flidr</a> tweaked the health check to add support for 3xx codes, <a href="https://github.com/zetaab" rel="noopener nofollow">Jesse Haka</a> added HTTP headers to the healthcheck, <a href="https://github.com/yue9944882" rel="noopener nofollow">Kim Min</a> made it possible to specify backend servers’ weight in Kubernetes, <a href="https://github.com/ryarnyah" rel="noopener nofollow">Ryarnya</a> enabled an async option to improve log performances, <a href="https://github.com/rodrigodiez" rel="noopener nofollow">Rodrigo Díez</a> (for his first PR!) added a duration filter for the logs, <a href="https://github.com/timoreimann" rel="noopener nofollow">Timo Reimann</a> added support for multi-port services in K8s, and the list goes on.</p><p>Once again, we improved many things behind the curtain and kept working to make Traefik better for everyone. You can check the whole <a href="https://github.com/containous/traefik/releases/tag/v1.7.0" rel="noopener nofollow">changelog</a> to catch a glimpse of the awesome work that has been done on this release.</p><hr><h2 id="before-you-go-the-future-has-begun-">Before You Go: The Future Has Begun!</h2><p>Even if the spoiler season has not yet begun, some of our dedicated contributors have noticed — <em><em>things</em></em> are brewing in the master branch, <em><em>things</em></em> we’ve been willing to do for a long time, <em><em>things</em></em> that have been postponed until now and that we’re excited to work on.</p><p>Yes, for now I agree that this cryptic message won’t help you find out what’s coming next, but we’re sure that you’ve already guessed that the next version will be huge.</p><p>We’ve decided to unlock all the constraints we had with the stable branch and to work on features we couldn’t easily implement because of the current architecture (and because of compatibility reasons). Our goal with the next version is to set everything up so we can welcome an endless panel of new features, so we can provide greater flexibility to our users (yes, you’ll soon be able to go even further when defining your routes).</p><p>To this day, we’ve only updated the code base to get rid of the deprecated elements, but we’ll soon need to introduce breaking changes to test our ideas. What matters here is that we want to share our vision with you so we can hear your feedback. These changes will not be final choices; they will be proposals put to the trial of the community — features matter only if they match your needs.</p><h3 id="what-does-that-mean">What does that mean?</h3><p>It means that the master branch will drift apart from the current stable branch to become the <em><em>future</em></em> branch. However, until the <em><em>future</em></em> is now, it will remain in constant evolution and prone to change with little notice.</p><p>This is the reason why we encourage our users and contributors to <em><em>not</em></em> use the master branch for their production system. This is also the reason why, in the meantime, we’ll be pickier with features introduced in the current branch and often redirect you to the master branch: so you can also be involved in the <em><em>big next</em></em>.</p><blockquote><em><em>Traefik is an open source project at its core, and we want to keep it this way — thank you for being part of its success!</em></em></blockquote><hr><p>Grab the latest binaries for Linux, Windows, and Mac on Github or get the official Docker image!</p><!--kg-card-begin: markdown--><pre><code>docker pull traefik:v1.7.0 (or 1.7.0, v1.7, 1.7, maroilles)
docker pull traefik:v1.7.0-alpine (or 1.7.0-alpine, v1.7-alpine, 1.7-alpine, maroilles-alpine)
docker pull traefik:1.7-nanoserver
</code></pre>
<!--kg-card-end: markdown--><p>The <em><em>versioned</em></em> documentation can be found on <a href="https://docs.traefik.io/" rel="noopener nofollow">https://docs.traefik.io</a>.</p><hr><p>By the way, if you want to join an incredible team so you can express your every talent:<strong><strong> We are hiring! </strong></strong>Check <a href="https://containous.ghost.io/careers" rel="noopener nofollow">our available positions</a>!</p><p>Traefik adoption rate is astounding! We’ve reached <strong><strong>17k+ stars</strong></strong> on Github and <strong><strong>200M+ downloads</strong></strong>!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href="https://github.com/containous/traefik" rel="noopener nofollow">GitHub</a>, <a href="https://twitter.com/traefik" rel="noopener nofollow">Twitter</a> or on the <a href="https://community.containo.us">Community Forum</a>!</p></hr></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Traefik 1.6 — Get Our Latest tetedemoine!]]></title><description><![CDATA[After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.6, codename “tetedemoine”.

We merged 168 pull requests from...]]></description><link>https://traefik.io/blog/traefik-1-6-get-our-latest-tetedemoine-1859164bf521/</link><guid isPermaLink="false">Ghost__Post__5dd7ee5df1db6f0038c7449a</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Mon, 07 May 2018 14:18:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/monkshead.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/3862/1*FA-ZxO_2HjFO9sJpBE1SEw.png" class="kg-image" alt="Traefik 1.6 — Get Our Latest tetedemoine!"><figcaption><a href="https://en.wikipedia.org/wiki/T%C3%AAte_de_Moine" class="bf cn hz ia ib ic" target="_blank" rel="noopener" style="box-sizing: inherit; color: inherit; text-decoration: none; -webkit-tap-highlight-color: transparent; background-repeat: repeat-x; background-image: url(&quot;data:image/svg+xml;utf8,<svg preserveAspectRatio=\&quot;none\&quot; viewBox=\&quot;0 0 1 1\&quot; xmlns=\&quot;http://www.w3.org/2000/svg\&quot;><line x1=\&quot;0\&quot; y1=\&quot;0\&quot; x2=\&quot;1\&quot; y2=\&quot;1\&quot; stroke=\&quot;rgba(0, 0, 0, 0.84)\&quot; /></svg>&quot;); background-size: 1px 1px; background-position: 0px calc(1em + 1px);">Monk’s head</a></figcaption></img></figure><img src="https://containous.ghost.io/content/images/2019/12/monkshead.png" alt="Traefik 1.6 — Get Our Latest tetedemoine!"/><p>After 3 months of development, we are thrilled to announce the fresh new release of Traefik: <em><em>1.6</em></em>, codename “<em><em>tetedemoine”</em></em>.</p><p>We merged 168 pull requests from more than 43 contributors! A huge thanks goes out to each of you who helped on this new version 😘.</p><p>The full changelog can be found <a href="https://github.com/containous/traefik/releases/tag/v1.6.0" rel="noopener">here</a> but here are some new features we want to highlight:</p><h2 id="let-s-encrypt-wildcard-certificates">Let’s Encrypt Wildcard Certificates</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-60.png" class="kg-image" alt="Traefik 1.6 — Get Our Latest tetedemoine!"/></figure><p>This was a long-awaited feature; we are proud to announce that we officially support Let’s Encrypt wildcard certificates generation, thanks to <a href="https://github.com/nmengin" rel="noopener">Nicolas Mengin</a> (and thanks to <a href="https://github.com/xenolf" rel="noopener">xenolf</a> to the initial ACMEv2 support in <a href="https://github.com/xenolf/lego" rel="noopener">lego</a>). This greatly simplifies certificate management as it avoids generating multiple sub-domains certificates. Now, it’s possible to generate root domain certificates, which will work for every sub-domain.</p><p>Note: ACME wildcard certificates can only be generated thanks to a <code>DNS-01</code> challenge:</p><pre><code class="language-toml">[acme]
# ...
[[acme.domains]]
  main = "*.local1.com"
  sans = ["local1.com"]
[[acme.domains]]
  main = "*.local2.com"
# ...</code></pre><p>No more <a href="https://letsencrypt.org/docs/rate-limits/" rel="noopener">Let’s Encrypt rate limits</a> :)</p><h2 id="open-tracing-zipkin-support">Open Tracing &amp; Zipkin support</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-61.png" class="kg-image" alt="Traefik 1.6 — Get Our Latest tetedemoine!"/></figure><p>In microservice architectures, being able to reconstruct the elaborate journeys that transactions take as they propagate across a distributed system has become a minimum requirement for effective monitoring.</p><blockquote><em><em>OpenTracing allows developers of application code, OSS packages, and OSS services to instrument their own code without binding to any particular tracing vendor.</em></em></blockquote><p>We received a wonderful gift from <a href="https://github.com/tcolgate" rel="noopener">Tristan Colgate-McFarlane</a> (with the help of <a href="https://github.com/containous/traefik/pull/2587" rel="noopener">Michaël Matur</a>) who implemented Open Tracing support, right into Traefik. Have a look at the <a href="https://docs.traefik.io/v1.6/configuration/tracing/" rel="noopener">documentation</a> to get more details.</p><h2 id="new-web-ui">New Web UI</h2><p><a href="https://github.com/jkuri" rel="noopener">Jan Kuri</a> &amp; <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a> revamped our web UI, and we love how shiny it is. Amazing job!</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-62.png" class="kg-image" alt="Traefik 1.6 — Get Our Latest tetedemoine!"/></figure><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-63.png" class="kg-image" alt="Traefik 1.6 — Get Our Latest tetedemoine!"/></figure><h2 id="tls-certificates-in-kubernetes-secrets">TLS Certificates in Kubernetes Secrets</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-64.png" class="kg-image" alt="Traefik 1.6 — Get Our Latest tetedemoine!"/></figure><p>Another awaited feature, <a href="https://github.com/gopenguin" rel="noopener">gopenguin</a> added Kubernetes Secrets support for fetching TLS certificates. This enables Traefik to read the Kubernetes secret defined in an ingress resource <a href="https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress" rel="noopener">via the </a><code><a href="https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress" rel="noopener">tls</a></code><a href="https://docs.traefik.io/v1.6/user-guide/kubernetes/#add-a-tls-certificate-to-the-ingress" rel="noopener"> property</a>:</p><pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: traefik-web-ui
  namespace: kube-system
  annotations:
    kubernetes.io/ingress.class: traefik
spec:
  rules:
  - host: traefik-ui.minikube
    http:
      paths:
      - backend:
          serviceName: traefik-web-ui
          servicePort: 80
  tls:
   - secretName: traefik-ui-tls-cert</code></pre><h2 id="access-logs-filtering">Access Logs Filtering</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-65.png" class="kg-image" alt="Traefik 1.6 — Get Our Latest tetedemoine!"/></figure><p>With the <a href="https://en.wikipedia.org/wiki/General_Data_Protection_Regulation" rel="noopener">GDPR</a> becoming real in EU, logging and storage of (potentially) personally identifiable information now need to be reduced in many organizations.</p><p>After a <a href="https://github.com/containous/traefik/issues/2875" rel="noopener">public proposal</a>, <a href="https://github.com/containous/traefik/pull/2587" rel="noopener">Michaël Matur</a> implemented a way to filter the content of access logs based on simple rules. Your can now <code>keep</code>, <code>drop</code>or <code>redact</code>fields and headers from your access logs. Take a look at <a href="https://docs.traefik.io/v1.6/configuration/logs/#access-logs" rel="noopener">our documentation</a> to get a deeper insight.</p><h2 id="labels-homogenization">Labels Homogenization</h2><p>Probably one of the biggest refactoring of all time on Traefik, <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a> changed the way we manage labels internally, in order to homogenize labels on all providers. We now support all labels on all providers, no more specific code on this part 🎉</p><p>This will make it a lot easier to maintain, and we will be able to ship new features faster on all providers.</p><hr><p>But that’s not all, check the whole <a href="https://github.com/containous/traefik/releases/tag/v1.6.0" rel="noopener">changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we also have been working on background refactoring tasks that will help us improving Traefik in future releases.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on Github or get the official Docker image!</p><pre><code class="language-shell">docker pull traefik:v1.6.0 (or 1.6.0, v1.6, 1.6, tetedemoine)
docker pull traefik:v1.6.0-alpine (or 1.6.0-alpine, v1.6-alpine, 1.6-alpine, tetedemoine-alpine)</code></pre><p>The <em><em>versioned</em></em> documentation can be found on <a href="https://docs.traefik.io/" rel="noopener">https://docs.traefik.io</a>.</p><hr><p><strong><strong>We are hiring developers and evangelists, try to solve our puzzle:containo.us/#jobs !</strong></strong></p><p>Traefik is still growing fast, we almost passed <strong><strong>15k stars</strong></strong> on Github and <strong><strong>90M downloads</strong></strong>!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href="https://github.com/containous/traefik" rel="noopener">GitHub</a>, <a href="https://twitter.com/traefikproxy" rel="noopener">Twitter</a> or on the <a href="https://community.containo.us">Community Forum</a>!</p></hr></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Træfik Goes to KubeCon Europe 2018!]]></title><description><![CDATA[Working on an open-source project can be frustrating: we code together but barely see each other.
So, this year, we’re excited to gather the whole team at the next KubeCon Europe...]]></description><link>https://traefik.io/blog/traefik-goes-to-kubecon-europe-2018-f89a216b1d95/</link><guid isPermaLink="false">Ghost__Post__5dd7f1d5f1db6f0038c744bd</guid><category><![CDATA[Blog]]></category><category><![CDATA[Community]]></category><dc:creator><![CDATA[Gerald Croes]]></dc:creator><pubDate>Tue, 01 May 2018 14:33:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/kubecon2018.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/kubecon2018.jpeg" alt="Træfik Goes to KubeCon Europe 2018!"/><p class="post-sub-title">Along with 200 T-Shirts for you to “tweet and win”</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-full"><img src="https://containous.ghost.io/content/images/2019/12/image-16.png" class="kg-image" alt="Træfik Goes to KubeCon Europe 2018!"/></figure><p>Working on <a href="https://containous.ghost.io/traefik/">an open-source project</a> can sometimes be frustrating: we code together but barely see each other.</p><p>So, this year, we’re excited to gather the whole team at the next <a href="https://events.linuxfoundation.org/events/kubecon-cloudnativecon-europe-2018/" rel="noopener">KubeCon Europe</a>. We can’t wait to engage in long-postponed debates around our beloved product, and we’re even more eager to spread the word:</p><blockquote>Yes, Træfik is THAT good of a reverse proxy.</blockquote><p>If you will be at the conference, come to talk to us there: <a href="https://containous.ghost.io/" rel="noopener">Containous</a> has set up a booth so we can answer your questions. If you were still undecided about attending — hesitate no more :-)</p><h2 id="our-demo-a-tweet-and-win-">Our Demo? A Tweet and Win!</h2><p>To demonstrate the power of <a href="https://github.com/containous/traefik" rel="noopener">Træfik</a>, we’ll ask you to create and deploy a container … in a Kubernetes cluster … that will automatically be exposed on an HTTPS URL … personalized with your username … that could win you a T-shirt … just by writing a single Tweet! (Yes, 140 characters will be enough, you won’t even need 280 of them.)</p><p>Want to participate? Here’s how:</p><ol><li>Tweet a (nice) message with the #TraefikIsABlast hashtag</li><li>Eagerly wait for our bot’s (friendly) response</li><li>Click on the provided URL in the message (that looks like https://username.kubecon.containo.us) to see if you’ve won a T-shirt</li><li>If you’ve won, rejoice (without interrupting the current talk) and come claim your prize at our booth</li><li>(Optional) Brag about your trophy and show off</li></ol><h2 id="interested-in-the-architecture-beyond-the-demo">Interested in the Architecture beyond the Demo?</h2><p>So, what just happened?</p><p>Let’s take a look at our architecture from a distance.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-66.png" class="kg-image" alt="Træfik Goes to KubeCon Europe 2018!"/></figure><p>Beyond the specific service that scans Tweeter for new messages and deploys the matching containers in Kubernetes, Træfik already embeds the magic required to dynamically expose the result on the internet (on an HTTPS endpoint).</p><p>And if you think that Træfik needs a lot of configuration, here is the whole file that does the job:</p><pre><code class="language-yaml">defaultEntryPoints = "https"
[entryPoints]
 [entryPoints.https]
  address = ":443" # - - - - - - - - - Listens on port 443
   [entryPoints.https.tls]
    [acme] # - - - - - - - - - - - - - Certificate configuration
     email = "youraccount@domain.dne"
     storage = "/acme/acme.json"
     entryPoint = "https"
     [acme.dnsChallenge]
      provider = "cloudflare"
      delayBeforeCheck = 30
      [[acme.domains]]
       main = "*.kubecon.containo.us" # Wildcard certificate
       sans = ["kubecon.containo.us"]
   [kubernetes] # - - - - - - - - - - - Tells Træfik to listen to Kubernetes</code></pre><p>That’s it: less than 20 lines that will never be updated whether there are dozens or even hundreds (or even <em><em>thousands</em></em>!) of deployed services. Træfik will <em><em>automatically</em></em> detect changes in your Kubernetes cluster and will publish them for you, without <em><em>any</em></em> further work on your part.</p><p>Træfik is all about making your life easier, and is pretty good at its job.</p><p>Now, if you want to set up your first Træfik architecture, you might want to try out <a href="https://docs.traefik.io/">the official 5-Minute Quick Start</a>.</p><p>See you at our booth! (Or in the comments section below if you can’t be there)</p><p>PS: the demo will be online as soon as the KubeCon Key Note starts.</p><hr><p>The demo was written by <a href="https://github.com/mmatur" rel="noopener">Michael Matur</a>.</p><p>Containous is the company that helps Træfik be the successful open-source project it is.</p><p>Follow <a href="https://twitter.com/containous" rel="noopener">Containous</a> &amp; <a href="https://twitter.com/traefikproxy" rel="noopener">Træfik</a> on Twitter.</p><p><a href="https://containous.ghost.io/" rel="noopener">Visit our website</a>.</p><p>And don’t forget, you’ll always be welcome on the <a href="https://community.containo.us">Community Forum</a>.</p></hr>]]></content:encoded></item><item><title><![CDATA[Traefik — Commercial Support Is Coming!]]></title><description><![CDATA[At Containous, we’re excited to share the news — Starting today, we’ll provide commercial support for Træfik.
We’re thrilled because beyond the...]]></description><link>https://traefik.io/blog/commercial-support-is-coming-for-traefik-a28a2caf1e91/</link><guid isPermaLink="false">Ghost__Post__5dd7f2d9f1db6f0038c744d5</guid><category><![CDATA[Blog]]></category><category><![CDATA[Announcements]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Tue, 10 Apr 2018 14:38:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/commercial-support.jpeg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: html--><img src="https://containous.ghost.io/content/images/2019/11/commercial-support.jpeg" alt="Traefik — Commercial Support Is Coming!"/><p class="post-sub-title">Season 1, Episode 1</p><!--kg-card-end: html--><figure class="kg-card kg-image-card kg-width-wide"><img src="https://containous.ghost.io/content/images/2019/12/image-17.png" class="kg-image" alt="Traefik — Commercial Support Is Coming!"/></figure><p>At Containous, we’re excited to share the news — Starting today, we’ll provide commercial support for Træfik.</p><p>We’re thrilled because beyond the mere satisfaction of helping you, it means that Træfik has reached yet another level of maturity. Not only is Træfik this easy-to-set-up full-fledged incredible reverse proxy; it is now a project we deem stable enough (roadmap-wise) to assure our future customers that we’ll be able to back them up when they most need it.</p><p><strong><strong>Making sure that every professional can rely on Træfik for their infrastructure is our top priority.</strong></strong></p><p>We’ve had lots of discussions about the possible plans we could provide to companies. The SLAs, the price, the ticket system… so many parameters that have stirred the fire of passion in our geek-crowded office.</p><p>We have finally settled on a plan that will fit the needs of most companies that already trust Træfik (or are about to), and that need this supplementary insurance — Yes, our team of experts will now be available to make sure <em><em>every</em></em> edge case of your specific set-up is handled correctly.</p><p>So, what does this standard plan consist of?</p><ul><li>We will support each major version of Træfik (we use <a href="https://semver.org/" rel="noopener">semantic versioning</a>) for a whole year after the next one is released. For example, once 2.0 is released, we will continue to support 1.n for one year (n being the latest minor version in that branch).</li><li><em><em>During</em></em> a major release cycle, in addition to supporting the current version, we will support the previous one. For example, once 1.8 is released, we will continue to support 1.7 (but will stop supporting 1.6) until 1.9 or 2.0 is released.</li><li>We will start working on any question you have within 2 hours of you contacting us (business hours, CET).</li></ul><p>Now we see your question coming, “What happens to the community support?”</p><p>Our answer cannot be simpler — nothing changes.</p><blockquote>Open source drives Træfik, and we will keep doing our best to make Træfik one of the most successful open-source projects ever.</blockquote><p><strong><strong>Have we talked about the price yet?</strong></strong></p><p>Træfik‘s success is propelled by its simplicity. Simplicity means that it reaches a broad audience, from the most straightforward infrastructure to intricate clusters with multiple layers of orchestration.</p><p>Our goal with the standard plan is to be able to provide support at an affordable price so that everyone can benefit from it.</p><p>For this reason, we concurred on a price that will allow a wide range of companies to subscribe to the standard support plan (without sacrificing other investments in their program).</p><p>Starting at €1,000 per instance of Træfik, you’ll benefit from our services for a whole year.</p><p>The standard plan can go as far as five supported instances of Træfik running on your infrastructure.</p><p><strong><strong>Need more support?</strong></strong></p><p>If your business requires a customized support plan, you can contact us to discuss further how we can help.</p><hr><p>Oh … by the way … you’ll find the form to request support on <a href="https://info.containo.us/commercial-services">our new website</a>!</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-67.png" class="kg-image" alt="Traefik — Commercial Support Is Coming!"/></figure><p>Happy Træfik!</p><hr><p>Containous is the company that helps Træfik be the successful open-source project it is.</p><p>Follow <a href="https://twitter.com/containous" rel="noopener">Containous</a> &amp; <a href="https://twitter.com/traefikproxy" rel="noopener">Træfik</a> on Twitter.</p><p><a href="https://containous.ghost.io/">Visit our website.</a></p><p>Share your opinion in the comments section.</p><p>And don’t forget, you’ll always be welcome on the <a href="https://community.containo.us">Community Forum</a>!</p></hr></hr>]]></content:encoded></item><item><title><![CDATA[Traefik 1.5 — Cancoillotte Is Here!]]></title><description><![CDATA[After 3 months of development, we are thrilled to announce the fresh new release of Traefik: 1.5, codename cancoillotte.
We merged 175 pull requests from...]]></description><link>https://traefik.io/blog/traefik-1-5-cancoillotte-is-here-7bd6713ae135/</link><guid isPermaLink="false">Ghost__Post__5dd7f42ef1db6f0038c744ed</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Wed, 24 Jan 2018 14:40:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/cancoillote.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/3330/1*bLR_qbi3qufT5w0EWxVGrg.png" class="kg-image" alt="Traefik 1.5 — Cancoillotte Is Here!"><figcaption>Try to <a href="https://www.youtube.com/watch?v=kOnUeb1Ck-8" class="bf cn hz ia ib ic" target="_blank" rel="noopener" style="box-sizing: inherit; color: inherit; text-decoration: none; -webkit-tap-highlight-color: transparent; background-repeat: repeat-x; background-image: url(&quot;data:image/svg+xml;utf8,<svg preserveAspectRatio=\&quot;none\&quot; viewBox=\&quot;0 0 1 1\&quot; xmlns=\&quot;http://www.w3.org/2000/svg\&quot;><line x1=\&quot;0\&quot; y1=\&quot;0\&quot; x2=\&quot;1\&quot; y2=\&quot;1\&quot; stroke=\&quot;rgba(0, 0, 0, 0.84)\&quot; /></svg>&quot;); background-size: 1px 1px; background-position: 0px calc(1em + 1px);">pronounce it right</a> ;)</figcaption></img></figure><img src="https://containous.ghost.io/content/images/2019/12/cancoillote.png" alt="Traefik 1.5 — Cancoillotte Is Here!"/><p>After 3 months of development, we are thrilled to announce the fresh new release of Traefik: <em><em>1.5</em></em>, codename <a href="https://en.wikipedia.org/wiki/Cancoillotte" rel="noopener"><em><em>cancoillotte</em></em></a>.</p><p>We merged 175 pull requests from more than 67 contributors ! Huge thanks goes to all of you who helped on this new version 😘.</p><p>The full changelog can be found <a href="https://github.com/containous/traefik/releases/tag/v1.5.0" rel="noopener">here</a> but here are some new features we want to highlight:</p><h2 id="let-s-encrypt-http-challenge">Let’s Encrypt HTTP Challenge</h2><p>On January the 9th, a little surprise appeared on our Twitter timeline:</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://community.letsencrypt.org/t/2018-01-09-issue-with-tls-sni-01-and-shared-hosting-infrastructure/49996?source=post_page-----7bd6713ae135----------------------"><div class="kg-bookmark-content"><div class="kg-bookmark-title">2018.01.09 Issue with TLS-SNI-01 and Shared Hosting Infrastructure</div><div class="kg-bookmark-description">[Update 2018-01-18: The most up-to-date summary is at IMPORTANT: What you need to know about TLS-SNI validation issues] At approximately 5 p.m. Pacific time on January 9, 2018, we received a report from Frans Rosén of Detectify outlining a method of exploiting some shared hosting infrastructures to…</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://aws1.discourse-cdn.com/letsencrypt/optimized/3X/c/a/ca6c06ea1ea201324bba7048c6841ce60236468d_2_180x180.png" alt="Traefik 1.5 — Cancoillotte Is Here!"><span class="kg-bookmark-author">josh</span><span class="kg-bookmark-publisher">Let's Encrypt Community Support</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://aws1.discourse-cdn.com/letsencrypt/original/3X/4/c/4c5760509a18adfc3bc657ba8bd49b301faaa66b.png" alt="Traefik 1.5 — Cancoillotte Is Here!"/></div></a></figure><p>And then:</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://community.letsencrypt.org/t/2018-01-11-update-regarding-acme-tls-sni-and-shared-hosting-infrastructure/50188?source=post_page-----7bd6713ae135----------------------"><div class="kg-bookmark-content"><div class="kg-bookmark-title">2018.01.11 Update Regarding ACME TLS-SNI and Shared Hosting Infrastructure</div><div class="kg-bookmark-description">[Update 2018-01-18: The most up-to-date summary is at IMPORTANT: What you need to know about TLS-SNI validation issues] Please see this post for background information. The last 48 hours have been a busy time for Let’s Encrypt staff. We’ve been working hard to come up with a plan for ACME TLS-SNI …</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://aws1.discourse-cdn.com/letsencrypt/optimized/3X/c/a/ca6c06ea1ea201324bba7048c6841ce60236468d_2_180x180.png" alt="Traefik 1.5 — Cancoillotte Is Here!"><span class="kg-bookmark-author">josh</span><span class="kg-bookmark-publisher">Let's Encrypt Community Support</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://aws1.discourse-cdn.com/letsencrypt/original/3X/4/c/4c5760509a18adfc3bc657ba8bd49b301faaa66b.png" alt="Traefik 1.5 — Cancoillotte Is Here!"/></div></a></figure><p><strong><strong>TL;DR</strong></strong>: Let’s Encrypt permanently disabled <code>TLS-SNI-0x</code> challenge due to a vulnerability.</p><p>And yes, Traefik was using <code>TLS-SNI-01</code> challenge by default. Ouch…</p><p>Even though we were at the end of a release cycle (<em><em>1.5.0-rc4</em></em> was already out), we decided to push a new release candidate in emergency to add <code>HTTP-01</code> challenge support. This fix was big enough to end in the new <em><em>1.5</em></em> and not as a bug fix on <em><em>1.4</em></em> branch. Users will need to enable it with the new <code>acme.httpChallenge</code> section.</p><h2 id="stats-collection">Stats Collection</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-68.png" class="kg-image" alt="Traefik 1.5 — Cancoillotte Is Here!"/></figure><p>Few months ago, we created <a href="https://github.com/containous/traefik/issues/2369" rel="noopener">a proposal</a> in which we came up with the idea of collecting stats from running Traefik instances:</p><blockquote><em><em>As you may know, the Traefik core development team is quite small and as with a lot of open source projects, we lack time and resources. As a consequence, we have to carefully choose which tasks and features need our attention. As a result, we usually invest our time on features needed or requested by most of the community. In order to efficiently do this, we have to know how our community uses Traefik.</em></em></blockquote><p>As this is a super sensitive topic, we preferred to open a public debate, and build a transparent and trusted solution with the community. We are excited to say that we quickly reached a consensus, and <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a> successfully implemented a safe configuration export mechanism.</p><p><strong><strong>We chose to make it opt-in</strong></strong>, which means that no data will be sent without enabling this feature. If enabled, <strong><strong>only anonymous configuration</strong></strong> options will be sent to a collecting server.</p><p>We really hope that all of our efforts will pay off, and that you will <strong><strong>help us improve Traefik enabling this feature</strong></strong> in your infrastructure:</p><pre><code>sendAnonymousUsage = true</code></pre><p><em><em>We invite you to read </em></em><a href="https://github.com/containous/traefik/issues/2369" rel="noopener"><em><em>the constructive discussion</em></em></a><em><em> that led to this new feature and the documentation to get more details. Many thanks to the community for its positive feedback!</em></em></p><h2 id="dynamic-tls-certificates">Dynamic TLS Certificates</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-69.png" class="kg-image" alt="Traefik 1.5 — Cancoillotte Is Here!"/></figure><p><a href="https://github.com/nmengin" rel="noopener">Nicolas Mengin</a> did a great job at making TLS certificates management dynamic. You can now add or remove TLS certificates while Traefik is started! In addition to <code>backends</code> and <code>frontends</code>, there is now a dedicated <code>tls</code> section in the dynamic configuration. Let’s declare two new certificates using the file provider, you can now add a new <code>tls</code> section in your TOML:</p><pre><code class="language-toml">[frontends]
...
[backends]
...

# HTTPS certificates
[[tls]]
  entryPoints = ["https"]
  [tls.certificate]
    certFile = "path/to/my.cert"
    keyFile = "path/to/my.key"

[[tls]]
  entryPoints = ["https"]
  [tls.certificate]
  certFile = "path/to/my/other.cert"
  keyFile = "path/to/my/other.key"</code></pre><p>Each change of this file will make Traefik reload its TLS certificates. You can also split your configuration into multiple files if you prefer.</p><h2 id="rate-limiting">Rate Limiting</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-70.png" class="kg-image" alt="Traefik 1.5 — Cancoillotte Is Here!"/></figure><p>We received a wonderful gift from <a href="https://github.com/bparli" rel="noopener">Ben Parli</a> who added rate limiting by frontend. You can even add multiple sets of rates to each frontend. Here is an example taken from <a href="https://docs.traefik.io/">the documentation</a>:</p><pre><code class="language-toml">[frontends]
    [frontends.frontend1]
    entrypoints = ["http"]
    backend = "backend1"
        [frontends.frontend1.routes.test_1]
        rule = "Path:/"
    [frontends.frontend1.ratelimit]
    extractorfunc = "client.ip"
        [frontends.frontend1.ratelimit.rateset.rateset1]
        period = "10s"
        average = 100
        burst = 200
        [frontends.frontend1.ratelimit.rateset.rateset2]
        period = "3s"
        average = 5
        burst = 10</code></pre><blockquote><em><em>In the above example, <code>frontend1</code> is configured to limit requests by the client’s ip address. An average of 5 requests every 3 seconds is allowed and an average of 100 requests every 10 seconds. These can “burst” up to 10 and 200 in each period respectively.</em></em></blockquote><h2 id="azure-service-fabric-support">Azure Service Fabric Support</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-71.png" class="kg-image" alt="Traefik 1.5 — Cancoillotte Is Here!"/></figure><p><a href="https://github.com/lawrencegripper" rel="noopener">Lawrence Gripper</a> and <a href="https://github.com/jjcollinge" rel="noopener">Joni Collinge</a> from Microsoft made a great contribution (with the help of <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a>) adding <a href="https://azure.microsoft.com/en-us/services/service-fabric/" rel="noopener">Azure Service Fabric</a> support to Traefik.</p><blockquote><em><em>Azure Service Fabric is a distributed systems platform that makes it easy to package, deploy, and manage scalable and reliable microservices and containers.</em></em></blockquote><p>This new provider uses labels to configure how services are exposed through Traefik using the services <code>ServiceManifest.xml</code> file.</p><p>Have a look at <a href="https://docs.traefik.io/">the documentation</a>, we will give more update on this soon!</p><h2 id="in-a-nutshell">In A Nutshell</h2><p><a href="https://github.com/dtomcej" rel="noopener">Daniel Tomcej</a> added Kubernetes annotations and Docker labels for security headers, <a href="https://github.com/nmengin" rel="noopener">Nicolas Mengin</a> added support to etcd v3, our great <a href="https://github.com/SantoDE" rel="noopener">Manuel Zapf</a> implemented the redirection to another entryPoint per frontend.<br>Thanks to <a href="https://github.com/adityacs" rel="noopener">Aditya C S</a>, Traefik can now export its metrics to InfluxDB. <a href="https://github.com/mmatur" rel="noopener">Michael Matur</a> and <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a> did a great job adding multi-versioning to our <a href="https://docs.traefik.io/">documentation</a>. <a href="https://github.com/juliens" rel="noopener">Julien Salleyron</a> refactored the web provider into API/Dashboard, ping, metric and Rest Provider.</br></p><p>But that’s not all, check the whole <a href="https://github.com/containous/traefik/releases/tag/v1.5.0" rel="noopener">changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we also have been working on background refactoring tasks that will help us improving Traefik in future releases.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on Github or get the official Docker image!</p><pre><code class="language-shell">docker pull traefik:v1.5.0 (or 1.5.0, v1.5, 1.5, cancoillotte)
docker pull traefik:v1.5.0-alpine (or 1.5.0-alpine, v1.5-alpine, 1.5-alpine, cancoillotte-alpine)</code></pre><p>The <em><em>versioned</em></em> documentation can be found on <a href="https://docs.traefik.io/">https://docs.traefik.io</a>.</p><hr><p><strong><strong>We are hiring developers and evangelists, try to solve our puzzle: containo.us/#jobs !</strong></strong></p><p>Traefik is still growing fast, we just passed <strong><strong>12k stars</strong></strong> on Github and <strong><strong>42M downloads</strong></strong>!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href="https://github.com/containous/traefik" rel="noopener">GitHub</a>, <a href="https://twitter.com/traefikproxy" rel="noopener">Twitter</a> or on the <a href="https://community.containo.us">Community Forum</a>!</p></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Solving containous/jobs]]></title><description><![CDATA[Last year, we had this idea to create a little puzzle to hire new engineers on Traefik...]]></description><link>https://traefik.io/blog/solving-containous-jobs-b4a5cae04f3/</link><guid isPermaLink="false">Ghost__Post__5dd7f6a7f1db6f0038c74518</guid><category><![CDATA[Blog]]></category><category><![CDATA[Company]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Tue, 14 Nov 2017 14:54:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/Screenshot-2019-12-02-at-19.58.56-1.png" medium="image"/><content:encoded><![CDATA[<img src="https://containous.ghost.io/content/images/2019/12/Screenshot-2019-12-02-at-19.58.56-1.png" alt="Solving containous/jobs"/><p>Last year, we had this idea to create a little puzzle to hire new engineers on <a href="https://containous.ghost.io/traefik/">Traefik</a>.</p><figure class="kg-card kg-embed-card"><blockquote class="twitter-tweet"><p lang="en" dir="ltr">⚡️We are hiring⚡️<br>$ docker run containous/jobs</br></p>&mdash; Traefik (@traefik) <a href="https://twitter.com/traefik/status/809435733949878272?ref_src=twsrc%5Etfw">December 15, 2016</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"/>
</figure><p>As we are deeply linked to Docker on this project, we thought it would be great to focus on technical challenges around containers. So we pushed a Docker image:</p><pre><code class="language-shell">$ docker run containous/jobs
Do you like puzzles ?</code></pre><p>Few people informed us that our image must have an issue as it was only printing <em><em>Do you like puzzles ?</em></em>. Yup. That was the whole point. Something was indeed hidden here, and you had to find it 😉</p><p>Let’s jump into it!</p><p>First of all, how is made <code>containous/job</code> ?</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-72.png" class="kg-image" alt="Solving containous/jobs"/></figure><p>Not really helpful… But there seems to be two files copied during the build process. <code>docker inspect containous/jobs</code> shows that <code>/default</code> is the entrypoint. Another file should be hidden there 😃</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-73.png" class="kg-image" alt="Solving containous/jobs"/></figure><p>If we export the container file system using <code><a href="https://docs.docker.com/engine/reference/commandline/export/" rel="noopener">docker export</a></code>, we see that there is our <code>/default</code> binary, and there is also, surprisingly, another binary: <code>/secret</code>. Wow ! Let’s test something…</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-74.png" class="kg-image" alt="Solving containous/jobs"/></figure><blockquote><em><em><em>Lineception… Kill me… Just kill me…</em></em></em></blockquote><p>OK, so our container is not exiting anymore, until we press enter and then we get <em><em>Game over :’(</em></em>. Hum, not that easy 🤔</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-75.png" class="kg-image" alt="Solving containous/jobs"/></figure><blockquote><em><em><em>Kill me… Just kill me…</em></em></em></blockquote><p>If we try to kill the container, it exits, but this time, without printing <em><em>Game over :’(. </em></em>Ha ! Let’s try with another kill signals then ! After few tries, you will end up using <code>SIGABRT</code>:</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-76.png" class="kg-image" alt="Solving containous/jobs"/></figure><p>A wonderful stack trace is now on the screen. We can see that this binary has been created using go 1.7, and that the repository of the code is <code>bitbucket.org/containous/jobs.</code> Wait a minute… What ?</p><p><strong><strong>WE JUST FOUND WHERE IS HOSTED THE SOURCE CODE !!!</strong></strong></p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-77.png" class="kg-image" alt="Solving containous/jobs"/></figure><p>Damn private repository…</p><p>Let’s start from the beginning. If we look closely at each step, we used every piece of clue given by our Docker image. Except one:</p><blockquote><em><em><em>Lineception…</em></em></em></blockquote><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-78.png" class="kg-image" alt="Solving containous/jobs"/></figure><p><strong><strong>Lineception = line + inception</strong></strong></p><p>Which line of our code is called when calling kill with <code>SIGABRT</code>?</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-79.png" class="kg-image" alt="Solving containous/jobs"/></figure><pre><code>bitbucket.org/containous/jobs/cmd/secret/secret.go:15</code></pre><p>And now:</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-80.png" class="kg-image" alt="Solving containous/jobs"/></figure><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/bingo.gif" class="kg-image" alt="Solving containous/jobs"/></figure><p>And that’s it!</p><p>It seems that the final part was a bit too complex as a lot a people found alternatives solutions. Many of you discovered a base 64 encoded string right into the binary:</p><pre><code>V2VsbCBkb25lIQ0KV2Ugd291bGQgbG92ZSB0byBrbm93IG1vcmUgYWJvdXQgeW91Lg0KUGxlYXNlIHNlbmQgdXMgYSBtYWlsIGF0IGpvYnMgYXQgY29udGFpbm8udXMgYW5kIHRlbGwgdXMgaG93IHlvdSBzb2x2ZWQgdGhpcyBwdXp6bGUgYW5kIHdoeSB5b3Ugd2FudCB0byB3b3JrIGF0IENvbnRhaW5vdXMgOikNCig1MCB3b3JkcyBtYXgpDQo=</code></pre><p>And yes, once decoded, you get straight away:</p><pre><code>Well done!
We would love to know more about you.
...</code></pre><p>In fact, very few people found the right solution using the line number. I would like to congratulate <a href="https://medium.com/u/f9295502fb9b?source=post_page-----b4a5cae04f3----------------------" rel="noopener">Cédric Nisio</a> who was the first who solved this puzzle. Well done 👏👏👏</p><hr><p>We really loved to read your feedback and answers on this little game and we think it’s now time to try something new 😉</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-81.png" class="kg-image" alt="Solving containous/jobs"/></figure><blockquote>Thanks to Vincent Demeester.</blockquote></hr>]]></content:encoded></item><item><title><![CDATA[Traefik 1.4 — Roquefort Is Here, And It’s Huge!]]></title><description><![CDATA[After 4 months of intense development, we are proud to announce the fresh new release of Traefik: 1.4, codename roquefort.
This release is quite big...]]></description><link>https://traefik.io/blog/traefik-1-4-roquefort-is-here-and-its-huge-c26654aba80f/</link><guid isPermaLink="false">Ghost__Post__5dd7f800f1db6f0038c74558</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Tue, 17 Oct 2017 15:00:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/rokefort.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/7366/1*2NS3OACEy6JsCzcK8EVwDw.png" class="kg-image" alt="Traefik 1.4 — Roquefort Is Here, And It’s Huge!"><figcaption>Rock Fort…</figcaption></img></figure><img src="https://containous.ghost.io/content/images/2019/12/rokefort.png" alt="Traefik 1.4 — Roquefort Is Here, And It’s Huge!"/><p>After 4 months of intense development, we are proud to announce the fresh new release of Traefik: <em><em>1.4</em></em>, codename <a href="https://en.wikipedia.org/wiki/Roquefort" rel="noopener"><em><em>roquefort</em></em></a><em><em>.</em></em></p><p>This release is quite big: we merged <a href="https://github.com/containous/traefik/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20milestone%3A1.4%20is%3Amerged" rel="noopener">250</a> pull requests from more than 60 contributors ! Huge thanks goes to all of you who helped on this new version 😘.</p><p>The full changelog can be found <a href="https://github.com/containous/traefik/releases/tag/v1.4.0" rel="noopener">here</a> but here are some new features we want to highlight:</p><h2 id="custom-headers-security">Custom Headers &amp; Security</h2><p>Our awesome <a href="https://github.com/dtomcej" rel="noopener">Daniel Tomcej</a> did some hard work on headers. We now have a way to customize headers:</p><blockquote><em><em>Custom headers can be configured through the frontends, to add headers to either requests or responses that match the frontend’s rules. This allows for setting headers such as <code>X-Script-Name</code> to be added to the request, or custom headers to be added to the response.</em></em></blockquote><p>If that was not enough, Daniel added security options on headers:</p><blockquote><em><em>Security related headers (HSTS headers, SSL redirection, Browser XSS filter, etc) can be added and configured per frontend in a similar manner to the custom headers above. This functionality allows for some easy security features to quickly be set.</em></em></blockquote><h2 id="multi-arch">Multi arch</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-82.png" class="kg-image" alt="Traefik 1.4 — Roquefort Is Here, And It’s Huge!"/></figure><p>Thanks to <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a>, <a href="https://github.com/docker-library/official-images/blob/master/library/traefik" rel="noopener">we now provide</a> the official Docker image on multiple architectures: <em><em>amd64</em></em>, <em><em>arm64v8</em></em>, <em><em>arm32v6</em></em>. The best part is that as of mid-September, Docker supports transparent multi-arch on official images. This allows to use <code>docker run traefik</code> transparently either on a <em><em>amd64 </em></em>or a<em><em> arm64v8 </em></em>Docker daemon. We plan to add a Windows based official image in the future.</p><h2 id="authentication-forward">Authentication Forward</h2><p>As a first step to <a href="https://github.com/containous/traefik/issues/593" rel="noopener">a generic authentication mechanism</a>, <a href="https://github.com/drampelt" rel="noopener">Daniel Rampelt</a> followed by <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a>, added a way to forward authentication to a delegate server. Have a look at <a href="https://github.com/containous/traefik/pull/1972" rel="noopener">both</a> <a href="https://github.com/containous/traefik/pull/2132" rel="noopener">PRs</a> to get more details on this.</p><h2 id="proxy-protocol">Proxy Protocol</h2><p>Traefik is often used behind another load-balancer like an <a href="https://aws.amazon.com/elasticloadbalancing" rel="noopener">ELB</a>. In this case, Traefik now supports Proxy Protocol, that allows to keep client information between the chain of proxies. Have a look at <a href="https://docs.traefik.io/">the documentation</a> to learn how to enable and configure safely this feature.</p><h2 id="custom-error-pages">Custom Error Pages</h2><p><a href="https://github.com/bparli" rel="noopener">Ben Parli</a> did some great job on adding custom error pages support into Traefik. But instead of rendering html pages, we decided to delegate this task to a backend server. You can now configure Traefik to get error pages from another server, using this syntax:</p><pre><code class="language-toml">[frontends]
  [frontends.website]
  backend = "website"
  [frontends.website.errors]
    [frontends.website.errors.network]
    status = ["500-599"]
    backend = "error"
    query = "/{status}.html"
  [frontends.website.routes.website]
  rule = "Host: website.mydomain.com"

[backends]
  [backends.website]
    [backends.website.servers.website]
    url = "https://1.2.3.4"
  [backends.error]
    [backends.error.servers.error]
    url = "http://2.3.4.5"</code></pre><p>In this example, if you hit a 502 error, Traefik will ask to the backend server <code>http://2.3.4.5 </code>for the page <code>502.html</code>.</p><h2 id="datadog-statd-metrics-export">Datadog, Statd metrics export</h2><p><a href="https://github.com/aantono" rel="noopener">Alex Antonov</a> completed the existing Prometheus metrics export with two famous monitoring services: Datadog and Statd. This allows to easily export internal Traefik metrics to monitoring systems and get <a href="https://grafana.com/dashboards/2240" rel="noopener">Grafana dashboards</a> of your running instances.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-83.png" class="kg-image" alt="Traefik 1.4 — Roquefort Is Here, And It’s Huge!"/></figure><h2 id="in-a-nutshell">In A Nutshell</h2><p><a href="https://github.com/juliens" rel="noopener">Julien Salleyron</a> added <a href="https://grpc.io/" rel="noopener">GRPC</a> support and made a <a href="https://docs.traefik.io/">great user guide</a> on this.<br>We now allow to customize cookie names thanks to <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a>, see the documentation <a href="https://docs.traefik.io/routing/services/">here</a>.<br><a href="https://github.com/drewwells" rel="noopener">Drew Wells</a> added the option <code>passTLSCert</code>to forward TLS Client certificates to the backend.<br>The documentation website <a href="https://docs.traefik.io/">https://docs.traefik.io</a> has been revamped by <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a>.</br></br></br></p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-84.png" class="kg-image" alt="Traefik 1.4 — Roquefort Is Here, And It’s Huge!"/></figure><p>But that’s not all, check the <a href="https://github.com/containous/traefik/releases/tag/v1.4.0" rel="noopener">whole changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we also have been working on <a href="https://github.com/containous/gallienii" rel="noopener">creating</a> <a href="https://github.com/containous/lobicornis" rel="noopener">awesome</a> <a href="https://github.com/containous/bibikoffi" rel="noopener">bots</a> <a href="https://github.com/containous/aloba" rel="noopener">that</a> <a href="https://github.com/traefiker" rel="noopener">do</a> great things for us.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on <a href="https://github.com/containous/traefik/releases/tag/v1.2.0" rel="noopener">Github</a> or get the <a href="https://hub.docker.com/_/traefik/" rel="noopener">official Docker image</a>!</p><pre><code class="language-shell">docker pull traefik:v1.4.0 (or 1.4.0, v1.4, 1.4, roquefort)
docker pull traefik:v1.4.0-alpine (or 1.4.0-alpine, v1.4-alpine, 1.4-alpine, roquefort-alpine)</code></pre><p>The documentation can be found on <a href="https://docs.traefik.io/">https://docs.traefik.io</a>.</p><hr><p>We are thrilled to welcome <a href="https://github.com/mmatur" rel="noopener">Michael Matur</a> who joined <a href="https://containous.ghost.io/" rel="noopener">Containous</a> and <a href="https://github.com/marco-jantke" rel="noopener">Marco Jantke</a> who joined the maintainers team 👋 ! <strong><strong>We are hiring developers and evangelists: containo.us/#jobs !</strong></strong></p><p>Traefik is still growing fast, we just passed <a href="https://github.com/containous/traefik/stargazers" rel="noopener">10k stars</a> on Github and 22M downloads!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href="https://github.com/containous/traefik" rel="noopener">GitHub</a>, <a href="https://twitter.com/traefikproxy" rel="noopener">Twitter</a> or on the <a href="https://community.containo.us">Community Forum</a>!</p></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Traefik 1.3 — Get Some More Raclette !]]></title><description><![CDATA[We released Traefik 1.2 only two months ago, and we are proud to announce that the fresh new Traefik 1.3, codename raclette is out!
As Traefik is getting bigger and bigger...]]></description><link>https://traefik.io/blog/traefik-1-3-get-some-more-raclette-1046664d862b/</link><guid isPermaLink="false">Ghost__Post__5dd7f8d2f1db6f0038c74576</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Thu, 01 Jun 2017 15:03:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/raclette.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://miro.medium.com/max/1222/1*iPjSJPBOsZGGmuijQSQOrw.png" class="kg-image" alt="Traefik 1.3 — Get Some More Raclette !"/></figure><img src="https://containous.ghost.io/content/images/2019/12/raclette.png" alt="Traefik 1.3 — Get Some More Raclette !"/><p>We released Traefik <em><em>1.2</em></em> only <a href="https://containous.ghost.io/blog/traefik-1-2-morbier-is-out-8bc304a66ef3/">two months ago</a>, and we are proud to announce that the fresh new Traefik <em><em>1.3</em></em>, codename <a href="https://en.wikipedia.org/wiki/Raclette" rel="noopener"><em><em>raclette</em></em></a> is out!</p><p>As Traefik is getting bigger and bigger, we decided to accelerate things and to release more often. From a 4 months release cycle, you will now have to wait only 2 months between each release.</p><p>The full changelog can be found <a href="https://github.com/containous/traefik/releases/tag/v1.3.0" rel="noopener">here</a> but here are some new features we want to highlight:</p><h2 id="multiple-rules-by-container">Multiple Rules by Container</h2><p>Thanks to <a href="https://github.com/benoitf" rel="noopener">Florent Benoit</a>, Traefik can now manage multiple rules by container, <a href="https://github.com/containous/traefik/pull/1257" rel="noopener">introducing service labels</a>. You can now easily forward multiple ports from a same container :) Here are all available labels:</p><pre><code>traefik.&lt;service-name&gt;.port
traefik.&lt;service-name&gt;.weight
traefik.&lt;service-name&gt;.protocol
traefik.&lt;service-name&gt;.frontend.backend
traefik.&lt;service-name&gt;.frontend.entryPoints
traefik.&lt;service-name&gt;.frontend.rule
traefik.&lt;service-name&gt;.frontend.passHostHeader
traefik.&lt;service-name&gt;.frontend.priority
traefik.&lt;service-name&gt;.frontend.rule</code></pre><h2 id="amazon-dynamodb-support">Amazon DynamoDB support</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-85.png" class="kg-image" alt="Traefik 1.3 — Get Some More Raclette !"/></figure><p><a href="https://github.com/tskinn" rel="noopener">Tskinn</a> made a great job on <a href="https://github.com/containous/traefik/pull/1158" rel="noopener">integrating</a> Traefik with <a href="https://aws.amazon.com/fr/dynamodb/" rel="noopener">Amazon DynamoDB</a>, a flexible NoSQL database service. You can now push your configuration (frontends and backends) into this database and Traefik will watch any changes dynamically.</p><h2 id="basic-authentication-per-frontend">Basic Authentication per Frontend</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-86.png" class="kg-image" alt="Traefik 1.3 — Get Some More Raclette !"/></figure><p>Another awaited feature, <a href="https://github.com/santode" rel="noopener">Manuel Laufenberg</a> added <a href="https://github.com/containous/traefik/pull/1147" rel="noopener">basic authentication per frontend</a> configuration (it was only globally configurable initially). Currently, Docker and Rancher backends are supported, more will be added in the future!</p><h2 id="dashboard-filter">Dashboard Filter</h2><p><a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a> added <a href="https://github.com/containous/traefik/pull/1437" rel="noopener">a nice little feature</a> in the webui: you now can filter frontends and backends. When you have a big configuration with many routes, it’s really handy to be able to quickly find what you want.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-87.png" class="kg-image" alt="Traefik 1.3 — Get Some More Raclette !"/></figure><p>But that’s not all, check the <a href="https://github.com/containous/traefik/releases/tag/v1.3.0" rel="noopener">whole changelog</a> to get an idea of the awesome work that has been done on this release. Lots of bugs have been fixed and we have begun a strong background work on our CI infrastructure and project quality in general.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on <a href="https://github.com/containous/traefik/releases/tag/v1.2.0" rel="noopener">Github</a> or get the <a href="https://hub.docker.com/_/traefik/" rel="noopener">official Docker image</a>!</p><pre><code class="language-shell">docker pull traefik:v1.3.0 (or 1.3.0, v1.3, 1.3, raclette)
docker pull traefik:v1.3.0-alpine (or 1.3.0-alpine, v1.3-alpine, 1.3-alpine, raclette-alpine)</code></pre><p>The documentation can be found on <a href="https://docs.traefik.io/" rel="noopener">https://docs.traefik.io</a>.</p><hr><p>Following our <a href="https://containous.ghost.io/blog/containous-raises-1-million-in-seed-round-funding-to-develop-traefik-f8238f47d2c7/">$1M seed</a>, 4 new developers joined <a href="https://containous.ghost.io/" rel="noopener">Containous</a> and are now part of the maintainers team. We are thrilled to welcome <a href="https://github.com/ldez" rel="noopener">Ludovic Fernandez</a>, <a href="https://github.com/atbore-phx" rel="noopener">Attilio Borello</a>, <a href="https://github.com/Juliens" rel="noopener">Julien Salleyron</a> and <a href="https://github.com/nmengin" rel="noopener">Nicolas Mengin</a> 👋 !</p><p>Traefik is still growing fast, we just passed <a href="https://github.com/containous/traefik/stargazers" rel="noopener">8k stars</a> on Github and 7M downloads!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href="https://github.com/containous/traefik" rel="noopener">GitHub</a>, <a href="https://twitter.com/traefikproxy" rel="noopener">Twitter</a> or on the <a href="https://community.containo.us">Community Forum</a>!</p></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Traefik 1.2 Morbier is out!]]></title><description><![CDATA[After 4 months of hard work, we are proud to announce a new release of Traefik: version 1.2.0, codename Morbier. The full changelog can be found...]]></description><link>https://traefik.io/blog/traefik-1-2-morbier-is-out-8bc304a66ef3/</link><guid isPermaLink="false">Ghost__Post__5dd7faaef1db6f0038c74593</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Wed, 22 Mar 2017 15:11:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/11/morbier.png" medium="image"/><content:encoded><![CDATA[<img src="https://containous.ghost.io/content/images/2019/11/morbier.png" alt="Traefik 1.2 Morbier is out!"/><p>After 4 months of hard work, we are proud to announce a new release of Traefik: version <em><em>1.2.0</em></em>, codename <a href="https://en.wikipedia.org/wiki/Morbier_cheese" rel="noopener"><em><em>Morbier</em></em></a>.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-88.png" class="kg-image" alt="Traefik 1.2 Morbier is out!"/></figure><p>The full changelog can be found <a href="https://github.com/containous/traefik/releases/tag/v1.2.0" rel="noopener">here</a> but here are some new features we want to highlight:</p><h2 id="amazon-ec2-container-service">Amazon EC2 Container Service</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-89.png" class="kg-image" alt="Traefik 1.2 Morbier is out!"/></figure><p>Thanks to <a href="https://github.com/lpetre" rel="noopener">Luke Petre</a>, Traefik now supports <a href="https://aws.amazon.com/fr/ecs" rel="noopener">Amazon EC2 Container Service</a>. This is a great news for AWS fans who need more than an ELB/ALB to manage their inbound traffic.</p><h2 id="rancher">Rancher</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-90.png" class="kg-image" alt="Traefik 1.2 Morbier is out!"/></figure><p>Finally, Traefik gets native Rancher support! Thank you <a href="https://github.com/santode" rel="noopener">Manuel Laufenberg</a>! It is now a lot simpler to have a specific configuration backend right into Traefik.</p><h2 id="prometheus">Prometheus</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-91.png" class="kg-image" alt="Traefik 1.2 Morbier is out!"/></figure><p>A lot of people were waiting for it, thanks to <a href="https://github.com/enxebre" rel="noopener">Alberto Garcial</a>, native Prometheus support is now real :) This allows you to export internal metrics to Prometheus using a simple flag <code>—web.metrics.prometheus</code>. More internal metrics will be added soon!</p><h2 id="netflix-eureka">Netflix Eureka</h2><p><a href="https://github.com/Netflix/eureka" rel="noopener">Eureka</a> is the service registry taken from the Netflix OSS stack. Traefik now supports Eureka as a configuration backend thanks to <a href="https://github.com/Juliens" rel="noopener">Julien Salleyron</a>!</p><h2 id="healthchecks">Healthchecks</h2><p>Another long awaited feature, healthchecks are here! Again, thanks to <a href="https://github.com/Juliens" rel="noopener">Julien Salleyron</a>. A health check can be configured in order to remove a backend from LB rotation as long as it keeps returning HTTP status codes other than 200 OK.</p><hr><p>Grab the latest binary for Linux, Windows, Mac on <a href="https://github.com/containous/traefik/releases/tag/v1.2.0" rel="noopener">Github</a> or get the <a href="https://hub.docker.com/_/traefik/" rel="noopener">official Docker image</a>!</p><pre><code class="language-shell">docker pull traefik:v1.2.0
docker pull traefik:morbier
docker pull traefik:v1.2.0-alpine
docker pull traefik:morbier-alpine</code></pre><p>The documentation can be found on <a href="https://docs.traefik.io/" rel="noopener">https://docs.traefik.io</a>.</p><hr><p>In case you missed it, we <a href="https://containous.ghost.io/blog/containous-raises-1-million-in-seed-round-funding-to-develop-traefik-f8238f47d2c7/">just raised $1M</a> :) You can expect a lot of new features in the coming months, as well as <a href="https://github.com/containous/traefik/issues/1266" rel="noopener">background work</a>. Of course, all this will be done involving the community as much as possible.</p><p>Traefik is still growing fast, we just passed <a href="https://github.com/containous/traefik/stargazers" rel="noopener">7k stars on Github</a> and 3.5M downloads! The maintainer team gains 2 more maintainers, <a href="https://github.com/trecloux" rel="noopener">Thomas Recloux</a> &amp; <a href="https://github.com/timoreimann" rel="noopener">Timo Reimann</a> 👋!</p><hr><p>We would love to hear your feedback on this new release. Join us on <a href="https://github.com/containous/traefik" rel="noopener">GitHub</a>, <a href="https://twitter.com/traefikproxy" rel="noopener">Twitter</a> or on the <a href="https://community.containo.us">Community Forum</a>!</p></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Containous Raises €1 Million in Seed Round Funding to Develop Traefik]]></title><description><![CDATA[We are proud to announce the closing of €1 million in seed round led by Elaia Partners, 360 Capital Partners and...]]></description><link>https://traefik.io/blog/containous-raises-1-million-in-seed-round-funding-to-develop-traefik-f8238f47d2c7/</link><guid isPermaLink="false">Ghost__Post__5dd7fb33f1db6f0038c745aa</guid><category><![CDATA[Blog]]></category><category><![CDATA[Announcements]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Mon, 20 Feb 2017 15:13:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/Screenshot-2019-12-02-at-20.04.39.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-width-wide kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/12/money.gif" class="kg-image" alt="Containous Raises €1 Million in Seed Round Funding to Develop Traefik"><figcaption>Our CEO, at office headquarters after the closing</figcaption></img></figure><img src="https://containous.ghost.io/content/images/2019/12/Screenshot-2019-12-02-at-20.04.39.png" alt="Containous Raises €1 Million in Seed Round Funding to Develop Traefik"/><p>We are proud to announce the closing of €1 million in seed round led by <a href="https://www.elaia.com/">Elaia Partners</a>, <a href="https://www.360cap.vc/">360 Capital Partners</a> and <a href="https://www.kimaventures.com/">Kima Ventures</a>!</p><p>Based in Lyon, France, Containous is building <a href="https://containous.ghost.io/traefik/">Traefik</a>, the next generation reverse-proxy &amp; load-balancer made to deploy microservices with ease. In 2016, Traefik has reached more than <a href="https://github.com/containous/traefik/stargazers" rel="noopener"><strong><strong>6.500 stars on Github</strong></strong></a> and has been downloaded more than <strong><strong>3M times</strong></strong>.</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-92.png" class="kg-image" alt="Containous Raises €1 Million in Seed Round Funding to Develop Traefik"/></figure><p>With the help of our investors, our main vision is to release new cheeses more and more often. We already bought a new factory that will double our production capacity. After Traefik 1.0 <em><em>reblochon</em></em> and 1.1 <em><em>camembert </em></em>in 2016, you can expect a lot more in the future!</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-93.png" class="kg-image" alt="Containous Raises €1 Million in Seed Round Funding to Develop Traefik"><figcaption>Our release manager inspecting our main cluster</figcaption></img></figure><blockquote><em><em>We believe this successful financing round does not only provide us with capital, but also with stellar partners that can help us take load-balancing to the next level. — VP Product &amp; Sales</em></em></blockquote><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/round.gif" class="kg-image" alt="Containous Raises €1 Million in Seed Round Funding to Develop Traefik"><figcaption>VP Product &amp; Sales</figcaption></img></figure><p>Stay tuned for more announcements ;)</p>]]></content:encoded></item><item><title><![CDATA[Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!]]></title><description><![CDATA[After 4 months of development, we are proud to announce the second release of Traefik: version 1.1.0, codename camembert.
The full changelog is quite huge...]]></description><link>https://traefik.io/blog/introducing-distributed-cheese-traefik-1-1-camembert-is-out-fb19e05a48c8/</link><guid isPermaLink="false">Ghost__Post__5dd7fc02f1db6f0038c745cc</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Tue, 22 Nov 2016 15:17:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/camembert.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://miro.medium.com/max/1054/1*b8EYMGIKAOiTn_Gteyn28g.png" class="kg-image" alt="Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!"><figcaption><a href="https://en.wikipedia.org/wiki/Camembert" class="bf cn hw hx hy hz" target="_blank" rel="noopener" style="box-sizing: inherit; color: inherit; text-decoration: none; -webkit-tap-highlight-color: transparent; background-repeat: repeat-x; background-image: url(&quot;data:image/svg+xml;utf8,<svg preserveAspectRatio=\&quot;none\&quot; viewBox=\&quot;0 0 1 1\&quot; xmlns=\&quot;http://www.w3.org/2000/svg\&quot;><line x1=\&quot;0\&quot; y1=\&quot;0\&quot; x2=\&quot;1\&quot; y2=\&quot;1\&quot; stroke=\&quot;rgba(0, 0, 0, 0.84)\&quot; /></svg>&quot;); background-size: 1px 1px; background-position: 0px calc(1em + 1px);">Camembert</a> cheese</figcaption></img></figure><img src="https://containous.ghost.io/content/images/2019/12/camembert.png" alt="Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!"/><p>After 4 months of development, we are proud to announce the second release of <a href="https://containous.ghost.io/traefik/">Traefik</a>: version <em><em>1.1.0</em></em>, codename <a href="https://en.wikipedia.org/wiki/Camembert" rel="noopener"><em><em>camembert</em></em></a>.</p><p>The full changelog is <a href="https://github.com/containous/traefik/releases/tag/v1.1.0" rel="noopener">quite huge</a> but here are some new features we want to highlight:</p><h2 id="swarm-mode-support">Swarm mode support</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-94.png" class="kg-image" alt="Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!"/></figure><p>In v1.12, Docker introduced <a href="https://docs.docker.com/engine/swarm/" rel="noopener">swarm mode</a>, for natively managing a cluster of Docker engines. Traefik is now able to connect to a swarm manager and will discover all services deployed on the swarm. Thank you <a href="https://github.com/diegofernandes" rel="noopener">diegofernandes</a> for your work :)</p><h2 id="constraints">Constraints</h2><p><a href="https://github.com/samber" rel="noopener">samber</a> initiated the addition of constraints, that limits Traefik scope to a smaller number of routes. It allows to easily deploy multiple instances with specific roles.<br>Let’s give an example and add this line to our TOML configurations:</br></p><pre><code class="language-toml"># traefik instance 1
constraints = [“tag==eu-*”, “tag==asia-*”]

# traefik instance 2
constraints = [“tag==us-*”]</code></pre><p>The instance 1 will now route services tagged with <em><em>eu-*</em></em> or <em><em>asia-*</em></em> (i.e. <em><em>eu-backend</em></em>, <em><em>eu-frontend</em></em>, <em><em>asia-data</em></em>…) and the instance 2, services tagged with <em><em>us-*</em></em>.<br>You can use Docker labels, Marathon labels or Consul Catalog tags to tag your services. For example, let’s deploy a new Docker application and tag it:</br></p><pre><code class="language-shell">docker run -d -l traefik.tags=eu-frontend emilevauge/whoami
</code></pre><p>This application will be taken into account by traefik instance 1 and ignored by instance 2.</p><h2 id="mesos-backend">Mesos backend</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-95.png" class="kg-image" alt="Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!"/></figure><p><a href="https://github.com/PierreLeresteux" rel="noopener">PierreLeresteux</a> &amp; <a href="https://github.com/skydjol" rel="noopener">skydjol</a> made a great pull request adding universal Mesos support to Traefik. In addition to <a href="https://mesosphere.github.io/marathon/" rel="noopener">Marathon</a>, Traefik can now be used with any Mesos framework (i.e. Chronos, Aurora, custom…). And yeah, the <em><em>v1.1</em></em> codename is <em><em>camembert</em></em> because of those <a href="https://en.wikipedia.org/wiki/Normans" rel="noopener">Normans</a> guys!</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://containous.ghost.io/content/images/2019/11/image-96.png" class="kg-image" alt="Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!"><figcaption>Why not <a href="https://github.com/containous/traefik/pull/353#issuecomment-233914436" rel="noopener">Saint-Nectaire</a>?</figcaption></img></figure><h2 id="session-affinity">Session affinity</h2><p><a href="https://github.com/containous/traefik/issues/5#issue-107706542" rel="noopener">Long awaited</a> sticky sessions are now supported thanks to <a href="https://github.com/owen" rel="noopener">owen</a>! <a href="https://12factor.net/processes" rel="noopener">Use them with caution</a> ;)</p><h2 id="cluster-mode-experimental-">Cluster mode (experimental)</h2><p>Traefik now has a cluster mode, which allows to deploy multiple instances sharing the same configuration. To do that without copying the same configuration file on each instance, Traefik uses a distributed Key-Value store (Etcd, Consul supported). What is great with <em><em>cluster mode</em></em> is that it works with Let’s Encrypt, using the Key-Value database to store the TLS certificates. <a href="https://docs.traefik.io/">Cluster mode</a> is available in this release as an experimental feature.</p><h2 id="official-alpine-image">Official Alpine image</h2><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-97.png" class="kg-image" alt="Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!"/></figure><p>In addition to the official “from scratch” Docker image, there is now an official Alpine image tagged <em><em>v1.1.0-alpine, camembert-alpine. </em></em>This can be useful to get a shell access to a Traefik container for debugging purpose.</p><h2 id="experimental-builds">Experimental builds</h2><p>For those who want to test bleeding edge features, we introduced experimental builds. Each time a pull request is merged into master branch, a docker image will be pushed at:</p><pre><code>containous/traefik:experimental</code></pre><p>A specific PR image will also be pushed at:</p><pre><code>containous/traefik:pr-#</code></pre><hr><p>Grab the latest binary for Linux, Windows, Mac on <a href="https://github.com/containous/traefik/releases/tag/v1.1.0" rel="noopener">Github</a> or get the <a href="https://hub.docker.com/_/traefik/" rel="noopener">official Docker image</a>!</p><pre><code>docker pull traefik:v1.1.0
docker pull traefik:v1.1.0-alpine
docker pull traefik:camembert
docker pull traefik:camembert-alpine</code></pre><p>The documentation can be found on <a href="https://docs.traefik.io/">http://docs.traefik.io</a>.</p><hr><p>Finally, we are very pleased to announce that <a href="https://github.com/dtomcej" rel="noopener">dtomcej</a> and <a href="https://github.com/SantoDE" rel="noopener">SantoDE</a> just joined the maintainers team. Welcome on board!</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-98.png" class="kg-image" alt="Introducing Distributed Cheese: Traefik 1.1 Camembert Is Out!"/></figure><hr><p>We would love to hear your feedback on this new release. Join us on <a href="https://github.com/containous/traefik" rel="noopener">GitHub</a>, <a href="https://twitter.com/traefikproxy" rel="noopener">Twitter</a> or on the <a href="https://community.containo.us">Community Forum</a>!</p><hr><p><strong><strong>Edit 12/29/2016:</strong></strong><br>We just pushed the first bug-fix release <em><em>v1.1.1</em></em> which deals with Kubernetes and Swarm connection issues. The full changelog can be found <a href="https://github.com/containous/traefik/releases/tag/v1.1.1" rel="noopener">here</a>.</br></p></hr></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Golang Configuration Made Easy With Flæg And Stært]]></title><description><![CDATA[There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files...]]></description><link>https://traefik.io/blog/golang-configuration-made-easy-with-flaeg-and-staert-2818921e78e/</link><guid isPermaLink="false">Ghost__Post__5dd7fce3f1db6f0038c745f2</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Traefik Labs]]></dc:creator><pubDate>Thu, 04 Aug 2016 15:21:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/flaeg.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://miro.medium.com/max/1420/0*ABKj5V2gw7tezUc5." class="kg-image" alt="Golang Configuration Made Easy With Flæg And Stært"/></figure><img src="https://containous.ghost.io/content/images/2019/12/flaeg.png" alt="Golang Configuration Made Easy With Flæg And Stært"/><p>There are many ways to provide a configuration to a program. Some use Command Line Interfaces, others use configuration files. Any setting changes can require a refactor on many lines of code. The configuration loading process have to be very robust. If not, programs could not work as we expected. Unfortunately <a href="https://golang.org/" rel="noopener">golang</a> programs are no exception. For instance, adding a new argument in a CLI requires to create a flag, to parse data, to deal with the help section, to manage default values and to affect the collected value into the configuration structure.</p><p>Close your eyes and imagine a library able to automatically manage all this configuration process for you. You can open them because we did it :)</p><hr><h2 id="fl-g">Flæg</h2><p><a href="https://github.com/containous/flaeg/" rel="noopener">Flæg</a> is a Go package for building dynamically a powerful modern Command Line Interface and loading a program configuration structure from arguments. Go developers don’t need to worry about keeping flags and commands updated anymore : it works by itself !</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-99.png" class="kg-image" alt="Golang Configuration Made Easy With Flæg And Stært"/></figure><p>Flæg package was born from the need of <a href="https://containous.ghost.io/traefik/">Træfik</a>, the famous reverse proxy created by <a href="https://github.com/emilevauge" rel="noopener">Emile Vauge</a>. It was more and more difficult to maintain the list of `flags`: parameters passed in argument which drive the program.</p><p>Thanks to <a href="https://github.com/containous/flaeg/" rel="noopener">Flæg</a>, the maintenance became a thing of the past. The `flags` are auto generated from the field names of the configuration structure. To do that, developers just have to add a <a href="https://golang.org/pkg/reflect/#StructTag" rel="noopener">StructTag</a> following the field to create a flag on it. The helper (i.e. what is displayed with <em><em>-help</em></em> argument) is generated from the key `description` in the <a href="https://golang.org/pkg/reflect/#StructTag" rel="noopener">StructTag</a></p><p>Here an example of a complex configuration with <a href="https://golang.org/pkg/reflect/#StructTag" rel="noopener">StructTag</a> that Flæg can process:</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/bbd5672a81175e07492c6c9e7b43aba7"><div class="kg-bookmark-content"><div class="kg-bookmark-title">flaegdemo.config.go</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p><a href="https://github.com/containous/flaeg/" rel="noopener">Flæg</a> is able to load the argument values ​​given in the configuration structure through <a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" rel="noopener">reflection</a>. The package supports most of field types, but no collections. Hopefully users can add a custom parser on specific types as collections or even whole structures.</p><p>Let’s see how simple it is to use Flæg.</p><p>First we will create a trivial command which do nothing but print the configuration:</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/600d3491c9f005195c3c8bc9234dfc99"><div class="kg-bookmark-content"><div class="kg-bookmark-title">Golang Configuration Made Easy With Flæg And Stært</div><div class="kg-bookmark-description">Golang Configuration Made Easy With Flæg And Stært - flaegdemo.cmd.go</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p>Then, we only have to create a Flæg object and call the function Run :</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/69620f12c8fad0953269df5edb3bb58d"><div class="kg-bookmark-content"><div class="kg-bookmark-title">flaegdemo.use.go</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p>Let’s try this program. We will first call the helper :</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/b8cb3e8f78d1661eefd0f48f46e38e65"><div class="kg-bookmark-content"><div class="kg-bookmark-title">flaegdemo.help.sh</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p>As you can see, the generated flags match the fields of the configuration structure with substructures `DatabaseInfo` and `OwnerInfo`. Default values ​​can be defined directly in the fields of the configuration structure. These fields will be unchanged if their `flags` are not used in argument.</p><p>Then, we can try the program:</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/090406f9f88d59d89e7dd0f09edcd8eb"><div class="kg-bookmark-content"><div class="kg-bookmark-title">flaegdemo.try.sh</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p>Flæg also handles sub-command, like the “version” command in the example :</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/2a88cf1605f3d4187c15e129d8b58a1d"><div class="kg-bookmark-content"><div class="kg-bookmark-title">flaegdemo.sub.cmd.go</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/5112adbf0f83027dc0fb7e30bd5cea80"><div class="kg-bookmark-content"><div class="kg-bookmark-title">flaegdemo.version.try.sh</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p>To learn much more about Flæg, please visit the github project page <a href="https://github.com/containous/flaeg" rel="noopener">https://github.com/containous/flaeg</a>.</p><p>Thanks to Flæg, we have a nice solution to load the configuration from the flags. The maintenance is now way simpler than it used to be, which is appreciated on open source projects. But how can we manage merging this CLI configuration with other sources like configuration files ?</p><hr><h2 id="st-rt">Stært</h2><p>The CLI is not the only way to provide configuration to a program. There are other sources of configuration. For instance, Træfik can take a configuration from flags, from a config file and from a distributed Key-Value Store.</p><p>We created <a href="https://github.com/containous/staert/" rel="noopener">Stært</a> to merge those configuration sources. So far, only flags (using <a href="https://github.com/containous/flaeg/" rel="noopener">Flæg</a>), TOML config file and <a href="https://github.com/containous/staert#kvstore" rel="noopener">Key-Value Stored</a> configuration are implemented, but we did the package in such way that it is easy to add other sources.</p><p>Stært uses the same <a href="https://github.com/containous/staert#the-command" rel="noopener">Command type</a> as <a href="https://github.com/containous/flaeg" rel="noopener">Flæg</a>.</p><p>We just have to <a href="https://github.com/containous/staert#use-st%C3%A6rt-with-sources" rel="noopener">create some sources</a> :</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/d8f1742a119e5f0069790f4fbf230d59"><div class="kg-bookmark-content"><div class="kg-bookmark-title">staertdemo.create.sources.go</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p>Then, we can create a <a href="https://github.com/containous/staert" rel="noopener">Stært</a> object and use it :</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/6742ba6bf48d82b62feae2c6c8f2af4c"><div class="kg-bookmark-content"><div class="kg-bookmark-title">staertdemo.use.go</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p>Stært will load the configuration in the row and overwrite it following precedence order :</p><ul><li>Key-Value Store source</li><li>Flæg source</li><li>TOML config file source</li></ul><p>Here an example of TOML file :</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/6273109426155223099407cd9a2624cc"><div class="kg-bookmark-content"><div class="kg-bookmark-title">staertdemo.try.toml</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p>And there is the way to store the Key-Value :</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://gist.github.com/cocap10/3115098a4c56b4bc13df9cc0182ac556"><div class="kg-bookmark-content"><div class="kg-bookmark-title">staertdemo.kv.md</div><div class="kg-bookmark-description">GitHub Gist: instantly share code, notes, and snippets.</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://github.githubassets.com/favicon.ico" alt="Golang Configuration Made Easy With Flæg And Stært"><span class="kg-bookmark-author">262588213843476</span><span class="kg-bookmark-publisher">Gist</span></img></div></div><div class="kg-bookmark-thumbnail"><img src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Golang Configuration Made Easy With Flæg And Stært"/></div></a></figure><p>This was a simple example of what we can do with Stært.</p><p>To conclude, those two packages made us save a lot of time on the <a href="https://github.com/containous/traefik" rel="noopener">Træfik project</a>. We can now load and merge several configurations from different sources. Any changes on the configuration structure are automagically handled.</p><p>More features are described on the Github project pages, please visit :</p><ul><li>Flæg: <a href="https://github.com/containous/flaeg/" rel="noopener">https://github.com/containous/flaeg/</a></li><li>Stært: <a href="https://github.com/containous/staert/" rel="noopener">https://github.com/containous/staert/</a></li></ul></hr></hr>]]></content:encoded></item><item><title><![CDATA[Traefik 1.0.0 reblochon is out!]]></title><description><![CDATA[After ten months of development, we are proud to announce the first stable release of Traefik: version 1.0.0, codename reblochon...]]></description><link>https://traefik.io/blog/traefik-1-0-0-reblochon-is-out-e6fca002284d/</link><guid isPermaLink="false">Ghost__Post__5dd800c2f1db6f0038c74612</guid><category><![CDATA[Blog]]></category><category><![CDATA[Product News]]></category><dc:creator><![CDATA[Emile Vauge]]></dc:creator><pubDate>Wed, 06 Jul 2016 15:37:00 GMT</pubDate><media:content url="https://containous.ghost.io/content/images/2019/12/reblochon.png" medium="image"/><content:encoded><![CDATA[<figure class="kg-card kg-image-card"><img src="https://miro.medium.com/max/1000/1*PKlwpne0ePJuncv4Cbxm2A.png" class="kg-image" alt="Traefik 1.0.0 reblochon is out!"/></figure><img src="https://containous.ghost.io/content/images/2019/12/reblochon.png" alt="Traefik 1.0.0 reblochon is out!"/><p>After ten months of development, we are proud to announce the first stable release of <a href="https://containous.ghost.io/traefik/">Traefik</a>: version <em><em>1.0.0</em></em>, codename <em><em>reblochon</em></em>.</p><blockquote><em><em>Træf</em>i<em>k is a modern HTTP reverse proxy and load balancer made to deploy microservices with ease. It supports several backends (<a href="https://www.docker.com/" rel="noopener">Docker</a>, <a href="https://docs.docker.com/swarm" rel="noopener">Swarm</a>, <a href="https://mesosphere.github.io/marathon/" rel="noopener">Mesos/Marathon</a>, <a href="http://kubernetes.io/" rel="noopener">Kubernetes</a>, <a href="https://www.consul.io/" rel="noopener">Consul</a>, <a href="https://coreos.com/etcd/" rel="noopener">Etcd</a>, <a href="https://zookeeper.apache.org/" rel="noopener">Zookeeper</a>, <a href="https://github.com/boltdb/bolt" rel="noopener">BoltDB</a>, Rest API, file…) to manage its configuration automatically and dynamically.</em></em></blockquote><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-100.png" class="kg-image" alt="Traefik 1.0.0 reblochon is out!"/></figure><hr><p>Here a some of the highlight features of this first release:</p><ul><li>Single binary, fast, made with go</li><li>Docker, Swarm, Mesos/Marathon, Kubernetes, Consul, Etcd, Zookeeper, BoltDB, Rest API, file configuration support</li><li>Hot-reloading of configuration with true zero-downtime</li><li>Circuit breakers on backends</li><li>Clean AngularJS Web UI</li><li>Websocket support</li><li>HTTP/2 support</li><li><a href="https://letsencrypt.org/" rel="noopener">Let’s Encrypt</a> support (Automatic HTTPS)</li><li>Available on Linux, MacOS and Windows</li></ul><p>A lot of work has been done to make this release: <strong><strong>237</strong></strong> Pull requests <a href="https://github.com/containous/traefik/pulls?q=is%3Apr+is%3Aclosed" rel="noopener">have been merged</a>, <strong><strong>184</strong></strong> issues <a href="https://github.com/containous/traefik/issues?q=is%3Aissue+is%3Aclosed" rel="noopener">closed</a>, by <strong><strong>38</strong></strong> awesome <a href="https://github.com/containous/traefik/graphs/contributors" rel="noopener">contributors</a>:</p><p><em><em>@jpillora @NicolasGeraud @KevinBusse @kumy @polds @janeczku @danzel @Hugues-Antoine @ReadmeCritic @ProPheT777 @gbjk @jonaz @Russell-IO @sample @s7anley @antoinecarton @wallies @pborreli @dontrebootme @kevioke @iadvizeponey @PierreZ @tayzlor @dylanmei @stongo @fclaeys @tboerger @download13 @keis @tooda02 @errm @advait @AlmogBaku @samber @cocap10 @ldez @vdemeester @emilevauge</em></em></p><p>I would like to give special thanks to <a href="https://github.com/vdemeester" rel="noopener"><em><em>@vdemeester</em></em></a> who has been helping me maintaining the project since the beginning, and <a href="https://github.com/cocap10" rel="noopener"><em><em>@cocap10</em></em></a><em><em> </em></em>for his great work on <a href="https://github.com/containous/staert" rel="noopener">staert</a> and <a href="https://github.com/containous/flaeg" rel="noopener">flaeg</a>. And we are very pleased to announce that <a href="https://github.com/samber" rel="noopener"><em><em>@samber</em></em></a><em><em>, </em></em><a href="https://github.com/errm" rel="noopener"><em><em>@errm</em></em></a><em><em>, </em></em><a href="https://github.com/Russell-IO" rel="noopener"><em><em>@Russell-IO</em></em></a><em><em> </em></em>just joined the maintainers team. Welcome on board!</p><hr><p>You can grab the binaries <a href="https://github.com/containous/traefik/releases/tag/v1.0.0" rel="noopener">on GitHub</a> or download the official <a href="https://hub.docker.com/r/_/traefik" rel="noopener">Docker image</a>:</p><pre><code class="language-shell">docker pull traefik:v1.0.0
docker pull traefik:reblochon // if you prefer cheese ;)</code></pre><p>The documentation can be found on <a href="https://docs.traefik.io/">docs.traefik.io</a>.</p><hr><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-101.png" class="kg-image" alt="Traefik 1.0.0 reblochon is out!"/></figure><p>Reblochon is a French cheese made in the Alpine region of Savoie. Like all good Frenchmen, we love food and especially cheese: it was obvious <strong><strong>we had to</strong></strong> call every Traefik release with a French cheese name ;)</p><figure class="kg-card kg-image-card"><img src="https://containous.ghost.io/content/images/2019/11/image-102.png" class="kg-image" alt="Traefik 1.0.0 reblochon is out!"/></figure><hr><p>We would love to hear your feedback on this first major release. Join us on <a href="https://github.com/containous/traefik" rel="noopener">GitHub</a>, <a href="https://twitter.com/traefikproxy" rel="noopener">Twitter</a> or on the <a href="https://community.containo.us/">Community Forum</a>!</p></hr></hr></hr></hr>]]></content:encoded></item></channel></rss>